
Hexfiles/Webserver_MEGA644_P.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800100  0000e484  0000e518  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000e484  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000bff  008001da  008001da  0000e5f2  2**0
                  ALLOC
  3 .stab         00018690  00000000  00000000  0000e5f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000b332  00000000  00000000  00026c84  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e3 11 	jmp	0x23c6	; 0x23c6 <__ctors_end>
       4:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
       8:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
       c:	0c 94 4a 15 	jmp	0x2a94	; 0x2a94 <__vector_3>
      10:	0c 94 be 64 	jmp	0xc97c	; 0xc97c <__vector_4>
      14:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      18:	0c 94 d3 64 	jmp	0xc9a6	; 0xc9a6 <__vector_6>
      1c:	0c 94 ee 64 	jmp	0xc9dc	; 0xc9dc <__vector_7>
      20:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      24:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      28:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      2c:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      30:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      34:	0c 94 34 22 	jmp	0x4468	; 0x4468 <__vector_13>
      38:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      3c:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      40:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      44:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      48:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      4c:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      50:	0c 94 f0 13 	jmp	0x27e0	; 0x27e0 <__vector_20>
      54:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      58:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      5c:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      60:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      64:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      68:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      6c:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      70:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      74:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>
      78:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__bad_interrupt>

0000007c <__c.2181>:
      7c:	45 52 52 4f 52 0d 0a 0d 0a 00                       ERROR.....

00000086 <__c.2179>:
      86:	0d 0a 53 44 3a 25 73 3e 00                          ..SD:%s>.

0000008f <__c.2177>:
      8f:	0d 0a 00                                            ...

00000092 <__c.2175>:
      92:	53 65 6e 73 6f 72 20 32 20 5a 65 69 74 3a 20 25     Sensor 2 Zeit: %
      a2:	69 20 53 65 6b 75 6e 64 65 6e 00                    i Sekunden.

000000ad <__c.2169>:
      ad:	43 6f 6d 70 69 6c 69 65 72 74 20 6d 69 74 20 47     Compiliert mit G
      bd:	43 43 20 56 65 72 73 69 6f 6e 20 34 2e 33 2e 35     CC Version 4.3.5
      cd:	0d 0a 00                                            ...

000000d0 <__c.2167>:
      d0:	43 6f 6d 70 69 6c 69 65 72 74 20 61 6d 20 4d 61     Compiliert am Ma
      e0:	72 20 31 34 20 32 30 31 31 20 75 6d 20 32 31 3a     r 14 2011 um 21:
      f0:	30 34 3a 32 31 0d 0a 00                             04:21...

000000f8 <__c.2165>:
      f8:	0a 0d 53 79 73 74 65 6d 20 52 65 61 64 79 0a 0d     ..System Ready..
	...

00000109 <Monatstage>:
     109:	1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f                 ............

00000115 <US_Monate>:
     115:	4a 61 6e 46 65 62 4d 61 72 41 70 72 4d 61 79 4a     JanFebMarAprMayJ
     125:	75 6e 4a 75 6c 41 75 67 53 65 70 4f 63 74 4e 6f     unJulAugSepOctNo
     135:	76 44 65 63 00                                      vDec.

0000013a <__c.1936>:
     13a:	25 32 64 20 25 73 20 25 34 64 00                    %2d %s %4d.

00000145 <BASE64CODE>:
     145:	41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50     ABCDEFGHIJKLMNOP
     155:	51 52 53 54 55 56 57 58 59 5a 61 62 63 64 65 66     QRSTUVWXYZabcdef
     165:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     175:	77 78 79 7a 30 31 32 33 34 35 36 37 38 39 2b 2f     wxyz0123456789+/
     185:	3d 00                                               =.

00000187 <enc_configdata>:
     187:	04 00 05 1a 06 ff 07 1f 08 00 09 00 0a ff 0b 19     ................
     197:	c1 00 c0 0d c2 33 ca ee cb 05 c4 15 c6 12 e4 00     .....3..........
     1a7:	e5 20 e2 18 e3 b1 e0 15 e1 3f 75 00 ff ff 00 01     . .......?u.....
     1b7:	00 14 07 42 ff ff                                   ...B..

000001bd <name_Page1>:
     1bd:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

000001c7 <Page1>:
     1c7:	3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 20 50     <!DOCTYPE html P
     1d7:	55 42 4c 49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44     UBLIC "-//W3C//D
     1e7:	54 44 20 48 54 4d 4c 20 34 2e 30 31 20 54 72 61     TD HTML 4.01 Tra
     1f7:	6e 73 69 74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22     nsitional//EN" "
     207:	68 74 74 70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72     http://www.w3.or
     217:	67 2f 54 52 2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65     g/TR/html4/loose
     227:	2e 64 74 64 22 3e 3c 68 74 6d 6c 3e 3c 68 65 61     .dtd"><html><hea
     237:	64 3e 3c 6d 65 74 61 20 68 74 74 70 2d 65 71 75     d><meta http-equ
     247:	69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54 79 70 65     iv="Content-Type
     257:	22 20 63 6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f     " content="text/
     267:	68 74 6d 6c 3b 20 63 68 61 72 73 65 74 3d 69 73     html; charset=is
     277:	6f 2d 38 38 35 39 2d 31 22 20 2f 3e 0d 0a 3c 74     o-8859-1" />..<t
     287:	69 74 6c 65 3e 41 56 52 20 6d 69 6e 69 20 57 65     itle>AVR mini We
     297:	62 73 65 72 76 65 72 3c 2f 74 69 74 6c 65 3e 3c     bserver</title><
     2a7:	73 63 72 69 70 74 20 74 79 70 65 3d 22 74 65 78     script type="tex
     2b7:	74 2f 6a 61 76 61 73 63 72 69 70 74 22 3e 0d 0a     t/javascript">..
     2c7:	66 75 6e 63 74 69 6f 6e 20 73 65 6e 64 28 70 69     function send(pi
     2d7:	6e 29 20 7b 0d 0a 76 61 72 20 4f 55 54 20 3d 20     n) {..var OUT = 
     2e7:	64 6f 63 75 6d 65 6e 74 2e 63 72 65 61 74 65 45     document.createE
     2f7:	6c 65 6d 65 6e 74 28 22 49 4e 50 55 54 22 29 3b     lement("INPUT");
     307:	0d 0a 4f 55 54 2e 74 79 70 65 20 3d 20 22 68 69     ..OUT.type = "hi
     317:	64 64 65 6e 22 3b 0d 0a 4f 55 54 2e 76 61 6c 75     dden";..OUT.valu
     327:	65 20 3d 20 70 69 6e 3b 0d 0a 4f 55 54 2e 6e 61     e = pin;..OUT.na
     337:	6d 65 20 3d 20 22 4f 55 54 22 3b 0d 0a 64 6f 63     me = "OUT";..doc
     347:	75 6d 65 6e 74 2e 67 65 74 45 6c 65 6d 65 6e 74     ument.getElement
     357:	42 79 49 64 28 22 68 69 64 65 22 29 2e 61 70 70     ById("hide").app
     367:	65 6e 64 43 68 69 6c 64 28 4f 55 54 29 3b 0d 0a     endChild(OUT);..
     377:	76 61 72 20 53 55 42 20 3d 20 64 6f 63 75 6d 65     var SUB = docume
     387:	6e 74 2e 63 72 65 61 74 65 45 6c 65 6d 65 6e 74     nt.createElement
     397:	28 22 49 4e 50 55 54 22 29 3b 0d 0a 53 55 42 2e     ("INPUT");..SUB.
     3a7:	74 79 70 65 20 3d 20 22 68 69 64 64 65 6e 22 3b     type = "hidden";
     3b7:	0d 0a 53 55 42 2e 76 61 6c 75 65 20 3d 20 22 78     ..SUB.value = "x
     3c7:	22 3b 0d 0a 53 55 42 2e 6e 61 6d 65 20 3d 20 22     ";..SUB.name = "
     3d7:	53 55 42 22 3b 0d 0a 64 6f 63 75 6d 65 6e 74 2e     SUB";..document.
     3e7:	67 65 74 45 6c 65 6d 65 6e 74 42 79 49 64 28 22     getElementById("
     3f7:	68 69 64 65 22 29 2e 61 70 70 65 6e 64 43 68 69     hide").appendChi
     407:	6c 64 28 53 55 42 29 3b 0d 0a 64 6f 63 75 6d 65     ld(SUB);..docume
     417:	6e 74 2e 67 65 74 45 6c 65 6d 65 6e 74 42 79 49     nt.getElementByI
     427:	64 28 22 68 69 64 65 22 29 2e 73 75 62 6d 69 74     d("hide").submit
     437:	28 29 0d 0a 7d 3c 2f 73 63 72 69 70 74 3e 0d 0a     ()..}</script>..
     447:	3c 73 74 79 6c 65 20 74 79 70 65 3d 22 74 65 78     <style type="tex
     457:	74 2f 63 73 73 22 3e 0d 0a 3c 21 2d 2d 0d 0a 42     t/css">..<!--..B
     467:	4f 44 59 20 7b 09 6d 61 72 67 69 6e 3a 20 30 20     ODY {.margin: 0 
     477:	30 20 30 20 30 3b 20 62 61 63 6b 67 72 6f 75 6e     0 0 0; backgroun
     487:	64 2d 63 6f 6c 6f 72 3a 20 77 68 69 74 65 3b 20     d-color: white; 
     497:	74 65 78 74 2d 61 6c 69 67 6e 3a 63 65 6e 74 65     text-align:cente
     4a7:	72 3b 20 7d 50 2c 20 44 49 56 2c 20 48 31 2c 20     r; }P, DIV, H1, 
     4b7:	48 32 20 7b 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a     H2 {font-family:
     4c7:	20 76 65 72 64 61 6e 61 2c 20 61 72 69 61 6c 3b      verdana, arial;
     4d7:	20 66 6f 6e 74 2d 73 69 7a 65 3a 20 31 31 70 78      font-size: 11px
     4e7:	3b 7d 48 31 20 7b 20 20 62 61 63 6b 67 72 6f 75     ;}H1 {  backgrou
     4f7:	6e 64 2d 63 6f 6c 6f 72 3a 20 23 43 43 43 43 46     nd-color: #CCCCF
     507:	46 3b 20 70 61 64 64 69 6e 67 2d 74 6f 70 3a 35     F; padding-top:5
     517:	70 78 3b 20 70 61 64 64 69 6e 67 2d 62 6f 74 74     px; padding-bott
     527:	6f 6d 3a 35 70 78 3b 66 6f 6e 74 2d 73 69 7a 65     om:5px;font-size
     537:	3a 20 32 30 70 78 3b 20 63 6f 6c 6f 72 3a 20 23     : 20px; color: #
     547:	30 30 34 30 36 30 3b 20 66 6f 6e 74 2d 77 65 69     004060; font-wei
     557:	67 68 74 3a 62 6f 6c 64 3b 20 6c 65 74 74 65 72     ght:bold; letter
     567:	2d 73 70 61 63 69 6e 67 3a 20 38 70 78 3b 62 6f     -spacing: 8px;bo
     577:	72 64 65 72 2d 74 6f 70 3a 20 32 70 78 20 73 6f     rder-top: 2px so
     587:	6c 69 64 20 23 45 45 45 45 45 45 3b 20 62 6f 72     lid #EEEEEE; bor
     597:	64 65 72 2d 6c 65 66 74 3a 20 32 70 78 20 73 6f     der-left: 2px so
     5a7:	6c 69 64 20 23 45 45 45 45 45 45 3b 62 6f 72 64     lid #EEEEEE;bord
     5b7:	65 72 2d 62 6f 74 74 6f 6d 3a 20 32 70 78 20 73     er-bottom: 2px s
     5c7:	6f 6c 69 64 20 23 30 30 34 30 36 30 3b 20 62 6f     olid #004060; bo
     5d7:	72 64 65 72 2d 72 69 67 68 74 3a 20 32 70 78 20     rder-right: 2px 
     5e7:	73 6f 6c 69 64 20 23 30 30 34 30 36 30 3b 7d 48     solid #004060;}H
     5f7:	32 20 7b 20 66 6f 6e 74 2d 73 69 7a 65 3a 20 31     2 { font-size: 1
     607:	35 70 78 3b 20 70 61 64 64 69 6e 67 2d 74 6f 70     5px; padding-top
     617:	3a 20 32 30 70 78 3b 20 70 61 64 64 69 6e 67 2d     : 20px; padding-
     627:	6c 65 66 74 3a 35 30 70 78 3b 20 70 61 64 64 69     left:50px; paddi
     637:	6e 67 2d 72 69 67 68 74 3a 35 30 70 78 3b 63 6f     ng-right:50px;co
     647:	6c 6f 72 3a 23 30 30 34 30 38 30 3b 20 66 6f 6e     lor:#004080; fon
     657:	74 2d 77 65 69 67 68 74 3a 62 6f 6c 64 3b 20 74     t-weight:bold; t
     667:	65 78 74 2d 64 65 63 6f 72 61 74 69 6f 6e 3a 75     ext-decoration:u
     677:	6e 64 65 72 6c 69 6e 65 3b 62 6f 72 64 65 72 2d     nderline;border-
     687:	74 6f 70 3a 20 31 70 78 20 73 6f 6c 69 64 20 23     top: 1px solid #
     697:	30 30 34 30 38 30 3b 7d 50 2c 20 48 31 2c 20 48     004080;}P, H1, H
     6a7:	32 20 7b 6d 61 72 67 69 6e 3a 20 30 70 78 20 30     2 {margin: 0px 0
     6b7:	70 78 20 35 70 78 20 30 70 78 3b 7d 0d 0a 2d 2d     px 5px 0px;}..--
     6c7:	3e 0d 0a 3c 2f 73 74 79 6c 65 3e 3c 2f 68 65 61     >..</style></hea
     6d7:	64 3e 0d 0a 3c 62 6f 64 79 3e 3c 62 6c 6f 63 6b     d>..<body><block
     6e7:	71 75 6f 74 65 3e 3c 62 6c 6f 63 6b 71 75 6f 74     quote><blockquot
     6f7:	65 3e 3c 62 6c 6f 63 6b 71 75 6f 74 65 3e 3c 64     e><blockquote><d
     707:	69 76 20 61 6c 69 67 6e 3d 22 63 65 6e 74 65 72     iv align="center
     717:	22 3e 3c 68 31 3e 41 56 52 20 6d 69 6e 69 20 57     "><h1>AVR mini W
     727:	65 62 73 65 72 76 65 72 3c 2f 68 31 3e 3c 2f 64     ebserver</h1></d
     737:	69 76 3e 3c 62 72 3e 0d 0a 3c 68 32 3e 47 6c 26     iv><br>..<h2>Gl&
     747:	75 75 6d 6c 3b 63 6b 77 75 6e 73 63 68 3c 2f 68     uuml;ckwunsch</h
     757:	32 3e 3c 42 52 3e 0d 0a 3c 70 3e 57 65 6e 6e 20     2><BR>..<p>Wenn 
     767:	64 75 20 64 69 65 73 65 6e 20 54 65 78 74 20 6c     du diesen Text l
     777:	65 73 65 6e 20 6b 61 6e 6e 73 74 2c 20 68 61 73     esen kannst, has
     787:	74 20 64 75 20 65 73 20 67 65 73 63 68 61 66 66     t du es geschaff
     797:	74 3a 3c 2f 70 3e 3c 42 52 3e 3c 42 52 3e 0d 0a     t:</p><BR><BR>..
     7a7:	3c 70 3e 3c 69 6d 67 20 73 72 63 3d 22 72 61 6b     <p><img src="rak
     7b7:	65 74 2e 67 69 66 22 20 77 69 64 74 68 3d 22 39     et.gif" width="9
     7c7:	30 22 20 68 65 69 67 68 74 3d 22 39 32 22 3e 3c     0" height="92"><
     7d7:	2f 70 3e 3c 42 52 3e 0d 0a 3c 70 3e 44 65 72 20     /p><BR>..<p>Der 
     7e7:	57 65 62 73 65 72 76 65 72 20 6c 26 61 75 6d 6c     Webserver l&auml
     7f7:	3b 75 66 74 20 21 21 21 20 25 57 44 41 59 2c 20     ;uft !!! %WDAY, 
     807:	25 44 41 54 45 20 2d 20 25 54 49 4d 45 3c 2f 70     %DATE - %TIME</p
     817:	3e 3c 42 52 3e 0d 0a 3c 64 69 76 20 73 74 79 6c     ><BR>..<div styl
     827:	65 3d 22 64 69 73 70 6c 61 79 3a 20 6e 6f 6e 65     e="display: none
     837:	3b 22 3e 3c 66 6f 72 6d 20 6d 65 74 68 6f 64 3d     ;"><form method=
     847:	22 70 6f 73 74 22 20 61 63 74 69 6f 6e 3d 22 22     "post" action=""
     857:	20 69 64 3d 22 68 69 64 65 22 3e 3c 2f 66 6f 72      id="hide"></for
     867:	6d 3e 3c 2f 64 69 76 3e 0d 0a 3c 61 20 68 72 65     m></div>..<a hre
     877:	66 3d 22 6a 61 76 61 73 63 72 69 70 74 3a 73 65     f="javascript:se
     887:	6e 64 28 27 41 27 29 22 3e 3c 69 6d 67 20 73 72     nd('A')"><img sr
     897:	63 3d 22 25 50 4f 52 54 41 30 22 20 62 6f 72 64     c="%PORTA0" bord
     8a7:	65 72 3d 22 30 22 3e 3c 2f 61 3e 20 50 6f 72 74     er="0"></a> Port
     8b7:	20 41 30 20 28 74 6f 67 67 6c 65 29 3c 62 72 3e      A0 (toggle)<br>
     8c7:	0d 0a 3c 61 20 68 72 65 66 3d 22 6a 61 76 61 73     ..<a href="javas
     8d7:	63 72 69 70 74 3a 73 65 6e 64 28 27 42 27 29 22     cript:send('B')"
     8e7:	3e 3c 69 6d 67 20 73 72 63 3d 22 25 50 4f 52 54     ><img src="%PORT
     8f7:	41 31 22 20 62 6f 72 64 65 72 3d 22 30 22 3e 3c     A1" border="0"><
     907:	2f 61 3e 20 50 6f 72 74 20 41 31 3c 62 72 3e 0d     /a> Port A1<br>.
     917:	0a 3c 61 20 68 72 65 66 3d 22 6a 61 76 61 73 63     .<a href="javasc
     927:	72 69 70 74 3a 73 65 6e 64 28 27 43 27 29 22 3e     ript:send('C')">
     937:	3c 69 6d 67 20 73 72 63 3d 22 25 50 4f 52 54 41     <img src="%PORTA
     947:	32 22 20 62 6f 72 64 65 72 3d 22 30 22 3e 3c 2f     2" border="0"></
     957:	61 3e 20 50 6f 72 74 20 41 32 3c 62 72 3e 0d 0a     a> Port A2<br>..
     967:	3c 62 72 3e 3c 62 72 3e 3c 70 3e 3c 69 6d 67 20     <br><br><p><img 
     977:	73 72 63 3d 22 25 50 49 4e 44 37 22 20 77 69 64     src="%PIND7" wid
     987:	74 68 3d 22 31 37 22 20 68 65 69 67 68 74 3d 22     th="17" height="
     997:	31 37 22 3e 20 50 6f 72 74 20 44 20 50 69 6e 20     17"> Port D Pin 
     9a7:	37 3c 2f 70 3e 0d 0a 3c 70 3e 3c 69 6d 67 20 73     7</p>..<p><img s
     9b7:	72 63 3d 22 25 50 49 4e 44 36 22 20 77 69 64 74     rc="%PIND6" widt
     9c7:	68 3d 22 31 37 22 20 68 65 69 67 68 74 3d 22 31     h="17" height="1
     9d7:	37 22 3e 20 50 6f 72 74 20 44 20 50 69 6e 20 36     7"> Port D Pin 6
     9e7:	3c 2f 70 3e 0d 0a 3c 70 3e 3c 69 6d 67 20 73 72     </p>..<p><img sr
     9f7:	63 3d 22 25 50 49 4e 44 35 22 20 77 69 64 74 68     c="%PIND5" width
     a07:	3d 22 31 37 22 20 68 65 69 67 68 74 3d 22 31 37     ="17" height="17
     a17:	22 3e 20 50 6f 72 74 20 44 20 50 69 6e 20 35 3c     "> Port D Pin 5<
     a27:	2f 70 3e 0d 0a 3c 62 72 3e 3c 62 72 3e 3c 74 61     /p>..<br><br><ta
     a37:	62 6c 65 20 61 6c 69 67 6e 3d 22 63 65 6e 74 65     ble align="cente
     a47:	72 22 20 77 69 64 74 68 3d 22 35 30 30 22 20 62     r" width="500" b
     a57:	6f 72 64 65 72 3d 22 30 22 3e 3c 74 72 3e 0d 0a     order="0"><tr>..
     a67:	3c 74 68 20 73 63 6f 70 65 3d 22 63 6f 6c 22 3e     <th scope="col">
     a77:	3c 70 20 61 6c 69 67 6e 3d 22 63 65 6e 74 65 72     <p align="center
     a87:	22 3e 45 69 6e 67 61 6e 67 3c 2f 70 3e 3c 2f 74     ">Eingang</p></t
     a97:	68 3e 3c 74 68 20 73 63 6f 70 65 3d 22 63 6f 6c     h><th scope="col
     aa7:	22 3e 3c 70 20 61 6c 69 67 6e 3d 22 63 65 6e 74     "><p align="cent
     ab7:	65 72 22 3e 42 61 6c 6b 65 6e 3c 2f 70 3e 3c 2f     er">Balken</p></
     ac7:	74 68 3e 3c 74 68 20 73 63 6f 70 65 3d 22 63 6f     th><th scope="co
     ad7:	6c 22 3e 3c 70 20 61 6c 69 67 6e 3d 22 63 65 6e     l"><p align="cen
     ae7:	74 65 72 22 3e 54 65 6d 70 65 72 61 74 75 72 20     ter">Temperatur 
     af7:	5b 26 64 65 67 3b 43 5d 3c 2f 70 3e 3c 2f 74 68     [&deg;C]</p></th
     b07:	3e 3c 2f 74 72 3e 3c 2f 74 61 62 6c 65 3e 3c 42     ></tr></table><B
     b17:	52 3e 3c 42 52 3e 20 3c 70 20 61 6c 69 67 6e 3d     R><BR> <p align=
     b27:	22 6c 65 66 74 22 3e 3c 42 52 3e 3c 70 3e 3c 61     "left"><BR><p><a
     b37:	20 68 72 65 66 3d 22 53 74 61 74 75 73 2e 68 74      href="Status.ht
     b47:	6d 22 3e 53 74 61 74 75 73 3c 2f 61 3e 3c 2f 70     m">Status</a></p
     b57:	3e 3c 42 52 3e 0d 0a 3c 42 52 3e 3c 42 52 3e 20     ><BR>..<BR><BR> 
     b67:	3c 70 20 61 6c 69 67 6e 3d 22 6c 65 66 74 22 3e     <p align="left">
     b77:	20 3c 68 32 3e 3c 2f 68 32 3e 3c 42 52 3e 0d 0a      <h2></h2><BR>..
     b87:	3c 70 3e 3c 61 20 68 72 65 66 3d 22 68 74 74 70     <p><a href="http
     b97:	3a 2f 2f 77 77 77 2e 75 6c 72 69 63 68 72 61 64     ://www.ulrichrad
     ba7:	69 67 2e 64 65 22 3e 77 77 77 2e 75 6c 72 69 63     ig.de">www.ulric
     bb7:	68 72 61 64 69 67 2e 64 65 3c 2f 61 3e 3c 2f 70     hradig.de</a></p
     bc7:	3e 3c 42 52 3e 3c 70 20 61 6c 69 67 6e 3d 22 6c     ><BR><p align="l
     bd7:	65 66 74 22 3e 55 6c 72 69 63 68 20 52 61 64 69     eft">Ulrich Radi
     be7:	67 20 32 30 30 38 20 3c 62 72 3e 3c 62 72 3e 3c     g 2008 <br><br><
     bf7:	2f 70 3e 0d 0a 3c 2f 64 69 76 3e 3c 2f 62 6c 6f     /p>..</div></blo
     c07:	63 6b 71 75 6f 74 65 3e 3c 2f 62 6c 6f 63 6b 71     ckquote></blockq
     c17:	75 6f 74 65 3e 3c 2f 62 6c 6f 63 6b 71 75 6f 74     uote></blockquot
     c27:	65 3e 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e     e></body></html>
     c37:	25 45 4e 44 00                                      %END.

00000c3c <name_Page4>:
     c3c:	53 74 61 74 75 73 2e 68 74 6d 00                    Status.htm.

00000c47 <Page4>:
     c47:	3c 21 44 4f 43 54 59 50 45 20 68 74 6d 6c 20 50     <!DOCTYPE html P
     c57:	55 42 4c 49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44     UBLIC "-//W3C//D
     c67:	54 44 20 48 54 4d 4c 20 34 2e 30 31 20 54 72 61     TD HTML 4.01 Tra
     c77:	6e 73 69 74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22     nsitional//EN" "
     c87:	68 74 74 70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72     http://www.w3.or
     c97:	67 2f 54 52 2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65     g/TR/html4/loose
     ca7:	2e 64 74 64 22 3e 3c 68 74 6d 6c 3e 3c 68 65 61     .dtd"><html><hea
     cb7:	64 3e 3c 6d 65 74 61 20 68 74 74 70 2d 65 71 75     d><meta http-equ
     cc7:	69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54 79 70 65     iv="Content-Type
     cd7:	22 20 63 6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f     " content="text/
     ce7:	68 74 6d 6c 3b 20 63 68 61 72 73 65 74 3d 69 73     html; charset=is
     cf7:	6f 2d 38 38 35 39 2d 31 22 20 2f 3e 3c 73 74 79     o-8859-1" /><sty
     d07:	6c 65 20 74 79 70 65 3d 22 74 65 78 74 2f 63 73     le type="text/cs
     d17:	73 22 3e 2e 73 74 79 6c 65 31 20 7b 20 66 6f 6e     s">.style1 { fon
     d27:	74 2d 73 69 7a 65 3a 20 73 6d 61 6c 6c 3b 20 7d     t-size: small; }
     d37:	2e 73 74 79 6c 65 32 20 7b 20 74 65 78 74 2d 61     .style2 { text-a
     d47:	6c 69 67 6e 3a 20 6c 65 66 74 3b 20 7d 3c 2f 73     lign: left; }</s
     d57:	74 79 6c 65 3e 3c 2f 68 65 61 64 3e 3c 62 6f 64     tyle></head><bod
     d67:	79 3e 3c 62 6c 6f 63 6b 71 75 6f 74 65 3e 3c 62     y><blockquote><b
     d77:	6c 6f 63 6b 71 75 6f 74 65 3e 3c 62 6c 6f 63 6b     lockquote><block
     d87:	71 75 6f 74 65 3e 0d 0a 3c 64 69 76 20 61 6c 69     quote>..<div ali
     d97:	67 6e 3d 22 63 65 6e 74 65 72 22 3e 3c 68 31 3e     gn="center"><h1>
     da7:	53 74 61 74 75 73 20 50 61 67 65 3c 2f 68 31 3e     Status Page</h1>
     db7:	3c 2f 64 69 76 3e 3c 62 72 3e 3c 64 69 76 3e 43     </div><br><div>C
     dc7:	6f 6d 70 69 6c 69 65 72 74 20 4d 61 72 20 31 34     ompiliert Mar 14
     dd7:	20 32 30 31 31 20 75 6d 20 32 31 3a 30 34 3a 32      2011 um 21:04:2
     de7:	31 20 6d 69 74 20 47 43 43 20 56 65 72 73 69 6f     1 mit GCC Versio
     df7:	6e 20 34 2e 33 2e 35 3c 2f 64 69 76 3e 3c 64 69     n 4.3.5</div><di
     e07:	76 3e 42 65 73 75 63 68 65 72 20 73 65 69 74 20     v>Besucher seit 
     e17:	53 74 61 72 74 20 64 65 73 20 57 65 62 73 65 72     Start des Webser
     e27:	76 65 72 73 20 28 25 56 41 40 30 39 29 3c 2f 64     vers (%VA@09)</d
     e37:	69 76 3e 3c 62 72 3e 3c 62 72 3e 3c 62 72 3e 3c     iv><br><br><br><
     e47:	70 20 63 6c 61 73 73 3d 22 73 74 79 6c 65 32 22     p class="style2"
     e57:	3e 3c 61 20 68 72 65 66 3d 22 69 6e 64 65 78 2e     ><a href="index.
     e67:	68 74 6d 22 3e 48 61 75 70 74 73 65 69 74 65 3c     htm">Hauptseite<
     e77:	2f 61 3e 3c 2f 70 3e 3c 62 72 3e 3c 62 72 3e 3c     /a></p><br><br><
     e87:	62 72 3e 3c 62 72 3e 3c 70 3e 3c 61 20 68 72 65     br><br><p><a hre
     e97:	66 3d 22 68 74 74 70 3a 2f 2f 77 77 77 2e 75 6c     f="http://www.ul
     ea7:	72 69 63 68 72 61 64 69 67 2e 64 65 22 3e 77 77     richradig.de">ww
     eb7:	77 2e 75 6c 72 69 63 68 72 61 64 69 67 2e 64 65     w.ulrichradig.de
     ec7:	3c 62 72 3e 3c 2f 61 3e 3c 62 72 3e 3c 73 70 61     <br></a><br><spa
     ed7:	6e 20 63 6c 61 73 73 3d 22 73 74 79 6c 65 31 22     n class="style1"
     ee7:	3e 55 6c 72 69 63 68 20 52 61 64 69 67 20 32 30     >Ulrich Radig 20
     ef7:	30 37 3c 2f 73 70 61 6e 3e 3c 2f 62 6c 6f 63 6b     07</span></block
     f07:	71 75 6f 74 65 3e 3c 2f 62 6c 6f 63 6b 71 75 6f     quote></blockquo
     f17:	74 65 3e 3c 2f 62 6c 6f 63 6b 71 75 6f 74 65 3e     te></blockquote>
     f27:	3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 25 45     </body></html>%E
     f37:	4e 44 00                                            ND.

00000f3a <name_led_on>:
     f3a:	6c 65 64 6f 6e 2e 67 69 66 00                       ledon.gif.

00000f44 <led_on>:
     f44:	47 49 46 38 39 61 11 00 11 00 a5 3f 00 4d 4d 4d     GIF89a.....?.MMM
     f54:	50 50 4f 54 54 54 41 6a 44 5c 5c 5c 3f 73 42 62     PPOTTTAjD\\\?sBb
     f64:	62 62 6a 6b 6b 16 a7 1e 6f 6f 6f 5f 7a 60 19 ad     bbjkk...ooo_z`..
     f74:	21 1c b2 25 56 94 59 7b 7b 7b 1a bd 23 23 ba 2c     !..%V.Y{{{..##.,
     f84:	1b c3 25 83 83 83 1c ca 26 7c 8b 7d 1c d3 26 8b     ..%.....&|.}..&.
     f94:	8b 8b 2d cc 36 1c d8 26 1d df 28 90 91 91 1d e1     ..-.6..&..(.....
     fa4:	28 1e e2 29 21 e2 2c 35 db 3f 2e e4 38 9c 9d 9d     (..)!.,5.?..8...
     fb4:	3e e6 47 40 e6 49 a5 a5 a5 47 e7 50 50 e4 58 a9     >.G@.I...G.PP.X.
     fc4:	a9 a9 4e e8 56 ae ae ad af b0 af b0 b0 b0 64 e6     ..N.V.........d.
     fd4:	6b b4 b4 b5 b8 b8 b9 6c ec 73 77 ed 7d bf c0 bf     k......l.sw.}...
     fe4:	c0 c0 c0 c2 c2 c2 a6 da a9 c9 c8 c9 93 f1 98 cc     ................
     ff4:	cc cc d1 d1 d1 a5 f3 a9 d5 d5 d5 de de de e0 e0     ................
    1004:	e0 c5 f7 c8 e7 e7 e7 ef ef ef ff ff ff 21 f9 04     .............!..
    1014:	01 0a 00 3f 00 2c 00 00 00 00 11 00 11 00 00 06     ...?.,..........
    1024:	ed c0 9f 50 d8 cb c9 54 a9 96 6d c8 fc f9 74 37     ...P...T..m...t7
    1034:	1a 8c 65 02 69 40 b4 a6 6f a7 2b 2d 10 e0 c5 45     ..e.i@..o.+-...E
    1044:	e2 68 0d 7d bb 19 23 e2 09 7d 32 95 c7 a2 91 80     .h.}..#..}2.....
    1054:	09 75 3a c6 c5 f5 72 9d 3e 1b 15 13 0b 09 12 3f     .u:...r.>......?
    1064:	3d 37 1e 11 2b 35 38 35 2e 22 1d 1b 18 0f 10 06     =7..+585."......
    1074:	2c 39 34 0b 1e 2f 38 3c 38 2f 24 1d 1b 1b 15 0b     ,94../8<8/$.....
    1084:	06 16 32 30 08 21 2e 35 38 35 2e 22 1c a4 18 08     ..20.!.585."....
    1094:	04 07 2a 2c 08 1f 27 2e 2f 2e 27 1f a4 1b 19 08     ..*,..'./.'.....
    10a4:	04 02 29 26 08 19 1f 22 24 22 1f c4 1b 19 08 02     ..)&..."$"......
    10b4:	06 2d 20 0b 18 1b 1d de d3 1b 15 0b 02 12 36 1a     .- ...........6.
    10c4:	10 0f e0 d3 11 10 00 28 3f 20 14 0b 13 ea 1b 13     .......(? ......
    10d4:	0b 03 09 42 34 0e 0d 0b 0f 18 32 6c c8 80 e1 c1     ...B4.....2l....
    10e4:	82 02 00 58 0c 69 91 40 01 84 05 60 10 2c 60 10     ...X.i.@...`.,`.
    10f4:	00 c0 08 26 3f 62 48 30 60 80 00 01 01 02 00 24     ...&?bH0`......$
    1104:	60 81 71 08 0b 0b 07 04 18 90 80 02 63 10 00 3b     `.q.........c..;
    1114:	25 45 4e 44                                         %END

00001118 <name_led_off>:
    1118:	6c 65 64 6f 66 66 2e 67 69 66 00                    ledoff.gif.

00001123 <led_off>:
    1123:	47 49 46 38 39 61 11 00 11 00 a5 3f 00 4d 4d 4d     GIF89a.....?.MMM
    1133:	50 50 50 52 52 52 54 54 54 57 56 57 5a 5a 59 5d     PPPRRRTTTWVWZZY]
    1143:	5d 5d 5e 5d 5d 5e 5e 5e 60 60 60 62 62 62 63 63     ]]^]]^^^```bbbcc
    1153:	63 64 64 64 65 65 65 69 69 69 6e 6e 6e 70 70 70     cdddeeeiiinnnppp
    1163:	77 77 77 78 78 78 7a 7a 7a 7b 7b 7b 7e 7e 7e 7f     wwwxxxzzz{{{~~~.
    1173:	7f 7f 80 80 80 81 81 81 83 83 83 87 87 87 89 89     ................
    1183:	89 8b 8b 8b 8e 8e 8e 90 91 91 91 91 92 93 93 93     ................
    1193:	97 97 97 9a 9a 9a 9c 9c 9c a5 a5 a5 a9 a9 a9 ab     ................
    11a3:	ab ab ac ac ac ae ae ad af af af af b0 af b0 b0     ................
    11b3:	b0 b2 b2 b2 b4 b4 b4 b4 b4 b5 b5 b5 b5 b8 b8 b9     ................
    11c3:	bf c0 bf bf c0 c0 c0 c0 c0 c2 c2 c2 c8 c8 c8 c9     ................
    11d3:	c9 c9 cc cc cc d1 d1 d1 d5 d5 d5 dd dd dd de df     ................
    11e3:	de e0 e0 e0 e7 e7 e7 ef ef ef ff ff ff 21 f9 04     .............!..
    11f3:	01 0a 00 3f 00 2c 00 00 00 00 11 00 11 00 00 06     ...?.,..........
    1203:	ec c0 9f 50 d8 cb d1 56 2a d8 6d c8 fc f9 76 b8     ...P...V*.m...v.
    1213:	5a ec 55 1a 79 46 b5 a6 8f a7 13 35 10 06 c4 42     Z.U.yF.....5...B
    1223:	a3 a1 c0 86 3e de cc 31 e9 7c 36 95 09 a4 11 81     ....>..1.|6.....
    1233:	c8 84 3b 9d a3 73 62 9d 46 1b 16 16 12 0c 0f 18     ..;..sb.F.......
    1243:	3f 3d 38 1f 13 27 34 37 34 27 20 18 82 10 12 0a     ?=8..'474' .....
    1253:	2e 39 36 0d 1d 2c 37 3b 37 2c 21 19 82 13 0a 09     .96..,7;7,!.....
    1263:	1c 34 31 08 1f 26 34 37 34 27 20 17 82 15 08 07     .41..&474' .....
    1273:	0e 2b 2f 06 1b 23 27 2c 27 23 1b 82 82 06 05 03     .+/..#','#......
    1283:	29 25 08 15 1b 20 21 20 1b c3 16 15 08 04 0c 30     )%... ! .......0
    1293:	23 0b 13 16 18 19 18 d1 16 13 0a 02 19 37 1e 17     #............7..
    12a3:	10 df d1 10 15 00 28 3f 23 1a 0d 12 e9 16 12 0a     ......(?#.......
    12b3:	01 0f 42 35 14 11 0c 10 13 15 2c 54 98 00 41 41     ..B5......,T..AA
    12c3:	01 00 2d 86 c0 80 f0 40 82 02 04 06 10 28 78 10     ..-....@.....(x.
    12d3:	00 00 89 26 33 30 28 48 60 a0 00 01 01 00 1e b4     ...&30(H`.......
    12e3:	68 32 c4 05 07 07 03 18 64 40 d1 24 08 00 3b 25     h2......d@.$..;%
    12f3:	45 4e 44                                            END

000012f6 <name_bild_balken>:
    12f6:	62 61 6c 6b 65 2e 67 69 66 00                       balke.gif.

00001300 <bild_balken>:
    1300:	47 49 46 38 39 61 02 00 0a 00 a2 00 00 a2 a5 ed     GIF89a..........
    1310:	84 8f e5 66 7c dd 49 60 d6 21 44 da fe 01 02 00     ...f|.I`.!D.....
    1320:	00 00 00 00 00 21 f9 04 05 14 00 05 00 2c 00 00     .....!.......,..
    1330:	00 00 02 00 0a 00 00 03 0a 48 34 23 12 01 48 00     .........H4#..H.
    1340:	1d 53 09 00 3b 25 45 4e 44                          .S..;%END

00001349 <name_bild_rakete>:
    1349:	72 61 6b 65 74 2e 67 69 66 00                       raket.gif.

00001353 <bild_rakete>:
    1353:	47 49 46 38 39 61 0f 00 0f 00 b3 0d 00 45 45 45     GIF89a.......EEE
    1363:	ff ea 00 00 00 00 ff ff ff ff ce 00 ff c9 00 ff     ................
    1373:	b4 00 fe 9d 00 ff fe 93 ff fd 13 ff ff c7 ff ff     ................
    1383:	eb ff e5 00 00 00 00 00 00 00 00 00 00 21 f9 04     .............!..
    1393:	01 00 00 0d 00 2c 00 00 00 00 0f 00 0f 00 00 04     .....,..........
    13a3:	59 b0 49 09 6a 9d b8 d5 a5 10 22 17 06 70 49 12     Y.I.j....."..pI.
    13b3:	9c c4 01 4c 40 67 9e 70 ba 6a 88 29 c0 77 00 6a     ...L@g.p.j.).w.j
    13c3:	ca 9b 07 b9 82 0a 80 f8 c1 70 86 4a 51 c0 6c 3a     .........p.JQ.l:
    13d3:	93 00 db 60 4a 1d 08 0a 50 02 b0 4a bd aa 34 5a     ...`J...P..J..4Z
    13e3:	01 f7 ba 03 13 18 4e f2 97 42 20 14 de 6f 59 a6     ......N..B ..oY.
    13f3:	62 a8 1b 86 19 96 65 36 89 00 00 3b 25 45 4e 44     b.....e6...;%END

00001403 <WEBPAGE_TABLE>:
    1403:	bd 01 c7 01 3c 0c 47 0c 49 13 53 13 f6 12 00 13     ....<.G.I.S.....
    1413:	3a 0f 44 0f 18 11 23 11 00 00 00 00                 :.D...#.....

0000141f <http_header1>:
    141f:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
    142f:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 53     ument follows..S
    143f:	65 72 76 65 72 3a 20 41 56 52 5f 53 6d 61 6c 6c     erver: AVR_Small
    144f:	5f 57 65 62 73 65 72 76 65 72 0d 0a 43 6f 6e 74     _Webserver..Cont
    145f:	65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 68     ent-Type: text/h
    146f:	74 6d 6c 0d 0a 0d 0a 00                             tml.....

00001477 <http_header2>:
    1477:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
    1487:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 53     ument follows..S
    1497:	65 72 76 65 72 3a 20 41 56 52 5f 53 6d 61 6c 6c     erver: AVR_Small
    14a7:	5f 57 65 62 73 65 72 76 65 72 0d 0a 43 6f 6e 74     _Webserver..Cont
    14b7:	65 6e 74 2d 54 79 70 65 3a 20 69 6d 61 67 65 2f     ent-Type: image/
    14c7:	6a 70 67 0d 0a 0d 0a 00                             jpg.....

000014cf <http_header3>:
    14cf:	48 54 54 50 2f 31 2e 30 20 34 30 31 20 55 6e 61     HTTP/1.0 401 Una
    14df:	75 74 68 6f 72 69 7a 65 64 0d 0a 53 65 72 76 65     uthorized..Serve
    14ef:	72 3a 20 41 56 52 5f 53 6d 61 6c 6c 5f 57 65 62     r: AVR_Small_Web
    14ff:	73 65 72 76 65 72 0d 0a 57 57 57 2d 41 75 74 68     server..WWW-Auth
    150f:	65 6e 74 69 63 61 74 65 3a 20 42 61 73 69 63 20     enticate: Basic 
    151f:	72 65 61 6c 6d 3d 22 4e 65 65 64 50 61 73 73 77     realm="NeedPassw
    152f:	6f 72 64 22 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79     ord"..Content-Ty
    153f:	70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 0d     pe: text/html...
    154f:	0a 00                                               ..

00001551 <http_csv_header>:
    1551:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
    1561:	0a 53 65 72 76 65 72 3a 20 41 56 52 5f 53 6d 61     .Server: AVR_Sma
    1571:	6c 6c 5f 57 65 62 73 65 72 76 65 72 0d 0a 43 6f     ll_Webserver..Co
    1581:	6e 74 65 6e 74 2d 44 69 73 70 6f 73 69 74 69 6f     ntent-Dispositio
    1591:	6e 3a 20 61 74 74 61 63 68 6d 65 6e 74 3b 66 69     n: attachment;fi
    15a1:	6c 65 6e 61 6d 65 3d 44 61 74 61 6c 6f 67 2e 63     lename=Datalog.c
    15b1:	73 76 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20     sv..Connection: 
    15c1:	63 6c 6f 73 65 0d 0a 43 6f 6e 74 65 6e 74 2d 54     close..Content-T
    15d1:	79 70 65 3a 20 66 69 6c 65 0d 0a 0d 0a 00           ype: file.....

000015df <Page0>:
    15df:	34 30 31 20 55 6e 61 75 74 68 6f 72 69 7a 65 64     401 Unauthorized
    15ef:	25 45 4e 44 00                                      %END.

000015f4 <__c.2113>:
    15f4:	25 45 4e 44 00                                      %END.

000015f9 <__c.2111>:
    15f9:	0d 0a 00                                            ...

000015fc <__c.2003>:
    15fc:	2e 67 69 66 00                                      .gif.

00001601 <__c.2001>:
    1601:	2e 6a 70 67 00                                      .jpg.

00001606 <__c.1999>:
    1606:	2e 68 74 6d 00                                      .htm.

0000160b <__c.1987>:
    160b:	63 73 76 00                                         csv.

0000160f <__c.1985>:
    160f:	68 74 6d 00                                         htm.

00001613 <__c.1983>:
    1613:	49 4e 44 45 58 2e 48 54 4d 00                       INDEX.HTM.

0000161d <__c.1959>:
    161d:	50 4f 53 54 00                                      POST.

00001622 <__c.1850>:
    1622:	53 74 61 72 74 20 54 65 6c 6e 65 74 20 53 65 72     Start Telnet Ser
    1632:	76 65 72 3a 0d 0a 00                                ver:...

00001639 <NTP_Request>:
    1639:	d9 00 0a fa 00 00 00 00 00 01 04 00 00 00 00 00     ................
	...
    1661:	c7 d6 ac 72 08 00 00 00 25 45 4e 44                 ...r....%END

0000166d <WEATHER_GET_STRING>:
    166d:	47 45 54 20 2f 67 6c 6f 62 61 6c 77 65 61 74 68     GET /globalweath
    167d:	65 72 2e 61 73 6d 78 2f 47 65 74 57 65 61 74 68     er.asmx/GetWeath
    168d:	65 72 3f 43 69 74 79 4e 61 6d 65 3d 50 61 64 65     er?CityName=Pade
    169d:	72 62 6f 72 6e 26 43 6f 75 6e 74 72 79 4e 61 6d     rborn&CountryNam
    16ad:	65 3d 47 65 72 6d 61 6e 79 20 48 54 54 50 2f 31     e=Germany HTTP/1
    16bd:	2e 31 0d 0a 48 6f 73 74 3a 20 77 77 77 2e 77 65     .1..Host: www.we
    16cd:	62 73 65 72 76 69 63 65 78 2e 6e 65 74 0d 0a 4b     bservicex.net..K
    16dd:	65 65 70 2d 41 6c 69 76 65 3a 20 33 30 30 0d 0a     eep-Alive: 300..
    16ed:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 4b 65 65 70     Connection: Keep
    16fd:	2d 41 6c 69 76 65 0d 0a 0d 0a 00                    -Alive.....

00001708 <__c.1917>:
    1708:	0d 0a 0d 0a 0d 0a 44 61 74 65 6e 20 41 6e 66 6f     ......Daten Anfo
    1718:	72 64 65 72 6e 0d 0a 00                             rdern...

00001720 <__c.1915>:
    1720:	54 43 50 20 45 69 6e 74 72 61 67 20 67 65 66 75     TCP Eintrag gefu
    1730:	6e 64 65 6e 20 28 48 54 54 50 5f 43 4c 49 45 4e     nden (HTTP_CLIEN
    1740:	54 29 21 0d 0a 00                                   T)!...

00001746 <__c.1910>:
    1746:	54 43 50 20 45 69 6e 74 72 61 67 20 6e 69 63 68     TCP Eintrag nich
    1756:	74 20 67 65 66 75 6e 64 65 6e 20 28 48 54 54 50     t gefunden (HTTP
    1766:	5f 43 4c 49 45 4e 54 29 21 0d 0a 00                 _CLIENT)!...

00001772 <__c.1901>:
    1772:	41 52 50 20 52 65 71 75 65 73 74 0a 0d 00           ARP Request...

00001780 <__c.1876>:
    1780:	25 63 00                                            %c.

00001783 <SMTP_HELO>:
    1783:	48 45 4c 4f 20 45 54 48 5f 4d 33 32 5f 45 58 0d     HELO ETH_M32_EX.
    1793:	0a 00                                               ..

00001795 <SMTP_AUTH>:
    1795:	41 55 54 48 20 4c 4f 47 49 4e 0d 0a 00              AUTH LOGIN...

000017a2 <SMTP_RSET>:
    17a2:	52 53 45 54 0d 0a 00                                RSET...

000017a9 <SMTP_DATA>:
    17a9:	44 41 54 41 0d 0a 00                                DATA...

000017b0 <SMTP_END>:
    17b0:	2e 0d 0a 00                                         ....

000017b4 <SMTP_QUIT>:
    17b4:	51 55 49 54 0d 0a 00                                QUIT...

000017bb <__c.2367>:
    17bb:	23 23 00                                            ##.

000017be <__c.2362>:
    17be:	23 23 00                                            ##.

000017c1 <__c.2305>:
    17c1:	4d 58 00                                            MX.

000017c4 <__c.2251>:
    17c4:	0d 0a 00                                            ...

000017c7 <__c.2249>:
    17c7:	23 23 00                                            ##.

000017ca <__c.2247>:
    17ca:	52 43 50 54 20 54 4f 3a 00                          RCPT TO:.

000017d3 <__c.2243>:
    17d3:	0d 0a 00                                            ...

000017d6 <__c.2241>:
    17d6:	46 52 00                                            FR.

000017d9 <__c.2239>:
    17d9:	4d 41 49 4c 20 46 52 4f 4d 3a 00                    MAIL FROM:.

000017e4 <__c.2235>:
    17e4:	0d 0a 00                                            ...

000017e7 <__c.2233>:
    17e7:	50 57 00                                            PW.

000017ea <__c.2229>:
    17ea:	0d 0a 00                                            ...

000017ed <__c.2227>:
    17ed:	55 53 00                                            US.

000017f0 <__c.2117>:
    17f0:	0d 0a 2a 2a 20 4d 58 20 65 6d 70 66 61 6e 67 65     ..** MX empfange
    1800:	6e 3a 20 25 73 00                                   n: %s.

00001806 <__c.2115>:
    1806:	0d 0a 2a 2a 20 50 54 52 20 65 6d 70 66 61 6e 67     ..** PTR empfang
    1816:	65 6e 3a 20 25 73 00                                en: %s.

0000181d <__c.2103>:
    181d:	0d 0a 2a 2a 20 53 4f 41 20 65 6d 70 66 61 6e 67     ..** SOA empfang
    182d:	65 6e 3a 20 25 73 00                                en: %s.

00001834 <__c.2101>:
    1834:	0d 0a 2a 2a 20 43 4e 41 4d 45 20 65 6d 70 66 61     ..** CNAME empfa
    1844:	6e 67 65 6e 3a 20 25 73 00                          ngen: %s.

0000184d <__c.2099>:
    184d:	0d 0a 2a 2a 20 4e 53 20 65 6d 70 66 61 6e 67 65     ..** NS empfange
    185d:	6e 3a 20 25 73 00                                   n: %s.

00001863 <__c.2096>:
    1863:	0d 0a 2a 2a 20 44 4e 53 20 49 50 20 65 6d 70 66     ..** DNS IP empf
    1873:	61 6e 67 65 6e 3a 20 25 69 2e 25 69 2e 25 69 2e     angen: %i.%i.%i.
    1883:	25 69 00                                            %i.

00001886 <__c.2094>:
    1886:	0d 0a 2a 2a 20 44 4e 53 20 54 59 50 45 20 25 69     ..** DNS TYPE %i
    1896:	20 43 4c 41 53 53 20 25 69 20 52 44 4c 65 6e 20      CLASS %i RDLen 
    18a6:	25 69 00                                            %i.

000018a9 <__c.2081>:
    18a9:	0d 0a 2a 2a 20 44 4e 53 3a 20 25 69 20 52 52 73     ..** DNS: %i RRs
	...

000018ba <__c.2078>:
    18ba:	0d 0a 2a 2a 20 44 4e 53 20 66 61 6c 73 63 68 65     ..** DNS falsche
    18ca:	20 49 44 3a 20 30 78 25 78 20 30 78 25 78 00         ID: 0x%x 0x%x.

000018d9 <__c.2075>:
    18d9:	2a 2a 20 44 4e 53 20 44 41 54 41 20 47 45 54 21     ** DNS DATA GET!
    18e9:	20 2a 2a 0d 0a 00                                    **...

000018ef <__c.2052>:
    18ef:	0d 0a 4b 65 69 6e 65 6e 20 44 4e 53 20 53 65 72     ..Keinen DNS Ser
    18ff:	76 65 72 20 67 65 66 75 6e 64 65 6e 21 21 00        ver gefunden!!.

0000190e <__c.2050>:
    190e:	0d 0a 2a 2a 20 44 4e 53 20 52 65 71 75 65 73 74     ..** DNS Request
    191e:	20 67 65 73 65 6e 64 65 74 21 20 2a 2a 00            gesendet! **.

0000192c <__c.2039>:
    192c:	0d 0a 44 4e 53 20 41 6e 66 72 61 67 65 3a 20 25     ..DNS Anfrage: %
    193c:	73 00                                               s.

0000193e <__c.2022>:
    193e:	25 69 2e 25 69 2e 25 69 2e 25 69 2e 69 6e 2d 61     %i.%i.%i.%i.in-a
    194e:	64 64 72 2e 61 72 70 61 00                          ddr.arpa.

00001957 <Tagesnamen>:
    1957:	53 6f 6e 4d 6f 6e 44 69 65 4d 69 74 44 6f 6e 46     SonMonDieMitDonF
    1967:	72 65 53 61 6d 00                                   reSam.

0000196d <__c.1980>:
    196d:	6c 65 64 6f 6e 2e 67 69 66 00                       ledon.gif.

00001977 <__c.1978>:
    1977:	6c 65 64 6f 66 66 2e 67 69 66 00                    ledoff.gif.

00001982 <__c.1969>:
    1982:	50 49 4e 00                                         PIN.

00001986 <__c.1967>:
    1986:	6c 65 64 6f 66 66 2e 67 69 66 00                    ledoff.gif.

00001991 <__c.1965>:
    1991:	6c 65 64 6f 6e 2e 67 69 66 00                       ledon.gif.

0000199b <__c.1956>:
    199b:	50 4f 52 54 00                                      PORT.

000019a0 <__c.1954>:
    19a0:	57 44 41 59 00                                      WDAY.

000019a5 <__c.1952>:
    19a5:	55 53 44 41 54 45 00                                USDATE.

000019ac <__c.1950>:
    19ac:	25 32 2e 32 64 2e 25 32 2e 32 64 2e 25 34 64 00     %2.2d.%2.2d.%4d.

000019bc <__c.1942>:
    19bc:	44 41 54 45 00                                      DATE.

000019c1 <__c.1940>:
    19c1:	25 32 2e 32 64 3a 25 32 2e 32 64 3a 25 32 2e 32     %2.2d:%2.2d:%2.2
    19d1:	64 00                                               d.

000019d3 <__c.1932>:
    19d3:	54 49 4d 45 00                                      TIME.

000019d8 <p_quit>:
    19d8:	51 55 49 54 00                                      QUIT.

000019dd <p_exit>:
    19dd:	45 58 49 54 00                                      EXIT.

000019e2 <p_reset>:
    19e2:	52 45 53 45 54 00                                   RESET.

000019e8 <p_arp>:
    19e8:	41 52 50 00                                         ARP.

000019ec <p_tcp>:
    19ec:	54 43 50 00                                         TCP.

000019f0 <p_ip>:
    19f0:	49 50 00                                            IP.

000019f3 <p_net>:
    19f3:	4e 45 54 00                                         NET.

000019f7 <p_router>:
    19f7:	52 4f 55 54 45 52 00                                ROUTER.

000019fe <p_ntp>:
    19fe:	4e 54 50 00                                         NTP.

00001a02 <p_mac>:
    1a02:	4d 41 43 00                                         MAC.

00001a06 <p_ver>:
    1a06:	56 45 52 00                                         VER.

00001a0a <p_sv>:
    1a0a:	53 56 00                                            SV.

00001a0d <p_time>:
    1a0d:	54 49 4d 45 00                                      TIME.

00001a12 <p_ntpr>:
    1a12:	4e 54 50 52 00                                      NTPR.

00001a17 <p_ping>:
    1a17:	50 49 4e 47 00                                      PING.

00001a1c <p_dns>:
    1a1c:	44 4e 53 00                                         DNS.

00001a20 <p_dnsqry>:
    1a20:	44 4e 53 51 00                                      DNSQ.

00001a25 <p_dnsrev>:
    1a25:	44 4e 53 52 00                                      DNSR.

00001a2a <p_dir>:
    1a2a:	44 49 52 00                                         DIR.

00001a2e <p_disk>:
    1a2e:	44 49 53 4b 00                                      DISK.

00001a33 <p_cat>:
    1a33:	43 41 54 00                                         CAT.

00001a37 <p_pwd>:
    1a37:	50 57 44 00                                         PWD.

00001a3b <p_cwd>:
    1a3b:	43 57 44 00                                         CWD.

00001a3f <p_cd>:
    1a3f:	43 44 00                                            CD.

00001a42 <p_cdup>:
    1a42:	43 44 55 50 00                                      CDUP.

00001a47 <p_user>:
    1a47:	55 53 45 52 00                                      USER.

00001a4c <p_pass>:
    1a4c:	50 41 53 53 00                                      PASS.

00001a51 <p_noop>:
    1a51:	4e 4f 4f 50 00                                      NOOP.

00001a56 <p_type>:
    1a56:	54 59 50 45 00                                      TYPE.

00001a5b <p_pasv>:
    1a5b:	50 41 53 56 00                                      PASV.

00001a60 <p_list>:
    1a60:	4c 49 53 54 00                                      LIST.

00001a65 <p_retr>:
    1a65:	52 45 54 52 00                                      RETR.

00001a6a <p_stor>:
    1a6a:	53 54 4f 52 00                                      STOR.

00001a6f <p_rmd>:
    1a6f:	52 4d 44 00                                         RMD.

00001a73 <p_mkd>:
    1a73:	4d 4b 44 00                                         MKD.

00001a77 <p_dele>:
    1a77:	44 45 4c 45 00                                      DELE.

00001a7c <p_syst>:
    1a7c:	53 59 53 54 00                                      SYST.

00001a81 <p_mail>:
    1a81:	6d 61 69 6c 00                                      mail.

00001a86 <p_help>:
    1a86:	48 45 4c 50 00                                      HELP.

00001a8b <p_help2>:
    1a8b:	3f 00                                               ?.

00001a8d <CMD_TABLE>:
    1a8d:	d8 19 bc 38 dd 19 bc 38 e2 19 bf 38 e8 19 16 3d     ...8...8...8...=
    1a9d:	ec 19 1a 3c f0 19 7e 46 f3 19 86 45 f7 19 0a 45     ...<..~F...E...E
    1aad:	02 1a 17 3a 06 1a cf 39 0a 1a c5 38 0d 1a 3b 39     ...:...9...8..;9
    1abd:	17 1a 9d 43 fe 19 02 46 12 1a 77 43 1c 1a 81 44     ...C...F..wC...D
    1acd:	20 1a 5b 43 25 1a fa 43 2a 1a c9 41 2e 1a d4 3a      .[C%..C*..A...:
    1add:	33 1a a2 41 37 1a 0a 39 3b 1a 9c 3f 3f 1a 9c 3f     3..A7..9;..??..?
    1aed:	42 1a 00 3f 47 1a 7b 3e 4c 1a 71 3e 51 1a 5a 3e     B..?G.{>L.q>Q.Z>
    1afd:	56 1a bc 3e 5b 1a c8 38 60 1a a5 3e 65 1a 08 41     V..>[..8`..>e..A
    1b0d:	6a 1a 6b 41 77 1a 31 41 73 1a ea 40 6f 1a 31 41     j.kAw.1As..@o.1A
    1b1d:	7c 1a e9 3e 81 1a 66 43 86 1a c0 3b 8b 1a c0 3b     |..>..fC...;...;
    1b2d:	00 00 00 00                                         ....

00001b31 <helptext>:
    1b31:	52 45 53 45 54 20 20 2d 20 72 65 73 65 74 20 74     RESET  - reset t
    1b41:	68 65 20 41 56 52 20 2d 20 43 6f 6e 74 72 6f 6c     he AVR - Control
    1b51:	6c 65 72 0d 0a 41 52 50 20 20 20 20 2d 20 6c 69     ler..ARP    - li
    1b61:	73 74 20 74 68 65 20 41 52 50 20 74 61 62 6c 65     st the ARP table
    1b71:	0d 0a 54 43 50 20 20 20 20 2d 20 6c 69 73 74 20     ..TCP    - list 
    1b81:	74 68 65 20 74 63 70 20 74 61 62 6c 65 0d 0a 49     the tcp table..I
    1b91:	50 20 20 20 20 20 2d 20 6c 69 73 74 2f 63 68 61     P     - list/cha
    1ba1:	6e 67 65 20 69 70 0d 0a 4e 45 54 20 20 20 20 2d     nge ip..NET    -
    1bb1:	20 6c 69 73 74 2f 63 68 61 6e 67 65 20 6e 65 74      list/change net
    1bc1:	6d 61 73 6b 0d 0a 52 4f 55 54 45 52 20 2d 20 6c     mask..ROUTER - l
    1bd1:	69 73 74 2f 63 68 61 6e 67 65 20 72 6f 75 74 65     ist/change route
    1be1:	72 20 69 70 0d 0a 4e 54 50 20 20 20 20 2d 20 6c     r ip..NTP    - l
    1bf1:	69 73 74 2f 63 68 61 6e 67 65 20 4e 54 50 0d 0a     ist/change NTP..
    1c01:	4e 54 50 52 20 20 20 2d 20 4e 54 50 20 52 65 66     NTPR   - NTP Ref
    1c11:	72 65 73 68 0d 0a 4d 41 43 20 20 20 20 2d 20 6c     resh..MAC    - l
    1c21:	69 73 74 20 4d 41 43 2d 61 64 64 72 65 73 73 0d     ist MAC-address.
    1c31:	0a 56 45 52 20 20 20 20 2d 20 6c 69 73 74 20 65     .VER    - list e
    1c41:	6e 63 20 76 65 72 73 69 6f 6e 20 6e 75 6d 62 65     nc version numbe
    1c51:	72 0d 0a 53 56 20 20 20 20 20 2d 20 73 65 74 20     r..SV     - set 
    1c61:	76 61 72 69 61 62 6c 65 0d 0a 50 49 4e 47 20 20     variable..PING  
    1c71:	20 2d 20 73 65 6e 64 20 50 69 6e 67 0d 0a 4d 41      - send Ping..MA
    1c81:	49 4c 20 20 20 2d 20 73 65 6e 64 20 45 2d 4d 61     IL   - send E-Ma
    1c91:	69 6c 0d 0a 64 69 73 6b 20 20 20 2d 20 53 44 2d     il..disk   - SD-
    1ca1:	4b 61 72 74 65 6e 69 6e 66 6f 72 6d 61 74 69 6f     Karteninformatio
    1cb1:	6e 0d 0a 64 69 72 20 20 20 20 2d 20 44 69 72 65     n..dir    - Dire
    1cc1:	63 74 6f 72 79 20 61 6e 7a 65 69 67 65 6e 0d 0a     ctory anzeigen..
    1cd1:	63 61 74 20 20 20 20 2d 20 44 61 74 65 69 20 61     cat    - Datei a
    1ce1:	6e 7a 65 69 67 65 6e 0d 0a 63 77 64 20 20 20 20     nzeigen..cwd    
    1cf1:	2d 20 63 68 61 6e 67 65 20 77 6f 72 6b 69 6e 67     - change working
    1d01:	20 64 69 72 65 63 74 6f 72 79 0d 0a 63 64 20 20      directory..cd  
    1d11:	20 20 20 2d 20 77 69 65 20 63 77 64 0d 0a 54 49        - wie cwd..TI
    1d21:	4d 45 20 20 20 2d 20 67 65 74 20 74 69 6d 65 0d     ME   - get time.
    1d31:	0a 48 45 4c 50 20 20 20 2d 20 70 72 69 6e 74 20     .HELP   - print 
    1d41:	48 65 6c 70 74 65 78 74 0d 0a 3f 20 20 20 20 20     Helptext..?     
    1d51:	20 2d 20 77 69 65 20 48 45 4c 50 0d 0a 00            - wie HELP...

00001d5f <__c.3211>:
    1d5f:	0d 0a 66 6f 72 6d 61 74 3a 20 20 25 69 00           ..format:  %i.

00001d6d <__c.3209>:
    1d6d:	0d 0a 77 72 2e 70 72 2e 3a 20 20 25 69 2f 25 69     ..wr.pr.:  %i/%i
	...

00001d7e <__c.3207>:
    1d7e:	0d 0a 63 6f 70 79 3a 20 20 20 20 25 69 00           ..copy:    %i.

00001d8c <__c.3205>:
    1d8c:	0d 0a 73 69 7a 65 3a 20 20 20 20 25 6c 00           ..size:    %l.

00001d9a <__c.3203>:
    1d9a:	0d 0a 64 61 74 65 3a 20 20 20 20 25 69 2f 25 69     ..date:    %i/%i
	...

00001dab <__c.3201>:
    1dab:	0d 0a 73 65 72 69 61 6c 3a 20 20 25 6c 00           ..serial:  %l.

00001db9 <__c.3199>:
    1db9:	0d 0a 72 65 76 3a 20 20 20 20 20 25 69 00           ..rev:     %i.

00001dc7 <__c.3197>:
    1dc7:	0d 0a 70 72 6f 64 3a 20 20 20 20 25 73 00           ..prod:    %s.

00001dd5 <__c.3195>:
    1dd5:	0d 0a 6f 65 6d 3a 20 20 20 20 20 25 73 00           ..oem:     %s.

00001de3 <__c.3193>:
    1de3:	0d 0a 6d 61 6e 75 66 3a 20 30 78 25 78 00           ..manuf: 0x%x.

00001df1 <__c.3191>:
    1df1:	0d 0a 44 69 73 6b 20 6b 61 6e 6e 20 6e 69 63 68     ..Disk kann nich
    1e01:	74 20 67 65 6c 65 73 65 6e 20 77 65 72 64 65 6e     t gelesen werden
    1e11:	2e 00                                               ..

00001e13 <__c.3180>:
    1e13:	25 63 00                                            %c.

00001e16 <__c.3129>:
    1e16:	32 32 37 20 45 6e 74 65 72 69 6e 67 20 50 61 73     227 Entering Pas
    1e26:	73 69 76 65 20 4d 6f 64 65 20 28 25 69 2c 25 69     sive Mode (%i,%i
    1e36:	2c 25 69 2c 25 69 2c 38 2c 35 32 29 0d 0a 00        ,%i,%i,8,52)...

00001e45 <__c.3122>:
    1e45:	35 35 30 20 52 65 71 75 65 73 74 65 64 20 61 63     550 Requested ac
    1e55:	74 69 6f 6e 20 6e 6f 74 20 74 61 6b 65 6e 2e 0d     tion not taken..
    1e65:	0a 00                                               ..

00001e67 <__c.3115>:
    1e67:	35 33 30 20 4e 6f 74 20 6c 6f 67 67 65 64 20 69     530 Not logged i
    1e77:	6e 2e 0d 0a 00                                      n....

00001e7c <__c.3108>:
    1e7c:	35 30 32 20 6e 6f 74 20 69 6d 70 6c 65 6d 65 6e     502 not implemen
    1e8c:	74 65 64 2e 0d 0a 00                                ted....

00001e93 <__c.3101>:
    1e93:	32 35 30 20 6f 6b 2e 0d 0a 00                       250 ok....

00001e9d <__c.3094>:
    1e9d:	32 30 30 20 43 6f 6d 6d 61 6e 64 20 6f 6b 2e 0d     200 Command ok..
    1ead:	0a 00                                               ..

00001eaf <__c.3085>:
    1eaf:	31 35 30 20 4f 70 65 6e 69 6e 67 20 41 53 43 49     150 Opening ASCI
    1ebf:	49 20 6d 6f 64 65 20 64 61 74 61 20 63 6f 6e 6e     I mode data conn
    1ecf:	65 63 74 69 6f 6e 2e 0d 0a 00                       ection....

00001ed9 <__c.3083>:
    1ed9:	31 35 30 20 4f 70 65 6e 69 6e 67 20 42 49 4e 41     150 Opening BINA
    1ee9:	52 59 20 6d 6f 64 65 20 64 61 74 61 20 63 6f 6e     RY mode data con
    1ef9:	6e 65 63 74 69 6f 6e 2e 0d 0a 00                    nection....

00001f04 <__c.3064>:
    1f04:	32 30 30 20 55 73 69 6e 67 20 41 53 43 49 49 20     200 Using ASCII 
    1f14:	6d 6f 64 65 20 74 6f 20 74 72 61 6e 73 66 65 72     mode to transfer
    1f24:	20 64 61 74 61 2e 0d 0a 00                           data....

00001f2d <__c.3062>:
    1f2d:	32 30 30 20 55 73 69 6e 67 20 42 49 4e 41 52 59     200 Using BINARY
    1f3d:	20 6d 6f 64 65 20 74 6f 20 74 72 61 6e 73 66 65      mode to transfe
    1f4d:	72 20 64 61 74 61 2e 0d 0a 00                       r data....

00001f57 <__c.3043>:
    1f57:	32 35 30 20 44 69 72 65 63 74 6f 72 79 20 63 68     250 Directory ch
    1f67:	61 6e 67 65 64 20 74 6f 20 25 73 0d 0a 00           anged to %s...

00001f75 <__c.3039>:
    1f75:	2f 00                                               /.

00001f77 <__c.2995>:
    1f77:	32 35 30 20 44 69 72 65 63 74 6f 72 79 20 63 68     250 Directory ch
    1f87:	61 6e 67 65 64 20 74 6f 20 25 73 0d 0a 00           anged to %s...

00001f95 <__c.2986>:
    1f95:	2f 00                                               /.

00001f97 <__c.2975>:
    1f97:	2f 00                                               /.

00001f99 <__c.2967>:
    1f99:	32 35 37 20 22 25 73 22 20 69 73 20 79 6f 75 72     257 "%s" is your
    1fa9:	20 63 75 72 72 65 6e 74 20 6c 6f 63 61 74 69 6f      current locatio
    1fb9:	6e 0d 0a 00                                         n...

00001fbd <__c.2948>:
    1fbd:	0d 0a 44 45 4c 45 3a 20 25 73 20 65 78 69 73 74     ..DELE: %s exist
    1fcd:	2e 00                                               ..

00001fcf <__c.2882>:
    1fcf:	25 73 00                                            %s.

00001fd2 <__c.2880>:
    1fd2:	25 39 6c 20 00                                      %9l .

00001fd7 <__c.2878>:
    1fd7:	20 20 20 20 3c 44 49 52 3e 20 00                        <DIR> .

00001fe2 <__c.2876>:
    1fe2:	0d 0a 25 32 69 2e 25 32 69 2e 25 69 20 25 32 69     ..%2i.%2i.%i %2i
    1ff2:	3a 25 32 69 20 00                                   :%2i .

00001ff8 <__c.2870>:
    1ff8:	25 69 2d 25 69 2d 25 69 20 25 69 3a 25 69 3a 25     %i-%i-%i %i:%i:%
    2008:	69 20 25 38 73 20 25 73 0d 0a 00                    i %8s %s...

00002013 <__c.2868>:
    2013:	25 6c 64 00                                         %ld.

00002017 <__c.2866>:
    2017:	3c 44 49 52 3e 00                                   <DIR>.

0000201d <__c.2855>:
    201d:	0a 0d 53 44 2d 4b 61 72 74 65 3a 00                 ..SD-Karte:.

00002029 <__c.2848>:
    2029:	32 31 35 20 44 4f 53 0d 0a 00                       215 DOS...

00002033 <__c.2810>:
    2033:	44 4e 53 20 49 50 3a 20 25 31 69 2e 25 31 69 2e     DNS IP: %1i.%1i.
    2043:	25 31 69 2e 25 31 69 0d 0a 00                       %1i.%1i...

0000204d <__c.2808>:
    204d:	32 35 30 20 6f 6b 2e 20 44 4e 53 20 49 50 3a 20     250 ok. DNS IP: 
    205d:	25 69 2e 25 69 2e 25 69 2e 25 69 0d 0a 00           %i.%i.%i.%i...

0000206b <__c.2772>:
    206b:	0a 0d 54 49 4d 45 3a 20 25 32 69 3a 25 32 69 3a     ..TIME: %2i:%2i:
    207b:	25 32 69 0d 0a 00                                   %2i...

00002081 <__c.2770>:
    2081:	32 35 30 20 6f 6b 2e 20 54 69 6d 65 3a 20 25 32     250 ok. Time: %2
    2091:	69 3a 25 32 69 3a 25 32 69 0d 0a 00                 i:%2i:%2i...

0000209d <__c.2730>:
    209d:	20 54 69 6d 65 3a 25 34 69 0d 0a 00                  Time:%4i...

000020a9 <__c.2728>:
    20a9:	20 44 45 53 54 5f 50 4f 52 54 3a 25 34 69 00         DEST_PORT:%4i.

000020b8 <__c.2726>:
    20b8:	20 53 52 43 5f 50 4f 52 54 3a 25 34 69 00            SRC_PORT:%4i.

000020c6 <__c.2724>:
    20c6:	2e 25 33 69 00                                      .%3i.

000020cb <__c.2722>:
    20cb:	2e 25 33 69 00                                      .%3i.

000020d0 <__c.2720>:
    20d0:	2e 25 33 69 00                                      .%3i.

000020d5 <__c.2718>:
    20d5:	20 20 49 50 3a 25 33 69 00                            IP:%3i.

000020de <__c.2716>:
    20de:	25 32 69 00                                         %2i.

000020e2 <__c.2680>:
    20e2:	20 20 54 69 6d 65 3a 25 34 69 0d 0a 00                Time:%4i...

000020ef <__c.2678>:
    20ef:	2e 25 33 69 00                                      .%3i.

000020f4 <__c.2676>:
    20f4:	2e 25 33 69 00                                      .%3i.

000020f9 <__c.2674>:
    20f9:	2e 25 33 69 00                                      .%3i.

000020fe <__c.2672>:
    20fe:	20 20 49 50 3a 25 33 69 00                            IP:%3i.

00002107 <__c.2670>:
    2107:	2e 25 32 78 00                                      .%2x.

0000210c <__c.2668>:
    210c:	2e 25 32 78 00                                      .%2x.

00002111 <__c.2666>:
    2111:	2e 25 32 78 00                                      .%2x.

00002116 <__c.2664>:
    2116:	2e 25 32 78 00                                      .%2x.

0000211b <__c.2662>:
    211b:	2e 25 32 78 00                                      .%2x.

00002120 <__c.2660>:
    2120:	25 32 69 20 20 4d 41 43 3a 25 32 78 00              %2i  MAC:%2x.

0000212d <__c.2649>:
    212d:	45 4e 43 32 38 4a 36 30 2d 56 65 72 73 69 6f 6e     ENC28J60-Version
    213d:	3a 20 25 31 78 0d 0a 00                             : %1x...

00002145 <__c.2647>:
    2145:	32 35 30 20 6f 6b 2e 20 45 4e 43 32 38 4a 36 30     250 ok. ENC28J60
    2155:	2d 56 65 72 73 69 6f 6e 3a 20 25 31 78 0d 0a 00     -Version: %1x...

00002165 <__c.2628>:
    2165:	4d 79 20 4d 41 43 3a 20 25 32 78 3a 25 32 78 3a     My MAC: %2x:%2x:
    2175:	25 32 78 3a 25 32 78 3a 25 32 78 3a 25 32 78 0d     %2x:%2x:%2x:%2x.
    2185:	0a 00                                               ..

00002187 <__c.2626>:
    2187:	32 35 30 20 6f 6b 2e 20 4d 79 20 4d 41 43 3a 20     250 ok. My MAC: 
    2197:	25 32 78 3a 25 32 78 3a 25 32 78 3a 25 32 78 3a     %2x:%2x:%2x:%2x:
    21a7:	25 32 78 3a 25 32 78 0d 0a 00                       %2x:%2x...

000021b1 <__c.2609>:
    21b1:	52 6f 75 74 65 72 20 49 50 3a 20 25 31 69 2e 25     Router IP: %1i.%
    21c1:	31 69 2e 25 31 69 2e 25 31 69 0d 0a 00              1i.%1i.%1i...

000021ce <__c.2607>:
    21ce:	32 35 30 20 6f 6b 2e 20 52 6f 75 74 65 72 20 49     250 ok. Router I
    21de:	50 3a 20 25 69 2e 25 69 2e 25 69 2e 25 69 0d 0a     P: %i.%i.%i.%i..
	...

000021ef <__c.2590>:
    21ef:	4e 45 54 4d 41 53 4b 3a 20 25 31 69 2e 25 31 69     NETMASK: %1i.%1i
    21ff:	2e 25 31 69 2e 25 31 69 0d 0a 00                    .%1i.%1i...

0000220a <__c.2588>:
    220a:	4e 45 54 4d 41 53 4b 3a 20 25 69 2e 25 69 2e 25     NETMASK: %i.%i.%
    221a:	69 2e 25 69 0d 0a 00                                i.%i...

00002221 <__c.2571>:
    2221:	4e 54 50 5f 53 65 72 76 65 72 3a 20 25 31 69 2e     NTP_Server: %1i.
    2231:	25 31 69 2e 25 31 69 2e 25 31 69 0d 0a 00           %1i.%1i.%1i...

0000223f <__c.2569>:
    223f:	4e 54 50 5f 53 65 72 76 65 72 3a 20 25 69 2e 25     NTP_Server: %i.%
    224f:	69 2e 25 69 2e 25 69 0d 0a 00                       i.%i.%i...

00002259 <__c.2531>:
    2259:	4d 79 20 49 50 3a 20 25 31 69 2e 25 31 69 2e 25     My IP: %1i.%1i.%
    2269:	31 69 2e 25 31 69 0d 0a 00                          1i.%1i...

00002272 <__c.2529>:
    2272:	4d 79 20 49 50 3a 20 25 69 2e 25 69 2e 25 69 2e     My IP: %i.%i.%i.
    2282:	25 69 0d 0a 00                                      %i...

00002287 <__c.2497>:
    2287:	0d 0a 00                                            ...

0000228a <__c.2215>:
    228a:	32 32 30 20 53 65 72 76 65 72 20 62 65 72 65 69     220 Server berei
    229a:	74 0d 0a 00                                         t...

0000229e <__c.2304>:
    229e:	32 32 36 20 54 72 61 6e 73 66 65 72 20 63 6f 6d     226 Transfer com
    22ae:	70 6c 65 74 65 2e 20 43 6c 6f 73 69 6e 67 20 64     plete. Closing d
    22be:	61 74 61 20 63 6f 6e 6e 65 63 74 69 6f 6e 0d 0a     ata connection..
	...

000022cf <__c.2195>:
    22cf:	62 79 65 2c 20 62 79 65 20 2e 2e 2e 0d 0a 00        bye, bye ......

000022de <__c.2190>:
    22de:	35 30 32 20 6e 6f 74 20 69 6d 70 6c 65 6d 65 6e     502 not implemen
    22ee:	74 65 64 2e 0d 0a 00                                ted....

000022f5 <__c.2439>:
    22f5:	0d 0a 00                                            ...

000022f8 <__c.2437>:
    22f8:	25 34 69 3b 25 34 69 3b 25 34 69 3b 25 34 69 3b     %4i;%4i;%4i;%4i;
	...

00002309 <__c.2435>:
    2309:	25 32 69 3b 25 32 69 3a 25 32 69 3a 25 32 69 3b     %2i;%2i:%2i:%2i;
    2319:	20 53 3b 25 63 25 63 25 63 3b 25 32 69 3b 25 69      S;%c%c%c;%2i;%i
    2329:	3b 25 69 3b 25 69 3b 00                             ;%i;%i;.

00002331 <__c.2417>:
    2331:	4c 6f 67 20 67 65 73 74 61 72 74 65 74 20 2d 2d     Log gestartet --
    2341:	2d 2d 2d 2d 2d 2d 0d 0a 00                          ------...

0000234a <__c.2415>:
    234a:	6c 67 25 32 2e 32 69 25 32 2e 32 69 25 32 2e 32     lg%2.2i%2.2i%2.2
    235a:	69 2e 63 73 76 00                                   i.csv.

00002360 <__c.2351>:
    2360:	6e 65 75 3b 25 63 25 63 25 63 3b 25 32 69 3b 0d     neu;%c%c%c;%2i;.
    2370:	0a 00                                               ..

00002372 <__c.2349>:
    2372:	25 32 69 3b 25 32 69 3a 25 32 69 3a 25 32 69 3b     %2i;%2i:%2i:%2i;
    2382:	61 6c 74 3b 25 63 25 63 25 63 3b 25 32 69 3b 00     alt;%c%c%c;%2i;.

00002392 <need_rounding>:
    2392:	01 03 04 06 09 0b 0c 0e                             ........

0000239a <__c.1885>:
    239a:	20 43 52 43 20 4f 2e 4b 2e 20 00                     CRC O.K. .

000023a5 <__c.1883>:
    23a5:	20 43 52 43 20 46 41 49 4c 20 00                     CRC FAIL .

000023b0 <__c.1878>:
    23b0:	28 20 3f 20 29 00                                   ( ? ).

000023b6 <__c.1876>:
    23b6:	28 31 38 42 29 00                                   (18B).

000023bc <__c.1874>:
    23bc:	28 31 38 53 29 00                                   (18S).

000023c2 <__c.1872>:
    23c2:	25 78 20 00                                         %x .

000023c6 <__ctors_end>:
    23c6:	11 24       	eor	r1, r1
    23c8:	1f be       	out	0x3f, r1	; 63
    23ca:	cf ef       	ldi	r28, 0xFF	; 255
    23cc:	d0 e1       	ldi	r29, 0x10	; 16
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	cd bf       	out	0x3d, r28	; 61

000023d2 <__do_copy_data>:
    23d2:	11 e0       	ldi	r17, 0x01	; 1
    23d4:	a0 e0       	ldi	r26, 0x00	; 0
    23d6:	b1 e0       	ldi	r27, 0x01	; 1
    23d8:	e4 e8       	ldi	r30, 0x84	; 132
    23da:	f4 ee       	ldi	r31, 0xE4	; 228
    23dc:	02 c0       	rjmp	.+4      	; 0x23e2 <.do_copy_data_start>

000023de <.do_copy_data_loop>:
    23de:	05 90       	lpm	r0, Z+
    23e0:	0d 92       	st	X+, r0

000023e2 <.do_copy_data_start>:
    23e2:	aa 3d       	cpi	r26, 0xDA	; 218
    23e4:	b1 07       	cpc	r27, r17
    23e6:	d9 f7       	brne	.-10     	; 0x23de <.do_copy_data_loop>

000023e8 <__do_clear_bss>:
    23e8:	1d e0       	ldi	r17, 0x0D	; 13
    23ea:	aa ed       	ldi	r26, 0xDA	; 218
    23ec:	b1 e0       	ldi	r27, 0x01	; 1
    23ee:	01 c0       	rjmp	.+2      	; 0x23f2 <.do_clear_bss_start>

000023f0 <.do_clear_bss_loop>:
    23f0:	1d 92       	st	X+, r1

000023f2 <.do_clear_bss_start>:
    23f2:	a9 3d       	cpi	r26, 0xD9	; 217
    23f4:	b1 07       	cpc	r27, r17
    23f6:	e1 f7       	brne	.-8      	; 0x23f0 <.do_clear_bss_loop>
    23f8:	0e 94 02 12 	call	0x2404	; 0x2404 <main>
    23fc:	0c 94 40 72 	jmp	0xe480	; 0xe480 <_exit>

00002400 <__bad_interrupt>:
    2400:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002404 <main>:
void read_T(void);

//----------------------------------------------------------------------------
//
int main(void)
{
    2404:	2f 92       	push	r2
    2406:	3f 92       	push	r3
    2408:	4f 92       	push	r4
    240a:	5f 92       	push	r5
    240c:	6f 92       	push	r6
    240e:	7f 92       	push	r7
    2410:	8f 92       	push	r8
    2412:	9f 92       	push	r9
    2414:	af 92       	push	r10
    2416:	bf 92       	push	r11
    2418:	cf 92       	push	r12
    241a:	df 92       	push	r13
    241c:	ef 92       	push	r14
    241e:	ff 92       	push	r15
    2420:	0f 93       	push	r16
    2422:	1f 93       	push	r17
    2424:	df 93       	push	r29
    2426:	cf 93       	push	r28
    2428:	00 d0       	rcall	.+0      	; 0x242a <main+0x26>
    242a:	cd b7       	in	r28, 0x3d	; 61
    242c:	de b7       	in	r29, 0x3e	; 62
	//Konfiguration der Ausgnge bzw. Eingnge
	//definition erfolgt in der config.h
	DDRA = OUTA;
    242e:	87 e0       	ldi	r24, 0x07	; 7
    2430:	81 b9       	out	0x01, r24	; 1
	DDRC = OUTC;
    2432:	17 b8       	out	0x07, r1	; 7
	DDRD = OUTD;
    2434:	1a b8       	out	0x0a, r1	; 10
    unsigned long a;
	#if USE_SERVO
		servo_init ();
	#endif //USE_SERVO
	
    usart_init(BAUDRATE); 	// setup the USART
    2436:	60 e0       	ldi	r22, 0x00	; 0
    2438:	76 e9       	ldi	r23, 0x96	; 150
    243a:	80 e0       	ldi	r24, 0x00	; 0
    243c:	90 e0       	ldi	r25, 0x00	; 0
    243e:	0e 94 ba 13 	call	0x2774	; 0x2774 <usart_init>
	stdout = &usart_out;	// set standard lib-functions
    2442:	84 e1       	ldi	r24, 0x14	; 20
    2444:	91 e0       	ldi	r25, 0x01	; 1
    2446:	90 93 d4 0d 	sts	0x0DD4, r25
    244a:	80 93 d3 0d 	sts	0x0DD3, r24
	
	#if USE_ADC
		ADC_Init();
	#endif
	
	printf_P(PSTR("\n\rSystem Ready\n\r"));
    244e:	00 d0       	rcall	.+0      	; 0x2450 <main+0x4c>
    2450:	88 ef       	ldi	r24, 0xF8	; 248
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	ed b7       	in	r30, 0x3d	; 61
    2456:	fe b7       	in	r31, 0x3e	; 62
    2458:	92 83       	std	Z+2, r25	; 0x02
    245a:	81 83       	std	Z+1, r24	; 0x01
    245c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    printf_P(PSTR("Compiliert am "__DATE__" um "__TIME__"\r\n"));
    2460:	80 ed       	ldi	r24, 0xD0	; 208
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	ed b7       	in	r30, 0x3d	; 61
    2466:	fe b7       	in	r31, 0x3e	; 62
    2468:	92 83       	std	Z+2, r25	; 0x02
    246a:	81 83       	std	Z+1, r24	; 0x01
    246c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    printf_P(PSTR("Compiliert mit GCC Version "__VERSION__"\r\n"));
    2470:	8d ea       	ldi	r24, 0xAD	; 173
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	ed b7       	in	r30, 0x3d	; 61
    2476:	fe b7       	in	r31, 0x3e	; 62
    2478:	92 83       	std	Z+2, r25	; 0x02
    247a:	81 83       	std	Z+1, r24	; 0x01
    247c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    2480:	80 e0       	ldi	r24, 0x00	; 0
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	a0 e0       	ldi	r26, 0x00	; 0
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	0f 90       	pop	r0
    248a:	0f 90       	pop	r0
	for(a=0;a<1000000;a++){asm("nop");};
    248c:	00 00       	nop
    248e:	01 96       	adiw	r24, 0x01	; 1
    2490:	a1 1d       	adc	r26, r1
    2492:	b1 1d       	adc	r27, r1
    2494:	80 34       	cpi	r24, 0x40	; 64
    2496:	f2 e4       	ldi	r31, 0x42	; 66
    2498:	9f 07       	cpc	r25, r31
    249a:	ff e0       	ldi	r31, 0x0F	; 15
    249c:	af 07       	cpc	r26, r31
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	bf 07       	cpc	r27, r31
    24a2:	a1 f7       	brne	.-24     	; 0x248c <main+0x88>

	//Applikationen starten
	timer_init();	// Timer starten - von stack_init() hierher verschoben
    24a4:	0e 94 f6 20 	call	0x41ec	; 0x41ec <timer_init>
	stack_init();
    24a8:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <stack_init>
	httpd_init();
    24ac:	0e 94 b2 2c 	call	0x5964	; 0x5964 <httpd_init>
	telnetd_init();
    24b0:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <telnetd_init>
	lcd_clear();
	back_light = 10;
	lcd_print(0,0,"System Ready");
	#endif
	//Ethernetcard Interrupt enable
	ETH_INT_ENABLE;
    24b4:	ea 9a       	sbi	0x1d, 2	; 29
	
	//Globale Interrupts einschalten
	sei(); 
    24b6:	78 94       	sei
		lcd_print(1,0,"CAMERA READY");
		#endif //USE_SER_LCD
	#endif //USE_CAM
	
	#if USE_DNS
		dns_init();
    24b8:	0e 94 e9 36 	call	0x6dd2	; 0x6dd2 <dns_init>
	#endif

	#if USE_NTP
        ntp_init();
    24bc:	0e 94 82 2f 	call	0x5f04	; 0x5f04 <ntp_init>
	#if USE_WOL
        wol_init();
	#endif //USE_WOL
    
    #if USE_MAIL
        sendmail_init();
    24c0:	0e 94 26 34 	call	0x684c	; 0x684c <sendmail_init>
	#endif //USE_MAIL
    
	#if TCP_SERVICE
		tcpsrvd_init();
    24c4:	0e 94 81 49 	call	0x9302	; 0x9302 <tcpsrvd_init>
	#endif

    #if USE_MMC
		f16_init();
    24c8:	0e 94 a9 4d 	call	0x9b52	; 0x9b52 <f16_init>
	rc5_init();
	#endif

	//**************************************************
	#define logdata usart_write
	messung_init();
    24cc:	0e 94 6e 67 	call	0xcedc	; 0xcedc <messung_init>

		#if USE_LOGDATEI
		if (machineStatus.LogInit ) {
			// neue Logdatei anlegen
			log_init();
			machineStatus.initialisieren = true;
    24d0:	22 24       	eor	r2, r2
    24d2:	23 94       	inc	r2

		if (machineStatus.regeln) {
			// Anlage entsprechend regeln
			// alle 10 Minuten wegen Schaltzustnden
			SOLL_STATUS aktSoll;
			TM_SollzustandGetAktuell(&aktSoll);
    24d4:	8e 01       	movw	r16, r28
    24d6:	0f 5f       	subi	r16, 0xFF	; 255
    24d8:	1f 4f       	sbci	r17, 0xFF	; 255
				*/
				if ( !(machineStatus.PINCStatus & 1<<SENS_PIN2) ) {	// falls eingeschaltet
					anlagenStatus.Zaehler2 = time;
				} 
				else {
					logdata("Sensor 2 Zeit: %i Sekunden",time - anlagenStatus.Zaehler2);
    24da:	62 e9       	ldi	r22, 0x92	; 146
    24dc:	46 2e       	mov	r4, r22
    24de:	60 e0       	ldi	r22, 0x00	; 0
    24e0:	56 2e       	mov	r5, r22
		#endif
	    eth_get_data();
		
        //Terminalcommandos auswerten
		if (usart_status.usart_ready){
            usart_write("\r\n");
    24e2:	5f e8       	ldi	r21, 0x8F	; 143
    24e4:	65 2e       	mov	r6, r21
    24e6:	50 e0       	ldi	r21, 0x00	; 0
    24e8:	75 2e       	mov	r7, r21
			}
			else
			{
				usart_write("ERROR\r\n\r\n");
			}
			PORTD ^= (1<<PD6);
    24ea:	40 e4       	ldi	r20, 0x40	; 64
    24ec:	34 2e       	mov	r3, r20
				usart_write("Ready\r\n\r\n");
			#endif
			}
			else
			{
				usart_write("ERROR\r\n\r\n");
    24ee:	3c e7       	ldi	r19, 0x7C	; 124
    24f0:	83 2e       	mov	r8, r19
    24f2:	30 e0       	ldi	r19, 0x00	; 0
    24f4:	93 2e       	mov	r9, r19
		if (usart_status.usart_ready){
            usart_write("\r\n");
			if(extract_cmd(&usart_rx_buffer[0]))
			{
			#if USE_MMC
				usart_write("\r\nSD:%s>",cwdirectory);
    24f6:	26 e8       	ldi	r18, 0x86	; 134
    24f8:	a2 2e       	mov	r10, r18
    24fa:	20 e0       	ldi	r18, 0x00	; 0
    24fc:	b2 2e       	mov	r11, r18
    24fe:	98 e7       	ldi	r25, 0x78	; 120
    2500:	c9 2e       	mov	r12, r25
    2502:	91 e0       	ldi	r25, 0x01	; 1
    2504:	d9 2e       	mov	r13, r25
        #endif

        //Empfang von Zeitinformationen
		#if USE_NTP
		if(!ntp_timer){
			ntp_timer = NTP_REFRESH;
    2506:	80 e2       	ldi	r24, 0x20	; 32
    2508:	e8 2e       	mov	r14, r24
    250a:	8c e1       	ldi	r24, 0x1C	; 28
    250c:	f8 2e       	mov	r15, r24
	 *	  von USART->TCP geschickt <tt>telnetd_send_data();</tt>
	 *
	 */	
	while(1)
	{
		if (machineStatus.timeChanged) {
    250e:	80 91 3c 06 	lds	r24, 0x063C
    2512:	88 23       	and	r24, r24
    2514:	91 f1       	breq	.+100    	; 0x257a <main+0x176>
			// eine Sekunde hochzhlen und
			// auf nderungen zu vordefinierten Zeiten reagieren
			TM_AddOneSecond();
    2516:	0e 94 7f 22 	call	0x44fe	; 0x44fe <TM_AddOneSecond>
			machineStatus.timeChanged--;
    251a:	80 91 3c 06 	lds	r24, 0x063C
    251e:	81 50       	subi	r24, 0x01	; 1
    2520:	80 93 3c 06 	sts	0x063C, r24
			eth.timer = 1;
    2524:	80 91 45 0b 	lds	r24, 0x0B45
    2528:	82 60       	ori	r24, 0x02	; 2
    252a:	80 93 45 0b 	sts	0x0B45, r24

			// Countdown-Timer bei Bedarf runterzhlen
			if (machineStatus.Timer1) {
    252e:	80 91 48 06 	lds	r24, 0x0648
    2532:	88 23       	and	r24, r24
    2534:	51 f0       	breq	.+20     	; 0x254a <main+0x146>
				machineStatus.Timer1--;
    2536:	80 91 48 06 	lds	r24, 0x0648
    253a:	81 50       	subi	r24, 0x01	; 1
    253c:	80 93 48 06 	sts	0x0648, r24
				if (!machineStatus.Timer1) {	// Zero?
    2540:	80 91 48 06 	lds	r24, 0x0648
    2544:	88 23       	and	r24, r24
    2546:	09 f4       	brne	.+2      	; 0x254a <main+0x146>
					// bei Zero (0) Flag fr Aktion setzen
					// oder sofort ausfhren
					PORTA &= ~(1<<2);	// Pin 2 resetten
    2548:	12 98       	cbi	0x02, 2	; 2
				}
			}

			// ... und der nchste Countdown
			if (machineStatus.Timer2) {
    254a:	80 91 49 06 	lds	r24, 0x0649
    254e:	88 23       	and	r24, r24
    2550:	a1 f0       	breq	.+40     	; 0x257a <main+0x176>
				machineStatus.Timer2--;
    2552:	80 91 49 06 	lds	r24, 0x0649
    2556:	81 50       	subi	r24, 0x01	; 1
    2558:	80 93 49 06 	sts	0x0649, r24
				if (!machineStatus.Timer2) {			// Zero?
    255c:	80 91 49 06 	lds	r24, 0x0649
    2560:	88 23       	and	r24, r24
    2562:	59 f4       	brne	.+22     	; 0x257a <main+0x176>
					if (machineStatus.Timer2_func)
    2564:	80 91 4a 06 	lds	r24, 0x064A
    2568:	90 91 4b 06 	lds	r25, 0x064B
    256c:	89 2b       	or	r24, r25
    256e:	29 f0       	breq	.+10     	; 0x257a <main+0x176>
						machineStatus.Timer2_func();	// ausfhren
    2570:	e0 91 4a 06 	lds	r30, 0x064A
    2574:	f0 91 4b 06 	lds	r31, 0x064B
    2578:	09 95       	icall
		*		machineStatus.Timer3_func = read_T;	// Funktionspointer fr abgelaufene Zeit setzen
		*	}
		*	\endcode
		*
		*/
		if (machineStatus.Time3Elapsed) {
    257a:	80 91 4d 06 	lds	r24, 0x064D
    257e:	88 23       	and	r24, r24
    2580:	69 f0       	breq	.+26     	; 0x259c <main+0x198>
			machineStatus.Time3Elapsed = false;
    2582:	10 92 4d 06 	sts	0x064D, r1
			if (machineStatus.Timer3_func)
    2586:	80 91 4e 06 	lds	r24, 0x064E
    258a:	90 91 4f 06 	lds	r25, 0x064F
    258e:	89 2b       	or	r24, r25
    2590:	29 f0       	breq	.+10     	; 0x259c <main+0x198>
				machineStatus.Timer3_func();			// ausfhren
    2592:	e0 91 4e 06 	lds	r30, 0x064E
    2596:	f0 91 4f 06 	lds	r31, 0x064F
    259a:	09 95       	icall
		}


		#if USE_MMC
		f16_check();	// Ein-/Ausstecken der SD-Karte erkennen
    259c:	0e 94 6d 4d 	call	0x9ada	; 0x9ada <f16_check>
		#endif

		#if USE_SCHEDULER

		#if USE_LOGDATEI
		if (machineStatus.LogInit ) {
    25a0:	80 91 40 06 	lds	r24, 0x0640
    25a4:	88 23       	and	r24, r24
    25a6:	31 f0       	breq	.+12     	; 0x25b4 <main+0x1b0>
			// neue Logdatei anlegen
			log_init();
    25a8:	0e 94 52 66 	call	0xcca4	; 0xcca4 <log_init>
			machineStatus.initialisieren = true;
    25ac:	20 92 3d 06 	sts	0x063D, r2
			machineStatus.LogInit = false;
    25b0:	10 92 40 06 	sts	0x0640, r1
		}
		#endif

		if (machineStatus.initialisieren) {
    25b4:	80 91 3d 06 	lds	r24, 0x063D
    25b8:	88 23       	and	r24, r24
    25ba:	31 f0       	breq	.+12     	; 0x25c8 <main+0x1c4>
			// Schaltzeiten neu einlesen
			initSchaltzeiten(0);
    25bc:	80 e0       	ldi	r24, 0x00	; 0
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	0e 94 b0 66 	call	0xcd60	; 0xcd60 <initSchaltzeiten>
			machineStatus.initialisieren = 0;
    25c4:	10 92 3d 06 	sts	0x063D, r1
		}

		if (machineStatus.regeln) {
    25c8:	80 91 3f 06 	lds	r24, 0x063F
    25cc:	88 23       	and	r24, r24
    25ce:	41 f0       	breq	.+16     	; 0x25e0 <main+0x1dc>
			// Anlage entsprechend regeln
			// alle 10 Minuten wegen Schaltzustnden
			SOLL_STATUS aktSoll;
			TM_SollzustandGetAktuell(&aktSoll);
    25d0:	c8 01       	movw	r24, r16
    25d2:	0e 94 21 22 	call	0x4442	; 0x4442 <TM_SollzustandGetAktuell>
			regelAnlage(&aktSoll);
    25d6:	c8 01       	movw	r24, r16
    25d8:	0e 94 a0 65 	call	0xcb40	; 0xcb40 <regelAnlage>
			machineStatus.regeln = 0;
    25dc:	10 92 3f 06 	sts	0x063F, r1
			machineStatus.Timer3_func = read_T;	// Funktionspointer fr abgelaufene Zeit setzen
		}
		#endif

		#if USE_LOGDATEI
		if (machineStatus.LogSchreiben) {
    25e0:	80 91 41 06 	lds	r24, 0x0641
    25e4:	88 23       	and	r24, r24
    25e6:	21 f0       	breq	.+8      	; 0x25f0 <main+0x1ec>
			// schreiben
			log_status();
    25e8:	0e 94 fd 64 	call	0xc9fa	; 0xc9fa <log_status>
			machineStatus.LogSchreiben = false;
    25ec:	10 92 41 06 	sts	0x0641, r1
		*
		*	Initialisiert wird Port C in <tt> \link messen messung_init()\endlink </tt> und fr das Setzen
		*	der Statusnderung ist der Interrupt <tt>ISR(PCINT2_vect)</tt> zustndig.
		*	Beide Funktionen befinden sich in messung.c
		*/
		if (machineStatus.PINCchanged != 0) {
    25f0:	80 91 44 06 	lds	r24, 0x0644
    25f4:	88 23       	and	r24, r24
    25f6:	09 f4       	brne	.+2      	; 0x25fa <main+0x1f6>
    25f8:	6f c0       	rjmp	.+222    	; 0x26d8 <main+0x2d4>

			// Eingang hat sich gendert

			if (machineStatus.PINCchanged & 1<<SENS_PIN1) {
    25fa:	80 91 44 06 	lds	r24, 0x0644
    25fe:	80 ff       	sbrs	r24, 0
    2600:	0d c0       	rjmp	.+26     	; 0x261c <main+0x218>
				 * zhlen wie oft der PIN eingeschaltet wurde<br>
				 * der Zhlerstand von PINCcounter kann dann<br>
				 * regelmssig ins Logfile geschrieben werden<br>
				*/

				if ( !(machineStatus.PINCStatus & 1<<SENS_PIN1) ) {	// falls eingeschaltet
    2602:	80 91 46 06 	lds	r24, 0x0646
    2606:	80 fd       	sbrc	r24, 0
    2608:	09 c0       	rjmp	.+18     	; 0x261c <main+0x218>
					anlagenStatus.Zaehler1++;
    260a:	80 91 ef 0b 	lds	r24, 0x0BEF
    260e:	90 91 f0 0b 	lds	r25, 0x0BF0
    2612:	01 96       	adiw	r24, 0x01	; 1
    2614:	90 93 f0 0b 	sts	0x0BF0, r25
    2618:	80 93 ef 0b 	sts	0x0BEF, r24
				}
			}

			if (machineStatus.PINCchanged & 1<<SENS_PIN2) {
    261c:	80 91 44 06 	lds	r24, 0x0644
    2620:	81 ff       	sbrs	r24, 1
    2622:	3c c0       	rjmp	.+120    	; 0x269c <main+0x298>
				 * Zustand von Sensor2 hat sich gendert<br>
				 * \b Beispielaktion:<br>
				 * Zeitspanne zwischen Ein- und Ausschalten messen<br>
				 * und in Logdatei festhalten
				*/
				if ( !(machineStatus.PINCStatus & 1<<SENS_PIN2) ) {	// falls eingeschaltet
    2624:	80 91 46 06 	lds	r24, 0x0646
    2628:	81 fd       	sbrc	r24, 1
    262a:	0d c0       	rjmp	.+26     	; 0x2646 <main+0x242>
					anlagenStatus.Zaehler2 = time;
    262c:	80 91 77 0c 	lds	r24, 0x0C77
    2630:	90 91 78 0c 	lds	r25, 0x0C78
    2634:	a0 91 79 0c 	lds	r26, 0x0C79
    2638:	b0 91 7a 0c 	lds	r27, 0x0C7A
    263c:	90 93 f2 0b 	sts	0x0BF2, r25
    2640:	80 93 f1 0b 	sts	0x0BF1, r24
    2644:	2b c0       	rjmp	.+86     	; 0x269c <main+0x298>
				} 
				else {
					logdata("Sensor 2 Zeit: %i Sekunden",time - anlagenStatus.Zaehler2);
    2646:	20 91 77 0c 	lds	r18, 0x0C77
    264a:	30 91 78 0c 	lds	r19, 0x0C78
    264e:	40 91 79 0c 	lds	r20, 0x0C79
    2652:	50 91 7a 0c 	lds	r21, 0x0C7A
    2656:	80 91 f1 0b 	lds	r24, 0x0BF1
    265a:	90 91 f2 0b 	lds	r25, 0x0BF2
    265e:	00 d0       	rcall	.+0      	; 0x2660 <main+0x25c>
    2660:	00 d0       	rcall	.+0      	; 0x2662 <main+0x25e>
    2662:	00 d0       	rcall	.+0      	; 0x2664 <main+0x260>
    2664:	ed b7       	in	r30, 0x3d	; 61
    2666:	fe b7       	in	r31, 0x3e	; 62
    2668:	52 82       	std	Z+2, r5	; 0x02
    266a:	41 82       	std	Z+1, r4	; 0x01
    266c:	a0 e0       	ldi	r26, 0x00	; 0
    266e:	b0 e0       	ldi	r27, 0x00	; 0
    2670:	28 1b       	sub	r18, r24
    2672:	39 0b       	sbc	r19, r25
    2674:	4a 0b       	sbc	r20, r26
    2676:	5b 0b       	sbc	r21, r27
    2678:	23 83       	std	Z+3, r18	; 0x03
    267a:	34 83       	std	Z+4, r19	; 0x04
    267c:	45 83       	std	Z+5, r20	; 0x05
    267e:	56 83       	std	Z+6, r21	; 0x06
    2680:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
					anlagenStatus.Zaehler2=0;
    2684:	10 92 f2 0b 	sts	0x0BF2, r1
    2688:	10 92 f1 0b 	sts	0x0BF1, r1
    268c:	8d b7       	in	r24, 0x3d	; 61
    268e:	9e b7       	in	r25, 0x3e	; 62
    2690:	06 96       	adiw	r24, 0x06	; 6
    2692:	0f b6       	in	r0, 0x3f	; 63
    2694:	f8 94       	cli
    2696:	9e bf       	out	0x3e, r25	; 62
    2698:	0f be       	out	0x3f, r0	; 63
    269a:	8d bf       	out	0x3d, r24	; 61
				}
			}

			if (machineStatus.PINCchanged & 1<<SENS_PIN3) {
    269c:	80 91 44 06 	lds	r24, 0x0644
    26a0:	86 ff       	sbrs	r24, 6
    26a2:	0d c0       	rjmp	.+26     	; 0x26be <main+0x2ba>
				 * - 3. Beispiel
				 * Zustand von Sensor3 hat sich gendert<br>
				 * <b>Beispielaktion:</b>
				 * in Abhngigkeit von Sensor2 Pulse an Sensor3 zhlen
				 */
				if ( !(machineStatus.PINCStatus & 1<<SENS_PIN2) ) {
    26a4:	80 91 46 06 	lds	r24, 0x0646
    26a8:	81 fd       	sbrc	r24, 1
    26aa:	09 c0       	rjmp	.+18     	; 0x26be <main+0x2ba>
					// nur zhlen, wenn Sensor2 eingeschaltet
				   	anlagenStatus.Zaehler3++;
    26ac:	80 91 f3 0b 	lds	r24, 0x0BF3
    26b0:	90 91 f4 0b 	lds	r25, 0x0BF4
    26b4:	01 96       	adiw	r24, 0x01	; 1
    26b6:	90 93 f4 0b 	sts	0x0BF4, r25
    26ba:	80 93 f3 0b 	sts	0x0BF3, r24
				} 
			}

			if (machineStatus.PINCchanged & 1<<SENS_PIN4) {
    26be:	80 91 44 06 	lds	r24, 0x0644
    26c2:	87 ff       	sbrs	r24, 7
    26c4:	07 c0       	rjmp	.+14     	; 0x26d4 <main+0x2d0>
				 * - 4. Beispiel
				 * Zustand von Sensor4 hat sich gendert<br>
				 * \b Beispielaktion:<br>
				 * vordefinierte E-Mail schicken
				 */
				if ( !(machineStatus.PINCStatus & 1<<SENS_PIN4) ) {
    26c6:	80 91 46 06 	lds	r24, 0x0646
    26ca:	87 fd       	sbrc	r24, 7
    26cc:	03 c0       	rjmp	.+6      	; 0x26d4 <main+0x2d0>
					#if USE_MAIL
			    	sendmail(1);
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <sendmail>
					usart_write("\r\nEine E-Mail sollte gesendet werden.");
					#endif
				}
			}

			machineStatus.PINCchanged = 0;
    26d4:	10 92 44 06 	sts	0x0644, r1

		// free running ADC
		#if USE_ADC
		ANALOG_ON;
		#endif
	    eth_get_data();
    26d8:	0e 94 75 1e 	call	0x3cea	; 0x3cea <eth_get_data>
		
        //Terminalcommandos auswerten
		if (usart_status.usart_ready){
    26dc:	80 91 f5 0b 	lds	r24, 0x0BF5
    26e0:	80 ff       	sbrs	r24, 0
    26e2:	2f c0       	rjmp	.+94     	; 0x2742 <main+0x33e>
            usart_write("\r\n");
    26e4:	00 d0       	rcall	.+0      	; 0x26e6 <main+0x2e2>
    26e6:	ed b7       	in	r30, 0x3d	; 61
    26e8:	fe b7       	in	r31, 0x3e	; 62
    26ea:	72 82       	std	Z+2, r7	; 0x02
    26ec:	61 82       	std	Z+1, r6	; 0x01
    26ee:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
			if(extract_cmd(&usart_rx_buffer[0]))
    26f2:	0f 90       	pop	r0
    26f4:	0f 90       	pop	r0
    26f6:	86 ef       	ldi	r24, 0xF6	; 246
    26f8:	9b e0       	ldi	r25, 0x0B	; 11
    26fa:	0e 94 fa 46 	call	0x8df4	; 0x8df4 <extract_cmd>
    26fe:	88 23       	and	r24, r24
    2700:	79 f0       	breq	.+30     	; 0x2720 <main+0x31c>
			{
			#if USE_MMC
				usart_write("\r\nSD:%s>",cwdirectory);
    2702:	00 d0       	rcall	.+0      	; 0x2704 <main+0x300>
    2704:	00 d0       	rcall	.+0      	; 0x2706 <main+0x302>
    2706:	ed b7       	in	r30, 0x3d	; 61
    2708:	fe b7       	in	r31, 0x3e	; 62
    270a:	b2 82       	std	Z+2, r11	; 0x02
    270c:	a1 82       	std	Z+1, r10	; 0x01
    270e:	d4 82       	std	Z+4, r13	; 0x04
    2710:	c3 82       	std	Z+3, r12	; 0x03
    2712:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    2716:	0f 90       	pop	r0
    2718:	0f 90       	pop	r0
    271a:	0f 90       	pop	r0
    271c:	0f 90       	pop	r0
    271e:	09 c0       	rjmp	.+18     	; 0x2732 <main+0x32e>
				usart_write("Ready\r\n\r\n");
			#endif
			}
			else
			{
				usart_write("ERROR\r\n\r\n");
    2720:	00 d0       	rcall	.+0      	; 0x2722 <main+0x31e>
    2722:	ed b7       	in	r30, 0x3d	; 61
    2724:	fe b7       	in	r31, 0x3e	; 62
    2726:	92 82       	std	Z+2, r9	; 0x02
    2728:	81 82       	std	Z+1, r8	; 0x01
    272a:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    272e:	0f 90       	pop	r0
    2730:	0f 90       	pop	r0
			}
			PORTD ^= (1<<PD6);
    2732:	8b b1       	in	r24, 0x0b	; 11
    2734:	83 25       	eor	r24, r3
    2736:	8b b9       	out	0x0b, r24	; 11
			usart_status.usart_ready =0;
    2738:	80 91 f5 0b 	lds	r24, 0x0BF5
    273c:	8e 7f       	andi	r24, 0xFE	; 254
    273e:	80 93 f5 0b 	sts	0x0BF5, r24
        http_request ();
        #endif

        //Empfang von Zeitinformationen
		#if USE_NTP
		if(!ntp_timer){
    2742:	80 91 4a 0b 	lds	r24, 0x0B4A
    2746:	90 91 4b 0b 	lds	r25, 0x0B4B
    274a:	89 2b       	or	r24, r25
    274c:	31 f4       	brne	.+12     	; 0x275a <main+0x356>
			ntp_timer = NTP_REFRESH;
    274e:	f0 92 4b 0b 	sts	0x0B4B, r15
    2752:	e0 92 4a 0b 	sts	0x0B4A, r14
			ntp_request();
    2756:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <ntp_request>
		}
		#endif //USE_NTP
		
        //Versand von E-Mails
        #if USE_MAIL
        if (machineStatus.sendmail != 0)
    275a:	80 91 43 06 	lds	r24, 0x0643
    275e:	88 23       	and	r24, r24
    2760:	31 f0       	breq	.+12     	; 0x276e <main+0x36a>
        {
            machineStatus.sendmail = sendmail(machineStatus.sendmail);
    2762:	80 91 43 06 	lds	r24, 0x0643
    2766:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <sendmail>
    276a:	80 93 43 06 	sts	0x0643, r24
            wol_request();
        }
        #endif //USE_WOL
           
		//USART Daten fr Telnetanwendung?
		telnetd_send_data();
    276e:	0e 94 bf 2c 	call	0x597e	; 0x597e <telnetd_send_data>
    2772:	cd ce       	rjmp	.-614    	; 0x250e <main+0x10a>

00002774 <usart_init>:
/**
 *	\ingroup usart
 * Init serielle Schnittstelle
 */
void usart_init(unsigned long baudrate) 
{ 
    2774:	9b 01       	movw	r18, r22
    2776:	ac 01       	movw	r20, r24
#if defined (__AVR_ATmega644P__) || !USE_CAM
	//Serielle Schnittstelle 1
  	//Enable TXEN im Register UCR TX-Data Enable
	UCR =(1 << TXEN | 1 << RXEN | 1<< RXCIE);
    2778:	88 e9       	ldi	r24, 0x98	; 152
    277a:	80 93 c1 00 	sts	0x00C1, r24
	// 1 = Parity Mode Enabled, Even Parity
	// 2 = Parity Mode Enabled, Odd Parity
	//UCSRC = 0x06 + ((parity+1)<<4);
	//UCSRC |= (1<<USBS);
	//Teiler wird gesetzt 
	UBRR=(F_CPU / (baudrate * 16L) - 1);
    277e:	84 e0       	ldi	r24, 0x04	; 4
    2780:	22 0f       	add	r18, r18
    2782:	33 1f       	adc	r19, r19
    2784:	44 1f       	adc	r20, r20
    2786:	55 1f       	adc	r21, r21
    2788:	8a 95       	dec	r24
    278a:	d1 f7       	brne	.-12     	; 0x2780 <usart_init+0xc>
    278c:	60 e0       	ldi	r22, 0x00	; 0
    278e:	70 e0       	ldi	r23, 0x00	; 0
    2790:	81 ee       	ldi	r24, 0xE1	; 225
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    2798:	21 50       	subi	r18, 0x01	; 1
    279a:	20 93 c4 00 	sts	0x00C4, r18
	usart_status.usart_disable = 0;
    279e:	80 91 f5 0b 	lds	r24, 0x0BF5
    27a2:	8b 7f       	andi	r24, 0xFB	; 251
    27a4:	80 93 f5 0b 	sts	0x0BF5, r24
#endif //USE_CAM
}
    27a8:	08 95       	ret

000027aa <usart_putchar>:
/**
 *	\ingroup usart
 * Routine fr die Serielle Ausgabe eines Zeichens
 */
int usart_putchar(char c, FILE *stream)
{
    27aa:	98 2f       	mov	r25, r24
        }
    }
    return 0;
#else
	#if defined (__AVR_ATmega644P__) || !USE_CAM
	if(!usart_status.usart_disable)
    27ac:	80 91 f5 0b 	lds	r24, 0x0BF5
    27b0:	82 fd       	sbrc	r24, 2
    27b2:	06 c0       	rjmp	.+12     	; 0x27c0 <usart_putchar+0x16>
	{
		//Warten solange bis Zeichen gesendet wurde
		while(!(USR & (1<<UDRE)));
    27b4:	80 91 c0 00 	lds	r24, 0x00C0
    27b8:	85 ff       	sbrs	r24, 5
    27ba:	fc cf       	rjmp	.-8      	; 0x27b4 <usart_putchar+0xa>
		//Ausgabe des Zeichens
		UDR = c;
    27bc:	90 93 c6 00 	sts	0x00C6, r25
	}
	return 0;
	#endif //USE_CAM
#endif
}
    27c0:	80 e0       	ldi	r24, 0x00	; 0
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	08 95       	ret

000027c6 <usart_getchar>:

//----------------------------------------------------------------------------
int usart_getchar(FILE *stream)
{
	if (buffercounter > 0) {
    27c6:	80 91 da 01 	lds	r24, 0x01DA
    27ca:	88 23       	and	r24, r24
    27cc:	19 f4       	brne	.+6      	; 0x27d4 <usart_getchar+0xe>
    27ce:	20 e0       	ldi	r18, 0x00	; 0
    27d0:	30 e0       	ldi	r19, 0x00	; 0
    27d2:	04 c0       	rjmp	.+8      	; 0x27dc <usart_getchar+0x16>
		return usart_rx_buffer[0];
    27d4:	80 91 f6 0b 	lds	r24, 0x0BF6
    27d8:	28 2f       	mov	r18, r24
    27da:	30 e0       	ldi	r19, 0x00	; 0
	}
	return 0;
}
    27dc:	c9 01       	movw	r24, r18
    27de:	08 95       	ret

000027e0 <__vector_20>:
/**
 *	\ingroup usart
 * Empfang eines Zeichens
 */
ISR(USART_RX)
{
    27e0:	1f 92       	push	r1
    27e2:	0f 92       	push	r0
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	0f 92       	push	r0
    27e8:	11 24       	eor	r1, r1
    27ea:	2f 93       	push	r18
    27ec:	3f 93       	push	r19
    27ee:	8f 93       	push	r24
    27f0:	9f 93       	push	r25
    27f2:	ef 93       	push	r30
    27f4:	ff 93       	push	r31
	if(!usart_status.usart_disable)
    27f6:	20 91 f5 0b 	lds	r18, 0x0BF5
    27fa:	22 fd       	sbrc	r18, 2
    27fc:	40 c0       	rjmp	.+128    	; 0x287e <__vector_20+0x9e>
	{
		unsigned char receive_char;
		receive_char = (UDR);
    27fe:	90 91 c6 00 	lds	r25, 0x00C6
#else
	#if defined (__AVR_ATmega644P__) || !USE_CAM
	if(!usart_status.usart_disable)
	{
		//Warten solange bis Zeichen gesendet wurde
		while(!(USR & (1<<UDRE)));
    2802:	80 91 c0 00 	lds	r24, 0x00C0
    2806:	85 ff       	sbrs	r24, 5
    2808:	fc cf       	rjmp	.-8      	; 0x2802 <__vector_20+0x22>
		//Ausgabe des Zeichens
		UDR = c;
    280a:	90 93 c6 00 	sts	0x00C6, r25
		
		#if USART_ECHO
		usart_write_char(receive_char);
		#endif
	
		if (usart_status.usart_ready)
    280e:	20 ff       	sbrs	r18, 0
    2810:	04 c0       	rjmp	.+8      	; 0x281a <__vector_20+0x3a>
		{
			usart_status.usart_rx_ovl = 1;
    2812:	80 91 f5 0b 	lds	r24, 0x0BF5
    2816:	82 60       	ori	r24, 0x02	; 2
    2818:	20 c0       	rjmp	.+64     	; 0x285a <__vector_20+0x7a>
			return; 
		}
        
        if (receive_char == 0x08)
    281a:	98 30       	cpi	r25, 0x08	; 8
    281c:	49 f4       	brne	.+18     	; 0x2830 <__vector_20+0x50>
        {
            if (buffercounter) buffercounter--;
    281e:	80 91 da 01 	lds	r24, 0x01DA
    2822:	88 23       	and	r24, r24
    2824:	09 f4       	brne	.+2      	; 0x2828 <__vector_20+0x48>
    2826:	48 c0       	rjmp	.+144    	; 0x28b8 <__vector_20+0xd8>
    2828:	80 91 da 01 	lds	r24, 0x01DA
    282c:	81 50       	subi	r24, 0x01	; 1
    282e:	24 c0       	rjmp	.+72     	; 0x2878 <__vector_20+0x98>
            return;
        }
    
		if (receive_char == '\r' && (!(usart_rx_buffer[buffercounter-1] == '\\')))
    2830:	9d 30       	cpi	r25, 0x0D	; 13
    2832:	b1 f4       	brne	.+44     	; 0x2860 <__vector_20+0x80>
    2834:	e0 91 da 01 	lds	r30, 0x01DA
    2838:	f0 e0       	ldi	r31, 0x00	; 0
    283a:	eb 50       	subi	r30, 0x0B	; 11
    283c:	f4 4f       	sbci	r31, 0xF4	; 244
    283e:	80 81       	ld	r24, Z
    2840:	8c 35       	cpi	r24, 0x5C	; 92
    2842:	71 f0       	breq	.+28     	; 0x2860 <__vector_20+0x80>
		{
			usart_rx_buffer[buffercounter] = 0;
    2844:	e0 91 da 01 	lds	r30, 0x01DA
    2848:	f0 e0       	ldi	r31, 0x00	; 0
    284a:	ea 50       	subi	r30, 0x0A	; 10
    284c:	f4 4f       	sbci	r31, 0xF4	; 244
    284e:	10 82       	st	Z, r1
			buffercounter = 0;
    2850:	10 92 da 01 	sts	0x01DA, r1
			usart_status.usart_ready = 1;
    2854:	80 91 f5 0b 	lds	r24, 0x0BF5
    2858:	81 60       	ori	r24, 0x01	; 1
    285a:	80 93 f5 0b 	sts	0x0BF5, r24
    285e:	2c c0       	rjmp	.+88     	; 0x28b8 <__vector_20+0xd8>
			return;    
		}
	
		if (buffercounter < BUFFER_SIZE - 1)
    2860:	80 91 da 01 	lds	r24, 0x01DA
    2864:	81 33       	cpi	r24, 0x31	; 49
    2866:	40 f5       	brcc	.+80     	; 0x28b8 <__vector_20+0xd8>
		{
			usart_rx_buffer[buffercounter++] = receive_char;    
    2868:	80 91 da 01 	lds	r24, 0x01DA
    286c:	e8 2f       	mov	r30, r24
    286e:	f0 e0       	ldi	r31, 0x00	; 0
    2870:	ea 50       	subi	r30, 0x0A	; 10
    2872:	f4 4f       	sbci	r31, 0xF4	; 244
    2874:	90 83       	st	Z, r25
    2876:	8f 5f       	subi	r24, 0xFF	; 255
    2878:	80 93 da 01 	sts	0x01DA, r24
    287c:	1d c0       	rjmp	.+58     	; 0x28b8 <__vector_20+0xd8>
		}
	}
	else
	{
		if(rx_buffer_pointer_in == (rx_buffer_pointer_out - 1))
    287e:	20 91 22 01 	lds	r18, 0x0122
    2882:	30 91 23 01 	lds	r19, 0x0123
    2886:	80 91 24 01 	lds	r24, 0x0124
    288a:	90 91 25 01 	lds	r25, 0x0125
    288e:	01 97       	sbiw	r24, 0x01	; 1
    2890:	28 17       	cp	r18, r24
    2892:	39 07       	cpc	r19, r25
    2894:	89 f0       	breq	.+34     	; 0x28b8 <__vector_20+0xd8>
		{
			//Datenverlust
			return;
		}
	
		*rx_buffer_pointer_in++ = UDR;
    2896:	80 91 c6 00 	lds	r24, 0x00C6
    289a:	f9 01       	movw	r30, r18
    289c:	81 93       	st	Z+, r24
    289e:	f0 93 23 01 	sts	0x0123, r31
    28a2:	e0 93 22 01 	sts	0x0122, r30
	
		if (rx_buffer_pointer_in == &usart_rx_buffer[BUFFER_SIZE-1])
    28a6:	e7 52       	subi	r30, 0x27	; 39
    28a8:	fc 40       	sbci	r31, 0x0C	; 12
    28aa:	31 f4       	brne	.+12     	; 0x28b8 <__vector_20+0xd8>
		{
			rx_buffer_pointer_in = &usart_rx_buffer[0];
    28ac:	20 53       	subi	r18, 0x30	; 48
    28ae:	30 40       	sbci	r19, 0x00	; 0
    28b0:	30 93 23 01 	sts	0x0123, r19
    28b4:	20 93 22 01 	sts	0x0122, r18
		}
	}
	return;
}
    28b8:	ff 91       	pop	r31
    28ba:	ef 91       	pop	r30
    28bc:	9f 91       	pop	r25
    28be:	8f 91       	pop	r24
    28c0:	3f 91       	pop	r19
    28c2:	2f 91       	pop	r18
    28c4:	0f 90       	pop	r0
    28c6:	0f be       	out	0x3f, r0	; 63
    28c8:	0f 90       	pop	r0
    28ca:	1f 90       	pop	r1
    28cc:	18 95       	reti

000028ce <htons>:
PING_STRUCT ping;

//----------------------------------------------------------------------------
//Converts integer variables to network Byte order
unsigned int htons(unsigned int val)
{
    28ce:	28 2f       	mov	r18, r24
  return HTONS(val);
}
    28d0:	89 2f       	mov	r24, r25
    28d2:	92 2f       	mov	r25, r18
    28d4:	08 95       	ret

000028d6 <htonl>:
//----------------------------------------------------------------------------
//Converts integer variables to network Byte order
unsigned long htonl(unsigned long val)
{
    28d6:	ef 92       	push	r14
    28d8:	ff 92       	push	r15
    28da:	0f 93       	push	r16
    28dc:	1f 93       	push	r17
    28de:	16 2f       	mov	r17, r22
    28e0:	00 27       	eor	r16, r16
    28e2:	ff 24       	eor	r15, r15
    28e4:	ee 24       	eor	r14, r14
    28e6:	29 2f       	mov	r18, r25
    28e8:	33 27       	eor	r19, r19
    28ea:	44 27       	eor	r20, r20
    28ec:	55 27       	eor	r21, r21
    28ee:	e2 0e       	add	r14, r18
    28f0:	f3 1e       	adc	r15, r19
    28f2:	04 1f       	adc	r16, r20
    28f4:	15 1f       	adc	r17, r21
    28f6:	9b 01       	movw	r18, r22
    28f8:	ac 01       	movw	r20, r24
    28fa:	20 70       	andi	r18, 0x00	; 0
    28fc:	30 70       	andi	r19, 0x00	; 0
    28fe:	50 70       	andi	r21, 0x00	; 0
    2900:	23 2f       	mov	r18, r19
    2902:	34 2f       	mov	r19, r20
    2904:	45 2f       	mov	r20, r21
    2906:	55 27       	eor	r21, r21
    2908:	e2 0e       	add	r14, r18
    290a:	f3 1e       	adc	r15, r19
    290c:	04 1f       	adc	r16, r20
    290e:	15 1f       	adc	r17, r21
    2910:	60 70       	andi	r22, 0x00	; 0
    2912:	80 70       	andi	r24, 0x00	; 0
    2914:	90 70       	andi	r25, 0x00	; 0
    2916:	98 2f       	mov	r25, r24
    2918:	87 2f       	mov	r24, r23
    291a:	76 2f       	mov	r23, r22
    291c:	66 27       	eor	r22, r22
    291e:	e6 0e       	add	r14, r22
    2920:	f7 1e       	adc	r15, r23
    2922:	08 1f       	adc	r16, r24
    2924:	19 1f       	adc	r17, r25
  return HTONL(val);
}
    2926:	b7 01       	movw	r22, r14
    2928:	c8 01       	movw	r24, r16
    292a:	1f 91       	pop	r17
    292c:	0f 91       	pop	r16
    292e:	ff 90       	pop	r15
    2930:	ef 90       	pop	r14
    2932:	08 95       	ret

00002934 <arp_timer_call>:
 *	\ingroup stack
 *	Verwaltung des ARP Timers
 *
 */
void arp_timer_call (void)
{
    2934:	40 e0       	ldi	r20, 0x00	; 0
    2936:	50 e0       	ldi	r21, 0x00	; 0
	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
	{
		if (arp_entry[a].arp_t_time == 0)
    2938:	9a 01       	movw	r18, r20
    293a:	22 0f       	add	r18, r18
    293c:	33 1f       	adc	r19, r19
    293e:	24 0f       	add	r18, r20
    2940:	35 1f       	adc	r19, r21
    2942:	d9 01       	movw	r26, r18
    2944:	aa 0f       	add	r26, r26
    2946:	bb 1f       	adc	r27, r27
    2948:	aa 0f       	add	r26, r26
    294a:	bb 1f       	adc	r27, r27
    294c:	a9 5f       	subi	r26, 0xF9	; 249
    294e:	b4 4f       	sbci	r27, 0xF4	; 244
    2950:	1a 96       	adiw	r26, 0x0a	; 10
    2952:	8d 91       	ld	r24, X+
    2954:	9c 91       	ld	r25, X
    2956:	1b 97       	sbiw	r26, 0x0b	; 11
    2958:	89 2b       	or	r24, r25
    295a:	09 f5       	brne	.+66     	; 0x299e <arp_timer_call+0x6a>
		{
			for (unsigned char b = 0;b<6;b++)
			{
				arp_entry[a].arp_t_mac[b]= 0;
    295c:	1c 92       	st	X, r1
    295e:	11 96       	adiw	r26, 0x01	; 1
    2960:	1c 92       	st	X, r1
    2962:	11 97       	sbiw	r26, 0x01	; 1
    2964:	f9 01       	movw	r30, r18
    2966:	ee 0f       	add	r30, r30
    2968:	ff 1f       	adc	r31, r31
    296a:	ee 0f       	add	r30, r30
    296c:	ff 1f       	adc	r31, r31
    296e:	e7 5f       	subi	r30, 0xF7	; 247
    2970:	f4 4f       	sbci	r31, 0xF4	; 244
    2972:	10 82       	st	Z, r1
    2974:	13 96       	adiw	r26, 0x03	; 3
    2976:	1c 92       	st	X, r1
    2978:	13 97       	sbiw	r26, 0x03	; 3
    297a:	f9 01       	movw	r30, r18
    297c:	ee 0f       	add	r30, r30
    297e:	ff 1f       	adc	r31, r31
    2980:	ee 0f       	add	r30, r30
    2982:	ff 1f       	adc	r31, r31
    2984:	e5 5f       	subi	r30, 0xF5	; 245
    2986:	f4 4f       	sbci	r31, 0xF4	; 244
    2988:	10 82       	st	Z, r1
    298a:	15 96       	adiw	r26, 0x05	; 5
    298c:	1c 92       	st	X, r1
    298e:	15 97       	sbiw	r26, 0x05	; 5
			}
			arp_entry[a].arp_t_ip = 0;
    2990:	16 96       	adiw	r26, 0x06	; 6
    2992:	1d 92       	st	X+, r1
    2994:	1d 92       	st	X+, r1
    2996:	1d 92       	st	X+, r1
    2998:	1c 92       	st	X, r1
    299a:	19 97       	sbiw	r26, 0x09	; 9
    299c:	09 c0       	rjmp	.+18     	; 0x29b0 <arp_timer_call+0x7c>
		}
		else
		{
			arp_entry[a].arp_t_time--;
    299e:	1a 96       	adiw	r26, 0x0a	; 10
    29a0:	8d 91       	ld	r24, X+
    29a2:	9c 91       	ld	r25, X
    29a4:	1b 97       	sbiw	r26, 0x0b	; 11
    29a6:	01 97       	sbiw	r24, 0x01	; 1
    29a8:	1b 96       	adiw	r26, 0x0b	; 11
    29aa:	9c 93       	st	X, r25
    29ac:	8e 93       	st	-X, r24
    29ae:	1a 97       	sbiw	r26, 0x0a	; 10
    29b0:	4f 5f       	subi	r20, 0xFF	; 255
    29b2:	5f 4f       	sbci	r21, 0xFF	; 255
 *	Verwaltung des ARP Timers
 *
 */
void arp_timer_call (void)
{
	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
    29b4:	45 30       	cpi	r20, 0x05	; 5
    29b6:	51 05       	cpc	r21, r1
    29b8:	09 f0       	breq	.+2      	; 0x29bc <arp_timer_call+0x88>
    29ba:	be cf       	rjmp	.-132    	; 0x2938 <arp_timer_call+0x4>
		else
		{
			arp_entry[a].arp_t_time--;
		}
	}
}
    29bc:	08 95       	ret

000029be <add_tcp_app>:
 *	\ingroup stack
 *	Trgt TCP PORT/Anwendung in Anwendungsliste ein
 *
 */
void add_tcp_app (unsigned int port, void(*fp1)(unsigned char))
{
    29be:	ac 01       	movw	r20, r24
    29c0:	20 e0       	ldi	r18, 0x00	; 0
    29c2:	01 c0       	rjmp	.+2      	; 0x29c6 <add_tcp_app+0x8>
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (TCP_PORT_TABLE[port_index].port)
	{ 
		port_index++;
    29c4:	2f 5f       	subi	r18, 0xFF	; 255
 */
void add_tcp_app (unsigned int port, void(*fp1)(unsigned char))
{
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (TCP_PORT_TABLE[port_index].port)
    29c6:	a2 2f       	mov	r26, r18
    29c8:	b0 e0       	ldi	r27, 0x00	; 0
    29ca:	fd 01       	movw	r30, r26
    29cc:	ee 0f       	add	r30, r30
    29ce:	ff 1f       	adc	r31, r31
    29d0:	ee 0f       	add	r30, r30
    29d2:	ff 1f       	adc	r31, r31
    29d4:	e5 52       	subi	r30, 0x25	; 37
    29d6:	fe 4f       	sbci	r31, 0xFE	; 254
    29d8:	80 81       	ld	r24, Z
    29da:	91 81       	ldd	r25, Z+1	; 0x01
    29dc:	89 2b       	or	r24, r25
    29de:	91 f7       	brne	.-28     	; 0x29c4 <add_tcp_app+0x6>
	{ 
		port_index++;
	}
	if (port_index >= MAX_APP_ENTRY)
    29e0:	26 30       	cpi	r18, 0x06	; 6
    29e2:	50 f4       	brcc	.+20     	; 0x29f8 <add_tcp_app+0x3a>
	{
		DEBUG("TCP Zuviele Anwendungen wurden gestartet\r\n");
		return;
	}
	DEBUG("TCP Anwendung wird in Liste eingetragen: Eintrag %i\r\n",port_index);
	TCP_PORT_TABLE[port_index].port = port;
    29e4:	51 83       	std	Z+1, r21	; 0x01
    29e6:	40 83       	st	Z, r20
	TCP_PORT_TABLE[port_index].fp = *fp1;
    29e8:	aa 0f       	add	r26, r26
    29ea:	bb 1f       	adc	r27, r27
    29ec:	aa 0f       	add	r26, r26
    29ee:	bb 1f       	adc	r27, r27
    29f0:	a3 52       	subi	r26, 0x23	; 35
    29f2:	be 4f       	sbci	r27, 0xFE	; 254
    29f4:	6d 93       	st	X+, r22
    29f6:	7c 93       	st	X, r23
    29f8:	08 95       	ret

000029fa <change_port_tcp_app>:
 *	\ingroup stack
 *	nderung der TCP PORT/Anwendung in Anwendungsliste
 *
 */
void change_port_tcp_app (unsigned int port_old, unsigned int port_new)
{
    29fa:	20 e0       	ldi	r18, 0x00	; 0
    29fc:	01 c0       	rjmp	.+2      	; 0x2a00 <change_port_tcp_app+0x6>
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (TCP_PORT_TABLE[port_index].port && TCP_PORT_TABLE[port_index].port != port_old)
	{ 
		port_index++;
    29fe:	2f 5f       	subi	r18, 0xFF	; 255
 */
void change_port_tcp_app (unsigned int port_old, unsigned int port_new)
{
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (TCP_PORT_TABLE[port_index].port && TCP_PORT_TABLE[port_index].port != port_old)
    2a00:	a2 2f       	mov	r26, r18
    2a02:	b0 e0       	ldi	r27, 0x00	; 0
    2a04:	fd 01       	movw	r30, r26
    2a06:	ee 0f       	add	r30, r30
    2a08:	ff 1f       	adc	r31, r31
    2a0a:	ee 0f       	add	r30, r30
    2a0c:	ff 1f       	adc	r31, r31
    2a0e:	e5 52       	subi	r30, 0x25	; 37
    2a10:	fe 4f       	sbci	r31, 0xFE	; 254
    2a12:	01 90       	ld	r0, Z+
    2a14:	f0 81       	ld	r31, Z
    2a16:	e0 2d       	mov	r30, r0
    2a18:	30 97       	sbiw	r30, 0x00	; 0
    2a1a:	19 f0       	breq	.+6      	; 0x2a22 <change_port_tcp_app+0x28>
    2a1c:	e8 17       	cp	r30, r24
    2a1e:	f9 07       	cpc	r31, r25
    2a20:	71 f7       	brne	.-36     	; 0x29fe <change_port_tcp_app+0x4>
	{ 
		port_index++;
	}
	if (port_index >= MAX_APP_ENTRY)
    2a22:	26 30       	cpi	r18, 0x06	; 6
    2a24:	40 f4       	brcc	.+16     	; 0x2a36 <change_port_tcp_app+0x3c>
	{
		DEBUG("(Portnderung) Port wurde nicht gefunden\r\n");
		return;
	}
	DEBUG("TCP Anwendung Port ndern: Eintrag %i\r\n",port_index);
	TCP_PORT_TABLE[port_index].port = port_new;
    2a26:	aa 0f       	add	r26, r26
    2a28:	bb 1f       	adc	r27, r27
    2a2a:	aa 0f       	add	r26, r26
    2a2c:	bb 1f       	adc	r27, r27
    2a2e:	a5 52       	subi	r26, 0x25	; 37
    2a30:	be 4f       	sbci	r27, 0xFE	; 254
    2a32:	6d 93       	st	X+, r22
    2a34:	7c 93       	st	X, r23
    2a36:	08 95       	ret

00002a38 <add_udp_app>:
 *	\ingroup stack
 *	Trgt UDP PORT/Anwendung in Anwendungsliste ein
 *
 */
void add_udp_app (unsigned int port, void(*fp1)(unsigned char))
{
    2a38:	ac 01       	movw	r20, r24
    2a3a:	20 e0       	ldi	r18, 0x00	; 0
    2a3c:	01 c0       	rjmp	.+2      	; 0x2a40 <add_udp_app+0x8>
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (UDP_PORT_TABLE[port_index].port)
	{ 
		port_index++;
    2a3e:	2f 5f       	subi	r18, 0xFF	; 255
 */
void add_udp_app (unsigned int port, void(*fp1)(unsigned char))
{
	unsigned char port_index = 0;
	//Freien Eintrag in der Anwendungliste suchen
	while (UDP_PORT_TABLE[port_index].port)
    2a40:	a2 2f       	mov	r26, r18
    2a42:	b0 e0       	ldi	r27, 0x00	; 0
    2a44:	fd 01       	movw	r30, r26
    2a46:	ee 0f       	add	r30, r30
    2a48:	ff 1f       	adc	r31, r31
    2a4a:	ee 0f       	add	r30, r30
    2a4c:	ff 1f       	adc	r31, r31
    2a4e:	ed 50       	subi	r30, 0x0D	; 13
    2a50:	fe 4f       	sbci	r31, 0xFE	; 254
    2a52:	80 81       	ld	r24, Z
    2a54:	91 81       	ldd	r25, Z+1	; 0x01
    2a56:	89 2b       	or	r24, r25
    2a58:	91 f7       	brne	.-28     	; 0x2a3e <add_udp_app+0x6>
	{ 
		port_index++;
	}
	if (port_index >= MAX_APP_ENTRY)
    2a5a:	26 30       	cpi	r18, 0x06	; 6
    2a5c:	50 f4       	brcc	.+20     	; 0x2a72 <add_udp_app+0x3a>
	{
		DEBUG("Zuviele UDP Anwendungen wurden gestartet\r\n");
		return;
	}
	DEBUG("UDP Anwendung wird in Liste eingetragen: Eintrag %i\r\n",port_index);
	UDP_PORT_TABLE[port_index].port = port;
    2a5e:	51 83       	std	Z+1, r21	; 0x01
    2a60:	40 83       	st	Z, r20
	UDP_PORT_TABLE[port_index].fp = *fp1;
    2a62:	aa 0f       	add	r26, r26
    2a64:	bb 1f       	adc	r27, r27
    2a66:	aa 0f       	add	r26, r26
    2a68:	bb 1f       	adc	r27, r27
    2a6a:	ab 50       	subi	r26, 0x0B	; 11
    2a6c:	be 4f       	sbci	r27, 0xFE	; 254
    2a6e:	6d 93       	st	X+, r22
    2a70:	7c 93       	st	X, r23
    2a72:	08 95       	ret

00002a74 <kill_udp_app>:
 *	\ingroup stack
 *	Lscht UDP Anwendung aus der Anwendungsliste
 *
 */
void kill_udp_app (unsigned int port)
{
    2a74:	9c 01       	movw	r18, r24
    2a76:	e3 ef       	ldi	r30, 0xF3	; 243
    2a78:	f1 e0       	ldi	r31, 0x01	; 1
    unsigned char i;

    for (i = 0; i < MAX_APP_ENTRY; i++)
    {
        if ( UDP_PORT_TABLE[i].port == port )
    2a7a:	80 81       	ld	r24, Z
    2a7c:	91 81       	ldd	r25, Z+1	; 0x01
    2a7e:	82 17       	cp	r24, r18
    2a80:	93 07       	cpc	r25, r19
    2a82:	11 f4       	brne	.+4      	; 0x2a88 <kill_udp_app+0x14>
        {
            UDP_PORT_TABLE[i].port = 0;
    2a84:	11 82       	std	Z+1, r1	; 0x01
    2a86:	10 82       	st	Z, r1
    2a88:	34 96       	adiw	r30, 0x04	; 4
 */
void kill_udp_app (unsigned int port)
{
    unsigned char i;

    for (i = 0; i < MAX_APP_ENTRY; i++)
    2a8a:	82 e0       	ldi	r24, 0x02	; 2
    2a8c:	eb 30       	cpi	r30, 0x0B	; 11
    2a8e:	f8 07       	cpc	r31, r24
    2a90:	a1 f7       	brne	.-24     	; 0x2a7a <kill_udp_app+0x6>
        {
            UDP_PORT_TABLE[i].port = 0;
        }
    }
    return;
}
    2a92:	08 95       	ret

00002a94 <__vector_3>:
 *	\ingroup stack
 *	Interrupt von der Netzwerkkarte
 *
 */
ISR(ETH_INTERRUPT)
{
    2a94:	1f 92       	push	r1
    2a96:	0f 92       	push	r0
    2a98:	0f b6       	in	r0, 0x3f	; 63
    2a9a:	0f 92       	push	r0
    2a9c:	11 24       	eor	r1, r1
    2a9e:	8f 93       	push	r24
	eth.data_present = 1;
    2aa0:	80 91 45 0b 	lds	r24, 0x0B45
    2aa4:	81 60       	ori	r24, 0x01	; 1
    2aa6:	80 93 45 0b 	sts	0x0B45, r24
    time_watchdog = 0;
    2aaa:	10 92 0d 02 	sts	0x020D, r1
    2aae:	10 92 0e 02 	sts	0x020E, r1
    2ab2:	10 92 0f 02 	sts	0x020F, r1
    2ab6:	10 92 10 02 	sts	0x0210, r1
	ETH_INT_DISABLE;
    2aba:	ea 98       	cbi	0x1d, 2	; 29
}
    2abc:	8f 91       	pop	r24
    2abe:	0f 90       	pop	r0
    2ac0:	0f be       	out	0x3f, r0	; 63
    2ac2:	0f 90       	pop	r0
    2ac4:	1f 90       	pop	r1
    2ac6:	18 95       	reti

00002ac8 <arp_entry_add>:
 *	\ingroup stack
 * erzeugt einen ARP - Eintrag wenn noch nicht vorhanden 
 *
 */
void arp_entry_add (void)
{
    2ac8:	0f 93       	push	r16
    2aca:	1f 93       	push	r17
    2acc:	cf 93       	push	r28
    2ace:	df 93       	push	r29
	ip       = (struct IP_Header       *)&eth_buffer[IP_OFFSET];

	//Eintrag schon vorhanden?
	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
	{
		if( ethernet->EnetPacketType == HTONS(0x0806) ) //If ARP
    2ad0:	00 91 62 06 	lds	r16, 0x0662
    2ad4:	10 91 63 06 	lds	r17, 0x0663
    2ad8:	60 e0       	ldi	r22, 0x00	; 0
    2ada:	70 e0       	ldi	r23, 0x00	; 0
    2adc:	86 e0       	ldi	r24, 0x06	; 6
    2ade:	08 30       	cpi	r16, 0x08	; 8
    2ae0:	18 07       	cpc	r17, r24
    2ae2:	c1 f4       	brne	.+48     	; 0x2b14 <arp_entry_add+0x4c>
		{
			if(arp_entry[a].arp_t_ip == arp->ARP_SIPAddr)
    2ae4:	fb 01       	movw	r30, r22
    2ae6:	ee 0f       	add	r30, r30
    2ae8:	ff 1f       	adc	r31, r31
    2aea:	e6 0f       	add	r30, r22
    2aec:	f7 1f       	adc	r31, r23
    2aee:	ee 0f       	add	r30, r30
    2af0:	ff 1f       	adc	r31, r31
    2af2:	ee 0f       	add	r30, r30
    2af4:	ff 1f       	adc	r31, r31
    2af6:	e9 5f       	subi	r30, 0xF9	; 249
    2af8:	f4 4f       	sbci	r31, 0xF4	; 244
    2afa:	26 81       	ldd	r18, Z+6	; 0x06
    2afc:	37 81       	ldd	r19, Z+7	; 0x07
    2afe:	40 85       	ldd	r20, Z+8	; 0x08
    2b00:	51 85       	ldd	r21, Z+9	; 0x09
    2b02:	80 91 72 06 	lds	r24, 0x0672
    2b06:	90 91 73 06 	lds	r25, 0x0673
    2b0a:	a0 91 74 06 	lds	r26, 0x0674
    2b0e:	b0 91 75 06 	lds	r27, 0x0675
    2b12:	1a c0       	rjmp	.+52     	; 0x2b48 <arp_entry_add+0x80>
			//Eintrag gefunden Time refresh
			arp_entry[a].arp_t_time = ARP_MAX_ENTRY_TIME;
			return;
			}
		} 
		if( ethernet->EnetPacketType == HTONS(0x0800) ) //If IP
    2b14:	08 30       	cpi	r16, 0x08	; 8
    2b16:	11 05       	cpc	r17, r1
    2b18:	09 f5       	brne	.+66     	; 0x2b5c <arp_entry_add+0x94>
		{
			if(arp_entry[a].arp_t_ip == ip->IP_Srcaddr)
    2b1a:	fb 01       	movw	r30, r22
    2b1c:	ee 0f       	add	r30, r30
    2b1e:	ff 1f       	adc	r31, r31
    2b20:	e6 0f       	add	r30, r22
    2b22:	f7 1f       	adc	r31, r23
    2b24:	ee 0f       	add	r30, r30
    2b26:	ff 1f       	adc	r31, r31
    2b28:	ee 0f       	add	r30, r30
    2b2a:	ff 1f       	adc	r31, r31
    2b2c:	e9 5f       	subi	r30, 0xF9	; 249
    2b2e:	f4 4f       	sbci	r31, 0xF4	; 244
    2b30:	26 81       	ldd	r18, Z+6	; 0x06
    2b32:	37 81       	ldd	r19, Z+7	; 0x07
    2b34:	40 85       	ldd	r20, Z+8	; 0x08
    2b36:	51 85       	ldd	r21, Z+9	; 0x09
    2b38:	80 91 70 06 	lds	r24, 0x0670
    2b3c:	90 91 71 06 	lds	r25, 0x0671
    2b40:	a0 91 72 06 	lds	r26, 0x0672
    2b44:	b0 91 73 06 	lds	r27, 0x0673
    2b48:	28 17       	cp	r18, r24
    2b4a:	39 07       	cpc	r19, r25
    2b4c:	4a 07       	cpc	r20, r26
    2b4e:	5b 07       	cpc	r21, r27
    2b50:	29 f4       	brne	.+10     	; 0x2b5c <arp_entry_add+0x94>
			{
			//Eintrag gefunden Time refresh
			arp_entry[a].arp_t_time = ARP_MAX_ENTRY_TIME;
    2b52:	84 e6       	ldi	r24, 0x64	; 100
    2b54:	90 e0       	ldi	r25, 0x00	; 0
    2b56:	93 87       	std	Z+11, r25	; 0x0b
    2b58:	82 87       	std	Z+10, r24	; 0x0a
    2b5a:	88 c0       	rjmp	.+272    	; 0x2c6c <arp_entry_add+0x1a4>
			return;
    2b5c:	6f 5f       	subi	r22, 0xFF	; 255
    2b5e:	7f 4f       	sbci	r23, 0xFF	; 255
	ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
	arp      = (struct ARP_Header      *)&eth_buffer[ARP_OFFSET];
	ip       = (struct IP_Header       *)&eth_buffer[IP_OFFSET];

	//Eintrag schon vorhanden?
	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
    2b60:	65 30       	cpi	r22, 0x05	; 5
    2b62:	71 05       	cpc	r23, r1
    2b64:	09 f0       	breq	.+2      	; 0x2b68 <arp_entry_add+0xa0>
    2b66:	ba cf       	rjmp	.-140    	; 0x2adc <arp_entry_add+0x14>
    2b68:	20 e0       	ldi	r18, 0x00	; 0
    2b6a:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	//Freien Eintrag finden
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
	{
		if(arp_entry[b].arp_t_ip == 0)
    2b6c:	a9 01       	movw	r20, r18
    2b6e:	44 0f       	add	r20, r20
    2b70:	55 1f       	adc	r21, r21
    2b72:	42 0f       	add	r20, r18
    2b74:	53 1f       	adc	r21, r19
    2b76:	ea 01       	movw	r28, r20
    2b78:	cc 0f       	add	r28, r28
    2b7a:	dd 1f       	adc	r29, r29
    2b7c:	cc 0f       	add	r28, r28
    2b7e:	dd 1f       	adc	r29, r29
    2b80:	c9 5f       	subi	r28, 0xF9	; 249
    2b82:	d4 4f       	sbci	r29, 0xF4	; 244
    2b84:	be 01       	movw	r22, r28
    2b86:	6a 5f       	subi	r22, 0xFA	; 250
    2b88:	7f 4f       	sbci	r23, 0xFF	; 255
    2b8a:	8e 81       	ldd	r24, Y+6	; 0x06
    2b8c:	9f 81       	ldd	r25, Y+7	; 0x07
    2b8e:	a8 85       	ldd	r26, Y+8	; 0x08
    2b90:	b9 85       	ldd	r27, Y+9	; 0x09
    2b92:	00 97       	sbiw	r24, 0x00	; 0
    2b94:	a1 05       	cpc	r26, r1
    2b96:	b1 05       	cpc	r27, r1
    2b98:	09 f0       	breq	.+2      	; 0x2b9c <arp_entry_add+0xd4>
    2b9a:	62 c0       	rjmp	.+196    	; 0x2c60 <arp_entry_add+0x198>
		{
			if( ethernet->EnetPacketType == HTONS(0x0806) ) //If ARP
    2b9c:	e6 e0       	ldi	r30, 0x06	; 6
    2b9e:	08 30       	cpi	r16, 0x08	; 8
    2ba0:	1e 07       	cpc	r17, r30
    2ba2:	49 f5       	brne	.+82     	; 0x2bf6 <arp_entry_add+0x12e>
			{
				for(unsigned char a = 0; a < 6; a++)
				{
					arp_entry[b].arp_t_mac[a] = ethernet->EnetPacketSrc[a]; 
    2ba4:	80 91 5c 06 	lds	r24, 0x065C
    2ba8:	88 83       	st	Y, r24
    2baa:	80 91 5d 06 	lds	r24, 0x065D
    2bae:	89 83       	std	Y+1, r24	; 0x01
    2bb0:	80 91 5e 06 	lds	r24, 0x065E
    2bb4:	fa 01       	movw	r30, r20
    2bb6:	ee 0f       	add	r30, r30
    2bb8:	ff 1f       	adc	r31, r31
    2bba:	ee 0f       	add	r30, r30
    2bbc:	ff 1f       	adc	r31, r31
    2bbe:	e7 5f       	subi	r30, 0xF7	; 247
    2bc0:	f4 4f       	sbci	r31, 0xF4	; 244
    2bc2:	80 83       	st	Z, r24
    2bc4:	80 91 5f 06 	lds	r24, 0x065F
    2bc8:	8b 83       	std	Y+3, r24	; 0x03
    2bca:	80 91 60 06 	lds	r24, 0x0660
    2bce:	fa 01       	movw	r30, r20
    2bd0:	ee 0f       	add	r30, r30
    2bd2:	ff 1f       	adc	r31, r31
    2bd4:	ee 0f       	add	r30, r30
    2bd6:	ff 1f       	adc	r31, r31
    2bd8:	e5 5f       	subi	r30, 0xF5	; 245
    2bda:	f4 4f       	sbci	r31, 0xF4	; 244
    2bdc:	80 83       	st	Z, r24
    2bde:	80 91 61 06 	lds	r24, 0x0661
    2be2:	8d 83       	std	Y+5, r24	; 0x05
				}
				arp_entry[b].arp_t_ip = arp->ARP_SIPAddr;
    2be4:	80 91 72 06 	lds	r24, 0x0672
    2be8:	90 91 73 06 	lds	r25, 0x0673
    2bec:	a0 91 74 06 	lds	r26, 0x0674
    2bf0:	b0 91 75 06 	lds	r27, 0x0675
    2bf4:	2b c0       	rjmp	.+86     	; 0x2c4c <arp_entry_add+0x184>
				arp_entry[b].arp_t_time = ARP_MAX_ENTRY_TIME;
				return;
			}
			if( ethernet->EnetPacketType == HTONS(0x0800) ) //If IP
    2bf6:	08 30       	cpi	r16, 0x08	; 8
    2bf8:	11 05       	cpc	r17, r1
    2bfa:	c1 f5       	brne	.+112    	; 0x2c6c <arp_entry_add+0x1a4>
			{
				for(unsigned char a = 0; a < 6; a++)
				{
					arp_entry[b].arp_t_mac[a] = ethernet->EnetPacketSrc[a]; 
    2bfc:	80 91 5c 06 	lds	r24, 0x065C
    2c00:	88 83       	st	Y, r24
    2c02:	80 91 5d 06 	lds	r24, 0x065D
    2c06:	89 83       	std	Y+1, r24	; 0x01
    2c08:	80 91 5e 06 	lds	r24, 0x065E
    2c0c:	fa 01       	movw	r30, r20
    2c0e:	ee 0f       	add	r30, r30
    2c10:	ff 1f       	adc	r31, r31
    2c12:	ee 0f       	add	r30, r30
    2c14:	ff 1f       	adc	r31, r31
    2c16:	e7 5f       	subi	r30, 0xF7	; 247
    2c18:	f4 4f       	sbci	r31, 0xF4	; 244
    2c1a:	80 83       	st	Z, r24
    2c1c:	80 91 5f 06 	lds	r24, 0x065F
    2c20:	8b 83       	std	Y+3, r24	; 0x03
    2c22:	80 91 60 06 	lds	r24, 0x0660
    2c26:	fa 01       	movw	r30, r20
    2c28:	ee 0f       	add	r30, r30
    2c2a:	ff 1f       	adc	r31, r31
    2c2c:	ee 0f       	add	r30, r30
    2c2e:	ff 1f       	adc	r31, r31
    2c30:	e5 5f       	subi	r30, 0xF5	; 245
    2c32:	f4 4f       	sbci	r31, 0xF4	; 244
    2c34:	80 83       	st	Z, r24
    2c36:	80 91 61 06 	lds	r24, 0x0661
    2c3a:	8d 83       	std	Y+5, r24	; 0x05
				}
				arp_entry[b].arp_t_ip = ip->IP_Srcaddr;
    2c3c:	80 91 70 06 	lds	r24, 0x0670
    2c40:	90 91 71 06 	lds	r25, 0x0671
    2c44:	a0 91 72 06 	lds	r26, 0x0672
    2c48:	b0 91 73 06 	lds	r27, 0x0673
    2c4c:	fb 01       	movw	r30, r22
    2c4e:	80 83       	st	Z, r24
    2c50:	91 83       	std	Z+1, r25	; 0x01
    2c52:	a2 83       	std	Z+2, r26	; 0x02
    2c54:	b3 83       	std	Z+3, r27	; 0x03
				arp_entry[b].arp_t_time = ARP_MAX_ENTRY_TIME;
    2c56:	84 e6       	ldi	r24, 0x64	; 100
    2c58:	90 e0       	ldi	r25, 0x00	; 0
    2c5a:	9b 87       	std	Y+11, r25	; 0x0b
    2c5c:	8a 87       	std	Y+10, r24	; 0x0a
    2c5e:	06 c0       	rjmp	.+12     	; 0x2c6c <arp_entry_add+0x1a4>
				return;
    2c60:	2f 5f       	subi	r18, 0xFF	; 255
    2c62:	3f 4f       	sbci	r19, 0xFF	; 255
			}
		}
	}
	
	//Freien Eintrag finden
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    2c64:	25 30       	cpi	r18, 0x05	; 5
    2c66:	31 05       	cpc	r19, r1
    2c68:	09 f0       	breq	.+2      	; 0x2c6c <arp_entry_add+0x1a4>
    2c6a:	80 cf       	rjmp	.-256    	; 0x2b6c <arp_entry_add+0xa4>
		}
	}
	//Eintrag konnte nicht mehr aufgenommen werden
	DEBUG("ARP entry tabelle voll!\r\n");
	return;
}
    2c6c:	df 91       	pop	r29
    2c6e:	cf 91       	pop	r28
    2c70:	1f 91       	pop	r17
    2c72:	0f 91       	pop	r16
    2c74:	08 95       	ret

00002c76 <arp_entry_search>:
 *	\ingroup stack
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
    2c76:	1f 93       	push	r17
    2c78:	ab 01       	movw	r20, r22
    2c7a:	bc 01       	movw	r22, r24
    2c7c:	20 e0       	ldi	r18, 0x00	; 0
    2c7e:	30 e0       	ldi	r19, 0x00	; 0
    2c80:	12 2f       	mov	r17, r18
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
	{
		if(arp_entry[b].arp_t_ip == dest_ip)
    2c82:	f9 01       	movw	r30, r18
    2c84:	ee 0f       	add	r30, r30
    2c86:	ff 1f       	adc	r31, r31
    2c88:	e2 0f       	add	r30, r18
    2c8a:	f3 1f       	adc	r31, r19
    2c8c:	ee 0f       	add	r30, r30
    2c8e:	ff 1f       	adc	r31, r31
    2c90:	ee 0f       	add	r30, r30
    2c92:	ff 1f       	adc	r31, r31
    2c94:	e9 5f       	subi	r30, 0xF9	; 249
    2c96:	f4 4f       	sbci	r31, 0xF4	; 244
    2c98:	86 81       	ldd	r24, Z+6	; 0x06
    2c9a:	97 81       	ldd	r25, Z+7	; 0x07
    2c9c:	a0 85       	ldd	r26, Z+8	; 0x08
    2c9e:	b1 85       	ldd	r27, Z+9	; 0x09
    2ca0:	84 17       	cp	r24, r20
    2ca2:	95 07       	cpc	r25, r21
    2ca4:	a6 07       	cpc	r26, r22
    2ca6:	b7 07       	cpc	r27, r23
    2ca8:	31 f0       	breq	.+12     	; 0x2cb6 <arp_entry_search+0x40>
    2caa:	2f 5f       	subi	r18, 0xFF	; 255
    2cac:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    2cae:	25 30       	cpi	r18, 0x05	; 5
    2cb0:	31 05       	cpc	r19, r1
    2cb2:	31 f7       	brne	.-52     	; 0x2c80 <arp_entry_search+0xa>
    2cb4:	15 e0       	ldi	r17, 0x05	; 5
		{
			return(b);
		}
	}
	return (MAX_ARP_ENTRY);
}
    2cb6:	81 2f       	mov	r24, r17
    2cb8:	1f 91       	pop	r17
    2cba:	08 95       	ret

00002cbc <new_eth_header>:
 *	\ingroup stack
 * Diese Routine Erzeugt ein neuen Ethernetheader
 *
 */
void new_eth_header (char *buffer,unsigned long dest_ip)
{
    2cbc:	ff 92       	push	r15
    2cbe:	0f 93       	push	r16
    2cc0:	1f 93       	push	r17
    2cc2:	18 2f       	mov	r17, r24
    2cc4:	09 2f       	mov	r16, r25
	unsigned char b;
	unsigned char a;
	struct Ethernet_Header *ethernet;

	ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
    2cc6:	20 e0       	ldi	r18, 0x00	; 0
    2cc8:	30 e0       	ldi	r19, 0x00	; 0
    2cca:	f2 2e       	mov	r15, r18
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
	{
		if(arp_entry[b].arp_t_ip == dest_ip)
    2ccc:	f9 01       	movw	r30, r18
    2cce:	ee 0f       	add	r30, r30
    2cd0:	ff 1f       	adc	r31, r31
    2cd2:	e2 0f       	add	r30, r18
    2cd4:	f3 1f       	adc	r31, r19
    2cd6:	ee 0f       	add	r30, r30
    2cd8:	ff 1f       	adc	r31, r31
    2cda:	ee 0f       	add	r30, r30
    2cdc:	ff 1f       	adc	r31, r31
    2cde:	e9 5f       	subi	r30, 0xF9	; 249
    2ce0:	f4 4f       	sbci	r31, 0xF4	; 244
    2ce2:	86 81       	ldd	r24, Z+6	; 0x06
    2ce4:	97 81       	ldd	r25, Z+7	; 0x07
    2ce6:	a0 85       	ldd	r26, Z+8	; 0x08
    2ce8:	b1 85       	ldd	r27, Z+9	; 0x09
    2cea:	84 17       	cp	r24, r20
    2cec:	95 07       	cpc	r25, r21
    2cee:	a6 07       	cpc	r26, r22
    2cf0:	b7 07       	cpc	r27, r23
    2cf2:	31 f0       	breq	.+12     	; 0x2d00 <new_eth_header+0x44>
    2cf4:	2f 5f       	subi	r18, 0xFF	; 255
    2cf6:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    2cf8:	25 30       	cpi	r18, 0x05	; 5
    2cfa:	31 05       	cpc	r19, r1
    2cfc:	31 f7       	brne	.-52     	; 0x2cca <new_eth_header+0xe>
    2cfe:	26 c0       	rjmp	.+76     	; 0x2d4c <new_eth_header+0x90>
    2d00:	21 2f       	mov	r18, r17
    2d02:	30 2f       	mov	r19, r16
    2d04:	c9 01       	movw	r24, r18
    2d06:	dc 01       	movw	r26, r24
    2d08:	40 e0       	ldi	r20, 0x00	; 0
    2d0a:	50 e0       	ldi	r21, 0x00	; 0
	if (b < MAX_ARP_ENTRY) //Eintrag gefunden wenn kleiner max. Eintrag
	{
		for(a = 0; a < 6; a++)
		{
			//MAC Destadresse wird geschrieben mit MAC Sourceadresse
			ethernet->EnetPacketDest[a] = arp_entry[b].arp_t_mac[a];
    2d0c:	8f 2d       	mov	r24, r15
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	9c 01       	movw	r18, r24
    2d12:	22 0f       	add	r18, r18
    2d14:	33 1f       	adc	r19, r19
    2d16:	28 0f       	add	r18, r24
    2d18:	39 1f       	adc	r19, r25
    2d1a:	22 0f       	add	r18, r18
    2d1c:	33 1f       	adc	r19, r19
    2d1e:	22 0f       	add	r18, r18
    2d20:	33 1f       	adc	r19, r19
    2d22:	f9 01       	movw	r30, r18
    2d24:	e4 0f       	add	r30, r20
    2d26:	f5 1f       	adc	r31, r21
    2d28:	e9 5f       	subi	r30, 0xF9	; 249
    2d2a:	f4 4f       	sbci	r31, 0xF4	; 244
    2d2c:	80 81       	ld	r24, Z
    2d2e:	8c 93       	st	X, r24
			//Meine MAC Adresse wird in Sourceadresse geschrieben
			ethernet->EnetPacketSrc[a] = mymac[a];
    2d30:	fa 01       	movw	r30, r20
    2d32:	e4 58       	subi	r30, 0x84	; 132
    2d34:	f3 4f       	sbci	r31, 0xF3	; 243
    2d36:	80 81       	ld	r24, Z
    2d38:	16 96       	adiw	r26, 0x06	; 6
    2d3a:	8c 93       	st	X, r24
    2d3c:	16 97       	sbiw	r26, 0x06	; 6
    2d3e:	4f 5f       	subi	r20, 0xFF	; 255
    2d40:	5f 4f       	sbci	r21, 0xFF	; 255
    2d42:	11 96       	adiw	r26, 0x01	; 1
	ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
	
	b = arp_entry_search (dest_ip);
	if (b < MAX_ARP_ENTRY) //Eintrag gefunden wenn kleiner max. Eintrag
	{
		for(a = 0; a < 6; a++)
    2d44:	46 30       	cpi	r20, 0x06	; 6
    2d46:	51 05       	cpc	r21, r1
    2d48:	61 f7       	brne	.-40     	; 0x2d22 <new_eth_header+0x66>
    2d4a:	0f c0       	rjmp	.+30     	; 0x2d6a <new_eth_header+0xae>
    2d4c:	ac e7       	ldi	r26, 0x7C	; 124
    2d4e:	bc e0       	ldi	r27, 0x0C	; 12
    2d50:	81 2f       	mov	r24, r17
    2d52:	90 2f       	mov	r25, r16
    2d54:	9c 01       	movw	r18, r24
    2d56:	f9 01       	movw	r30, r18

	DEBUG("ARP Eintrag nicht gefunden*\r\n");
	for(a = 0; a < 6; a++)
	{
		//MAC Destadresse wird geschrieben mit MAC Sourceadresse
		ethernet->EnetPacketDest[a] = 0xFF;
    2d58:	9f ef       	ldi	r25, 0xFF	; 255
    2d5a:	90 83       	st	Z, r25
		//Meine MAC Adresse wird in Sourceadresse geschrieben
		ethernet->EnetPacketSrc[a] = mymac[a];
    2d5c:	8d 91       	ld	r24, X+
    2d5e:	86 83       	std	Z+6, r24	; 0x06
    2d60:	31 96       	adiw	r30, 0x01	; 1
		}
		return;
	}

	DEBUG("ARP Eintrag nicht gefunden*\r\n");
	for(a = 0; a < 6; a++)
    2d62:	8c e0       	ldi	r24, 0x0C	; 12
    2d64:	a2 38       	cpi	r26, 0x82	; 130
    2d66:	b8 07       	cpc	r27, r24
    2d68:	c1 f7       	brne	.-16     	; 0x2d5a <new_eth_header+0x9e>
		//Meine MAC Adresse wird in Sourceadresse geschrieben
		ethernet->EnetPacketSrc[a] = mymac[a];
	}
	return;

}
    2d6a:	1f 91       	pop	r17
    2d6c:	0f 91       	pop	r16
    2d6e:	ff 90       	pop	r15
    2d70:	08 95       	ret

00002d72 <checksum>:
 *	\ingroup stack
 * Diese Routine erzeugt eine Cecksumme
 *
 */
unsigned int checksum (unsigned char *pointer,unsigned int result16,unsigned long result32)
{
    2d72:	ef 92       	push	r14
    2d74:	ff 92       	push	r15
    2d76:	0f 93       	push	r16
    2d78:	1f 93       	push	r17
    2d7a:	cf 93       	push	r28
    2d7c:	df 93       	push	r29
    2d7e:	7c 01       	movw	r14, r24
    2d80:	8b 01       	movw	r16, r22
    2d82:	ec 01       	movw	r28, r24
    2d84:	11 c0       	rjmp	.+34     	; 0x2da8 <checksum+0x36>
	
	//Jetzt werden alle Packete in einer While Schleife addiert
	while(result16 > 1)
	{
		//schreibt Inhalt Pointer nach DATAH danach inc Pointer
		DataH=*pointer++;
    2d86:	88 81       	ld	r24, Y

		//schreibt Inhalt Pointer nach DATAL danach inc Pointer
		DataL=*pointer++;
    2d88:	99 81       	ldd	r25, Y+1	; 0x01
 *	\ingroup stack
 * Diese Routine erzeugt eine Cecksumme
 *
 */
unsigned int checksum (unsigned char *pointer,unsigned int result16,unsigned long result32)
{
    2d8a:	22 96       	adiw	r28, 0x02	; 2
		DataL=*pointer++;

		//erzeugt Int aus Data L und Data H
		result16_1 = ((DataH << 8)+DataL);
		//Addiert packet mit vorherigen
		result32 = result32 + result16_1;
    2d8c:	f8 2f       	mov	r31, r24
    2d8e:	e0 e0       	ldi	r30, 0x00	; 0
    2d90:	df 01       	movw	r26, r30
    2d92:	a9 0f       	add	r26, r25
    2d94:	b1 1d       	adc	r27, r1
    2d96:	cd 01       	movw	r24, r26
    2d98:	a0 e0       	ldi	r26, 0x00	; 0
    2d9a:	b0 e0       	ldi	r27, 0x00	; 0
    2d9c:	28 0f       	add	r18, r24
    2d9e:	39 1f       	adc	r19, r25
    2da0:	4a 1f       	adc	r20, r26
    2da2:	5b 1f       	adc	r21, r27
		//decrimiert Lnge von TCP Headerschleife um 2
		result16 -=2;
    2da4:	62 50       	subi	r22, 0x02	; 2
    2da6:	70 40       	sbci	r23, 0x00	; 0
	unsigned int result16_1 = 0x0000;
	unsigned char DataH;
	unsigned char DataL;
	
	//Jetzt werden alle Packete in einer While Schleife addiert
	while(result16 > 1)
    2da8:	62 30       	cpi	r22, 0x02	; 2
    2daa:	71 05       	cpc	r23, r1
    2dac:	60 f7       	brcc	.-40     	; 0x2d86 <checksum+0x14>
    2dae:	f8 01       	movw	r30, r16
    2db0:	ee 7f       	andi	r30, 0xFE	; 254
    2db2:	ee 0d       	add	r30, r14
    2db4:	ff 1d       	adc	r31, r15
		//decrimiert Lnge von TCP Headerschleife um 2
		result16 -=2;
	}

	//Ist der Wert result16 ungerade ist DataL = 0
	if(result16 > 0)
    2db6:	00 ff       	sbrs	r16, 0
    2db8:	08 c0       	rjmp	.+16     	; 0x2dca <checksum+0x58>
		//schreibt Inhalt Pointer nach DATAH danach inc Pointer
		DataH=*pointer;
		//erzeugt Int aus Data L ist 0 (ist nicht in der Berechnung) und Data H
		result16_1 = (DataH << 8);
		//Addiert packet mit vorherigen
		result32 = result32 + result16_1;
    2dba:	90 81       	ld	r25, Z
    2dbc:	80 e0       	ldi	r24, 0x00	; 0
    2dbe:	a0 e0       	ldi	r26, 0x00	; 0
    2dc0:	b0 e0       	ldi	r27, 0x00	; 0
    2dc2:	28 0f       	add	r18, r24
    2dc4:	39 1f       	adc	r19, r25
    2dc6:	4a 1f       	adc	r20, r26
    2dc8:	5b 1f       	adc	r21, r27
	}
	
	//Komplementbildung (addiert Long INT_H Byte mit Long INT L Byte)
	result32 = ((result32 & 0x0000FFFF)+ ((result32 & 0xFFFF0000) >> 16));
    2dca:	ca 01       	movw	r24, r20
    2dcc:	aa 27       	eor	r26, r26
    2dce:	bb 27       	eor	r27, r27
    2dd0:	40 70       	andi	r20, 0x00	; 0
    2dd2:	50 70       	andi	r21, 0x00	; 0
    2dd4:	82 0f       	add	r24, r18
    2dd6:	93 1f       	adc	r25, r19
    2dd8:	a4 1f       	adc	r26, r20
    2dda:	b5 1f       	adc	r27, r21
	result32 = ((result32 & 0x0000FFFF)+ ((result32 & 0xFFFF0000) >> 16));	
    2ddc:	9d 01       	movw	r18, r26
    2dde:	44 27       	eor	r20, r20
    2de0:	55 27       	eor	r21, r21
    2de2:	a0 70       	andi	r26, 0x00	; 0
    2de4:	b0 70       	andi	r27, 0x00	; 0
    2de6:	28 0f       	add	r18, r24
    2de8:	39 1f       	adc	r19, r25
    2dea:	4a 1f       	adc	r20, r26
    2dec:	5b 1f       	adc	r21, r27
    2dee:	20 95       	com	r18
    2df0:	30 95       	com	r19
	result16 =~(result32 & 0x0000FFFF);
	
	return (result16);
}
    2df2:	c9 01       	movw	r24, r18
    2df4:	df 91       	pop	r29
    2df6:	cf 91       	pop	r28
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	ff 90       	pop	r15
    2dfe:	ef 90       	pop	r14
    2e00:	08 95       	ret

00002e02 <make_ip_header>:
 *	\ingroup stack
 * Diese Routine erzeugt ein IP Packet
 *
 */
void make_ip_header (char *buffer,unsigned long dest_ip)
{
    2e02:	af 92       	push	r10
    2e04:	bf 92       	push	r11
    2e06:	cf 92       	push	r12
    2e08:	df 92       	push	r13
    2e0a:	ef 92       	push	r14
    2e0c:	ff 92       	push	r15
    2e0e:	0f 93       	push	r16
    2e10:	1f 93       	push	r17
    2e12:	7c 01       	movw	r14, r24
    2e14:	5a 01       	movw	r10, r20
    2e16:	6b 01       	movw	r12, r22
    unsigned int result16;  //Checksum
    struct Ethernet_Header *ethernet;
    struct IP_Header       *ip;

    ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
    ip       = (struct IP_Header       *)&buffer[IP_OFFSET];
    2e18:	8c 01       	movw	r16, r24
    2e1a:	02 5f       	subi	r16, 0xF2	; 242
    2e1c:	1f 4f       	sbci	r17, 0xFF	; 255

    new_eth_header (buffer, dest_ip);         //Erzeugt einen neuen Ethernetheader
    2e1e:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <new_eth_header>
    ethernet->EnetPacketType = HTONS(0x0800); //Nutzlast 0x0800=IP
    2e22:	88 e0       	ldi	r24, 0x08	; 8
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	f7 01       	movw	r30, r14
    2e28:	95 87       	std	Z+13, r25	; 0x0d
    2e2a:	84 87       	std	Z+12, r24	; 0x0c

    IP_id_counter++;
    2e2c:	20 91 0b 02 	lds	r18, 0x020B
    2e30:	30 91 0c 02 	lds	r19, 0x020C
    2e34:	2f 5f       	subi	r18, 0xFF	; 255
    2e36:	3f 4f       	sbci	r19, 0xFF	; 255
    2e38:	30 93 0c 02 	sts	0x020C, r19
    2e3c:	20 93 0b 02 	sts	0x020B, r18

    ip->IP_Frag_Offset = 0x0040;  //don't fragment
    2e40:	80 e4       	ldi	r24, 0x40	; 64
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	f8 01       	movw	r30, r16
    2e46:	97 83       	std	Z+7, r25	; 0x07
    2e48:	86 83       	std	Z+6, r24	; 0x06
    ip->IP_ttl         = 128;      //max. hops
    2e4a:	80 e8       	ldi	r24, 0x80	; 128
    2e4c:	80 87       	std	Z+8, r24	; 0x08
    ip->IP_Id          = htons(IP_id_counter);
    2e4e:	34 83       	std	Z+4, r19	; 0x04
    2e50:	25 83       	std	Z+5, r18	; 0x05
    ip->IP_Vers_Len    = 0x45;  //4 BIT Die Versionsnummer von IP, 
    2e52:	85 e4       	ldi	r24, 0x45	; 69
    2e54:	f7 01       	movw	r30, r14
    2e56:	86 87       	std	Z+14, r24	; 0x0e
    ip->IP_Tos         = 0;
    2e58:	f8 01       	movw	r30, r16
    2e5a:	11 82       	std	Z+1, r1	; 0x01
    ip->IP_Destaddr     = dest_ip;
    2e5c:	a0 8a       	std	Z+16, r10	; 0x10
    2e5e:	b1 8a       	std	Z+17, r11	; 0x11
    2e60:	c2 8a       	std	Z+18, r12	; 0x12
    2e62:	d3 8a       	std	Z+19, r13	; 0x13
    ip->IP_Srcaddr     = *((unsigned long *)&myip[0]);
    2e64:	80 91 46 0b 	lds	r24, 0x0B46
    2e68:	90 91 47 0b 	lds	r25, 0x0B47
    2e6c:	a0 91 48 0b 	lds	r26, 0x0B48
    2e70:	b0 91 49 0b 	lds	r27, 0x0B49
    2e74:	84 87       	std	Z+12, r24	; 0x0c
    2e76:	95 87       	std	Z+13, r25	; 0x0d
    2e78:	a6 87       	std	Z+14, r26	; 0x0e
    2e7a:	b7 87       	std	Z+15, r27	; 0x0f
    ip->IP_Hdr_Cksum   = 0;
    2e7c:	13 86       	std	Z+11, r1	; 0x0b
    2e7e:	12 86       	std	Z+10, r1	; 0x0a
  
    //Berechnung der IP Header lnge  
    result16 = (ip->IP_Vers_Len & 0x0F) << 2;

    //jetzt wird die Checksumme berechnet
    result16 = checksum (&ip->IP_Vers_Len, result16, 0);
    2e80:	c8 01       	movw	r24, r16
    2e82:	64 e1       	ldi	r22, 0x14	; 20
    2e84:	70 e0       	ldi	r23, 0x00	; 0
    2e86:	20 e0       	ldi	r18, 0x00	; 0
    2e88:	30 e0       	ldi	r19, 0x00	; 0
    2e8a:	40 e0       	ldi	r20, 0x00	; 0
    2e8c:	50 e0       	ldi	r21, 0x00	; 0
    2e8e:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <checksum>

    //schreibt Checksumme ins Packet
    ip->IP_Hdr_Cksum = htons(result16);
    2e92:	f8 01       	movw	r30, r16
    2e94:	92 87       	std	Z+10, r25	; 0x0a
    2e96:	83 87       	std	Z+11, r24	; 0x0b
    return;
}
    2e98:	1f 91       	pop	r17
    2e9a:	0f 91       	pop	r16
    2e9c:	ff 90       	pop	r15
    2e9e:	ef 90       	pop	r14
    2ea0:	df 90       	pop	r13
    2ea2:	cf 90       	pop	r12
    2ea4:	bf 90       	pop	r11
    2ea6:	af 90       	pop	r10
    2ea8:	08 95       	ret

00002eaa <tcp_entry_add>:
 *	\ingroup stack
 * Diese Routine verwaltet TCP-Eintrge
 *
 */
void tcp_entry_add (char *buffer)
{
    2eaa:	af 92       	push	r10
    2eac:	bf 92       	push	r11
    2eae:	cf 92       	push	r12
    2eb0:	df 92       	push	r13
    2eb2:	ef 92       	push	r14
    2eb4:	ff 92       	push	r15
    2eb6:	0f 93       	push	r16
    2eb8:	1f 93       	push	r17
    2eba:	cf 93       	push	r28
    2ebc:	df 93       	push	r29
    2ebe:	8c 01       	movw	r16, r24
	unsigned long result32;

	struct TCP_Header *tcp;
	struct IP_Header *ip;

	tcp = (struct TCP_Header *)&buffer[TCP_OFFSET];
    2ec0:	ec 01       	movw	r28, r24
    2ec2:	a2 96       	adiw	r28, 0x22	; 34
	ip  = (struct IP_Header  *)&buffer[IP_OFFSET];
    2ec4:	bc 01       	movw	r22, r24
    2ec6:	62 5f       	subi	r22, 0xF2	; 242
    2ec8:	7f 4f       	sbci	r23, 0xFF	; 255
	
	//Eintrag schon vorhanden?
	for (unsigned char index = 0;index<(MAX_TCP_ENTRY);index++)
	{
		if(	tcp_entry[index].ip == ip->IP_Srcaddr &&
    2eca:	db 01       	movw	r26, r22
    2ecc:	1c 96       	adiw	r26, 0x0c	; 12
    2ece:	cd 90       	ld	r12, X+
    2ed0:	dd 90       	ld	r13, X+
    2ed2:	ed 90       	ld	r14, X+
    2ed4:	fc 90       	ld	r15, X
    2ed6:	1f 97       	sbiw	r26, 0x0f	; 15
    2ed8:	40 e0       	ldi	r20, 0x00	; 0
    2eda:	50 e0       	ldi	r21, 0x00	; 0
    2edc:	e6 e1       	ldi	r30, 0x16	; 22
    2ede:	ae 2e       	mov	r10, r30
    2ee0:	b1 2c       	mov	r11, r1
    2ee2:	4a 9d       	mul	r20, r10
    2ee4:	f0 01       	movw	r30, r0
    2ee6:	4b 9d       	mul	r20, r11
    2ee8:	f0 0d       	add	r31, r0
    2eea:	5a 9d       	mul	r21, r10
    2eec:	f0 0d       	add	r31, r0
    2eee:	11 24       	eor	r1, r1
    2ef0:	ec 5a       	subi	r30, 0xAC	; 172
    2ef2:	f4 4f       	sbci	r31, 0xF4	; 244
    2ef4:	80 81       	ld	r24, Z
    2ef6:	91 81       	ldd	r25, Z+1	; 0x01
    2ef8:	a2 81       	ldd	r26, Z+2	; 0x02
    2efa:	b3 81       	ldd	r27, Z+3	; 0x03
    2efc:	8c 15       	cp	r24, r12
    2efe:	9d 05       	cpc	r25, r13
    2f00:	ae 05       	cpc	r26, r14
    2f02:	bf 05       	cpc	r27, r15
    2f04:	09 f0       	breq	.+2      	; 0x2f08 <tcp_entry_add+0x5e>
    2f06:	56 c0       	rjmp	.+172    	; 0x2fb4 <tcp_entry_add+0x10a>
    2f08:	24 81       	ldd	r18, Z+4	; 0x04
    2f0a:	35 81       	ldd	r19, Z+5	; 0x05
    2f0c:	88 81       	ld	r24, Y
    2f0e:	99 81       	ldd	r25, Y+1	; 0x01
    2f10:	28 17       	cp	r18, r24
    2f12:	39 07       	cpc	r19, r25
    2f14:	09 f0       	breq	.+2      	; 0x2f18 <tcp_entry_add+0x6e>
    2f16:	4e c0       	rjmp	.+156    	; 0x2fb4 <tcp_entry_add+0x10a>
			tcp_entry[index].src_port == tcp->TCP_SrcPort)
		{
		//Eintrag gefunden Time refresh
		tcp_entry[index].ack_counter = tcp->TCP_Acknum;
    2f18:	88 85       	ldd	r24, Y+8	; 0x08
    2f1a:	99 85       	ldd	r25, Y+9	; 0x09
    2f1c:	aa 85       	ldd	r26, Y+10	; 0x0a
    2f1e:	bb 85       	ldd	r27, Y+11	; 0x0b
    2f20:	80 87       	std	Z+8, r24	; 0x08
    2f22:	91 87       	std	Z+9, r25	; 0x09
    2f24:	a2 87       	std	Z+10, r26	; 0x0a
    2f26:	b3 87       	std	Z+11, r27	; 0x0b
		tcp_entry[index].seq_counter = tcp->TCP_Seqnum;
    2f28:	8c 81       	ldd	r24, Y+4	; 0x04
    2f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    2f2c:	ae 81       	ldd	r26, Y+6	; 0x06
    2f2e:	bf 81       	ldd	r27, Y+7	; 0x07
    2f30:	84 87       	std	Z+12, r24	; 0x0c
    2f32:	95 87       	std	Z+13, r25	; 0x0d
    2f34:	a6 87       	std	Z+14, r26	; 0x0e
    2f36:	b7 87       	std	Z+15, r27	; 0x0f
		tcp_entry[index].status = tcp->TCP_HdrFlags;
    2f38:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f3a:	80 8b       	std	Z+16, r24	; 0x10
		if (tcp_entry[index].time!=TCP_TIME_OFF)
    2f3c:	83 89       	ldd	r24, Z+19	; 0x13
    2f3e:	8f 3f       	cpi	r24, 0xFF	; 255
    2f40:	11 f0       	breq	.+4      	; 0x2f46 <tcp_entry_add+0x9c>
		{
			tcp_entry[index].time = TCP_MAX_ENTRY_TIME;
    2f42:	83 e0       	ldi	r24, 0x03	; 3
    2f44:	83 8b       	std	Z+19, r24	; 0x13
		}
		result32 = htons(ip->IP_Pktlen) - IP_VERS_LEN - ((tcp->TCP_Hdrlen& 0xF0) >>2);
    2f46:	fb 01       	movw	r30, r22
    2f48:	f2 80       	ldd	r15, Z+2	; 0x02
    2f4a:	e3 80       	ldd	r14, Z+3	; 0x03
    2f4c:	8c ee       	ldi	r24, 0xEC	; 236
    2f4e:	9f ef       	ldi	r25, 0xFF	; 255
    2f50:	e8 0e       	add	r14, r24
    2f52:	f9 1e       	adc	r15, r25
    2f54:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f56:	90 e0       	ldi	r25, 0x00	; 0
    2f58:	80 7f       	andi	r24, 0xF0	; 240
    2f5a:	90 70       	andi	r25, 0x00	; 0
    2f5c:	95 95       	asr	r25
    2f5e:	87 95       	ror	r24
    2f60:	95 95       	asr	r25
    2f62:	87 95       	ror	r24
    2f64:	e8 1a       	sub	r14, r24
    2f66:	f9 0a       	sbc	r15, r25
    2f68:	00 e0       	ldi	r16, 0x00	; 0
    2f6a:	10 e0       	ldi	r17, 0x00	; 0
		result32 = result32 + htonl(tcp_entry[index].seq_counter);
    2f6c:	86 e1       	ldi	r24, 0x16	; 22
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	48 9f       	mul	r20, r24
    2f72:	60 01       	movw	r12, r0
    2f74:	49 9f       	mul	r20, r25
    2f76:	d0 0c       	add	r13, r0
    2f78:	58 9f       	mul	r21, r24
    2f7a:	d0 0c       	add	r13, r0
    2f7c:	11 24       	eor	r1, r1
    2f7e:	a4 e5       	ldi	r26, 0x54	; 84
    2f80:	bb e0       	ldi	r27, 0x0B	; 11
    2f82:	ca 0e       	add	r12, r26
    2f84:	db 1e       	adc	r13, r27
    2f86:	f6 01       	movw	r30, r12
    2f88:	64 85       	ldd	r22, Z+12	; 0x0c
    2f8a:	75 85       	ldd	r23, Z+13	; 0x0d
    2f8c:	86 85       	ldd	r24, Z+14	; 0x0e
    2f8e:	97 85       	ldd	r25, Z+15	; 0x0f
    2f90:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
		tcp_entry[index].seq_counter = htonl(result32);
    2f94:	e6 0e       	add	r14, r22
    2f96:	f7 1e       	adc	r15, r23
    2f98:	08 1f       	adc	r16, r24
    2f9a:	19 1f       	adc	r17, r25
    2f9c:	c8 01       	movw	r24, r16
    2f9e:	b7 01       	movw	r22, r14
    2fa0:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    2fa4:	d6 01       	movw	r26, r12
    2fa6:	1c 96       	adiw	r26, 0x0c	; 12
    2fa8:	6d 93       	st	X+, r22
    2faa:	7d 93       	st	X+, r23
    2fac:	8d 93       	st	X+, r24
    2fae:	9c 93       	st	X, r25
    2fb0:	1f 97       	sbiw	r26, 0x0f	; 15
    2fb2:	4f c0       	rjmp	.+158    	; 0x3052 <tcp_entry_add+0x1a8>
		
		DEBUG("TCP Entry gefunden %i\r\n",index);
		return;
    2fb4:	4f 5f       	subi	r20, 0xFF	; 255
    2fb6:	5f 4f       	sbci	r21, 0xFF	; 255

	tcp = (struct TCP_Header *)&buffer[TCP_OFFSET];
	ip  = (struct IP_Header  *)&buffer[IP_OFFSET];
	
	//Eintrag schon vorhanden?
	for (unsigned char index = 0;index<(MAX_TCP_ENTRY);index++)
    2fb8:	45 30       	cpi	r20, 0x05	; 5
    2fba:	51 05       	cpc	r21, r1
    2fbc:	09 f0       	breq	.+2      	; 0x2fc0 <tcp_entry_add+0x116>
    2fbe:	91 cf       	rjmp	.-222    	; 0x2ee2 <tcp_entry_add+0x38>
    2fc0:	20 e0       	ldi	r18, 0x00	; 0
    2fc2:	30 e0       	ldi	r19, 0x00	; 0
	}
	
	//Freien Eintrag finden
	for (unsigned char index = 0;index<(MAX_TCP_ENTRY);index++)
	{
		if(tcp_entry[index].ip == 0)
    2fc4:	66 e1       	ldi	r22, 0x16	; 22
    2fc6:	70 e0       	ldi	r23, 0x00	; 0
    2fc8:	26 9f       	mul	r18, r22
    2fca:	a0 01       	movw	r20, r0
    2fcc:	27 9f       	mul	r18, r23
    2fce:	50 0d       	add	r21, r0
    2fd0:	36 9f       	mul	r19, r22
    2fd2:	50 0d       	add	r21, r0
    2fd4:	11 24       	eor	r1, r1
    2fd6:	fa 01       	movw	r30, r20
    2fd8:	ec 5a       	subi	r30, 0xAC	; 172
    2fda:	f4 4f       	sbci	r31, 0xF4	; 244
    2fdc:	80 81       	ld	r24, Z
    2fde:	91 81       	ldd	r25, Z+1	; 0x01
    2fe0:	a2 81       	ldd	r26, Z+2	; 0x02
    2fe2:	b3 81       	ldd	r27, Z+3	; 0x03
    2fe4:	00 97       	sbiw	r24, 0x00	; 0
    2fe6:	a1 05       	cpc	r26, r1
    2fe8:	b1 05       	cpc	r27, r1
    2fea:	69 f5       	brne	.+90     	; 0x3046 <tcp_entry_add+0x19c>
		{
			tcp_entry[index].ip          = ip->IP_Srcaddr;
    2fec:	c0 82       	st	Z, r12
    2fee:	d1 82       	std	Z+1, r13	; 0x01
    2ff0:	e2 82       	std	Z+2, r14	; 0x02
    2ff2:	f3 82       	std	Z+3, r15	; 0x03
			tcp_entry[index].src_port    = tcp->TCP_SrcPort;
    2ff4:	d8 01       	movw	r26, r16
    2ff6:	92 96       	adiw	r26, 0x22	; 34
    2ff8:	8d 91       	ld	r24, X+
    2ffa:	9c 91       	ld	r25, X
    2ffc:	93 97       	sbiw	r26, 0x23	; 35
    2ffe:	95 83       	std	Z+5, r25	; 0x05
    3000:	84 83       	std	Z+4, r24	; 0x04
			tcp_entry[index].dest_port   = tcp->TCP_DestPort;
    3002:	8a 81       	ldd	r24, Y+2	; 0x02
    3004:	9b 81       	ldd	r25, Y+3	; 0x03
    3006:	97 83       	std	Z+7, r25	; 0x07
    3008:	86 83       	std	Z+6, r24	; 0x06
			tcp_entry[index].ack_counter = tcp->TCP_Acknum;
    300a:	88 85       	ldd	r24, Y+8	; 0x08
    300c:	99 85       	ldd	r25, Y+9	; 0x09
    300e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3010:	bb 85       	ldd	r27, Y+11	; 0x0b
    3012:	80 87       	std	Z+8, r24	; 0x08
    3014:	91 87       	std	Z+9, r25	; 0x09
    3016:	a2 87       	std	Z+10, r26	; 0x0a
    3018:	b3 87       	std	Z+11, r27	; 0x0b
			tcp_entry[index].seq_counter = tcp->TCP_Seqnum;
    301a:	8c 81       	ldd	r24, Y+4	; 0x04
    301c:	9d 81       	ldd	r25, Y+5	; 0x05
    301e:	ae 81       	ldd	r26, Y+6	; 0x06
    3020:	bf 81       	ldd	r27, Y+7	; 0x07
    3022:	84 87       	std	Z+12, r24	; 0x0c
    3024:	95 87       	std	Z+13, r25	; 0x0d
    3026:	a6 87       	std	Z+14, r26	; 0x0e
    3028:	b7 87       	std	Z+15, r27	; 0x0f
			tcp_entry[index].status      = tcp->TCP_HdrFlags;
    302a:	8d 85       	ldd	r24, Y+13	; 0x0d
    302c:	80 8b       	std	Z+16, r24	; 0x10
			tcp_entry[index].app_status  = 0;
    302e:	12 8a       	std	Z+18, r1	; 0x12
    3030:	11 8a       	std	Z+17, r1	; 0x11
			tcp_entry[index].time        = TCP_MAX_ENTRY_TIME;
    3032:	83 e0       	ldi	r24, 0x03	; 3
    3034:	83 8b       	std	Z+19, r24	; 0x13
			tcp_entry[index].error_count = 0;
    3036:	14 8a       	std	Z+20, r1	; 0x14
			tcp_entry[index].first_ack   = 0;
    3038:	fa 01       	movw	r30, r20
    303a:	e7 59       	subi	r30, 0x97	; 151
    303c:	f4 4f       	sbci	r31, 0xF4	; 244
    303e:	80 81       	ld	r24, Z
    3040:	8e 7f       	andi	r24, 0xFE	; 254
    3042:	80 83       	st	Z, r24
    3044:	06 c0       	rjmp	.+12     	; 0x3052 <tcp_entry_add+0x1a8>
			DEBUG("TCP Entry neuer Eintrag %i\r\n",index);
			return;  
    3046:	2f 5f       	subi	r18, 0xFF	; 255
    3048:	3f 4f       	sbci	r19, 0xFF	; 255
		return;
		}
	}
	
	//Freien Eintrag finden
	for (unsigned char index = 0;index<(MAX_TCP_ENTRY);index++)
    304a:	25 30       	cpi	r18, 0x05	; 5
    304c:	31 05       	cpc	r19, r1
    304e:	09 f0       	breq	.+2      	; 0x3052 <tcp_entry_add+0x1a8>
    3050:	bb cf       	rjmp	.-138    	; 0x2fc8 <tcp_entry_add+0x11e>
		}
	}
	//Eintrag konnte nicht mehr aufgenommen werden
	DEBUG("Server Busy (NO MORE CONNECTIONS)!\r\n");
	return;
}
    3052:	df 91       	pop	r29
    3054:	cf 91       	pop	r28
    3056:	1f 91       	pop	r17
    3058:	0f 91       	pop	r16
    305a:	ff 90       	pop	r15
    305c:	ef 90       	pop	r14
    305e:	df 90       	pop	r13
    3060:	cf 90       	pop	r12
    3062:	bf 90       	pop	r11
    3064:	af 90       	pop	r10
    3066:	08 95       	ret

00003068 <tcp_entry_search>:
 *	\ingroup stack
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
    3068:	ef 92       	push	r14
    306a:	ff 92       	push	r15
    306c:	0f 93       	push	r16
    306e:	1f 93       	push	r17
    3070:	cf 93       	push	r28
    3072:	df 93       	push	r29
    3074:	7b 01       	movw	r14, r22
    3076:	8c 01       	movw	r16, r24
    3078:	20 e0       	ldi	r18, 0x00	; 0
    307a:	30 e0       	ldi	r19, 0x00	; 0
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    307c:	c6 e1       	ldi	r28, 0x16	; 22
    307e:	d0 e0       	ldi	r29, 0x00	; 0
 *	\ingroup stack
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
    3080:	62 2f       	mov	r22, r18
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    3082:	2c 9f       	mul	r18, r28
    3084:	f0 01       	movw	r30, r0
    3086:	2d 9f       	mul	r18, r29
    3088:	f0 0d       	add	r31, r0
    308a:	3c 9f       	mul	r19, r28
    308c:	f0 0d       	add	r31, r0
    308e:	11 24       	eor	r1, r1
    3090:	ec 5a       	subi	r30, 0xAC	; 172
    3092:	f4 4f       	sbci	r31, 0xF4	; 244
    3094:	80 81       	ld	r24, Z
    3096:	91 81       	ldd	r25, Z+1	; 0x01
    3098:	a2 81       	ldd	r26, Z+2	; 0x02
    309a:	b3 81       	ldd	r27, Z+3	; 0x03
    309c:	8e 15       	cp	r24, r14
    309e:	9f 05       	cpc	r25, r15
    30a0:	a0 07       	cpc	r26, r16
    30a2:	b1 07       	cpc	r27, r17
    30a4:	29 f4       	brne	.+10     	; 0x30b0 <tcp_entry_search+0x48>
    30a6:	84 81       	ldd	r24, Z+4	; 0x04
    30a8:	95 81       	ldd	r25, Z+5	; 0x05
    30aa:	84 17       	cp	r24, r20
    30ac:	95 07       	cpc	r25, r21
    30ae:	31 f0       	breq	.+12     	; 0x30bc <tcp_entry_search+0x54>
    30b0:	2f 5f       	subi	r18, 0xFF	; 255
    30b2:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    30b4:	25 30       	cpi	r18, 0x05	; 5
    30b6:	31 05       	cpc	r19, r1
    30b8:	19 f7       	brne	.-58     	; 0x3080 <tcp_entry_search+0x18>
    30ba:	65 e0       	ldi	r22, 0x05	; 5
		{
			return(index);
		}
	}
	return (MAX_TCP_ENTRY);
}
    30bc:	86 2f       	mov	r24, r22
    30be:	df 91       	pop	r29
    30c0:	cf 91       	pop	r28
    30c2:	1f 91       	pop	r17
    30c4:	0f 91       	pop	r16
    30c6:	ff 90       	pop	r15
    30c8:	ef 90       	pop	r14
    30ca:	08 95       	ret

000030cc <udp_socket_process>:
void udp_socket_process(void)
{
	unsigned char port_index = 0;
		
	struct UDP_Header *udp;
	udp = (struct UDP_Header *)&eth_buffer[UDP_OFFSET];
    30cc:	20 e0       	ldi	r18, 0x00	; 0
    30ce:	01 c0       	rjmp	.+2      	; 0x30d2 <udp_socket_process+0x6>

	//UDP DestPort mit Portanwendungsliste durchfhren
	while (UDP_PORT_TABLE[port_index].port && UDP_PORT_TABLE[port_index].port!=(htons(udp->udp_DestPort)))
	{ 
		port_index++;
    30d0:	2f 5f       	subi	r18, 0xFF	; 255
		
	struct UDP_Header *udp;
	udp = (struct UDP_Header *)&eth_buffer[UDP_OFFSET];

	//UDP DestPort mit Portanwendungsliste durchfhren
	while (UDP_PORT_TABLE[port_index].port && UDP_PORT_TABLE[port_index].port!=(htons(udp->udp_DestPort)))
    30d2:	a2 2f       	mov	r26, r18
    30d4:	b0 e0       	ldi	r27, 0x00	; 0
    30d6:	fd 01       	movw	r30, r26
    30d8:	ee 0f       	add	r30, r30
    30da:	ff 1f       	adc	r31, r31
    30dc:	ee 0f       	add	r30, r30
    30de:	ff 1f       	adc	r31, r31
    30e0:	ed 50       	subi	r30, 0x0D	; 13
    30e2:	fe 4f       	sbci	r31, 0xFE	; 254
    30e4:	01 90       	ld	r0, Z+
    30e6:	f0 81       	ld	r31, Z
    30e8:	e0 2d       	mov	r30, r0
    30ea:	30 97       	sbiw	r30, 0x00	; 0
    30ec:	89 f0       	breq	.+34     	; 0x3110 <udp_socket_process+0x44>
    30ee:	90 91 7a 06 	lds	r25, 0x067A
    30f2:	80 91 7b 06 	lds	r24, 0x067B
    30f6:	e8 17       	cp	r30, r24
    30f8:	f9 07       	cpc	r31, r25
    30fa:	51 f7       	brne	.-44     	; 0x30d0 <udp_socket_process+0x4>
		DEBUG("UDP Keine Anwendung gefunden!\r\n");
		return;
	}

	//zugehrige Anwendung ausfhren
	UDP_PORT_TABLE[port_index].fp(0); 
    30fc:	aa 0f       	add	r26, r26
    30fe:	bb 1f       	adc	r27, r27
    3100:	aa 0f       	add	r26, r26
    3102:	bb 1f       	adc	r27, r27
    3104:	ab 50       	subi	r26, 0x0B	; 11
    3106:	be 4f       	sbci	r27, 0xFE	; 254
    3108:	ed 91       	ld	r30, X+
    310a:	fc 91       	ld	r31, X
    310c:	80 e0       	ldi	r24, 0x00	; 0
    310e:	09 95       	icall
    3110:	08 95       	ret

00003112 <find_and_start>:
 *	\ingroup stack
 * Diese Routine findet die Anwendung anhand des TCP Ports (fas find and start)
 *
 */
void find_and_start (unsigned char index)
{
    3112:	cf 93       	push	r28
    3114:	df 93       	push	r29
    3116:	58 2f       	mov	r21, r24
    3118:	cb ed       	ldi	r28, 0xDB	; 219
    311a:	d1 e0       	ldi	r29, 0x01	; 1
    311c:	e0 e0       	ldi	r30, 0x00	; 0
    311e:	f0 e0       	ldi	r31, 0x00	; 0
	unsigned char port_index = 0;

	//Port mit Anwendung in der Liste suchen
	while ( (TCP_PORT_TABLE[port_index].port!=(htons(tcp_entry[index].dest_port))) &&
    3120:	28 2f       	mov	r18, r24
    3122:	30 e0       	ldi	r19, 0x00	; 0
    3124:	86 e1       	ldi	r24, 0x16	; 22
    3126:	90 e0       	ldi	r25, 0x00	; 0
    3128:	28 9f       	mul	r18, r24
    312a:	d0 01       	movw	r26, r0
    312c:	29 9f       	mul	r18, r25
    312e:	b0 0d       	add	r27, r0
    3130:	38 9f       	mul	r19, r24
    3132:	b0 0d       	add	r27, r0
    3134:	11 24       	eor	r1, r1
    3136:	a6 5a       	subi	r26, 0xA6	; 166
    3138:	b4 4f       	sbci	r27, 0xF4	; 244
    313a:	8d 91       	ld	r24, X+
    313c:	9c 91       	ld	r25, X
    313e:	11 97       	sbiw	r26, 0x01	; 1
    3140:	38 2f       	mov	r19, r24
    3142:	29 2f       	mov	r18, r25
    3144:	88 81       	ld	r24, Y
    3146:	99 81       	ldd	r25, Y+1	; 0x01
    3148:	82 17       	cp	r24, r18
    314a:	93 07       	cpc	r25, r19
    314c:	31 f0       	breq	.+12     	; 0x315a <find_and_start+0x48>
    314e:	31 96       	adiw	r30, 0x01	; 1
    3150:	24 96       	adiw	r28, 0x04	; 4
    3152:	e7 30       	cpi	r30, 0x07	; 7
    3154:	f1 05       	cpc	r31, r1
    3156:	89 f7       	brne	.-30     	; 0x313a <find_and_start+0x28>
    3158:	0d c0       	rjmp	.+26     	; 0x3174 <find_and_start+0x62>
	      (port_index < MAX_APP_ENTRY)                                                 )
	{ 
	    port_index++;
	}
	if (port_index >= MAX_APP_ENTRY) return;
    315a:	e6 30       	cpi	r30, 0x06	; 6
    315c:	58 f4       	brcc	.+22     	; 0x3174 <find_and_start+0x62>

	//zugehrige Anwendung ausfhren (Senden wiederholen)
	TCP_PORT_TABLE[port_index].fp(index);
    315e:	ee 0f       	add	r30, r30
    3160:	ff 1f       	adc	r31, r31
    3162:	ee 0f       	add	r30, r30
    3164:	ff 1f       	adc	r31, r31
    3166:	e3 52       	subi	r30, 0x23	; 35
    3168:	fe 4f       	sbci	r31, 0xFE	; 254
    316a:	01 90       	ld	r0, Z+
    316c:	f0 81       	ld	r31, Z
    316e:	e0 2d       	mov	r30, r0
    3170:	85 2f       	mov	r24, r21
    3172:	09 95       	icall
	return;
}
    3174:	df 91       	pop	r29
    3176:	cf 91       	pop	r28
    3178:	08 95       	ret

0000317a <tcp_index_del>:
 * Diese Routine lscht einen Eintrag
 *
 */
void tcp_index_del (unsigned char index)
{
	if (index<MAX_TCP_ENTRY + 1)
    317a:	86 30       	cpi	r24, 0x06	; 6
    317c:	38 f5       	brcc	.+78     	; 0x31cc <tcp_index_del+0x52>
	{
		tcp_entry[index].ip = 0;
    317e:	28 2f       	mov	r18, r24
    3180:	30 e0       	ldi	r19, 0x00	; 0
    3182:	86 e1       	ldi	r24, 0x16	; 22
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	28 9f       	mul	r18, r24
    3188:	d0 01       	movw	r26, r0
    318a:	29 9f       	mul	r18, r25
    318c:	b0 0d       	add	r27, r0
    318e:	38 9f       	mul	r19, r24
    3190:	b0 0d       	add	r27, r0
    3192:	11 24       	eor	r1, r1
    3194:	fd 01       	movw	r30, r26
    3196:	ec 5a       	subi	r30, 0xAC	; 172
    3198:	f4 4f       	sbci	r31, 0xF4	; 244
    319a:	10 82       	st	Z, r1
    319c:	11 82       	std	Z+1, r1	; 0x01
    319e:	12 82       	std	Z+2, r1	; 0x02
    31a0:	13 82       	std	Z+3, r1	; 0x03
		tcp_entry[index].src_port = 0;
    31a2:	15 82       	std	Z+5, r1	; 0x05
    31a4:	14 82       	std	Z+4, r1	; 0x04
		tcp_entry[index].dest_port = 0;
    31a6:	17 82       	std	Z+7, r1	; 0x07
    31a8:	16 82       	std	Z+6, r1	; 0x06
		tcp_entry[index].ack_counter = 0;
    31aa:	10 86       	std	Z+8, r1	; 0x08
    31ac:	11 86       	std	Z+9, r1	; 0x09
    31ae:	12 86       	std	Z+10, r1	; 0x0a
    31b0:	13 86       	std	Z+11, r1	; 0x0b
		tcp_entry[index].seq_counter = 0;
    31b2:	14 86       	std	Z+12, r1	; 0x0c
    31b4:	15 86       	std	Z+13, r1	; 0x0d
    31b6:	16 86       	std	Z+14, r1	; 0x0e
    31b8:	17 86       	std	Z+15, r1	; 0x0f
		tcp_entry[index].status = 0;
    31ba:	10 8a       	std	Z+16, r1	; 0x10
		tcp_entry[index].app_status = 0;
    31bc:	12 8a       	std	Z+18, r1	; 0x12
    31be:	11 8a       	std	Z+17, r1	; 0x11
		tcp_entry[index].time = 0;
    31c0:	13 8a       	std	Z+19, r1	; 0x13
		tcp_entry[index].first_ack = 0;
    31c2:	a7 59       	subi	r26, 0x97	; 151
    31c4:	b4 4f       	sbci	r27, 0xF4	; 244
    31c6:	8c 91       	ld	r24, X
    31c8:	8e 7f       	andi	r24, 0xFE	; 254
    31ca:	8c 93       	st	X, r24
    31cc:	08 95       	ret

000031ce <create_new_tcp_packet>:
 *	\ingroup stack
 * Diese Routine Erzeugt ein neues TCP Packet
 *
 */
void create_new_tcp_packet(unsigned int data_length,unsigned char index)
{
    31ce:	cf 92       	push	r12
    31d0:	df 92       	push	r13
    31d2:	ef 92       	push	r14
    31d4:	ff 92       	push	r15
    31d6:	0f 93       	push	r16
    31d8:	1f 93       	push	r17
    31da:	cf 93       	push	r28
    31dc:	df 93       	push	r29
    31de:	ec 01       	movw	r28, r24

	struct TCP_Header *tcp;
	struct IP_Header  *ip;

	tcp = (struct TCP_Header *)&eth_buffer[TCP_OFFSET];
	ip  = (struct IP_Header  *)&eth_buffer[IP_OFFSET];
    31e0:	34 e6       	ldi	r19, 0x64	; 100
    31e2:	e3 2e       	mov	r14, r19
    31e4:	36 e0       	ldi	r19, 0x06	; 6
    31e6:	f3 2e       	mov	r15, r19

	tcp->TCP_SrcPort   = tcp_entry[index].dest_port;
    31e8:	c6 2e       	mov	r12, r22
    31ea:	dd 24       	eor	r13, r13
    31ec:	86 e1       	ldi	r24, 0x16	; 22
    31ee:	90 e0       	ldi	r25, 0x00	; 0
    31f0:	c8 9e       	mul	r12, r24
    31f2:	80 01       	movw	r16, r0
    31f4:	c9 9e       	mul	r12, r25
    31f6:	10 0d       	add	r17, r0
    31f8:	d8 9e       	mul	r13, r24
    31fa:	10 0d       	add	r17, r0
    31fc:	11 24       	eor	r1, r1
    31fe:	0c 5a       	subi	r16, 0xAC	; 172
    3200:	14 4f       	sbci	r17, 0xF4	; 244
    3202:	f8 01       	movw	r30, r16
    3204:	86 81       	ldd	r24, Z+6	; 0x06
    3206:	97 81       	ldd	r25, Z+7	; 0x07
    3208:	90 93 79 06 	sts	0x0679, r25
    320c:	80 93 78 06 	sts	0x0678, r24
	tcp->TCP_DestPort  = tcp_entry[index].src_port;
    3210:	84 81       	ldd	r24, Z+4	; 0x04
    3212:	95 81       	ldd	r25, Z+5	; 0x05
    3214:	90 93 7b 06 	sts	0x067B, r25
    3218:	80 93 7a 06 	sts	0x067A, r24
	tcp->TCP_UrgentPtr = 0;
    321c:	10 92 8b 06 	sts	0x068B, r1
    3220:	10 92 8a 06 	sts	0x068A, r1
	tcp->TCP_Window    = htons(MAX_WINDOWS_SIZE);
    3224:	84 e0       	ldi	r24, 0x04	; 4
    3226:	9c e4       	ldi	r25, 0x4C	; 76
    3228:	90 93 87 06 	sts	0x0687, r25
    322c:	80 93 86 06 	sts	0x0686, r24
	tcp->TCP_Hdrlen    = 0x50;
    3230:	80 e5       	ldi	r24, 0x50	; 80
    3232:	80 93 84 06 	sts	0x0684, r24

	DEBUG("TCP SrcPort %4i\r\n", htons(tcp->TCP_SrcPort));

	result32 = htonl(tcp_entry[index].seq_counter); 
    3236:	64 85       	ldd	r22, Z+12	; 0x0c
    3238:	75 85       	ldd	r23, Z+13	; 0x0d
    323a:	86 85       	ldd	r24, Z+14	; 0x0e
    323c:	97 85       	ldd	r25, Z+15	; 0x0f
    323e:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    3242:	9b 01       	movw	r18, r22
    3244:	ac 01       	movw	r20, r24

	tcp->TCP_HdrFlags = tcp_entry[index].status;
    3246:	f8 01       	movw	r30, r16
    3248:	80 89       	ldd	r24, Z+16	; 0x10
    324a:	80 93 85 06 	sts	0x0685, r24

	//Verbindung wird aufgebaut
	if(tcp_entry[index].status & SYN_FLAG)
    324e:	80 89       	ldd	r24, Z+16	; 0x10
    3250:	81 ff       	sbrs	r24, 1
    3252:	14 c0       	rjmp	.+40     	; 0x327c <create_new_tcp_packet+0xae>
	{
	    result32++;
    3254:	2f 5f       	subi	r18, 0xFF	; 255
    3256:	3f 4f       	sbci	r19, 0xFF	; 255
    3258:	4f 4f       	sbci	r20, 0xFF	; 255
    325a:	5f 4f       	sbci	r21, 0xFF	; 255
	    // MSS-Option (siehe RFC 879) wil.
	    eth_buffer[TCP_DATA_START]   = 2;
    325c:	82 e0       	ldi	r24, 0x02	; 2
    325e:	80 93 8c 06 	sts	0x068C, r24
	    eth_buffer[TCP_DATA_START+1] = 4;
    3262:	84 e0       	ldi	r24, 0x04	; 4
    3264:	80 93 8d 06 	sts	0x068D, r24
	    eth_buffer[TCP_DATA_START+2] = (MAX_WINDOWS_SIZE >> 8) & 0xff;
    3268:	80 93 8e 06 	sts	0x068E, r24
	    eth_buffer[TCP_DATA_START+3] = MAX_WINDOWS_SIZE & 0xff;
    326c:	8c e4       	ldi	r24, 0x4C	; 76
    326e:	80 93 8f 06 	sts	0x068F, r24
	    data_length                  = 0x04;
	    tcp->TCP_Hdrlen              = 0x60;
    3272:	80 e6       	ldi	r24, 0x60	; 96
    3274:	80 93 84 06 	sts	0x0684, r24
    3278:	c4 e0       	ldi	r28, 0x04	; 4
    327a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	tcp->TCP_Acknum = htonl(result32);
    327c:	ca 01       	movw	r24, r20
    327e:	b9 01       	movw	r22, r18
    3280:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    3284:	60 93 80 06 	sts	0x0680, r22
    3288:	70 93 81 06 	sts	0x0681, r23
    328c:	80 93 82 06 	sts	0x0682, r24
    3290:	90 93 83 06 	sts	0x0683, r25
	tcp->TCP_Seqnum = tcp_entry[index].ack_counter;
    3294:	86 e1       	ldi	r24, 0x16	; 22
    3296:	90 e0       	ldi	r25, 0x00	; 0
    3298:	c8 9e       	mul	r12, r24
    329a:	80 01       	movw	r16, r0
    329c:	c9 9e       	mul	r12, r25
    329e:	10 0d       	add	r17, r0
    32a0:	d8 9e       	mul	r13, r24
    32a2:	10 0d       	add	r17, r0
    32a4:	11 24       	eor	r1, r1
    32a6:	0c 5a       	subi	r16, 0xAC	; 172
    32a8:	14 4f       	sbci	r17, 0xF4	; 244
    32aa:	f8 01       	movw	r30, r16
    32ac:	80 85       	ldd	r24, Z+8	; 0x08
    32ae:	91 85       	ldd	r25, Z+9	; 0x09
    32b0:	a2 85       	ldd	r26, Z+10	; 0x0a
    32b2:	b3 85       	ldd	r27, Z+11	; 0x0b
    32b4:	80 93 7c 06 	sts	0x067C, r24
    32b8:	90 93 7d 06 	sts	0x067D, r25
    32bc:	a0 93 7e 06 	sts	0x067E, r26
    32c0:	b0 93 7f 06 	sts	0x067F, r27

	bufferlen = IP_VERS_LEN + TCP_HDR_LEN + data_length;    //IP Headerlnge + TCP Headerlnge
    32c4:	ce 01       	movw	r24, r28
    32c6:	88 96       	adiw	r24, 0x28	; 40
	ip->IP_Pktlen = htons(bufferlen);                      //Hier wird erstmal der IP Header neu erstellt
    32c8:	f7 01       	movw	r30, r14
    32ca:	92 83       	std	Z+2, r25	; 0x02
    32cc:	83 83       	std	Z+3, r24	; 0x03
	bufferlen += ETH_HDR_LEN;
	ip->IP_Proto = PROT_TCP;
    32ce:	86 e0       	ldi	r24, 0x06	; 6
    32d0:	81 87       	std	Z+9, r24	; 0x09
	make_ip_header (eth_buffer,tcp_entry[index].ip);
    32d2:	f8 01       	movw	r30, r16
    32d4:	40 81       	ld	r20, Z
    32d6:	51 81       	ldd	r21, Z+1	; 0x01
    32d8:	62 81       	ldd	r22, Z+2	; 0x02
    32da:	73 81       	ldd	r23, Z+3	; 0x03
    32dc:	86 e5       	ldi	r24, 0x56	; 86
    32de:	96 e0       	ldi	r25, 0x06	; 6
    32e0:	0e 94 01 17 	call	0x2e02	; 0x2e02 <make_ip_header>

	tcp->TCP_Chksum = 0;
    32e4:	10 92 89 06 	sts	0x0689, r1
    32e8:	10 92 88 06 	sts	0x0688, r1

	//Berechnet Headerlnge und Addiert Pseudoheaderlnge 2XIP = 8
	result16 = htons(ip->IP_Pktlen) + 8;
    32ec:	70 91 66 06 	lds	r23, 0x0666
    32f0:	60 91 67 06 	lds	r22, 0x0667
    32f4:	68 5f       	subi	r22, 0xF8	; 248
    32f6:	7f 4f       	sbci	r23, 0xFF	; 255
	result16 = result16 - ((ip->IP_Vers_Len & 0x0F) << 2);
    32f8:	80 91 64 06 	lds	r24, 0x0664
    32fc:	90 e0       	ldi	r25, 0x00	; 0
    32fe:	8f 70       	andi	r24, 0x0F	; 15
    3300:	90 70       	andi	r25, 0x00	; 0
    3302:	88 0f       	add	r24, r24
    3304:	99 1f       	adc	r25, r25
    3306:	88 0f       	add	r24, r24
    3308:	99 1f       	adc	r25, r25
    330a:	68 1b       	sub	r22, r24
    330c:	79 0b       	sbc	r23, r25
	result32 = result16 - 2;
    330e:	62 50       	subi	r22, 0x02	; 2
    3310:	70 40       	sbci	r23, 0x00	; 0
    3312:	9b 01       	movw	r18, r22
    3314:	40 e0       	ldi	r20, 0x00	; 0
    3316:	50 e0       	ldi	r21, 0x00	; 0
    3318:	6e 5f       	subi	r22, 0xFE	; 254
    331a:	7f 4f       	sbci	r23, 0xFF	; 255

	//Checksum
	result16 = checksum ((&ip->IP_Vers_Len+12), result16, result32);
    331c:	80 e7       	ldi	r24, 0x70	; 112
    331e:	96 e0       	ldi	r25, 0x06	; 6
    3320:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <checksum>
	tcp->TCP_Chksum = htons(result16);
    3324:	90 93 88 06 	sts	0x0688, r25
    3328:	80 93 89 06 	sts	0x0689, r24

	//Send the TCP packet
	ETH_PACKET_SEND(bufferlen,(uint8_t *)eth_buffer);
    332c:	ce 01       	movw	r24, r28
    332e:	c6 96       	adiw	r24, 0x36	; 54
    3330:	66 e5       	ldi	r22, 0x56	; 86
    3332:	76 e0       	ldi	r23, 0x06	; 6
    3334:	0e 94 78 24 	call	0x48f0	; 0x48f0 <enc_send_packet>
	//Fr Retransmission
	tcp_entry[index].status = 0;
    3338:	f8 01       	movw	r30, r16
    333a:	10 8a       	std	Z+16, r1	; 0x10
	return;
}
    333c:	df 91       	pop	r29
    333e:	cf 91       	pop	r28
    3340:	1f 91       	pop	r17
    3342:	0f 91       	pop	r16
    3344:	ff 90       	pop	r15
    3346:	ef 90       	pop	r14
    3348:	df 90       	pop	r13
    334a:	cf 90       	pop	r12
    334c:	08 95       	ret

0000334e <tcp_port_open>:
 *	\ingroup stack
 * Diese Routine ffnet einen TCP-Port
 *
 */
void tcp_port_open (unsigned long dest_ip,unsigned int port_dst,unsigned int port_src)
{
    334e:	8f 92       	push	r8
    3350:	9f 92       	push	r9
    3352:	af 92       	push	r10
    3354:	bf 92       	push	r11
    3356:	df 92       	push	r13
    3358:	ef 92       	push	r14
    335a:	ff 92       	push	r15
    335c:	0f 93       	push	r16
    335e:	1f 93       	push	r17
    3360:	cf 93       	push	r28
    3362:	df 93       	push	r29
    3364:	7b 01       	movw	r14, r22
    3366:	8c 01       	movw	r16, r24
    3368:	5a 01       	movw	r10, r20
    336a:	49 01       	movw	r8, r18
	unsigned char index;
	ETH_INT_DISABLE;
    336c:	ea 98       	cbi	0x1d, 2	; 29
    336e:	20 e0       	ldi	r18, 0x00	; 0
    3370:	30 e0       	ldi	r19, 0x00	; 0
	DEBUG("Oeffen eines Ports mit Server\r\n");
	
	//Freien Eintrag finden
	for (index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(tcp_entry[index].ip == 0)
    3372:	46 e1       	ldi	r20, 0x16	; 22
    3374:	50 e0       	ldi	r21, 0x00	; 0
 *
 */
void tcp_port_open (unsigned long dest_ip,unsigned int port_dst,unsigned int port_src)
{
	unsigned char index;
	ETH_INT_DISABLE;
    3376:	d2 2e       	mov	r13, r18
	DEBUG("Oeffen eines Ports mit Server\r\n");
	
	//Freien Eintrag finden
	for (index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(tcp_entry[index].ip == 0)
    3378:	24 9f       	mul	r18, r20
    337a:	e0 01       	movw	r28, r0
    337c:	25 9f       	mul	r18, r21
    337e:	d0 0d       	add	r29, r0
    3380:	34 9f       	mul	r19, r20
    3382:	d0 0d       	add	r29, r0
    3384:	11 24       	eor	r1, r1
    3386:	cc 5a       	subi	r28, 0xAC	; 172
    3388:	d4 4f       	sbci	r29, 0xF4	; 244
    338a:	88 81       	ld	r24, Y
    338c:	99 81       	ldd	r25, Y+1	; 0x01
    338e:	aa 81       	ldd	r26, Y+2	; 0x02
    3390:	bb 81       	ldd	r27, Y+3	; 0x03
    3392:	00 97       	sbiw	r24, 0x00	; 0
    3394:	a1 05       	cpc	r26, r1
    3396:	b1 05       	cpc	r27, r1
    3398:	f1 f4       	brne	.+60     	; 0x33d6 <tcp_port_open+0x88>
		{
			tcp_index_del(index);
    339a:	82 2f       	mov	r24, r18
    339c:	0e 94 bd 18 	call	0x317a	; 0x317a <tcp_index_del>
			tcp_entry[index].ip = dest_ip;
    33a0:	e8 82       	st	Y, r14
    33a2:	f9 82       	std	Y+1, r15	; 0x01
    33a4:	0a 83       	std	Y+2, r16	; 0x02
    33a6:	1b 83       	std	Y+3, r17	; 0x03
			tcp_entry[index].src_port = port_dst;
    33a8:	bd 82       	std	Y+5, r11	; 0x05
    33aa:	ac 82       	std	Y+4, r10	; 0x04
			tcp_entry[index].dest_port = port_src;
    33ac:	9f 82       	std	Y+7, r9	; 0x07
    33ae:	8e 82       	std	Y+6, r8	; 0x06
			tcp_entry[index].ack_counter = 1234;
    33b0:	82 ed       	ldi	r24, 0xD2	; 210
    33b2:	94 e0       	ldi	r25, 0x04	; 4
    33b4:	a0 e0       	ldi	r26, 0x00	; 0
    33b6:	b0 e0       	ldi	r27, 0x00	; 0
    33b8:	88 87       	std	Y+8, r24	; 0x08
    33ba:	99 87       	std	Y+9, r25	; 0x09
    33bc:	aa 87       	std	Y+10, r26	; 0x0a
    33be:	bb 87       	std	Y+11, r27	; 0x0b
			tcp_entry[index].seq_counter = 2345;
    33c0:	89 e2       	ldi	r24, 0x29	; 41
    33c2:	99 e0       	ldi	r25, 0x09	; 9
    33c4:	a0 e0       	ldi	r26, 0x00	; 0
    33c6:	b0 e0       	ldi	r27, 0x00	; 0
    33c8:	8c 87       	std	Y+12, r24	; 0x0c
    33ca:	9d 87       	std	Y+13, r25	; 0x0d
    33cc:	ae 87       	std	Y+14, r26	; 0x0e
    33ce:	bf 87       	std	Y+15, r27	; 0x0f
			tcp_entry[index].time = MAX_TCP_PORT_OPEN_TIME;
    33d0:	8e e1       	ldi	r24, 0x1E	; 30
    33d2:	8b 8b       	std	Y+19, r24	; 0x13
    33d4:	06 c0       	rjmp	.+12     	; 0x33e2 <tcp_port_open+0x94>
			DEBUG("TCP Open neuer Eintrag %i\r\n",index);
			break;
    33d6:	d3 94       	inc	r13
    33d8:	2f 5f       	subi	r18, 0xFF	; 255
    33da:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char index;
	ETH_INT_DISABLE;
	DEBUG("Oeffen eines Ports mit Server\r\n");
	
	//Freien Eintrag finden
	for (index = 0;index<MAX_TCP_ENTRY;index++)
    33dc:	25 30       	cpi	r18, 0x05	; 5
    33de:	31 05       	cpc	r19, r1
    33e0:	51 f6       	brne	.-108    	; 0x3376 <tcp_port_open+0x28>
	{
		//Eintrag konnte nicht mehr aufgenommen werden
		DEBUG("Busy (NO MORE CONNECTIONS)!\r\n");
	}
	
	tcp_entry[index].status =  SYN_FLAG;
    33e2:	2d 2d       	mov	r18, r13
    33e4:	30 e0       	ldi	r19, 0x00	; 0
    33e6:	86 e1       	ldi	r24, 0x16	; 22
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	28 9f       	mul	r18, r24
    33ec:	f0 01       	movw	r30, r0
    33ee:	29 9f       	mul	r18, r25
    33f0:	f0 0d       	add	r31, r0
    33f2:	38 9f       	mul	r19, r24
    33f4:	f0 0d       	add	r31, r0
    33f6:	11 24       	eor	r1, r1
    33f8:	ec 5a       	subi	r30, 0xAC	; 172
    33fa:	f4 4f       	sbci	r31, 0xF4	; 244
    33fc:	82 e0       	ldi	r24, 0x02	; 2
    33fe:	80 8b       	std	Z+16, r24	; 0x10
	create_new_tcp_packet(0,index);
    3400:	80 e0       	ldi	r24, 0x00	; 0
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	6d 2d       	mov	r22, r13
    3406:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
	ETH_INT_ENABLE;
    340a:	ea 9a       	sbi	0x1d, 2	; 29
	return;
}
    340c:	df 91       	pop	r29
    340e:	cf 91       	pop	r28
    3410:	1f 91       	pop	r17
    3412:	0f 91       	pop	r16
    3414:	ff 90       	pop	r15
    3416:	ef 90       	pop	r14
    3418:	df 90       	pop	r13
    341a:	bf 90       	pop	r11
    341c:	af 90       	pop	r10
    341e:	9f 90       	pop	r9
    3420:	8f 90       	pop	r8
    3422:	08 95       	ret

00003424 <tcp_Port_close>:
 *	\ingroup stack
 * Diese Routine schliet einen offenen TCP-Port
 *
 */
void tcp_Port_close (unsigned char index)
{
    3424:	68 2f       	mov	r22, r24
	DEBUG("Port wird im TCP Stack geschlossen STACK:%i\r\n",index);
	tcp_entry[index].app_status = 0xFFFF;
    3426:	28 2f       	mov	r18, r24
    3428:	30 e0       	ldi	r19, 0x00	; 0
    342a:	86 e1       	ldi	r24, 0x16	; 22
    342c:	90 e0       	ldi	r25, 0x00	; 0
    342e:	28 9f       	mul	r18, r24
    3430:	f0 01       	movw	r30, r0
    3432:	29 9f       	mul	r18, r25
    3434:	f0 0d       	add	r31, r0
    3436:	38 9f       	mul	r19, r24
    3438:	f0 0d       	add	r31, r0
    343a:	11 24       	eor	r1, r1
    343c:	ec 5a       	subi	r30, 0xAC	; 172
    343e:	f4 4f       	sbci	r31, 0xF4	; 244
    3440:	8f ef       	ldi	r24, 0xFF	; 255
    3442:	9f ef       	ldi	r25, 0xFF	; 255
    3444:	92 8b       	std	Z+18, r25	; 0x12
    3446:	81 8b       	std	Z+17, r24	; 0x11
	tcp_entry[index].status =  ACK_FLAG | FIN_FLAG;
    3448:	81 e1       	ldi	r24, 0x11	; 17
    344a:	80 8b       	std	Z+16, r24	; 0x10
	create_new_tcp_packet(0,index);
    344c:	80 e0       	ldi	r24, 0x00	; 0
    344e:	90 e0       	ldi	r25, 0x00	; 0
    3450:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
	return;
}
    3454:	08 95       	ret

00003456 <tcp_socket_process>:
 *	\ingroup stack
 * Diese Routine verwaltet die TCP Ports
 *
 */
void tcp_socket_process(void)
{
    3456:	af 92       	push	r10
    3458:	bf 92       	push	r11
    345a:	df 92       	push	r13
    345c:	ef 92       	push	r14
    345e:	ff 92       	push	r15
    3460:	0f 93       	push	r16
    3462:	1f 93       	push	r17
    3464:	cf 93       	push	r28
    3466:	df 93       	push	r29
	unsigned char index = 0;
	unsigned char port_index = 0;
	unsigned long result32 = 0;

	struct TCP_Header *tcp;
	tcp = (struct TCP_Header *)&eth_buffer[TCP_OFFSET];
    3468:	20 e0       	ldi	r18, 0x00	; 0
    346a:	01 c0       	rjmp	.+2      	; 0x346e <tcp_socket_process+0x18>
	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];

	//TCP DestPort mit Portanwendungsliste durchfhren
	while (TCP_PORT_TABLE[port_index].port && TCP_PORT_TABLE[port_index].port!=(htons(tcp->TCP_DestPort)))
	{ 
		port_index++;
    346c:	2f 5f       	subi	r18, 0xFF	; 255

	struct IP_Header *ip;
	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];

	//TCP DestPort mit Portanwendungsliste durchfhren
	while (TCP_PORT_TABLE[port_index].port && TCP_PORT_TABLE[port_index].port!=(htons(tcp->TCP_DestPort)))
    346e:	02 2f       	mov	r16, r18
    3470:	10 e0       	ldi	r17, 0x00	; 0
    3472:	f8 01       	movw	r30, r16
    3474:	ee 0f       	add	r30, r30
    3476:	ff 1f       	adc	r31, r31
    3478:	ee 0f       	add	r30, r30
    347a:	ff 1f       	adc	r31, r31
    347c:	e5 52       	subi	r30, 0x25	; 37
    347e:	fe 4f       	sbci	r31, 0xFE	; 254
    3480:	01 90       	ld	r0, Z+
    3482:	f0 81       	ld	r31, Z
    3484:	e0 2d       	mov	r30, r0
    3486:	30 97       	sbiw	r30, 0x00	; 0
    3488:	09 f4       	brne	.+2      	; 0x348c <tcp_socket_process+0x36>
    348a:	cf c1       	rjmp	.+926    	; 0x382a <tcp_socket_process+0x3d4>
    348c:	90 91 7a 06 	lds	r25, 0x067A
    3490:	80 91 7b 06 	lds	r24, 0x067B
    3494:	e8 17       	cp	r30, r24
    3496:	f9 07       	cpc	r31, r25
    3498:	49 f7       	brne	.-46     	; 0x346c <tcp_socket_process+0x16>
		DEBUG("TCP Keine Anwendung gefunden!\r\n");
		return;
	}	
	
	//Server ffnet Port
	if((tcp->TCP_HdrFlags & SYN_FLAG) && (tcp->TCP_HdrFlags & ACK_FLAG))
    349a:	40 91 85 06 	lds	r20, 0x0685
    349e:	24 2f       	mov	r18, r20
    34a0:	30 e0       	ldi	r19, 0x00	; 0
    34a2:	c9 01       	movw	r24, r18
    34a4:	82 71       	andi	r24, 0x12	; 18
    34a6:	90 70       	andi	r25, 0x00	; 0
    34a8:	42 97       	sbiw	r24, 0x12	; 18
    34aa:	09 f0       	breq	.+2      	; 0x34ae <tcp_socket_process+0x58>
    34ac:	65 c0       	rjmp	.+202    	; 0x3578 <tcp_socket_process+0x122>
	{	
		//Nimmt Eintrag auf da es eine Client - Anwendung fr den Port gibt
		tcp_entry_add (eth_buffer);
    34ae:	86 e5       	ldi	r24, 0x56	; 86
    34b0:	96 e0       	ldi	r25, 0x06	; 6
    34b2:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <tcp_entry_add>
		//War der Eintrag erfolgreich?
		index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
    34b6:	40 91 70 06 	lds	r20, 0x0670
    34ba:	50 91 71 06 	lds	r21, 0x0671
    34be:	60 91 72 06 	lds	r22, 0x0672
    34c2:	70 91 73 06 	lds	r23, 0x0673
    34c6:	00 91 78 06 	lds	r16, 0x0678
    34ca:	10 91 79 06 	lds	r17, 0x0679
    34ce:	c0 e0       	ldi	r28, 0x00	; 0
    34d0:	d0 e0       	ldi	r29, 0x00	; 0
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    34d2:	a6 e1       	ldi	r26, 0x16	; 22
    34d4:	ea 2e       	mov	r14, r26
    34d6:	f1 2c       	mov	r15, r1
	if((tcp->TCP_HdrFlags & SYN_FLAG) && (tcp->TCP_HdrFlags & ACK_FLAG))
	{	
		//Nimmt Eintrag auf da es eine Client - Anwendung fr den Port gibt
		tcp_entry_add (eth_buffer);
		//War der Eintrag erfolgreich?
		index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
    34d8:	2c 2f       	mov	r18, r28
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    34da:	ce 9d       	mul	r28, r14
    34dc:	f0 01       	movw	r30, r0
    34de:	cf 9d       	mul	r28, r15
    34e0:	f0 0d       	add	r31, r0
    34e2:	de 9d       	mul	r29, r14
    34e4:	f0 0d       	add	r31, r0
    34e6:	11 24       	eor	r1, r1
    34e8:	ec 5a       	subi	r30, 0xAC	; 172
    34ea:	f4 4f       	sbci	r31, 0xF4	; 244
    34ec:	80 81       	ld	r24, Z
    34ee:	91 81       	ldd	r25, Z+1	; 0x01
    34f0:	a2 81       	ldd	r26, Z+2	; 0x02
    34f2:	b3 81       	ldd	r27, Z+3	; 0x03
    34f4:	84 17       	cp	r24, r20
    34f6:	95 07       	cpc	r25, r21
    34f8:	a6 07       	cpc	r26, r22
    34fa:	b7 07       	cpc	r27, r23
    34fc:	29 f4       	brne	.+10     	; 0x3508 <tcp_socket_process+0xb2>
    34fe:	84 81       	ldd	r24, Z+4	; 0x04
    3500:	95 81       	ldd	r25, Z+5	; 0x05
    3502:	80 17       	cp	r24, r16
    3504:	91 07       	cpc	r25, r17
    3506:	29 f0       	breq	.+10     	; 0x3512 <tcp_socket_process+0xbc>
    3508:	21 96       	adiw	r28, 0x01	; 1
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    350a:	c5 30       	cpi	r28, 0x05	; 5
    350c:	d1 05       	cpc	r29, r1
    350e:	21 f7       	brne	.-56     	; 0x34d8 <tcp_socket_process+0x82>
    3510:	8c c1       	rjmp	.+792    	; 0x382a <tcp_socket_process+0x3d4>
		{
			DEBUG("TCP Eintrag nicht erfolgreich!\r\n");
			return;
		}
	
		tcp_entry[index].time = MAX_TCP_PORT_OPEN_TIME;
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	86 e1       	ldi	r24, 0x16	; 22
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	28 9f       	mul	r18, r24
    351a:	80 01       	movw	r16, r0
    351c:	29 9f       	mul	r18, r25
    351e:	10 0d       	add	r17, r0
    3520:	38 9f       	mul	r19, r24
    3522:	10 0d       	add	r17, r0
    3524:	11 24       	eor	r1, r1
    3526:	0c 5a       	subi	r16, 0xAC	; 172
    3528:	14 4f       	sbci	r17, 0xF4	; 244
    352a:	8e e1       	ldi	r24, 0x1E	; 30
    352c:	d8 01       	movw	r26, r16
    352e:	53 96       	adiw	r26, 0x13	; 19
    3530:	8c 93       	st	X, r24
    3532:	53 97       	sbiw	r26, 0x13	; 19
		DEBUG("TCP Port wurde vom Server geffnet STACK:%i\r\n",index);
		result32 = htonl(tcp_entry[index].seq_counter) + 1;
    3534:	1c 96       	adiw	r26, 0x0c	; 12
    3536:	6d 91       	ld	r22, X+
    3538:	7d 91       	ld	r23, X+
    353a:	8d 91       	ld	r24, X+
    353c:	9c 91       	ld	r25, X
    353e:	1f 97       	sbiw	r26, 0x0f	; 15
    3540:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
		tcp_entry[index].seq_counter = htonl(result32);
    3544:	6f 5f       	subi	r22, 0xFF	; 255
    3546:	7f 4f       	sbci	r23, 0xFF	; 255
    3548:	8f 4f       	sbci	r24, 0xFF	; 255
    354a:	9f 4f       	sbci	r25, 0xFF	; 255
    354c:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    3550:	f8 01       	movw	r30, r16
    3552:	64 87       	std	Z+12, r22	; 0x0c
    3554:	75 87       	std	Z+13, r23	; 0x0d
    3556:	86 87       	std	Z+14, r24	; 0x0e
    3558:	97 87       	std	Z+15, r25	; 0x0f
		tcp_entry[index].status =  ACK_FLAG;
    355a:	80 e1       	ldi	r24, 0x10	; 16
    355c:	80 8b       	std	Z+16, r24	; 0x10
		create_new_tcp_packet(0,index);
    355e:	80 e0       	ldi	r24, 0x00	; 0
    3560:	90 e0       	ldi	r25, 0x00	; 0
    3562:	6c 2f       	mov	r22, r28
    3564:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		//Server Port wurde geffnet App. kann nun daten senden!
		tcp_entry[index].app_status = 1;
    3568:	81 e0       	ldi	r24, 0x01	; 1
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	d8 01       	movw	r26, r16
    356e:	52 96       	adiw	r26, 0x12	; 18
    3570:	9c 93       	st	X, r25
    3572:	8e 93       	st	-X, r24
    3574:	51 97       	sbiw	r26, 0x11	; 17
    3576:	59 c1       	rjmp	.+690    	; 0x382a <tcp_socket_process+0x3d4>
		return;
	}
	
	//Verbindungsaufbau nicht fr Anwendung bestimmt
	if(tcp->TCP_HdrFlags == SYN_FLAG)
    3578:	42 30       	cpi	r20, 0x02	; 2
    357a:	09 f0       	breq	.+2      	; 0x357e <tcp_socket_process+0x128>
    357c:	46 c0       	rjmp	.+140    	; 0x360a <tcp_socket_process+0x1b4>
	{
		//Nimmt Eintrag auf da es eine Server - Anwendung fr den Port gibt
		tcp_entry_add (eth_buffer);
    357e:	86 e5       	ldi	r24, 0x56	; 86
    3580:	96 e0       	ldi	r25, 0x06	; 6
    3582:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <tcp_entry_add>
		//War der Eintrag erfolgreich?
		index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
    3586:	20 91 70 06 	lds	r18, 0x0670
    358a:	30 91 71 06 	lds	r19, 0x0671
    358e:	40 91 72 06 	lds	r20, 0x0672
    3592:	50 91 73 06 	lds	r21, 0x0673
    3596:	c0 91 78 06 	lds	r28, 0x0678
    359a:	d0 91 79 06 	lds	r29, 0x0679
    359e:	60 e0       	ldi	r22, 0x00	; 0
    35a0:	70 e0       	ldi	r23, 0x00	; 0
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    35a2:	f6 e1       	ldi	r31, 0x16	; 22
    35a4:	ef 2e       	mov	r14, r31
    35a6:	f1 2c       	mov	r15, r1
    35a8:	6e 9d       	mul	r22, r14
    35aa:	f0 01       	movw	r30, r0
    35ac:	6f 9d       	mul	r22, r15
    35ae:	f0 0d       	add	r31, r0
    35b0:	7e 9d       	mul	r23, r14
    35b2:	f0 0d       	add	r31, r0
    35b4:	11 24       	eor	r1, r1
    35b6:	ec 5a       	subi	r30, 0xAC	; 172
    35b8:	f4 4f       	sbci	r31, 0xF4	; 244
    35ba:	80 81       	ld	r24, Z
    35bc:	91 81       	ldd	r25, Z+1	; 0x01
    35be:	a2 81       	ldd	r26, Z+2	; 0x02
    35c0:	b3 81       	ldd	r27, Z+3	; 0x03
    35c2:	82 17       	cp	r24, r18
    35c4:	93 07       	cpc	r25, r19
    35c6:	a4 07       	cpc	r26, r20
    35c8:	b5 07       	cpc	r27, r21
    35ca:	29 f4       	brne	.+10     	; 0x35d6 <tcp_socket_process+0x180>
    35cc:	84 81       	ldd	r24, Z+4	; 0x04
    35ce:	95 81       	ldd	r25, Z+5	; 0x05
    35d0:	8c 17       	cp	r24, r28
    35d2:	9d 07       	cpc	r25, r29
    35d4:	31 f0       	breq	.+12     	; 0x35e2 <tcp_socket_process+0x18c>
    35d6:	6f 5f       	subi	r22, 0xFF	; 255
    35d8:	7f 4f       	sbci	r23, 0xFF	; 255
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    35da:	65 30       	cpi	r22, 0x05	; 5
    35dc:	71 05       	cpc	r23, r1
    35de:	21 f7       	brne	.-56     	; 0x35a8 <tcp_socket_process+0x152>
    35e0:	24 c1       	rjmp	.+584    	; 0x382a <tcp_socket_process+0x3d4>
			return;
		}
	
		DEBUG("TCP New SERVER Connection! STACK:%i\r\n",index);
		
		tcp_entry[index].status =  ACK_FLAG | SYN_FLAG;
    35e2:	26 2f       	mov	r18, r22
    35e4:	30 e0       	ldi	r19, 0x00	; 0
    35e6:	86 e1       	ldi	r24, 0x16	; 22
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	28 9f       	mul	r18, r24
    35ec:	f0 01       	movw	r30, r0
    35ee:	29 9f       	mul	r18, r25
    35f0:	f0 0d       	add	r31, r0
    35f2:	38 9f       	mul	r19, r24
    35f4:	f0 0d       	add	r31, r0
    35f6:	11 24       	eor	r1, r1
    35f8:	ec 5a       	subi	r30, 0xAC	; 172
    35fa:	f4 4f       	sbci	r31, 0xF4	; 244
    35fc:	82 e1       	ldi	r24, 0x12	; 18
    35fe:	80 8b       	std	Z+16, r24	; 0x10
		create_new_tcp_packet(0,index);
    3600:	80 e0       	ldi	r24, 0x00	; 0
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
    3608:	10 c1       	rjmp	.+544    	; 0x382a <tcp_socket_process+0x3d4>
		return;
	}

	//Packeteintrag im TCP Stack finden!
	index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
    360a:	40 91 70 06 	lds	r20, 0x0670
    360e:	50 91 71 06 	lds	r21, 0x0671
    3612:	60 91 72 06 	lds	r22, 0x0672
    3616:	70 91 73 06 	lds	r23, 0x0673
    361a:	e0 90 78 06 	lds	r14, 0x0678
    361e:	f0 90 79 06 	lds	r15, 0x0679
    3622:	c0 e0       	ldi	r28, 0x00	; 0
    3624:	d0 e0       	ldi	r29, 0x00	; 0
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    3626:	e6 e1       	ldi	r30, 0x16	; 22
    3628:	ae 2e       	mov	r10, r30
    362a:	b1 2c       	mov	r11, r1
		create_new_tcp_packet(0,index);
		return;
	}

	//Packeteintrag im TCP Stack finden!
	index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
    362c:	dc 2e       	mov	r13, r28
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if(	tcp_entry[index].ip == dest_ip &&
    362e:	ca 9d       	mul	r28, r10
    3630:	f0 01       	movw	r30, r0
    3632:	cb 9d       	mul	r28, r11
    3634:	f0 0d       	add	r31, r0
    3636:	da 9d       	mul	r29, r10
    3638:	f0 0d       	add	r31, r0
    363a:	11 24       	eor	r1, r1
    363c:	ec 5a       	subi	r30, 0xAC	; 172
    363e:	f4 4f       	sbci	r31, 0xF4	; 244
    3640:	80 81       	ld	r24, Z
    3642:	91 81       	ldd	r25, Z+1	; 0x01
    3644:	a2 81       	ldd	r26, Z+2	; 0x02
    3646:	b3 81       	ldd	r27, Z+3	; 0x03
    3648:	84 17       	cp	r24, r20
    364a:	95 07       	cpc	r25, r21
    364c:	a6 07       	cpc	r26, r22
    364e:	b7 07       	cpc	r27, r23
    3650:	29 f4       	brne	.+10     	; 0x365c <tcp_socket_process+0x206>
    3652:	84 81       	ldd	r24, Z+4	; 0x04
    3654:	95 81       	ldd	r25, Z+5	; 0x05
    3656:	8e 15       	cp	r24, r14
    3658:	9f 05       	cpc	r25, r15
    365a:	29 f0       	breq	.+10     	; 0x3666 <tcp_socket_process+0x210>
    365c:	21 96       	adiw	r28, 0x01	; 1
 * Diese Routine sucht den etntry eintrag
 *
 */
char tcp_entry_search (unsigned long dest_ip,unsigned int SrcPort)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    365e:	c5 30       	cpi	r28, 0x05	; 5
    3660:	d1 05       	cpc	r29, r1
    3662:	21 f7       	brne	.-56     	; 0x362c <tcp_socket_process+0x1d6>
    3664:	dd c0       	rjmp	.+442    	; 0x3820 <tcp_socket_process+0x3ca>
		return;
	}


	//Refresh des Eintrages
	tcp_entry_add (eth_buffer);
    3666:	86 e5       	ldi	r24, 0x56	; 86
    3668:	96 e0       	ldi	r25, 0x06	; 6
    366a:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <tcp_entry_add>
	
	//Host will verbindung beenden!
	if(tcp_entry[index].status & FIN_FLAG || tcp_entry[index].status & RST_FLAG)
    366e:	4c 2f       	mov	r20, r28
    3670:	50 e0       	ldi	r21, 0x00	; 0
    3672:	86 e1       	ldi	r24, 0x16	; 22
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	48 9f       	mul	r20, r24
    3678:	f0 01       	movw	r30, r0
    367a:	49 9f       	mul	r20, r25
    367c:	f0 0d       	add	r31, r0
    367e:	58 9f       	mul	r21, r24
    3680:	f0 0d       	add	r31, r0
    3682:	11 24       	eor	r1, r1
    3684:	ec 5a       	subi	r30, 0xAC	; 172
    3686:	f4 4f       	sbci	r31, 0xF4	; 244
    3688:	80 89       	ldd	r24, Z+16	; 0x10
    368a:	80 ff       	sbrs	r24, 0
    368c:	2b c0       	rjmp	.+86     	; 0x36e4 <tcp_socket_process+0x28e>
    368e:	2d c0       	rjmp	.+90     	; 0x36ea <tcp_socket_process+0x294>
	if (index >= MAX_TCP_ENTRY) //Eintrag nicht gefunden
	{
		DEBUG("TCP Eintrag nicht gefunden\r\n");
		if(tcp->TCP_HdrFlags & FIN_FLAG || tcp->TCP_HdrFlags & RST_FLAG)
		{	
			tcp_entry_add (eth_buffer);//Temporrer Indexplatz	
    3690:	86 e5       	ldi	r24, 0x56	; 86
    3692:	96 e0       	ldi	r25, 0x06	; 6
    3694:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <tcp_entry_add>
			
			result32 = htonl(tcp_entry[index].seq_counter) + 1;
    3698:	60 91 ce 0b 	lds	r22, 0x0BCE
    369c:	70 91 cf 0b 	lds	r23, 0x0BCF
    36a0:	80 91 d0 0b 	lds	r24, 0x0BD0
    36a4:	90 91 d1 0b 	lds	r25, 0x0BD1
    36a8:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
			tcp_entry[index].seq_counter = htonl(result32);
    36ac:	6f 5f       	subi	r22, 0xFF	; 255
    36ae:	7f 4f       	sbci	r23, 0xFF	; 255
    36b0:	8f 4f       	sbci	r24, 0xFF	; 255
    36b2:	9f 4f       	sbci	r25, 0xFF	; 255
    36b4:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    36b8:	60 93 ce 0b 	sts	0x0BCE, r22
    36bc:	70 93 cf 0b 	sts	0x0BCF, r23
    36c0:	80 93 d0 0b 	sts	0x0BD0, r24
    36c4:	90 93 d1 0b 	sts	0x0BD1, r25
			
			if (tcp_entry[index].status & FIN_FLAG)
    36c8:	80 91 d2 0b 	lds	r24, 0x0BD2
    36cc:	80 ff       	sbrs	r24, 0
    36ce:	08 c0       	rjmp	.+16     	; 0x36e0 <tcp_socket_process+0x28a>
			{
				tcp_entry[index].status = ACK_FLAG;
    36d0:	80 e1       	ldi	r24, 0x10	; 16
    36d2:	80 93 d2 0b 	sts	0x0BD2, r24
				create_new_tcp_packet(0,index);
    36d6:	80 e0       	ldi	r24, 0x00	; 0
    36d8:	90 e0       	ldi	r25, 0x00	; 0
    36da:	65 e0       	ldi	r22, 0x05	; 5
    36dc:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
			}
			tcp_index_del(index);
    36e0:	85 e0       	ldi	r24, 0x05	; 5
    36e2:	34 c0       	rjmp	.+104    	; 0x374c <tcp_socket_process+0x2f6>

	//Refresh des Eintrages
	tcp_entry_add (eth_buffer);
	
	//Host will verbindung beenden!
	if(tcp_entry[index].status & FIN_FLAG || tcp_entry[index].status & RST_FLAG)
    36e4:	80 89       	ldd	r24, Z+16	; 0x10
    36e6:	82 ff       	sbrs	r24, 2
    36e8:	34 c0       	rjmp	.+104    	; 0x3752 <tcp_socket_process+0x2fc>
	{	
		result32 = htonl(tcp_entry[index].seq_counter) + 1;
    36ea:	86 e1       	ldi	r24, 0x16	; 22
    36ec:	90 e0       	ldi	r25, 0x00	; 0
    36ee:	48 9f       	mul	r20, r24
    36f0:	e0 01       	movw	r28, r0
    36f2:	49 9f       	mul	r20, r25
    36f4:	d0 0d       	add	r29, r0
    36f6:	58 9f       	mul	r21, r24
    36f8:	d0 0d       	add	r29, r0
    36fa:	11 24       	eor	r1, r1
    36fc:	cc 5a       	subi	r28, 0xAC	; 172
    36fe:	d4 4f       	sbci	r29, 0xF4	; 244
    3700:	6c 85       	ldd	r22, Y+12	; 0x0c
    3702:	7d 85       	ldd	r23, Y+13	; 0x0d
    3704:	8e 85       	ldd	r24, Y+14	; 0x0e
    3706:	9f 85       	ldd	r25, Y+15	; 0x0f
    3708:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
		tcp_entry[index].seq_counter = htonl(result32);
    370c:	6f 5f       	subi	r22, 0xFF	; 255
    370e:	7f 4f       	sbci	r23, 0xFF	; 255
    3710:	8f 4f       	sbci	r24, 0xFF	; 255
    3712:	9f 4f       	sbci	r25, 0xFF	; 255
    3714:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <htonl>
    3718:	6c 87       	std	Y+12, r22	; 0x0c
    371a:	7d 87       	std	Y+13, r23	; 0x0d
    371c:	8e 87       	std	Y+14, r24	; 0x0e
    371e:	9f 87       	std	Y+15, r25	; 0x0f
		
		if (tcp_entry[index].status & FIN_FLAG)
    3720:	88 89       	ldd	r24, Y+16	; 0x10
    3722:	80 ff       	sbrs	r24, 0
    3724:	12 c0       	rjmp	.+36     	; 0x374a <tcp_socket_process+0x2f4>
		{
			// Ende der Anwendung mitteilen !
			TCP_PORT_TABLE[port_index].fp(index);
    3726:	00 0f       	add	r16, r16
    3728:	11 1f       	adc	r17, r17
    372a:	00 0f       	add	r16, r16
    372c:	11 1f       	adc	r17, r17
    372e:	03 52       	subi	r16, 0x23	; 35
    3730:	1e 4f       	sbci	r17, 0xFE	; 254
    3732:	d8 01       	movw	r26, r16
    3734:	ed 91       	ld	r30, X+
    3736:	fc 91       	ld	r31, X
    3738:	8d 2d       	mov	r24, r13
    373a:	09 95       	icall

			tcp_entry[index].status = ACK_FLAG | FIN_FLAG;
    373c:	81 e1       	ldi	r24, 0x11	; 17
    373e:	88 8b       	std	Y+16, r24	; 0x10
			create_new_tcp_packet(0,index);
    3740:	80 e0       	ldi	r24, 0x00	; 0
    3742:	90 e0       	ldi	r25, 0x00	; 0
    3744:	6d 2d       	mov	r22, r13
    3746:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		}
		tcp_index_del(index);
    374a:	8d 2d       	mov	r24, r13
    374c:	0e 94 bd 18 	call	0x317a	; 0x317a <tcp_index_del>
    3750:	6c c0       	rjmp	.+216    	; 0x382a <tcp_socket_process+0x3d4>
		DEBUG("TCP-Stack Eintrag gelscht! STACK:%i\r\n",index);
		return;
	}
	
	//Daten fr Anwendung PSH-Flag gesetzt?
	if((tcp_entry[index].status & PSH_FLAG) && 
    3752:	80 89       	ldd	r24, Z+16	; 0x10
    3754:	83 ff       	sbrs	r24, 3
    3756:	15 c0       	rjmp	.+42     	; 0x3782 <tcp_socket_process+0x32c>
    3758:	80 89       	ldd	r24, Z+16	; 0x10
    375a:	84 ff       	sbrs	r24, 4
    375c:	12 c0       	rjmp	.+36     	; 0x3782 <tcp_socket_process+0x32c>
		(tcp_entry[index].status & ACK_FLAG))
	{
		//zugehrige Anwendung ausfhren
		tcp_entry[index].app_status++;	
    375e:	81 89       	ldd	r24, Z+17	; 0x11
    3760:	92 89       	ldd	r25, Z+18	; 0x12
    3762:	01 96       	adiw	r24, 0x01	; 1
    3764:	92 8b       	std	Z+18, r25	; 0x12
    3766:	81 8b       	std	Z+17, r24	; 0x11
		tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    3768:	88 e1       	ldi	r24, 0x18	; 24
    376a:	80 8b       	std	Z+16, r24	; 0x10
		TCP_PORT_TABLE[port_index].fp(index); 
    376c:	00 0f       	add	r16, r16
    376e:	11 1f       	adc	r17, r17
    3770:	00 0f       	add	r16, r16
    3772:	11 1f       	adc	r17, r17
    3774:	03 52       	subi	r16, 0x23	; 35
    3776:	1e 4f       	sbci	r17, 0xFE	; 254
    3778:	d8 01       	movw	r26, r16
    377a:	ed 91       	ld	r30, X+
    377c:	fc 91       	ld	r31, X
    377e:	8c 2f       	mov	r24, r28
    3780:	4d c0       	rjmp	.+154    	; 0x381c <tcp_socket_process+0x3c6>
		return;
	}
	
	//Empfangene Packet wurde besttigt keine Daten fr Anwendung
	//z.B. nach Verbindungsaufbau (SYN-PACKET)
	if((tcp_entry[index].status & ACK_FLAG) && (tcp_entry[index].first_ack == 0))
    3782:	86 e1       	ldi	r24, 0x16	; 22
    3784:	90 e0       	ldi	r25, 0x00	; 0
    3786:	48 9f       	mul	r20, r24
    3788:	90 01       	movw	r18, r0
    378a:	49 9f       	mul	r20, r25
    378c:	30 0d       	add	r19, r0
    378e:	58 9f       	mul	r21, r24
    3790:	30 0d       	add	r19, r0
    3792:	11 24       	eor	r1, r1
    3794:	f9 01       	movw	r30, r18
    3796:	ec 5a       	subi	r30, 0xAC	; 172
    3798:	f4 4f       	sbci	r31, 0xF4	; 244
    379a:	80 89       	ldd	r24, Z+16	; 0x10
    379c:	84 ff       	sbrs	r24, 4
    379e:	0a c0       	rjmp	.+20     	; 0x37b4 <tcp_socket_process+0x35e>
    37a0:	f9 01       	movw	r30, r18
    37a2:	e7 59       	subi	r30, 0x97	; 151
    37a4:	f4 4f       	sbci	r31, 0xF4	; 244
    37a6:	80 81       	ld	r24, Z
    37a8:	80 fd       	sbrc	r24, 0
    37aa:	04 c0       	rjmp	.+8      	; 0x37b4 <tcp_socket_process+0x35e>
	{
		//keine weitere Aktion
		tcp_entry[index].first_ack = 1;
    37ac:	80 81       	ld	r24, Z
    37ae:	81 60       	ori	r24, 0x01	; 1
    37b0:	80 83       	st	Z, r24
    37b2:	3b c0       	rjmp	.+118    	; 0x382a <tcp_socket_process+0x3d4>
		return;
	}
	
	//Empfangsbesttigung fr ein von der Anwendung gesendetes Packet (ENDE)
	if((tcp_entry[index].status & ACK_FLAG) && (tcp_entry[index].first_ack == 1))
    37b4:	86 e1       	ldi	r24, 0x16	; 22
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	48 9f       	mul	r20, r24
    37ba:	f0 01       	movw	r30, r0
    37bc:	49 9f       	mul	r20, r25
    37be:	f0 0d       	add	r31, r0
    37c0:	58 9f       	mul	r21, r24
    37c2:	f0 0d       	add	r31, r0
    37c4:	11 24       	eor	r1, r1
    37c6:	df 01       	movw	r26, r30
    37c8:	ac 5a       	subi	r26, 0xAC	; 172
    37ca:	b4 4f       	sbci	r27, 0xF4	; 244
    37cc:	50 96       	adiw	r26, 0x10	; 16
    37ce:	8c 91       	ld	r24, X
    37d0:	50 97       	sbiw	r26, 0x10	; 16
    37d2:	84 ff       	sbrs	r24, 4
    37d4:	2a c0       	rjmp	.+84     	; 0x382a <tcp_socket_process+0x3d4>
    37d6:	e7 59       	subi	r30, 0x97	; 151
    37d8:	f4 4f       	sbci	r31, 0xF4	; 244
    37da:	80 81       	ld	r24, Z
    37dc:	80 ff       	sbrs	r24, 0
    37de:	25 c0       	rjmp	.+74     	; 0x382a <tcp_socket_process+0x3d4>
	{
		//ACK fr Verbindungs abbau
		if(tcp_entry[index].app_status == 0xFFFF)
    37e0:	51 96       	adiw	r26, 0x11	; 17
    37e2:	8d 91       	ld	r24, X+
    37e4:	9c 91       	ld	r25, X
    37e6:	52 97       	sbiw	r26, 0x12	; 18
    37e8:	8f 5f       	subi	r24, 0xFF	; 255
    37ea:	9f 4f       	sbci	r25, 0xFF	; 255
    37ec:	f1 f0       	breq	.+60     	; 0x382a <tcp_socket_process+0x3d4>
		{
			return;
		}

		//zugehrige Anwendung ausfhren
		tcp_entry[index].status =  ACK_FLAG;
    37ee:	80 e1       	ldi	r24, 0x10	; 16
    37f0:	50 96       	adiw	r26, 0x10	; 16
    37f2:	8c 93       	st	X, r24
    37f4:	50 97       	sbiw	r26, 0x10	; 16
		tcp_entry[index].app_status++;
    37f6:	51 96       	adiw	r26, 0x11	; 17
    37f8:	8d 91       	ld	r24, X+
    37fa:	9c 91       	ld	r25, X
    37fc:	52 97       	sbiw	r26, 0x12	; 18
    37fe:	01 96       	adiw	r24, 0x01	; 1
    3800:	52 96       	adiw	r26, 0x12	; 18
    3802:	9c 93       	st	X, r25
    3804:	8e 93       	st	-X, r24
    3806:	51 97       	sbiw	r26, 0x11	; 17
		TCP_PORT_TABLE[port_index].fp(index);
    3808:	00 0f       	add	r16, r16
    380a:	11 1f       	adc	r17, r17
    380c:	00 0f       	add	r16, r16
    380e:	11 1f       	adc	r17, r17
    3810:	03 52       	subi	r16, 0x23	; 35
    3812:	1e 4f       	sbci	r17, 0xFE	; 254
    3814:	d8 01       	movw	r26, r16
    3816:	ed 91       	ld	r30, X+
    3818:	fc 91       	ld	r31, X
    381a:	8d 2d       	mov	r24, r13
    381c:	09 95       	icall
    381e:	05 c0       	rjmp	.+10     	; 0x382a <tcp_socket_process+0x3d4>
	index = tcp_entry_search (ip->IP_Srcaddr,tcp->TCP_SrcPort);
	
	if (index >= MAX_TCP_ENTRY) //Eintrag nicht gefunden
	{
		DEBUG("TCP Eintrag nicht gefunden\r\n");
		if(tcp->TCP_HdrFlags & FIN_FLAG || tcp->TCP_HdrFlags & RST_FLAG)
    3820:	25 70       	andi	r18, 0x05	; 5
    3822:	30 70       	andi	r19, 0x00	; 0
    3824:	23 2b       	or	r18, r19
    3826:	09 f0       	breq	.+2      	; 0x382a <tcp_socket_process+0x3d4>
    3828:	33 cf       	rjmp	.-410    	; 0x3690 <tcp_socket_process+0x23a>
		tcp_entry[index].app_status++;
		TCP_PORT_TABLE[port_index].fp(index);
		return;
	}
	return;
}
    382a:	df 91       	pop	r29
    382c:	cf 91       	pop	r28
    382e:	1f 91       	pop	r17
    3830:	0f 91       	pop	r16
    3832:	ff 90       	pop	r15
    3834:	ef 90       	pop	r14
    3836:	df 90       	pop	r13
    3838:	bf 90       	pop	r11
    383a:	af 90       	pop	r10
    383c:	08 95       	ret

0000383e <tcp_timer_call>:
 *	\ingroup stack
 *	Verwaltung des TCP Timers
 *
 */
void tcp_timer_call (void)
{
    383e:	ef 92       	push	r14
    3840:	ff 92       	push	r15
    3842:	0f 93       	push	r16
    3844:	1f 93       	push	r17
    3846:	cf 93       	push	r28
    3848:	df 93       	push	r29
    384a:	c0 e0       	ldi	r28, 0x00	; 0
    384c:	d0 e0       	ldi	r29, 0x00	; 0
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if (tcp_entry[index].time == 0)
    384e:	06 e1       	ldi	r16, 0x16	; 22
    3850:	10 e0       	ldi	r17, 0x00	; 0
		{
			if (tcp_entry[index].ip != 0)
			{
				tcp_entry[index].time = TCP_MAX_ENTRY_TIME;
    3852:	93 e0       	ldi	r25, 0x03	; 3
    3854:	e9 2e       	mov	r14, r25
				if ((tcp_entry[index].error_count++) > MAX_TCP_ERRORCOUNT)
				{
					DEBUG("Eintrag wird entfernt MAX_ERROR STACK:%i\r\n",index);
					ETH_INT_DISABLE;
					tcp_entry[index].status =  RST_FLAG | ACK_FLAG;
    3856:	84 e1       	ldi	r24, 0x14	; 20
    3858:	f8 2e       	mov	r15, r24
 */
void tcp_timer_call (void)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		if (tcp_entry[index].time == 0)
    385a:	c0 9f       	mul	r28, r16
    385c:	f0 01       	movw	r30, r0
    385e:	c1 9f       	mul	r28, r17
    3860:	f0 0d       	add	r31, r0
    3862:	d0 9f       	mul	r29, r16
    3864:	f0 0d       	add	r31, r0
    3866:	11 24       	eor	r1, r1
    3868:	ec 5a       	subi	r30, 0xAC	; 172
    386a:	f4 4f       	sbci	r31, 0xF4	; 244
    386c:	83 89       	ldd	r24, Z+19	; 0x13
    386e:	88 23       	and	r24, r24
    3870:	f9 f4       	brne	.+62     	; 0x38b0 <tcp_timer_call+0x72>
		{
			if (tcp_entry[index].ip != 0)
    3872:	80 81       	ld	r24, Z
    3874:	91 81       	ldd	r25, Z+1	; 0x01
    3876:	a2 81       	ldd	r26, Z+2	; 0x02
    3878:	b3 81       	ldd	r27, Z+3	; 0x03
    387a:	00 97       	sbiw	r24, 0x00	; 0
    387c:	a1 05       	cpc	r26, r1
    387e:	b1 05       	cpc	r27, r1
    3880:	e9 f0       	breq	.+58     	; 0x38bc <tcp_timer_call+0x7e>
			{
				tcp_entry[index].time = TCP_MAX_ENTRY_TIME;
    3882:	e3 8a       	std	Z+19, r14	; 0x13
				if ((tcp_entry[index].error_count++) > MAX_TCP_ERRORCOUNT)
    3884:	84 89       	ldd	r24, Z+20	; 0x14
    3886:	8f 5f       	subi	r24, 0xFF	; 255
    3888:	84 8b       	std	Z+20, r24	; 0x14
    388a:	81 50       	subi	r24, 0x01	; 1
    388c:	86 30       	cpi	r24, 0x06	; 6
    388e:	60 f0       	brcs	.+24     	; 0x38a8 <tcp_timer_call+0x6a>
				{
					DEBUG("Eintrag wird entfernt MAX_ERROR STACK:%i\r\n",index);
					ETH_INT_DISABLE;
    3890:	ea 98       	cbi	0x1d, 2	; 29
					tcp_entry[index].status =  RST_FLAG | ACK_FLAG;
    3892:	f0 8a       	std	Z+16, r15	; 0x10
					create_new_tcp_packet(0,index);
    3894:	80 e0       	ldi	r24, 0x00	; 0
    3896:	90 e0       	ldi	r25, 0x00	; 0
    3898:	6c 2f       	mov	r22, r28
    389a:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
					ETH_INT_ENABLE;
    389e:	ea 9a       	sbi	0x1d, 2	; 29
					tcp_index_del(index);
    38a0:	8c 2f       	mov	r24, r28
    38a2:	0e 94 bd 18 	call	0x317a	; 0x317a <tcp_index_del>
    38a6:	0a c0       	rjmp	.+20     	; 0x38bc <tcp_timer_call+0x7e>
				}
				else
				{
					DEBUG("Packet wird erneut gesendet STACK:%i\r\n",index);
					find_and_start (index);
    38a8:	8c 2f       	mov	r24, r28
    38aa:	0e 94 89 18 	call	0x3112	; 0x3112 <find_and_start>
    38ae:	06 c0       	rjmp	.+12     	; 0x38bc <tcp_timer_call+0x7e>
				}
			}
		}
		else
		{
			if (tcp_entry[index].time != TCP_TIME_OFF)
    38b0:	83 89       	ldd	r24, Z+19	; 0x13
    38b2:	8f 3f       	cpi	r24, 0xFF	; 255
    38b4:	19 f0       	breq	.+6      	; 0x38bc <tcp_timer_call+0x7e>
			{
				tcp_entry[index].time--;
    38b6:	83 89       	ldd	r24, Z+19	; 0x13
    38b8:	81 50       	subi	r24, 0x01	; 1
    38ba:	83 8b       	std	Z+19, r24	; 0x13
    38bc:	21 96       	adiw	r28, 0x01	; 1
 *	Verwaltung des TCP Timers
 *
 */
void tcp_timer_call (void)
{
	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    38be:	c5 30       	cpi	r28, 0x05	; 5
    38c0:	d1 05       	cpc	r29, r1
    38c2:	59 f6       	brne	.-106    	; 0x385a <tcp_timer_call+0x1c>
			{
				tcp_entry[index].time--;
			}
		}
	}
}
    38c4:	df 91       	pop	r29
    38c6:	cf 91       	pop	r28
    38c8:	1f 91       	pop	r17
    38ca:	0f 91       	pop	r16
    38cc:	ff 90       	pop	r15
    38ce:	ef 90       	pop	r14
    38d0:	08 95       	ret

000038d2 <create_new_udp_packet>:
 */
void create_new_udp_packet(	unsigned int data_length,
							unsigned int src_port,
							unsigned int dest_port,
							unsigned long dest_ip)
{
    38d2:	8f 92       	push	r8
    38d4:	9f 92       	push	r9
    38d6:	af 92       	push	r10
    38d8:	bf 92       	push	r11
    38da:	cf 92       	push	r12
    38dc:	df 92       	push	r13
    38de:	ef 92       	push	r14
    38e0:	ff 92       	push	r15
    38e2:	0f 93       	push	r16
    38e4:	1f 93       	push	r17
    38e6:	5c 01       	movw	r10, r24
	unsigned long result32;

	struct UDP_Header *udp;
	struct IP_Header  *ip;

	udp = (struct UDP_Header *)&eth_buffer[UDP_OFFSET];
    38e8:	f8 e7       	ldi	r31, 0x78	; 120
    38ea:	cf 2e       	mov	r12, r31
    38ec:	f6 e0       	ldi	r31, 0x06	; 6
    38ee:	df 2e       	mov	r13, r31
	ip  = (struct IP_Header  *)&eth_buffer[IP_OFFSET];
    38f0:	ec ee       	ldi	r30, 0xEC	; 236
    38f2:	ee 2e       	mov	r14, r30
    38f4:	ef ef       	ldi	r30, 0xFF	; 255
    38f6:	fe 2e       	mov	r15, r30
    38f8:	ec 0c       	add	r14, r12
    38fa:	fd 1c       	adc	r15, r13

	udp->udp_SrcPort  = htons(src_port);
    38fc:	70 93 78 06 	sts	0x0678, r23
    3900:	60 93 79 06 	sts	0x0679, r22
	udp->udp_DestPort = htons(dest_port);
    3904:	50 93 7a 06 	sts	0x067A, r21
    3908:	40 93 7b 06 	sts	0x067B, r20

	data_length     += UDP_HDR_LEN;                //UDP Packetlength
    390c:	08 96       	adiw	r24, 0x08	; 8
	udp->udp_Hdrlen = htons(data_length);
    390e:	90 93 7c 06 	sts	0x067C, r25
    3912:	80 93 7d 06 	sts	0x067D, r24

	data_length     += IP_VERS_LEN;                //IP Headerlnge + UDP Headerlnge
    3916:	c5 01       	movw	r24, r10
    3918:	4c 96       	adiw	r24, 0x1c	; 28
	ip->IP_Pktlen = htons(data_length);
    391a:	f7 01       	movw	r30, r14
    391c:	92 83       	std	Z+2, r25	; 0x02
    391e:	83 83       	std	Z+3, r24	; 0x03
	data_length += ETH_HDR_LEN;
	ip->IP_Proto = PROT_UDP;
    3920:	81 e1       	ldi	r24, 0x11	; 17
    3922:	81 87       	std	Z+9, r24	; 0x09
	make_ip_header (eth_buffer,dest_ip);
    3924:	4e ed       	ldi	r20, 0xDE	; 222
    3926:	84 2e       	mov	r8, r20
    3928:	4f ef       	ldi	r20, 0xFF	; 255
    392a:	94 2e       	mov	r9, r20
    392c:	8c 0c       	add	r8, r12
    392e:	9d 1c       	adc	r9, r13
    3930:	c4 01       	movw	r24, r8
    3932:	b9 01       	movw	r22, r18
    3934:	a8 01       	movw	r20, r16
    3936:	0e 94 01 17 	call	0x2e02	; 0x2e02 <make_ip_header>

	udp->udp_Chksum = 0;
    393a:	10 92 7f 06 	sts	0x067F, r1
    393e:	10 92 7e 06 	sts	0x067E, r1

	//Berechnet Headerlnge und Addiert Pseudoheaderlnge 2XIP = 8
	result16 = htons(ip->IP_Pktlen) + 8;
    3942:	f7 01       	movw	r30, r14
    3944:	72 81       	ldd	r23, Z+2	; 0x02
    3946:	63 81       	ldd	r22, Z+3	; 0x03
    3948:	68 5f       	subi	r22, 0xF8	; 248
    394a:	7f 4f       	sbci	r23, 0xFF	; 255
	result16 = result16 - ((ip->IP_Vers_Len & 0x0F) << 2);
    394c:	80 81       	ld	r24, Z
    394e:	90 e0       	ldi	r25, 0x00	; 0
    3950:	8f 70       	andi	r24, 0x0F	; 15
    3952:	90 70       	andi	r25, 0x00	; 0
    3954:	88 0f       	add	r24, r24
    3956:	99 1f       	adc	r25, r25
    3958:	88 0f       	add	r24, r24
    395a:	99 1f       	adc	r25, r25
    395c:	68 1b       	sub	r22, r24
    395e:	79 0b       	sbc	r23, r25
	result32 = result16 + 0x09;
    3960:	67 5f       	subi	r22, 0xF7	; 247
    3962:	7f 4f       	sbci	r23, 0xFF	; 255
    3964:	9b 01       	movw	r18, r22
    3966:	40 e0       	ldi	r20, 0x00	; 0
    3968:	50 e0       	ldi	r21, 0x00	; 0
    396a:	69 50       	subi	r22, 0x09	; 9
    396c:	70 40       	sbci	r23, 0x00	; 0

	//Routine berechnet die Checksumme
	result16 = checksum ((&ip->IP_Vers_Len+12), result16, result32);
    396e:	c6 01       	movw	r24, r12
    3970:	08 97       	sbiw	r24, 0x08	; 8
    3972:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <checksum>
	udp->udp_Chksum = htons(result16);
    3976:	90 93 7e 06 	sts	0x067E, r25
    397a:	80 93 7f 06 	sts	0x067F, r24

	ETH_PACKET_SEND(data_length,(uint8_t *)eth_buffer); //send...
    397e:	c5 01       	movw	r24, r10
    3980:	8a 96       	adiw	r24, 0x2a	; 42
    3982:	b4 01       	movw	r22, r8
    3984:	0e 94 78 24 	call	0x48f0	; 0x48f0 <enc_send_packet>
	return;
}
    3988:	1f 91       	pop	r17
    398a:	0f 91       	pop	r16
    398c:	ff 90       	pop	r15
    398e:	ef 90       	pop	r14
    3990:	df 90       	pop	r13
    3992:	cf 90       	pop	r12
    3994:	bf 90       	pop	r11
    3996:	af 90       	pop	r10
    3998:	9f 90       	pop	r9
    399a:	8f 90       	pop	r8
    399c:	08 95       	ret

0000399e <icmp_send>:
 *
 */
void icmp_send (unsigned long dest_ip, unsigned char icmp_type, 
                unsigned char icmp_code, unsigned int icmp_sn, 
                unsigned int icmp_id)
{
    399e:	6f 92       	push	r6
    39a0:	7f 92       	push	r7
    39a2:	8f 92       	push	r8
    39a4:	9f 92       	push	r9
    39a6:	af 92       	push	r10
    39a8:	bf 92       	push	r11
    39aa:	cf 92       	push	r12
    39ac:	df 92       	push	r13
    39ae:	ef 92       	push	r14
    39b0:	ff 92       	push	r15
    39b2:	0f 93       	push	r16
    39b4:	1f 93       	push	r17
    39b6:	3b 01       	movw	r6, r22
    39b8:	4c 01       	movw	r8, r24
    unsigned int result16;  //Checksum
    struct IP_Header   *ip;
    struct ICMP_Header *icmp;

    ip   = (struct IP_Header   *)&eth_buffer[IP_OFFSET];
    39ba:	84 e6       	ldi	r24, 0x64	; 100
    39bc:	a8 2e       	mov	r10, r24
    39be:	86 e0       	ldi	r24, 0x06	; 6
    39c0:	b8 2e       	mov	r11, r24
    icmp = (struct ICMP_Header *)&eth_buffer[ICMP_OFFSET];
    39c2:	b4 e1       	ldi	r27, 0x14	; 20
    39c4:	cb 2e       	mov	r12, r27
    39c6:	d1 2c       	mov	r13, r1
    39c8:	ca 0c       	add	r12, r10
    39ca:	db 1c       	adc	r13, r11

    //Das ist ein Echo Reply Packet
    icmp->ICMP_Type   = icmp_type;
    39cc:	40 93 78 06 	sts	0x0678, r20
    icmp->ICMP_Code   = icmp_code;
    39d0:	f6 01       	movw	r30, r12
    39d2:	21 83       	std	Z+1, r18	; 0x01
    icmp->ICMP_Id     = icmp_id;
    39d4:	f5 82       	std	Z+5, r15	; 0x05
    39d6:	e4 82       	std	Z+4, r14	; 0x04
    icmp->ICMP_SeqNum = icmp_sn;
    39d8:	17 83       	std	Z+7, r17	; 0x07
    39da:	06 83       	std	Z+6, r16	; 0x06
    icmp->ICMP_Cksum  = 0;
    39dc:	13 82       	std	Z+3, r1	; 0x03
    39de:	12 82       	std	Z+2, r1	; 0x02
    ip->IP_Pktlen     = HTONS(0x0054);   // 0x54 = 84 
    39e0:	80 e0       	ldi	r24, 0x00	; 0
    39e2:	94 e5       	ldi	r25, 0x54	; 84
    39e4:	90 93 67 06 	sts	0x0667, r25
    39e8:	80 93 66 06 	sts	0x0666, r24
    ip->IP_Proto      = PROT_ICMP;
    39ec:	81 e0       	ldi	r24, 0x01	; 1
    39ee:	80 93 6d 06 	sts	0x066D, r24
    make_ip_header (eth_buffer,dest_ip);
    39f2:	82 ef       	ldi	r24, 0xF2	; 242
    39f4:	9f ef       	ldi	r25, 0xFF	; 255
    39f6:	a8 0e       	add	r10, r24
    39f8:	b9 1e       	adc	r11, r25
    39fa:	c5 01       	movw	r24, r10
    39fc:	b4 01       	movw	r22, r8
    39fe:	a3 01       	movw	r20, r6
    3a00:	0e 94 01 17 	call	0x2e02	; 0x2e02 <make_ip_header>

//----------------------------------------------------------------------------
//Converts integer variables to network Byte order
unsigned int htons(unsigned int val)
{
  return HTONS(val);
    3a04:	70 91 66 06 	lds	r23, 0x0666
    3a08:	60 91 67 06 	lds	r22, 0x0667
    ip->IP_Proto      = PROT_ICMP;
    make_ip_header (eth_buffer,dest_ip);

    //Berechnung der ICMP Header lnge
    result16 = htons(ip->IP_Pktlen);
    result16 = result16 - ((ip->IP_Vers_Len & 0x0F) << 2);
    3a0c:	80 91 64 06 	lds	r24, 0x0664
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	8f 70       	andi	r24, 0x0F	; 15
    3a14:	90 70       	andi	r25, 0x00	; 0
    3a16:	88 0f       	add	r24, r24
    3a18:	99 1f       	adc	r25, r25
    3a1a:	88 0f       	add	r24, r24
    3a1c:	99 1f       	adc	r25, r25
    3a1e:	68 1b       	sub	r22, r24
    3a20:	79 0b       	sbc	r23, r25

    //pointer wird auf das erste Paket im ICMP Header gesetzt
    //jetzt wird die Checksumme berechnet
    result16 = checksum (&icmp->ICMP_Type, result16, 0);
    3a22:	c6 01       	movw	r24, r12
    3a24:	20 e0       	ldi	r18, 0x00	; 0
    3a26:	30 e0       	ldi	r19, 0x00	; 0
    3a28:	40 e0       	ldi	r20, 0x00	; 0
    3a2a:	50 e0       	ldi	r21, 0x00	; 0
    3a2c:	0e 94 b9 16 	call	0x2d72	; 0x2d72 <checksum>
  
    //schreibt Checksumme ins Packet
    icmp->ICMP_Cksum = htons(result16);
    3a30:	f6 01       	movw	r30, r12
    3a32:	92 83       	std	Z+2, r25	; 0x02
    3a34:	83 83       	std	Z+3, r24	; 0x03
  
    //Sendet das erzeugte ICMP Packet 
    ETH_PACKET_SEND(ICMP_REPLY_LEN,(uint8_t *)eth_buffer);
    3a36:	82 e6       	ldi	r24, 0x62	; 98
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	b5 01       	movw	r22, r10
    3a3c:	0e 94 78 24 	call	0x48f0	; 0x48f0 <enc_send_packet>
}
    3a40:	1f 91       	pop	r17
    3a42:	0f 91       	pop	r16
    3a44:	ff 90       	pop	r15
    3a46:	ef 90       	pop	r14
    3a48:	df 90       	pop	r13
    3a4a:	cf 90       	pop	r12
    3a4c:	bf 90       	pop	r11
    3a4e:	af 90       	pop	r10
    3a50:	9f 90       	pop	r9
    3a52:	8f 90       	pop	r8
    3a54:	7f 90       	pop	r7
    3a56:	6f 90       	pop	r6
    3a58:	08 95       	ret

00003a5a <arp_reply>:
 *	\ingroup stack
 * Diese Routine Antwortet auf ein ARP Packet
 *
 */
void arp_reply (void)
{
    3a5a:	0f 93       	push	r16
    3a5c:	1f 93       	push	r17

	ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
	arp      = (struct ARP_Header      *)&eth_buffer[ARP_OFFSET];


	if( arp->ARP_HWType  == HTONS(0x0001)  &&             // Hardware Typ:   Ethernet
    3a5e:	80 91 64 06 	lds	r24, 0x0664
    3a62:	90 91 65 06 	lds	r25, 0x0665
    3a66:	80 50       	subi	r24, 0x00	; 0
    3a68:	91 40       	sbci	r25, 0x01	; 1
    3a6a:	09 f0       	breq	.+2      	; 0x3a6e <arp_reply+0x14>
    3a6c:	c1 c0       	rjmp	.+386    	; 0x3bf0 <arp_reply+0x196>
    3a6e:	80 91 66 06 	lds	r24, 0x0666
    3a72:	90 91 67 06 	lds	r25, 0x0667
    3a76:	08 97       	sbiw	r24, 0x08	; 8
    3a78:	09 f0       	breq	.+2      	; 0x3a7c <arp_reply+0x22>
    3a7a:	ba c0       	rjmp	.+372    	; 0x3bf0 <arp_reply+0x196>
    3a7c:	80 91 68 06 	lds	r24, 0x0668
    3a80:	86 30       	cpi	r24, 0x06	; 6
    3a82:	09 f0       	breq	.+2      	; 0x3a86 <arp_reply+0x2c>
    3a84:	b5 c0       	rjmp	.+362    	; 0x3bf0 <arp_reply+0x196>
    3a86:	80 91 69 06 	lds	r24, 0x0669
    3a8a:	84 30       	cpi	r24, 0x04	; 4
    3a8c:	09 f0       	breq	.+2      	; 0x3a90 <arp_reply+0x36>
    3a8e:	b0 c0       	rjmp	.+352    	; 0x3bf0 <arp_reply+0x196>
    3a90:	20 91 7c 06 	lds	r18, 0x067C
    3a94:	30 91 7d 06 	lds	r19, 0x067D
    3a98:	40 91 7e 06 	lds	r20, 0x067E
    3a9c:	50 91 7f 06 	lds	r21, 0x067F
    3aa0:	80 91 46 0b 	lds	r24, 0x0B46
    3aa4:	90 91 47 0b 	lds	r25, 0x0B47
    3aa8:	a0 91 48 0b 	lds	r26, 0x0B48
    3aac:	b0 91 49 0b 	lds	r27, 0x0B49
    3ab0:	28 17       	cp	r18, r24
    3ab2:	39 07       	cpc	r19, r25
    3ab4:	4a 07       	cpc	r20, r26
    3ab6:	5b 07       	cpc	r21, r27
    3ab8:	09 f0       	breq	.+2      	; 0x3abc <arp_reply+0x62>
    3aba:	9a c0       	rjmp	.+308    	; 0x3bf0 <arp_reply+0x196>
    	arp->ARP_PRType  == HTONS(0x0800)  &&             // Protokoll Typ:  IP
    	arp->ARP_HWLen   == 0x06           &&             // Lnge der Hardwareadresse: 6
    	arp->ARP_PRLen   == 0x04           &&             // Lnge der Protokolladresse: 4 
    	arp->ARP_TIPAddr == *((unsigned long*)&myip[0]))  // Fr uns? Vergleiche ARP Target IP Adresse mit meiner IP
	{
		if (arp->ARP_Op == HTONS(0x0001))				  // ARP request?
    3abc:	80 91 6a 06 	lds	r24, 0x066A
    3ac0:	90 91 6b 06 	lds	r25, 0x066B
    3ac4:	e1 e0       	ldi	r30, 0x01	; 1
    3ac6:	80 30       	cpi	r24, 0x00	; 0
    3ac8:	9e 07       	cpc	r25, r30
    3aca:	09 f0       	breq	.+2      	; 0x3ace <arp_reply+0x74>
    3acc:	8c c0       	rjmp	.+280    	; 0x3be6 <arp_reply+0x18c>
		{
			arp_entry_add();							  // Rechner eintragen wenn noch nicht geschehen
    3ace:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <arp_entry_add>
			new_eth_header(eth_buffer, arp->ARP_SIPAddr); // Erzeugt ein neuen Ethernetheader
    3ad2:	04 e6       	ldi	r16, 0x64	; 100
    3ad4:	16 e0       	ldi	r17, 0x06	; 6
    3ad6:	0e 50       	subi	r16, 0x0E	; 14
    3ad8:	10 40       	sbci	r17, 0x00	; 0
    3ada:	40 91 72 06 	lds	r20, 0x0672
    3ade:	50 91 73 06 	lds	r21, 0x0673
    3ae2:	60 91 74 06 	lds	r22, 0x0674
    3ae6:	70 91 75 06 	lds	r23, 0x0675
    3aea:	c8 01       	movw	r24, r16
    3aec:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <new_eth_header>
			ethernet->EnetPacketType = HTONS(0x0806);	  // Nutzlast 0x0800=IP Datagramm;0x0806 = ARP
    3af0:	88 e0       	ldi	r24, 0x08	; 8
    3af2:	96 e0       	ldi	r25, 0x06	; 6
    3af4:	f8 01       	movw	r30, r16
    3af6:	95 87       	std	Z+13, r25	; 0x0d
    3af8:	84 87       	std	Z+12, r24	; 0x0c
			
			b = arp_entry_search (arp->ARP_SIPAddr);
    3afa:	40 91 72 06 	lds	r20, 0x0672
    3afe:	50 91 73 06 	lds	r21, 0x0673
    3b02:	60 91 74 06 	lds	r22, 0x0674
    3b06:	70 91 75 06 	lds	r23, 0x0675
    3b0a:	20 e0       	ldi	r18, 0x00	; 0
    3b0c:	30 e0       	ldi	r19, 0x00	; 0
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
	{
		if(arp_entry[b].arp_t_ip == dest_ip)
    3b0e:	f9 01       	movw	r30, r18
    3b10:	ee 0f       	add	r30, r30
    3b12:	ff 1f       	adc	r31, r31
    3b14:	e2 0f       	add	r30, r18
    3b16:	f3 1f       	adc	r31, r19
    3b18:	ee 0f       	add	r30, r30
    3b1a:	ff 1f       	adc	r31, r31
    3b1c:	ee 0f       	add	r30, r30
    3b1e:	ff 1f       	adc	r31, r31
    3b20:	e9 5f       	subi	r30, 0xF9	; 249
    3b22:	f4 4f       	sbci	r31, 0xF4	; 244
    3b24:	86 81       	ldd	r24, Z+6	; 0x06
    3b26:	97 81       	ldd	r25, Z+7	; 0x07
    3b28:	a0 85       	ldd	r26, Z+8	; 0x08
    3b2a:	b1 85       	ldd	r27, Z+9	; 0x09
    3b2c:	84 17       	cp	r24, r20
    3b2e:	95 07       	cpc	r25, r21
    3b30:	a6 07       	cpc	r26, r22
    3b32:	b7 07       	cpc	r27, r23
    3b34:	31 f0       	breq	.+12     	; 0x3b42 <arp_reply+0xe8>
    3b36:	2f 5f       	subi	r18, 0xFF	; 255
    3b38:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    3b3a:	25 30       	cpi	r18, 0x05	; 5
    3b3c:	31 05       	cpc	r19, r1
    3b3e:	39 f7       	brne	.-50     	; 0x3b0e <arp_reply+0xb4>
    3b40:	25 c0       	rjmp	.+74     	; 0x3b8c <arp_reply+0x132>
    3b42:	a4 e6       	ldi	r26, 0x64	; 100
    3b44:	b6 e0       	ldi	r27, 0x06	; 6
    3b46:	40 e0       	ldi	r20, 0x00	; 0
    3b48:	50 e0       	ldi	r21, 0x00	; 0
			if (b < MAX_ARP_ENTRY)						  // Eintrag gefunden wenn kleiner
			{
				for(a = 0; a < 6; a++)
				{
					//ARP MAC Targetadresse wird geschrieben mit ARP Sourceadresse
					arp->ARP_THAddr[a] = arp_entry[b].arp_t_mac[a];
    3b4a:	82 2f       	mov	r24, r18
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	9c 01       	movw	r18, r24
    3b50:	22 0f       	add	r18, r18
    3b52:	33 1f       	adc	r19, r19
    3b54:	28 0f       	add	r18, r24
    3b56:	39 1f       	adc	r19, r25
    3b58:	22 0f       	add	r18, r18
    3b5a:	33 1f       	adc	r19, r19
    3b5c:	22 0f       	add	r18, r18
    3b5e:	33 1f       	adc	r19, r19
    3b60:	f9 01       	movw	r30, r18
    3b62:	e4 0f       	add	r30, r20
    3b64:	f5 1f       	adc	r31, r21
    3b66:	e9 5f       	subi	r30, 0xF9	; 249
    3b68:	f4 4f       	sbci	r31, 0xF4	; 244
    3b6a:	80 81       	ld	r24, Z
    3b6c:	52 96       	adiw	r26, 0x12	; 18
    3b6e:	8c 93       	st	X, r24
    3b70:	52 97       	sbiw	r26, 0x12	; 18
					//ARP MAC Sourceadresse wird geschrieben mit My MAC Adresse
					arp->ARP_SHAddr[a] = mymac[a];
    3b72:	fa 01       	movw	r30, r20
    3b74:	e4 58       	subi	r30, 0x84	; 132
    3b76:	f3 4f       	sbci	r31, 0xF3	; 243
    3b78:	80 81       	ld	r24, Z
    3b7a:	18 96       	adiw	r26, 0x08	; 8
    3b7c:	8c 93       	st	X, r24
    3b7e:	18 97       	sbiw	r26, 0x08	; 8
    3b80:	4f 5f       	subi	r20, 0xFF	; 255
    3b82:	5f 4f       	sbci	r21, 0xFF	; 255
    3b84:	11 96       	adiw	r26, 0x01	; 1
			ethernet->EnetPacketType = HTONS(0x0806);	  // Nutzlast 0x0800=IP Datagramm;0x0806 = ARP
			
			b = arp_entry_search (arp->ARP_SIPAddr);
			if (b < MAX_ARP_ENTRY)						  // Eintrag gefunden wenn kleiner
			{
				for(a = 0; a < 6; a++)
    3b86:	46 30       	cpi	r20, 0x06	; 6
    3b88:	51 05       	cpc	r21, r1
    3b8a:	51 f7       	brne	.-44     	; 0x3b60 <arp_reply+0x106>
			else
			{
				DEBUG("ARP Eintrag nicht gefunden\r\n");		// Unwarscheinlich das das jemals passiert!
			}
			
			arp->ARP_Op = HTONS(0x0002);						// ARP op=ECHO gesetzt damit es der andere merkt
    3b8c:	80 e0       	ldi	r24, 0x00	; 0
    3b8e:	92 e0       	ldi	r25, 0x02	; 2
    3b90:	90 93 6b 06 	sts	0x066B, r25
    3b94:	80 93 6a 06 	sts	0x066A, r24
			arp->ARP_TIPAddr = arp->ARP_SIPAddr;				// ARP Target IP Adresse
    3b98:	80 91 72 06 	lds	r24, 0x0672
    3b9c:	90 91 73 06 	lds	r25, 0x0673
    3ba0:	a0 91 74 06 	lds	r26, 0x0674
    3ba4:	b0 91 75 06 	lds	r27, 0x0675
    3ba8:	80 93 7c 06 	sts	0x067C, r24
    3bac:	90 93 7d 06 	sts	0x067D, r25
    3bb0:	a0 93 7e 06 	sts	0x067E, r26
    3bb4:	b0 93 7f 06 	sts	0x067F, r27
			arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);	// ARP Source = Meine IP Adresse
    3bb8:	80 91 46 0b 	lds	r24, 0x0B46
    3bbc:	90 91 47 0b 	lds	r25, 0x0B47
    3bc0:	a0 91 48 0b 	lds	r26, 0x0B48
    3bc4:	b0 91 49 0b 	lds	r27, 0x0B49
    3bc8:	80 93 72 06 	sts	0x0672, r24
    3bcc:	90 93 73 06 	sts	0x0673, r25
    3bd0:	a0 93 74 06 	sts	0x0674, r26
    3bd4:	b0 93 75 06 	sts	0x0675, r27
			
			//Nun ist das ARP-Packet fertig zum Senden !!!
			ETH_PACKET_SEND(ARP_REPLY_LEN,(uint8_t *)eth_buffer);			// ARP Reply senden...
    3bd8:	8c e3       	ldi	r24, 0x3C	; 60
    3bda:	90 e0       	ldi	r25, 0x00	; 0
    3bdc:	66 e5       	ldi	r22, 0x56	; 86
    3bde:	76 e0       	ldi	r23, 0x06	; 6
    3be0:	0e 94 78 24 	call	0x48f0	; 0x48f0 <enc_send_packet>
    3be4:	05 c0       	rjmp	.+10     	; 0x3bf0 <arp_reply+0x196>
			return;
		}

        if ( arp->ARP_Op == HTONS(0x0002) )						// REPLY von einem anderen Client
    3be6:	80 50       	subi	r24, 0x00	; 0
    3be8:	92 40       	sbci	r25, 0x02	; 2
    3bea:	11 f4       	brne	.+4      	; 0x3bf0 <arp_reply+0x196>
		{
			arp_entry_add();									// Rechner eintragen wenn noch nicht geschehen
    3bec:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <arp_entry_add>
			DEBUG("ARP REPLY EMPFANGEN!\r\n");
		}
	}
	return;
}
    3bf0:	1f 91       	pop	r17
    3bf2:	0f 91       	pop	r16
    3bf4:	08 95       	ret

00003bf6 <check_packet>:
 *	\ingroup stack
 * Check Packet and call Stack for TCP or UDP
 *
 */
void check_packet (void)
{
    3bf6:	ef 92       	push	r14
    3bf8:	ff 92       	push	r15
    3bfa:	0f 93       	push	r16
    3bfc:	1f 93       	push	r17
    ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
    ip       = (struct IP_Header       *)&eth_buffer[IP_OFFSET];
    tcp      = (struct TCP_Header      *)&eth_buffer[TCP_OFFSET];
    icmp     = (struct ICMP_Header     *)&eth_buffer[ICMP_OFFSET];
		
    if(ethernet->EnetPacketType == HTONS(0x0806) )     //ARP
    3bfe:	80 91 62 06 	lds	r24, 0x0662
    3c02:	90 91 63 06 	lds	r25, 0x0663
    3c06:	26 e0       	ldi	r18, 0x06	; 6
    3c08:	88 30       	cpi	r24, 0x08	; 8
    3c0a:	92 07       	cpc	r25, r18
    3c0c:	19 f4       	brne	.+6      	; 0x3c14 <check_packet+0x1e>
	{
        arp_reply(); // check arp packet request/reply
    3c0e:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <arp_reply>
    3c12:	66 c0       	rjmp	.+204    	; 0x3ce0 <check_packet+0xea>
	}
	else
	{
        if( ethernet->EnetPacketType == HTONS(0x0800) )  // if IP
    3c14:	08 97       	sbiw	r24, 0x08	; 8
    3c16:	09 f0       	breq	.+2      	; 0x3c1a <check_packet+0x24>
    3c18:	63 c0       	rjmp	.+198    	; 0x3ce0 <check_packet+0xea>
		{
            if( ip->IP_Destaddr == *((unsigned long*)&myip[0]) )  // if my IP address 
    3c1a:	20 91 74 06 	lds	r18, 0x0674
    3c1e:	30 91 75 06 	lds	r19, 0x0675
    3c22:	40 91 76 06 	lds	r20, 0x0676
    3c26:	50 91 77 06 	lds	r21, 0x0677
    3c2a:	80 91 46 0b 	lds	r24, 0x0B46
    3c2e:	90 91 47 0b 	lds	r25, 0x0B47
    3c32:	a0 91 48 0b 	lds	r26, 0x0B48
    3c36:	b0 91 49 0b 	lds	r27, 0x0B49
    3c3a:	28 17       	cp	r18, r24
    3c3c:	39 07       	cpc	r19, r25
    3c3e:	4a 07       	cpc	r20, r26
    3c40:	5b 07       	cpc	r21, r27
    3c42:	09 f0       	breq	.+2      	; 0x3c46 <check_packet+0x50>
    3c44:	42 c0       	rjmp	.+132    	; 0x3cca <check_packet+0xd4>
            {
                arp_entry_add();  ///Refresh des ARP Eintrages
    3c46:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <arp_entry_add>
                if(ip->IP_Proto == PROT_ICMP)
    3c4a:	80 91 6d 06 	lds	r24, 0x066D
    3c4e:	81 30       	cpi	r24, 0x01	; 1
    3c50:	b9 f5       	brne	.+110    	; 0x3cc0 <check_packet+0xca>
                {
                    switch ( icmp->ICMP_Type )
    3c52:	80 91 78 06 	lds	r24, 0x0678
    3c56:	88 23       	and	r24, r24
    3c58:	c1 f0       	breq	.+48     	; 0x3c8a <check_packet+0x94>
    3c5a:	88 30       	cpi	r24, 0x08	; 8
    3c5c:	09 f0       	breq	.+2      	; 0x3c60 <check_packet+0x6a>
    3c5e:	40 c0       	rjmp	.+128    	; 0x3ce0 <check_packet+0xea>
                    {
                        case (8): //Ping reqest
                            icmp_send(ip->IP_Srcaddr,0,0,icmp->ICMP_SeqNum,icmp->ICMP_Id); 
    3c60:	60 91 70 06 	lds	r22, 0x0670
    3c64:	70 91 71 06 	lds	r23, 0x0671
    3c68:	80 91 72 06 	lds	r24, 0x0672
    3c6c:	90 91 73 06 	lds	r25, 0x0673
    3c70:	00 91 7e 06 	lds	r16, 0x067E
    3c74:	10 91 7f 06 	lds	r17, 0x067F
    3c78:	e0 90 7c 06 	lds	r14, 0x067C
    3c7c:	f0 90 7d 06 	lds	r15, 0x067D
    3c80:	40 e0       	ldi	r20, 0x00	; 0
    3c82:	20 e0       	ldi	r18, 0x00	; 0
    3c84:	0e 94 cf 1c 	call	0x399e	; 0x399e <icmp_send>
    3c88:	2b c0       	rjmp	.+86     	; 0x3ce0 <check_packet+0xea>
                            break;
                            
                        case (0): //Ping reply
                            if ((*((unsigned long*)&ping.ip1[0])) == ip->IP_Srcaddr)
    3c8a:	20 91 28 0c 	lds	r18, 0x0C28
    3c8e:	30 91 29 0c 	lds	r19, 0x0C29
    3c92:	40 91 2a 0c 	lds	r20, 0x0C2A
    3c96:	50 91 2b 0c 	lds	r21, 0x0C2B
    3c9a:	80 91 70 06 	lds	r24, 0x0670
    3c9e:	90 91 71 06 	lds	r25, 0x0671
    3ca2:	a0 91 72 06 	lds	r26, 0x0672
    3ca6:	b0 91 73 06 	lds	r27, 0x0673
    3caa:	28 17       	cp	r18, r24
    3cac:	39 07       	cpc	r19, r25
    3cae:	4a 07       	cpc	r20, r26
    3cb0:	5b 07       	cpc	r21, r27
    3cb2:	b1 f4       	brne	.+44     	; 0x3ce0 <check_packet+0xea>
                            {
                                ping.result |= 0x01;
    3cb4:	80 91 2d 0c 	lds	r24, 0x0C2D
    3cb8:	81 60       	ori	r24, 0x01	; 1
    3cba:	80 93 2d 0c 	sts	0x0C2D, r24
    3cbe:	10 c0       	rjmp	.+32     	; 0x3ce0 <check_packet+0xea>
                    }
                    return;
                }
                else
                {
                    if( ip->IP_Proto == PROT_TCP ) tcp_socket_process();
    3cc0:	86 30       	cpi	r24, 0x06	; 6
    3cc2:	41 f4       	brne	.+16     	; 0x3cd4 <check_packet+0xde>
    3cc4:	0e 94 2b 1a 	call	0x3456	; 0x3456 <tcp_socket_process>
    3cc8:	05 c0       	rjmp	.+10     	; 0x3cd4 <check_packet+0xde>
                    if( ip->IP_Proto == PROT_UDP ) udp_socket_process();
                }
            }
            else
            if (ip->IP_Destaddr == (unsigned long)0xffffffff ) // if broadcast
    3cca:	2f 5f       	subi	r18, 0xFF	; 255
    3ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    3cce:	4f 4f       	sbci	r20, 0xFF	; 255
    3cd0:	5f 4f       	sbci	r21, 0xFF	; 255
    3cd2:	31 f4       	brne	.+12     	; 0x3ce0 <check_packet+0xea>
            {
                if( ip->IP_Proto == PROT_UDP ) udp_socket_process();
    3cd4:	80 91 6d 06 	lds	r24, 0x066D
    3cd8:	81 31       	cpi	r24, 0x11	; 17
    3cda:	11 f4       	brne	.+4      	; 0x3ce0 <check_packet+0xea>
    3cdc:	0e 94 66 18 	call	0x30cc	; 0x30cc <udp_socket_process>
            }
		}
	}
	return;
}
    3ce0:	1f 91       	pop	r17
    3ce2:	0f 91       	pop	r16
    3ce4:	ff 90       	pop	r15
    3ce6:	ef 90       	pop	r14
    3ce8:	08 95       	ret

00003cea <eth_get_data>:
 * Ethernet Datenempfang
 *
 */
void eth_get_data (void)
{ 	
	if(eth.timer)
    3cea:	80 91 45 0b 	lds	r24, 0x0B45
    3cee:	81 ff       	sbrs	r24, 1
    3cf0:	09 c0       	rjmp	.+18     	; 0x3d04 <eth_get_data+0x1a>
	{
		tcp_timer_call();
    3cf2:	0e 94 1f 1c 	call	0x383e	; 0x383e <tcp_timer_call>
		arp_timer_call();
    3cf6:	0e 94 9a 14 	call	0x2934	; 0x2934 <arp_timer_call>
		eth.timer = 0;
    3cfa:	80 91 45 0b 	lds	r24, 0x0B45
    3cfe:	8d 7f       	andi	r24, 0xFD	; 253
    3d00:	80 93 45 0b 	sts	0x0B45, r24
	}	
	if(eth.data_present)
    3d04:	80 91 45 0b 	lds	r24, 0x0B45
    3d08:	80 fd       	sbrc	r24, 0
    3d0a:	0f c0       	rjmp	.+30     	; 0x3d2a <eth_get_data+0x40>
    3d0c:	08 95       	ret
			while (ByteL != ByteH) //(!= bedeutet ungleich)
			{	
	#endif	
				unsigned int packet_length;
				  
				packet_length = ETH_PACKET_RECEIVE(MTU_SIZE,(uint8_t *)eth_buffer);
    3d0e:	80 eb       	ldi	r24, 0xB0	; 176
    3d10:	94 e0       	ldi	r25, 0x04	; 4
    3d12:	66 e5       	ldi	r22, 0x56	; 86
    3d14:	76 e0       	ldi	r23, 0x06	; 6
    3d16:	0e 94 f5 24 	call	0x49ea	; 0x49ea <enc_receive_packet>
    3d1a:	fc 01       	movw	r30, r24
				if(packet_length > 0)
    3d1c:	00 97       	sbiw	r24, 0x00	; 0
    3d1e:	29 f0       	breq	.+10     	; 0x3d2a <eth_get_data+0x40>
				{
					eth_buffer[packet_length+1] = 0;
    3d20:	ea 5a       	subi	r30, 0xAA	; 170
    3d22:	f9 4f       	sbci	r31, 0xF9	; 249
    3d24:	11 82       	std	Z+1, r1	; 0x01
					check_packet();
    3d26:	0e 94 fb 1d 	call	0x3bf6	; 0x3bf6 <check_packet>
		eth.timer = 0;
	}	
	if(eth.data_present)
	{
	#if USE_ENC28J60
		while(ETH_INT_ACTIVE)
    3d2a:	1a 9b       	sbis	0x03, 2	; 3
    3d2c:	f0 cf       	rjmp	.-32     	; 0x3d0e <eth_get_data+0x24>
		}
	#if USE_RTL8019
		Networkcard_INT_RES();
		Networkcard_Start();
	#endif
		eth.data_present = 0;
    3d2e:	80 91 45 0b 	lds	r24, 0x0B45
    3d32:	8e 7f       	andi	r24, 0xFE	; 254
    3d34:	80 93 45 0b 	sts	0x0B45, r24
		ETH_INT_ENABLE;
    3d38:	ea 9a       	sbi	0x1d, 2	; 29
    3d3a:	08 95       	ret

00003d3c <arp_request>:
 *	\ingroup stack
 * Diese Routine erzeugt ein ARP Request
 *
 */
char arp_request (unsigned long dest_ip)
{
    3d3c:	8f 92       	push	r8
    3d3e:	9f 92       	push	r9
    3d40:	af 92       	push	r10
    3d42:	bf 92       	push	r11
    3d44:	cf 92       	push	r12
    3d46:	df 92       	push	r13
    3d48:	ef 92       	push	r14
    3d4a:	ff 92       	push	r15
    3d4c:	0f 93       	push	r16
    3d4e:	1f 93       	push	r17
    3d50:	df 93       	push	r29
    3d52:	cf 93       	push	r28
    3d54:	cd b7       	in	r28, 0x3d	; 61
    3d56:	de b7       	in	r29, 0x3e	; 62
    3d58:	aa 97       	sbiw	r28, 0x2a	; 42
    3d5a:	0f b6       	in	r0, 0x3f	; 63
    3d5c:	f8 94       	cli
    3d5e:	de bf       	out	0x3e, r29	; 62
    3d60:	0f be       	out	0x3f, r0	; 63
    3d62:	cd bf       	out	0x3d, r28	; 61
    3d64:	4b 01       	movw	r8, r22
    3d66:	5c 01       	movw	r10, r24

    struct Ethernet_Header *ethernet;
    struct ARP_Header *arp;

    ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
    arp      = (struct ARP_Header      *)&buffer[ARP_OFFSET];
    3d68:	8e 01       	movw	r16, r28
    3d6a:	01 5f       	subi	r16, 0xF1	; 241
    3d6c:	1f 4f       	sbci	r17, 0xFF	; 255

	dest_ip_store = dest_ip;

	if ((dest_ip & (*((unsigned long *)&netmask[0])))==
    3d6e:	80 91 46 0b 	lds	r24, 0x0B46
    3d72:	90 91 47 0b 	lds	r25, 0x0B47
    3d76:	a0 91 48 0b 	lds	r26, 0x0B48
    3d7a:	b0 91 49 0b 	lds	r27, 0x0B49
    3d7e:	88 25       	eor	r24, r8
    3d80:	99 25       	eor	r25, r9
    3d82:	aa 25       	eor	r26, r10
    3d84:	bb 25       	eor	r27, r11
    3d86:	20 91 50 0b 	lds	r18, 0x0B50
    3d8a:	30 91 51 0b 	lds	r19, 0x0B51
    3d8e:	40 91 52 0b 	lds	r20, 0x0B52
    3d92:	50 91 53 0b 	lds	r21, 0x0B53
    3d96:	82 23       	and	r24, r18
    3d98:	93 23       	and	r25, r19
    3d9a:	a4 23       	and	r26, r20
    3d9c:	b5 23       	and	r27, r21
    3d9e:	00 97       	sbiw	r24, 0x00	; 0
    3da0:	a1 05       	cpc	r26, r1
    3da2:	b1 05       	cpc	r27, r1
    3da4:	19 f4       	brne	.+6      	; 0x3dac <arp_request+0x70>
    3da6:	75 01       	movw	r14, r10
    3da8:	64 01       	movw	r12, r8
    3daa:	08 c0       	rjmp	.+16     	; 0x3dbc <arp_request+0x80>
		DEBUG("MY NETWORK!\r\n");
	}
	else
	{
		DEBUG("ROUTING!\r\n");
		dest_ip = (*((unsigned long *)&router_ip[0]));
    3dac:	c0 90 4c 0b 	lds	r12, 0x0B4C
    3db0:	d0 90 4d 0b 	lds	r13, 0x0B4D
    3db4:	e0 90 4e 0b 	lds	r14, 0x0B4E
    3db8:	f0 90 4f 0b 	lds	r15, 0x0B4F
	}

    ethernet->EnetPacketType = HTONS(0x0806);          // Nutzlast 0x0800=IP Datagramm;0x0806 = ARP
    3dbc:	88 e0       	ldi	r24, 0x08	; 8
    3dbe:	96 e0       	ldi	r25, 0x06	; 6
    3dc0:	9e 87       	std	Y+14, r25	; 0x0e
    3dc2:	8d 87       	std	Y+13, r24	; 0x0d
  
    new_eth_header (buffer,dest_ip);
    3dc4:	ce 01       	movw	r24, r28
    3dc6:	01 96       	adiw	r24, 0x01	; 1
    3dc8:	b7 01       	movw	r22, r14
    3dca:	a6 01       	movw	r20, r12
    3dcc:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <new_eth_header>
  
    arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);   // MyIP = ARP Source IP
    3dd0:	80 91 46 0b 	lds	r24, 0x0B46
    3dd4:	90 91 47 0b 	lds	r25, 0x0B47
    3dd8:	a0 91 48 0b 	lds	r26, 0x0B48
    3ddc:	b0 91 49 0b 	lds	r27, 0x0B49
    3de0:	f8 01       	movw	r30, r16
    3de2:	86 87       	std	Z+14, r24	; 0x0e
    3de4:	97 87       	std	Z+15, r25	; 0x0f
    3de6:	a0 8b       	std	Z+16, r26	; 0x10
    3de8:	b1 8b       	std	Z+17, r27	; 0x11
    arp->ARP_TIPAddr = dest_ip;                         // Dest IP 
    3dea:	c0 8e       	std	Z+24, r12	; 0x18
    3dec:	d1 8e       	std	Z+25, r13	; 0x19
    3dee:	e2 8e       	std	Z+26, r14	; 0x1a
    3df0:	f3 8e       	std	Z+27, r15	; 0x1b
    3df2:	ac e7       	ldi	r26, 0x7C	; 124
    3df4:	bc e0       	ldi	r27, 0x0C	; 12
	
	for(unsigned char count = 0; count < 6; count++)
	{
		  arp->ARP_SHAddr[count] = mymac[count];
    3df6:	8d 91       	ld	r24, X+
    3df8:	80 87       	std	Z+8, r24	; 0x08
		  arp->ARP_THAddr[count] = 0;
    3dfa:	12 8a       	std	Z+18, r1	; 0x12
    3dfc:	31 96       	adiw	r30, 0x01	; 1
    new_eth_header (buffer,dest_ip);
  
    arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);   // MyIP = ARP Source IP
    arp->ARP_TIPAddr = dest_ip;                         // Dest IP 
	
	for(unsigned char count = 0; count < 6; count++)
    3dfe:	2c e0       	ldi	r18, 0x0C	; 12
    3e00:	a2 38       	cpi	r26, 0x82	; 130
    3e02:	b2 07       	cpc	r27, r18
    3e04:	c1 f7       	brne	.-16     	; 0x3df6 <arp_request+0xba>
	{
		  arp->ARP_SHAddr[count] = mymac[count];
		  arp->ARP_THAddr[count] = 0;
	}
	
    arp->ARP_HWType = HTONS(0x0001);
    3e06:	20 e0       	ldi	r18, 0x00	; 0
    3e08:	31 e0       	ldi	r19, 0x01	; 1
    3e0a:	f8 01       	movw	r30, r16
    3e0c:	31 83       	std	Z+1, r19	; 0x01
    3e0e:	20 83       	st	Z, r18
    arp->ARP_PRType = HTONS(0x0800);
    3e10:	88 e0       	ldi	r24, 0x08	; 8
    3e12:	90 e0       	ldi	r25, 0x00	; 0
    3e14:	93 83       	std	Z+3, r25	; 0x03
    3e16:	82 83       	std	Z+2, r24	; 0x02
    arp->ARP_HWLen  = 0x06;
    3e18:	86 e0       	ldi	r24, 0x06	; 6
    3e1a:	84 83       	std	Z+4, r24	; 0x04
    arp->ARP_PRLen  = 0x04;
    3e1c:	84 e0       	ldi	r24, 0x04	; 4
    3e1e:	85 83       	std	Z+5, r24	; 0x05
    arp->ARP_Op     = HTONS(0x0001);
    3e20:	37 83       	std	Z+7, r19	; 0x07
    3e22:	26 83       	std	Z+6, r18	; 0x06

    ETH_PACKET_SEND(ARP_REQUEST_LEN, (uint8_t *)buffer);        //send....
    3e24:	8a e2       	ldi	r24, 0x2A	; 42
    3e26:	90 e0       	ldi	r25, 0x00	; 0
    3e28:	be 01       	movw	r22, r28
    3e2a:	6f 5f       	subi	r22, 0xFF	; 255
    3e2c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e2e:	0e 94 78 24 	call	0x48f0	; 0x48f0 <enc_send_packet>
    3e32:	10 e0       	ldi	r17, 0x00	; 0
    3e34:	5a c0       	rjmp	.+180    	; 0x3eea <arp_request+0x1ae>
    3e36:	42 2f       	mov	r20, r18
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
	{
		if(arp_entry[b].arp_t_ip == dest_ip)
    3e38:	f9 01       	movw	r30, r18
    3e3a:	ee 0f       	add	r30, r30
    3e3c:	ff 1f       	adc	r31, r31
    3e3e:	e2 0f       	add	r30, r18
    3e40:	f3 1f       	adc	r31, r19
    3e42:	ee 0f       	add	r30, r30
    3e44:	ff 1f       	adc	r31, r31
    3e46:	ee 0f       	add	r30, r30
    3e48:	ff 1f       	adc	r31, r31
    3e4a:	e9 5f       	subi	r30, 0xF9	; 249
    3e4c:	f4 4f       	sbci	r31, 0xF4	; 244
    3e4e:	86 81       	ldd	r24, Z+6	; 0x06
    3e50:	97 81       	ldd	r25, Z+7	; 0x07
    3e52:	a0 85       	ldd	r26, Z+8	; 0x08
    3e54:	b1 85       	ldd	r27, Z+9	; 0x09
    3e56:	88 15       	cp	r24, r8
    3e58:	99 05       	cpc	r25, r9
    3e5a:	aa 05       	cpc	r26, r10
    3e5c:	bb 05       	cpc	r27, r11
    3e5e:	31 f0       	breq	.+12     	; 0x3e6c <arp_request+0x130>
    3e60:	2f 5f       	subi	r18, 0xFF	; 255
    3e62:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    3e64:	25 30       	cpi	r18, 0x05	; 5
    3e66:	31 05       	cpc	r19, r1
    3e68:	31 f7       	brne	.-52     	; 0x3e36 <arp_request+0xfa>
    3e6a:	45 e0       	ldi	r20, 0x05	; 5
    3e6c:	20 e0       	ldi	r18, 0x00	; 0
    3e6e:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(arp_entry[b].arp_t_ip == dest_ip)
    3e70:	f9 01       	movw	r30, r18
    3e72:	ee 0f       	add	r30, r30
    3e74:	ff 1f       	adc	r31, r31
    3e76:	e2 0f       	add	r30, r18
    3e78:	f3 1f       	adc	r31, r19
    3e7a:	ee 0f       	add	r30, r30
    3e7c:	ff 1f       	adc	r31, r31
    3e7e:	ee 0f       	add	r30, r30
    3e80:	ff 1f       	adc	r31, r31
    3e82:	e9 5f       	subi	r30, 0xF9	; 249
    3e84:	f4 4f       	sbci	r31, 0xF4	; 244
    3e86:	86 81       	ldd	r24, Z+6	; 0x06
    3e88:	97 81       	ldd	r25, Z+7	; 0x07
    3e8a:	a0 85       	ldd	r26, Z+8	; 0x08
    3e8c:	b1 85       	ldd	r27, Z+9	; 0x09
    3e8e:	8c 15       	cp	r24, r12
    3e90:	9d 05       	cpc	r25, r13
    3e92:	ae 05       	cpc	r26, r14
    3e94:	bf 05       	cpc	r27, r15
    3e96:	31 f0       	breq	.+12     	; 0x3ea4 <arp_request+0x168>
    3e98:	2f 5f       	subi	r18, 0xFF	; 255
    3e9a:	3f 4f       	sbci	r19, 0xFF	; 255
 * Diese Routine such anhand der IP den ARP eintrag
 *
 */
char arp_entry_search (unsigned long dest_ip)
{
	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
    3e9c:	25 30       	cpi	r18, 0x05	; 5
    3e9e:	31 05       	cpc	r19, r1
    3ea0:	39 f7       	brne	.-50     	; 0x3e70 <arp_request+0x134>
    3ea2:	3a c0       	rjmp	.+116    	; 0x3f18 <arp_request+0x1dc>
		index_tmp = arp_entry_search(dest_ip_store);
		index = arp_entry_search(dest_ip);
		if (index < MAX_ARP_ENTRY || index_tmp < MAX_ARP_ENTRY)
		{
			DEBUG("ARP EINTRAG GEFUNDEN!\r\n");
			if (index_tmp < MAX_ARP_ENTRY) return(1);//OK
    3ea4:	45 30       	cpi	r20, 0x05	; 5
    3ea6:	21 f5       	brne	.+72     	; 0x3ef0 <arp_request+0x1b4>
			arp_entry[index].arp_t_ip = dest_ip_store;
    3ea8:	82 2f       	mov	r24, r18
    3eaa:	90 e0       	ldi	r25, 0x00	; 0
    3eac:	fc 01       	movw	r30, r24
    3eae:	ee 0f       	add	r30, r30
    3eb0:	ff 1f       	adc	r31, r31
    3eb2:	e8 0f       	add	r30, r24
    3eb4:	f9 1f       	adc	r31, r25
    3eb6:	ee 0f       	add	r30, r30
    3eb8:	ff 1f       	adc	r31, r31
    3eba:	ee 0f       	add	r30, r30
    3ebc:	ff 1f       	adc	r31, r31
    3ebe:	e9 5f       	subi	r30, 0xF9	; 249
    3ec0:	f4 4f       	sbci	r31, 0xF4	; 244
    3ec2:	86 82       	std	Z+6, r8	; 0x06
    3ec4:	97 82       	std	Z+7, r9	; 0x07
    3ec6:	a0 86       	std	Z+8, r10	; 0x08
    3ec8:	b1 86       	std	Z+9, r11	; 0x09
    3eca:	12 c0       	rjmp	.+36     	; 0x3ef0 <arp_request+0x1b4>
			return(1);//OK
    3ecc:	80 e0       	ldi	r24, 0x00	; 0
    3ece:	90 e0       	ldi	r25, 0x00	; 0
		}
        for(a=0;a<10000;a++)
        {
            asm("nop");
    3ed0:	00 00       	nop
    3ed2:	01 96       	adiw	r24, 0x01	; 1
			DEBUG("ARP EINTRAG GEFUNDEN!\r\n");
			if (index_tmp < MAX_ARP_ENTRY) return(1);//OK
			arp_entry[index].arp_t_ip = dest_ip_store;
			return(1);//OK
		}
        for(a=0;a<10000;a++)
    3ed4:	f7 e2       	ldi	r31, 0x27	; 39
    3ed6:	80 31       	cpi	r24, 0x10	; 16
    3ed8:	9f 07       	cpc	r25, r31
    3eda:	d1 f7       	brne	.-12     	; 0x3ed0 <arp_request+0x194>
        {
            asm("nop");
        }
		eth_get_data();
    3edc:	0e 94 75 1e 	call	0x3cea	; 0x3cea <eth_get_data>
    arp->ARP_PRLen  = 0x04;
    arp->ARP_Op     = HTONS(0x0001);

    ETH_PACKET_SEND(ARP_REQUEST_LEN, (uint8_t *)buffer);        //send....
	
	for(count = 0;count<20;count++)
    3ee0:	1f 5f       	subi	r17, 0xFF	; 255
    3ee2:	14 31       	cpi	r17, 0x14	; 20
    3ee4:	11 f4       	brne	.+4      	; 0x3eea <arp_request+0x1ae>
    3ee6:	80 e0       	ldi	r24, 0x00	; 0
    3ee8:	04 c0       	rjmp	.+8      	; 0x3ef2 <arp_request+0x1b6>
    3eea:	20 e0       	ldi	r18, 0x00	; 0
    3eec:	30 e0       	ldi	r19, 0x00	; 0
    3eee:	a3 cf       	rjmp	.-186    	; 0x3e36 <arp_request+0xfa>
    3ef0:	81 e0       	ldi	r24, 0x01	; 1
        }
		eth_get_data();
		DEBUG("**KEINEN ARP EINTRAG GEFUNDEN**\r\n");
	}
	return(0);//keine Antwort
}
    3ef2:	aa 96       	adiw	r28, 0x2a	; 42
    3ef4:	0f b6       	in	r0, 0x3f	; 63
    3ef6:	f8 94       	cli
    3ef8:	de bf       	out	0x3e, r29	; 62
    3efa:	0f be       	out	0x3f, r0	; 63
    3efc:	cd bf       	out	0x3d, r28	; 61
    3efe:	cf 91       	pop	r28
    3f00:	df 91       	pop	r29
    3f02:	1f 91       	pop	r17
    3f04:	0f 91       	pop	r16
    3f06:	ff 90       	pop	r15
    3f08:	ef 90       	pop	r14
    3f0a:	df 90       	pop	r13
    3f0c:	cf 90       	pop	r12
    3f0e:	bf 90       	pop	r11
    3f10:	af 90       	pop	r10
    3f12:	9f 90       	pop	r9
    3f14:	8f 90       	pop	r8
    3f16:	08 95       	ret
	
	for(count = 0;count<20;count++)
	{
		index_tmp = arp_entry_search(dest_ip_store);
		index = arp_entry_search(dest_ip);
		if (index < MAX_ARP_ENTRY || index_tmp < MAX_ARP_ENTRY)
    3f18:	45 30       	cpi	r20, 0x05	; 5
    3f1a:	c1 f2       	breq	.-80     	; 0x3ecc <arp_request+0x190>
    3f1c:	e9 cf       	rjmp	.-46     	; 0x3ef0 <arp_request+0x1b4>

00003f1e <get_eeprom_value>:
}

//----------------------------------------------------------------------------
//
unsigned long get_eeprom_value (unsigned int eeprom_adresse,unsigned long default_value)
{
    3f1e:	8f 92       	push	r8
    3f20:	9f 92       	push	r9
    3f22:	af 92       	push	r10
    3f24:	bf 92       	push	r11
    3f26:	cf 92       	push	r12
    3f28:	df 92       	push	r13
    3f2a:	ef 92       	push	r14
    3f2c:	ff 92       	push	r15
    3f2e:	0f 93       	push	r16
    3f30:	1f 93       	push	r17
    3f32:	df 93       	push	r29
    3f34:	cf 93       	push	r28
    3f36:	00 d0       	rcall	.+0      	; 0x3f38 <get_eeprom_value+0x1a>
    3f38:	00 d0       	rcall	.+0      	; 0x3f3a <get_eeprom_value+0x1c>
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	7c 01       	movw	r14, r24
    3f40:	b4 2e       	mov	r11, r20
    3f42:	a5 2e       	mov	r10, r21
    3f44:	96 2e       	mov	r9, r22
    3f46:	87 2e       	mov	r8, r23
    3f48:	00 e0       	ldi	r16, 0x00	; 0
    3f4a:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char value[4];
	
	for (unsigned char count = 0; count<4;count++)
	{
		eeprom_busy_wait ();	
		value[count] = eeprom_read_byte((unsigned char *)(eeprom_adresse + count));
    3f4c:	6e 01       	movw	r12, r28
    3f4e:	08 94       	sec
    3f50:	c1 1c       	adc	r12, r1
    3f52:	d1 1c       	adc	r13, r1
{
	unsigned char value[4];
	
	for (unsigned char count = 0; count<4;count++)
	{
		eeprom_busy_wait ();	
    3f54:	f9 99       	sbic	0x1f, 1	; 31
    3f56:	fe cf       	rjmp	.-4      	; 0x3f54 <get_eeprom_value+0x36>
		value[count] = eeprom_read_byte((unsigned char *)(eeprom_adresse + count));
    3f58:	c8 01       	movw	r24, r16
    3f5a:	8e 0d       	add	r24, r14
    3f5c:	9f 1d       	adc	r25, r15
    3f5e:	0e 94 3f 71 	call	0xe27e	; 0xe27e <__eerd_byte_m644p>
    3f62:	f6 01       	movw	r30, r12
    3f64:	e0 0f       	add	r30, r16
    3f66:	f1 1f       	adc	r31, r17
    3f68:	80 83       	st	Z, r24
    3f6a:	0f 5f       	subi	r16, 0xFF	; 255
    3f6c:	1f 4f       	sbci	r17, 0xFF	; 255
//
unsigned long get_eeprom_value (unsigned int eeprom_adresse,unsigned long default_value)
{
	unsigned char value[4];
	
	for (unsigned char count = 0; count<4;count++)
    3f6e:	04 30       	cpi	r16, 0x04	; 4
    3f70:	11 05       	cpc	r17, r1
    3f72:	81 f7       	brne	.-32     	; 0x3f54 <get_eeprom_value+0x36>
		eeprom_busy_wait ();	
		value[count] = eeprom_read_byte((unsigned char *)(eeprom_adresse + count));
	}

	//Ist der EEPROM Inhalt leer?
	if ((*((unsigned long*)&value[0])) == 0xFFFFFFFF)
    3f74:	29 81       	ldd	r18, Y+1	; 0x01
    3f76:	3a 81       	ldd	r19, Y+2	; 0x02
    3f78:	4b 81       	ldd	r20, Y+3	; 0x03
    3f7a:	5c 81       	ldd	r21, Y+4	; 0x04
    3f7c:	2f 3f       	cpi	r18, 0xFF	; 255
    3f7e:	8f ef       	ldi	r24, 0xFF	; 255
    3f80:	38 07       	cpc	r19, r24
    3f82:	8f ef       	ldi	r24, 0xFF	; 255
    3f84:	48 07       	cpc	r20, r24
    3f86:	8f ef       	ldi	r24, 0xFF	; 255
    3f88:	58 07       	cpc	r21, r24
    3f8a:	41 f4       	brne	.+16     	; 0x3f9c <get_eeprom_value+0x7e>
    3f8c:	2b 2d       	mov	r18, r11
    3f8e:	3a 2d       	mov	r19, r10
    3f90:	49 2d       	mov	r20, r9
    3f92:	58 2d       	mov	r21, r8
    3f94:	c9 01       	movw	r24, r18
    3f96:	da 01       	movw	r26, r20
    3f98:	9c 01       	movw	r18, r24
    3f9a:	ad 01       	movw	r20, r26
	{
		return(default_value);
	}
	return((*((unsigned long*)&value[0])));
}
    3f9c:	b9 01       	movw	r22, r18
    3f9e:	ca 01       	movw	r24, r20
    3fa0:	0f 90       	pop	r0
    3fa2:	0f 90       	pop	r0
    3fa4:	0f 90       	pop	r0
    3fa6:	0f 90       	pop	r0
    3fa8:	cf 91       	pop	r28
    3faa:	df 91       	pop	r29
    3fac:	1f 91       	pop	r17
    3fae:	0f 91       	pop	r16
    3fb0:	ff 90       	pop	r15
    3fb2:	ef 90       	pop	r14
    3fb4:	df 90       	pop	r13
    3fb6:	cf 90       	pop	r12
    3fb8:	bf 90       	pop	r11
    3fba:	af 90       	pop	r10
    3fbc:	9f 90       	pop	r9
    3fbe:	8f 90       	pop	r8
    3fc0:	08 95       	ret

00003fc2 <stack_init>:
 *
 */
void stack_init (void)
{
	//IP, NETMASK und ROUTER_IP aus EEPROM auslesen	
    (*((unsigned long*)&myip[0])) = get_eeprom_value(IP_EEPROM_STORE,MYIP);
    3fc2:	8e e1       	ldi	r24, 0x1E	; 30
    3fc4:	90 e0       	ldi	r25, 0x00	; 0
    3fc6:	40 ec       	ldi	r20, 0xC0	; 192
    3fc8:	58 ea       	ldi	r21, 0xA8	; 168
    3fca:	61 e0       	ldi	r22, 0x01	; 1
    3fcc:	73 e6       	ldi	r23, 0x63	; 99
    3fce:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    3fd2:	60 93 46 0b 	sts	0x0B46, r22
    3fd6:	70 93 47 0b 	sts	0x0B47, r23
    3fda:	80 93 48 0b 	sts	0x0B48, r24
    3fde:	90 93 49 0b 	sts	0x0B49, r25
	(*((unsigned long*)&netmask[0])) = get_eeprom_value(NETMASK_EEPROM_STORE,NETMASK);
    3fe2:	82 e2       	ldi	r24, 0x22	; 34
    3fe4:	90 e0       	ldi	r25, 0x00	; 0
    3fe6:	4f ef       	ldi	r20, 0xFF	; 255
    3fe8:	5f ef       	ldi	r21, 0xFF	; 255
    3fea:	6f ef       	ldi	r22, 0xFF	; 255
    3fec:	70 e0       	ldi	r23, 0x00	; 0
    3fee:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    3ff2:	60 93 50 0b 	sts	0x0B50, r22
    3ff6:	70 93 51 0b 	sts	0x0B51, r23
    3ffa:	80 93 52 0b 	sts	0x0B52, r24
    3ffe:	90 93 53 0b 	sts	0x0B53, r25
	(*((unsigned long*)&router_ip[0])) = get_eeprom_value(ROUTER_IP_EEPROM_STORE,ROUTER_IP);
    4002:	86 e2       	ldi	r24, 0x26	; 38
    4004:	90 e0       	ldi	r25, 0x00	; 0
    4006:	40 ec       	ldi	r20, 0xC0	; 192
    4008:	58 ea       	ldi	r21, 0xA8	; 168
    400a:	60 e0       	ldi	r22, 0x00	; 0
    400c:	71 e0       	ldi	r23, 0x01	; 1
    400e:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    4012:	60 93 4c 0b 	sts	0x0B4C, r22
    4016:	70 93 4d 0b 	sts	0x0B4D, r23
    401a:	80 93 4e 0b 	sts	0x0B4E, r24
    401e:	90 93 4f 0b 	sts	0x0B4F, r25
	
    #if USE_DNS
    //DNS-Server IP aus EEPROM auslesen
    (*((unsigned long*)&dns_server_ip[0])) = get_eeprom_value(DNS_IP_EEPROM_STORE,DNS_IP);
    4022:	8a e2       	ldi	r24, 0x2A	; 42
    4024:	90 e0       	ldi	r25, 0x00	; 0
    4026:	40 ec       	ldi	r20, 0xC0	; 192
    4028:	58 ea       	ldi	r21, 0xA8	; 168
    402a:	60 e0       	ldi	r22, 0x00	; 0
    402c:	71 e0       	ldi	r23, 0x01	; 1
    402e:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    4032:	60 93 6a 0d 	sts	0x0D6A, r22
    4036:	70 93 6b 0d 	sts	0x0D6B, r23
    403a:	80 93 6c 0d 	sts	0x0D6C, r24
    403e:	90 93 6d 0d 	sts	0x0D6D, r25
    #endif

	//MAC Adresse setzen
	mymac[0] = MYMAC1;
    4042:	10 92 7c 0c 	sts	0x0C7C, r1
    mymac[1] = MYMAC2;
    4046:	80 e2       	ldi	r24, 0x20	; 32
    4048:	80 93 7d 0c 	sts	0x0C7D, r24
    mymac[2] = MYMAC3;
    404c:	88 e1       	ldi	r24, 0x18	; 24
    404e:	80 93 7e 0c 	sts	0x0C7E, r24
    mymac[3] = MYMAC4;
    4052:	81 eb       	ldi	r24, 0xB1	; 177
    4054:	80 93 7f 0c 	sts	0x0C7F, r24
    mymac[4] = MYMAC5;
    4058:	85 e1       	ldi	r24, 0x15	; 21
    405a:	80 93 80 0c 	sts	0x0C80, r24
    mymac[5] = MYMAC6;
    405e:	8f e3       	ldi	r24, 0x3F	; 63
    4060:	80 93 81 0c 	sts	0x0C81, r24
	
	/*NIC Initialisieren*/
	DEBUG("\n\rNIC init:");
	ETH_INIT();
    4064:	0e 94 7d 25 	call	0x4afa	; 0x4afa <enc_init>
	DEBUG("READY!\r\n");
	
	DEBUG("My IP: %1i.%1i.%1i.%1i\r\n\r\n",myip[0],myip[1],myip[2],myip[3]);
}
    4068:	08 95       	ret

0000406a <AnzahlTageImMonat>:
 *	\ingroup time
 *	AnzahlTageImMonat
 */
uint8_t AnzahlTageImMonat(uint8_t monat, uint8_t jahr)
{
    if (monat != 2) {
    406a:	82 30       	cpi	r24, 0x02	; 2
    406c:	31 f0       	breq	.+12     	; 0x407a <AnzahlTageImMonat+0x10>
	    return pgm_read_byte(&Monatstage[monat-1]);
    406e:	e8 2f       	mov	r30, r24
    4070:	f0 e0       	ldi	r31, 0x00	; 0
    4072:	e8 5f       	subi	r30, 0xF8	; 248
    4074:	fe 4f       	sbci	r31, 0xFE	; 254
    4076:	84 91       	lpm	r24, Z+
    4078:	08 95       	ret
    }
	else {
        if ((jahr % 4) != 0) {	// bis zum nchsten Jahrhundertwechsel reicht das!
    407a:	86 2f       	mov	r24, r22
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	83 70       	andi	r24, 0x03	; 3
    4080:	90 70       	andi	r25, 0x00	; 0
    4082:	89 2b       	or	r24, r25
    4084:	11 f4       	brne	.+4      	; 0x408a <AnzahlTageImMonat+0x20>
    4086:	8d e1       	ldi	r24, 0x1D	; 29
    4088:	08 95       	ret
    408a:	8c e1       	ldi	r24, 0x1C	; 28
        }
		else {
            return 29;
        }
    }
}
    408c:	08 95       	ret

0000408e <GetYearYYYY>:
 *	\ingroup time
 *   GetYearYYYY
 */
uint16_t GetYearYYYY(void)
{
    return 2000 + (uint16_t) TM_YY;
    408e:	20 91 31 0c 	lds	r18, 0x0C31
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	20 53       	subi	r18, 0x30	; 48
    4096:	38 4f       	sbci	r19, 0xF8	; 248
}
    4098:	c9 01       	movw	r24, r18
    409a:	08 95       	ret

0000409c <get_datetime>:
 *	\ingroup time
 *	get_datetime
 */

void get_datetime(uint16_t* year, uint8_t* month, uint8_t* day, uint8_t* hour, uint8_t* min, uint8_t* sec)
{
    409c:	ef 92       	push	r14
    409e:	ff 92       	push	r15
    40a0:	0f 93       	push	r16
    40a2:	1f 93       	push	r17
    40a4:	fc 01       	movw	r30, r24
    40a6:	db 01       	movw	r26, r22
    40a8:	b8 01       	movw	r22, r16
	*year 	= TM_YY + 2000;
    40aa:	80 91 31 0c 	lds	r24, 0x0C31
    40ae:	90 e0       	ldi	r25, 0x00	; 0
    40b0:	80 53       	subi	r24, 0x30	; 48
    40b2:	98 4f       	sbci	r25, 0xF8	; 248
    40b4:	91 83       	std	Z+1, r25	; 0x01
    40b6:	80 83       	st	Z, r24
	*month 	= TM_MM;
    40b8:	80 91 32 0c 	lds	r24, 0x0C32
    40bc:	8c 93       	st	X, r24
	*day 	= TM_DD;
    40be:	80 91 7b 0c 	lds	r24, 0x0C7B
    40c2:	fa 01       	movw	r30, r20
    40c4:	80 83       	st	Z, r24

	*hour	= TM_hh;
    40c6:	80 91 75 0c 	lds	r24, 0x0C75
    40ca:	f9 01       	movw	r30, r18
    40cc:	80 83       	st	Z, r24
	*min	= TM_mm;
    40ce:	80 91 74 0c 	lds	r24, 0x0C74
    40d2:	fb 01       	movw	r30, r22
    40d4:	80 83       	st	Z, r24
	*sec	= TM_ss;
    40d6:	80 91 73 0c 	lds	r24, 0x0C73
    40da:	f7 01       	movw	r30, r14
    40dc:	80 83       	st	Z, r24
}
    40de:	1f 91       	pop	r17
    40e0:	0f 91       	pop	r16
    40e2:	ff 90       	pop	r15
    40e4:	ef 90       	pop	r14
    40e6:	08 95       	ret

000040e8 <TM_SetDayOfWeek>:

/*
 *   
 */
void TM_SetDayOfWeek(void)
{
    40e8:	cf 93       	push	r28
    40ea:	df 93       	push	r29
    uint16_t day_of_year;
    uint16_t tmp_dow;

    // Day of year
    day_of_year = 31 * (TM_MM-1) + TM_DD;
    40ec:	80 91 32 0c 	lds	r24, 0x0C32
    40f0:	20 91 7b 0c 	lds	r18, 0x0C7B
    40f4:	90 e0       	ldi	r25, 0x00	; 0
    40f6:	01 97       	sbiw	r24, 0x01	; 1
    40f8:	ec 01       	movw	r28, r24
    40fa:	35 e0       	ldi	r19, 0x05	; 5
    40fc:	cc 0f       	add	r28, r28
    40fe:	dd 1f       	adc	r29, r29
    4100:	3a 95       	dec	r19
    4102:	e1 f7       	brne	.-8      	; 0x40fc <TM_SetDayOfWeek+0x14>
    4104:	c8 1b       	sub	r28, r24
    4106:	d9 0b       	sbc	r29, r25
    4108:	c2 0f       	add	r28, r18
    410a:	d1 1d       	adc	r29, r1
    
    // Monate kleiner 31 Tage abziehen
    if (TM_MM > 2) {
    410c:	80 91 32 0c 	lds	r24, 0x0C32
    4110:	83 30       	cpi	r24, 0x03	; 3
    4112:	50 f0       	brcs	.+20     	; 0x4128 <TM_SetDayOfWeek+0x40>
        if ( TM_YY % 4 ){	// bis zum nchsten Jahrhundertwechsel reicht das!
    4114:	80 91 31 0c 	lds	r24, 0x0C31
    4118:	90 e0       	ldi	r25, 0x00	; 0
    411a:	83 70       	andi	r24, 0x03	; 3
    411c:	90 70       	andi	r25, 0x00	; 0
    411e:	89 2b       	or	r24, r25
    4120:	11 f0       	breq	.+4      	; 0x4126 <TM_SetDayOfWeek+0x3e>
            day_of_year -= 3;
    4122:	23 97       	sbiw	r28, 0x03	; 3
    4124:	01 c0       	rjmp	.+2      	; 0x4128 <TM_SetDayOfWeek+0x40>
        } else {
            day_of_year -= 2;
    4126:	22 97       	sbiw	r28, 0x02	; 2
        }
    }
    if (TM_MM >  4) {day_of_year--;}       // april
    4128:	80 91 32 0c 	lds	r24, 0x0C32
    412c:	85 30       	cpi	r24, 0x05	; 5
    412e:	08 f0       	brcs	.+2      	; 0x4132 <TM_SetDayOfWeek+0x4a>
    4130:	21 97       	sbiw	r28, 0x01	; 1
    if (TM_MM >  6) {day_of_year--;}       // juni
    4132:	80 91 32 0c 	lds	r24, 0x0C32
    4136:	87 30       	cpi	r24, 0x07	; 7
    4138:	08 f0       	brcs	.+2      	; 0x413c <TM_SetDayOfWeek+0x54>
    413a:	21 97       	sbiw	r28, 0x01	; 1
    if (TM_MM >  9) {day_of_year--;}       // september
    413c:	80 91 32 0c 	lds	r24, 0x0C32
    4140:	8a 30       	cpi	r24, 0x0A	; 10
    4142:	08 f0       	brcs	.+2      	; 0x4146 <TM_SetDayOfWeek+0x5e>
    4144:	21 97       	sbiw	r28, 0x01	; 1
    if (TM_MM > 11) {day_of_year--;}       // november
    4146:	80 91 32 0c 	lds	r24, 0x0C32
    414a:	8c 30       	cpi	r24, 0x0C	; 12
    414c:	08 f0       	brcs	.+2      	; 0x4150 <TM_SetDayOfWeek+0x68>
    414e:	21 97       	sbiw	r28, 0x01	; 1

    // calc weekday
    tmp_dow = TM_YY + ((TM_YY-1) / 4) - ((TM_YY-1) / 100) + day_of_year;
    4150:	40 91 31 0c 	lds	r20, 0x0C31
    4154:	80 91 31 0c 	lds	r24, 0x0C31
    4158:	20 91 31 0c 	lds	r18, 0x0C31
    415c:	90 e0       	ldi	r25, 0x00	; 0
    415e:	01 97       	sbiw	r24, 0x01	; 1
    4160:	64 e0       	ldi	r22, 0x04	; 4
    4162:	70 e0       	ldi	r23, 0x00	; 0
    4164:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divmodhi4>
    4168:	fb 01       	movw	r30, r22
    416a:	30 e0       	ldi	r19, 0x00	; 0
    416c:	c9 01       	movw	r24, r18
    416e:	01 97       	sbiw	r24, 0x01	; 1
    4170:	6c e9       	ldi	r22, 0x9C	; 156
    4172:	7f ef       	ldi	r23, 0xFF	; 255
    4174:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divmodhi4>
    4178:	e6 0f       	add	r30, r22
    417a:	f7 1f       	adc	r31, r23
    417c:	e4 0f       	add	r30, r20
    417e:	f1 1d       	adc	r31, r1
    4180:	ec 0f       	add	r30, r28
    4182:	fd 1f       	adc	r31, r29
    if (TM_YY > 0) {
    4184:	80 91 31 0c 	lds	r24, 0x0C31
    4188:	81 11       	cpse	r24, r1
        tmp_dow++;                          // 2000 war Schaltjahr
    418a:	31 96       	adiw	r30, 0x01	; 1
    }

    // set DOW
    TM_DOW = (uint8_t) ((tmp_dow + 5) % 7);	// 31.12.1999 war Freitag (+5)
    418c:	cf 01       	movw	r24, r30
    418e:	05 96       	adiw	r24, 0x05	; 5
    4190:	67 e0       	ldi	r22, 0x07	; 7
    4192:	70 e0       	ldi	r23, 0x00	; 0
    4194:	0e 94 3b 6b 	call	0xd676	; 0xd676 <__udivmodhi4>
    4198:	80 93 30 0c 	sts	0x0C30, r24
}
    419c:	df 91       	pop	r29
    419e:	cf 91       	pop	r28
    41a0:	08 95       	ret

000041a2 <TM_SetDayofYear>:

/*
 *   
 */
void TM_SetDayofYear(uint16_t tage)
{
    41a2:	cf 93       	push	r28
    41a4:	df 93       	push	r29
    41a6:	ec 01       	movw	r28, r24
	uint8_t i;

	TIMER_DEBUG("\r\nSetDayofYear: %i Tage",tage);
	TM_MM = 1;				// Monate einzeln hochzhlen und #Tage im Monat abziehen
    41a8:	81 e0       	ldi	r24, 0x01	; 1
    41aa:	80 93 32 0c 	sts	0x0C32, r24
	i = AnzahlTageImMonat(TM_MM, TM_YY);
    41ae:	80 91 32 0c 	lds	r24, 0x0C32
    41b2:	60 91 31 0c 	lds	r22, 0x0C31
    41b6:	0e 94 35 20 	call	0x406a	; 0x406a <AnzahlTageImMonat>
    41ba:	0d c0       	rjmp	.+26     	; 0x41d6 <TM_SetDayofYear+0x34>
	TIMER_DEBUG("\r\nMonat #%i: %i Tage - Rest: %i -Start",TM_MM,i,tage);
	while ( tage > i ) {
		tage -= i;
    41bc:	c8 1b       	sub	r28, r24
    41be:	d9 0b       	sbc	r29, r25
		TM_MM += 1;
    41c0:	80 91 32 0c 	lds	r24, 0x0C32
    41c4:	8f 5f       	subi	r24, 0xFF	; 255
    41c6:	80 93 32 0c 	sts	0x0C32, r24
		i = AnzahlTageImMonat(TM_MM, TM_YY);
    41ca:	80 91 32 0c 	lds	r24, 0x0C32
    41ce:	60 91 31 0c 	lds	r22, 0x0C31
    41d2:	0e 94 35 20 	call	0x406a	; 0x406a <AnzahlTageImMonat>

	TIMER_DEBUG("\r\nSetDayofYear: %i Tage",tage);
	TM_MM = 1;				// Monate einzeln hochzhlen und #Tage im Monat abziehen
	i = AnzahlTageImMonat(TM_MM, TM_YY);
	TIMER_DEBUG("\r\nMonat #%i: %i Tage - Rest: %i -Start",TM_MM,i,tage);
	while ( tage > i ) {
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	8c 17       	cp	r24, r28
    41da:	9d 07       	cpc	r25, r29
    41dc:	78 f3       	brcs	.-34     	; 0x41bc <TM_SetDayofYear+0x1a>
		tage -= i;
		TM_MM += 1;
		i = AnzahlTageImMonat(TM_MM, TM_YY);
		TIMER_DEBUG("\r\nMonat #%i: %i Tage - Rest: %i",TM_MM,i,tage);
	}
	TM_DD = tage;
    41de:	c0 93 7b 0c 	sts	0x0C7B, r28
    TM_SetDayOfWeek();
    41e2:	0e 94 74 20 	call	0x40e8	; 0x40e8 <TM_SetDayOfWeek>
}
    41e6:	df 91       	pop	r29
    41e8:	cf 91       	pop	r28
    41ea:	08 95       	ret

000041ec <timer_init>:
 * Diese Routine startet und initialisiert den Timer
 */
void timer_init (void)
{
	// bei interner Uhr wird Timer1 verwendet
	TCCR1B |= (1<<WGM12) | (1<<CS10 | 0<<CS11 | 1<<CS12);
    41ec:	80 91 81 00 	lds	r24, 0x0081
    41f0:	8d 60       	ori	r24, 0x0D	; 13
    41f2:	80 93 81 00 	sts	0x0081, r24
	TCNT1 = 0;
    41f6:	10 92 85 00 	sts	0x0085, r1
    41fa:	10 92 84 00 	sts	0x0084, r1
	// der Compare-Interrupt wird alle 'TIMERBASE' Millisekunden ausgelst
	OCR1A = (F_CPU / 1024 / 1000 * TIMERBASE)  - 1;
    41fe:	8d e5       	ldi	r24, 0x5D	; 93
    4200:	91 e0       	ldi	r25, 0x01	; 1
    4202:	90 93 89 00 	sts	0x0089, r25
    4206:	80 93 88 00 	sts	0x0088, r24
	TIMSK |= (1 << OCIE1A);		// enable overflow interrupt
    420a:	80 91 6f 00 	lds	r24, 0x006F
    420e:	82 60       	ori	r24, 0x02	; 2
    4210:	80 93 6f 00 	sts	0x006F, r24
	machineStatus.Timer2_func = NULL;
    4214:	10 92 4b 06 	sts	0x064B, r1
    4218:	10 92 4a 06 	sts	0x064A, r1
	machineStatus.Timer3_func = NULL;
    421c:	10 92 4f 06 	sts	0x064F, r1
    4220:	10 92 4e 06 	sts	0x064E, r1
    4224:	80 e0       	ldi	r24, 0x00	; 0
    4226:	90 e0       	ldi	r25, 0x00	; 0
	
	#if USE_SCHEDULER
	for (uint8_t i=0; i<TM_MAX_SCHALTZEITEN; i++){
			TM_Schaltzeit[i].Uhrzeit = TM_SCHALTER_AUS;	 // alle ausschalten, sonst gehen sie um 00:00 Uhr an
    4228:	2f ef       	ldi	r18, 0xFF	; 255
    422a:	fc 01       	movw	r30, r24
    422c:	ee 0f       	add	r30, r30
    422e:	ff 1f       	adc	r31, r31
    4230:	ee 0f       	add	r30, r30
    4232:	ff 1f       	adc	r31, r31
    4234:	ed 5c       	subi	r30, 0xCD	; 205
    4236:	f3 4f       	sbci	r31, 0xF3	; 243
    4238:	20 83       	st	Z, r18
    423a:	01 96       	adiw	r24, 0x01	; 1
	TIMSK |= (1 << OCIE1A);		// enable overflow interrupt
	machineStatus.Timer2_func = NULL;
	machineStatus.Timer3_func = NULL;
	
	#if USE_SCHEDULER
	for (uint8_t i=0; i<TM_MAX_SCHALTZEITEN; i++){
    423c:	80 31       	cpi	r24, 0x10	; 16
    423e:	91 05       	cpc	r25, r1
    4240:	a1 f7       	brne	.-24     	; 0x422a <timer_init+0x3e>
			TM_Schaltzeit[i].Uhrzeit = TM_SCHALTER_AUS;	 // alle ausschalten, sonst gehen sie um 00:00 Uhr an
	}

	// ersten Eintrag auf Montag 0:00 Uhr mit Defaultwerten besetzen
	TM_Schaltzeit[0].Uhrzeit = 0;
    4242:	10 92 33 0c 	sts	0x0C33, r1
	TM_Schaltzeit[0].Wochentag = 0;
    4246:	10 92 34 0c 	sts	0x0C34, r1
	TM_Schaltzeit[0].Zustand.Schalter1 = 0;
    424a:	80 91 35 0c 	lds	r24, 0x0C35
    424e:	8e 7f       	andi	r24, 0xFE	; 254
    4250:	80 93 35 0c 	sts	0x0C35, r24
	TM_Schaltzeit[0].Zustand.Schalter2 = 0;
    4254:	80 91 35 0c 	lds	r24, 0x0C35
    4258:	8d 7f       	andi	r24, 0xFD	; 253
    425a:	80 93 35 0c 	sts	0x0C35, r24
	TM_Schaltzeit[0].Zustand.Schalter3 = 1;
    425e:	80 91 35 0c 	lds	r24, 0x0C35
    4262:	84 60       	ori	r24, 0x04	; 4
    4264:	80 93 35 0c 	sts	0x0C35, r24
	TM_Schaltzeit[0].Zustand.TReglerWert = 0;
    4268:	10 92 36 0c 	sts	0x0C36, r1
	#endif

    // initial time 00:00:00
    TM_hh = 0;
    426c:	10 92 75 0c 	sts	0x0C75, r1
    TM_mm = 0;
    4270:	10 92 74 0c 	sts	0x0C74, r1
    TM_ss = 0;
    4274:	10 92 73 0c 	sts	0x0C73, r1
    // initial date 1.01.2008
    TM_DD = 1;
    4278:	81 e0       	ldi	r24, 0x01	; 1
    427a:	80 93 7b 0c 	sts	0x0C7B, r24
    TM_MM = 1;
    427e:	80 93 32 0c 	sts	0x0C32, r24
    TM_YY = 8;
    4282:	88 e0       	ldi	r24, 0x08	; 8
    4284:	80 93 31 0c 	sts	0x0C31, r24
    // day of week
    TM_SetDayOfWeek();
    4288:	0e 94 74 20 	call	0x40e8	; 0x40e8 <TM_SetDayOfWeek>
	TM_DS = 0;
    428c:	10 92 76 0c 	sts	0x0C76, r1


	// Timer auf Anfangswerte
	timerT = TIME_TEMP;		// Messintervall Temperatur
    4290:	8c e3       	ldi	r24, 0x3C	; 60
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	90 93 2f 0c 	sts	0x0C2F, r25
    4298:	80 93 2e 0c 	sts	0x0C2E, r24
	return;
};
    429c:	08 95       	ret

0000429e <TM_AddOneDay>:
 *   
 */
void TM_AddOneDay(void)
{
    // How many days has actual month
    uint8_t dom = AnzahlTageImMonat(TM_MM, TM_YY);
    429e:	80 91 32 0c 	lds	r24, 0x0C32
    42a2:	60 91 31 0c 	lds	r22, 0x0C31
    42a6:	0e 94 35 20 	call	0x406a	; 0x406a <AnzahlTageImMonat>
    if (++TM_DD == (dom+1)) {                   // Next Month
    42aa:	90 91 7b 0c 	lds	r25, 0x0C7B
    42ae:	9f 5f       	subi	r25, 0xFF	; 255
    42b0:	90 93 7b 0c 	sts	0x0C7B, r25
    42b4:	20 91 7b 0c 	lds	r18, 0x0C7B
    42b8:	30 e0       	ldi	r19, 0x00	; 0
    42ba:	90 e0       	ldi	r25, 0x00	; 0
    42bc:	01 96       	adiw	r24, 0x01	; 1
    42be:	28 17       	cp	r18, r24
    42c0:	39 07       	cpc	r19, r25
    42c2:	99 f4       	brne	.+38     	; 0x42ea <TM_AddOneDay+0x4c>
		TM_DD = 1;
    42c4:	91 e0       	ldi	r25, 0x01	; 1
    42c6:	90 93 7b 0c 	sts	0x0C7B, r25
		if (++TM_MM == 13) {                    // Next year
    42ca:	80 91 32 0c 	lds	r24, 0x0C32
    42ce:	8f 5f       	subi	r24, 0xFF	; 255
    42d0:	80 93 32 0c 	sts	0x0C32, r24
    42d4:	80 91 32 0c 	lds	r24, 0x0C32
    42d8:	8d 30       	cpi	r24, 0x0D	; 13
    42da:	39 f4       	brne	.+14     	; 0x42ea <TM_AddOneDay+0x4c>
			TM_MM = 1;
    42dc:	90 93 32 0c 	sts	0x0C32, r25
			TM_YY++;
    42e0:	80 91 31 0c 	lds	r24, 0x0C31
    42e4:	8f 5f       	subi	r24, 0xFF	; 255
    42e6:	80 93 31 0c 	sts	0x0C31, r24
		}
	}

    // next day of week
    TM_DOW++;
    42ea:	80 91 30 0c 	lds	r24, 0x0C30
    42ee:	8f 5f       	subi	r24, 0xFF	; 255
    42f0:	80 93 30 0c 	sts	0x0C30, r24
    TM_DOW %= 7;
    42f4:	80 91 30 0c 	lds	r24, 0x0C30
    42f8:	67 e0       	ldi	r22, 0x07	; 7
    42fa:	0e 94 2f 6b 	call	0xd65e	; 0xd65e <__udivmodqi4>
    42fe:	90 93 30 0c 	sts	0x0C30, r25

	#if USE_LOGDATEI
	machineStatus.LogInit = true;		// neue Logdatei initialisieren - wird in Mainloop erledigt
    4302:	81 e0       	ldi	r24, 0x01	; 1
    4304:	80 93 40 06 	sts	0x0640, r24
	#endif
}
    4308:	08 95       	ret

0000430a <TM_SchaltzeitSet>:
/**
 *	\ingroup schedul
 *	setzt Schaltzeiten
 */
void TM_SchaltzeitSet(uint8_t slot, uint8_t schaltzeit, uint8_t Wochentag, SOLL_STATUS *ptrZustand)
{
    430a:	0f 93       	push	r16
    430c:	1f 93       	push	r17
    430e:	cf 93       	push	r28
    4310:	df 93       	push	r29
    4312:	d9 01       	movw	r26, r18
    TM_Schaltzeit[slot].Uhrzeit = schaltzeit;
    4314:	e8 2f       	mov	r30, r24
    4316:	f0 e0       	ldi	r31, 0x00	; 0
    4318:	23 e3       	ldi	r18, 0x33	; 51
    431a:	3c e0       	ldi	r19, 0x0C	; 12
    431c:	ee 0f       	add	r30, r30
    431e:	ff 1f       	adc	r31, r31
    4320:	ee 0f       	add	r30, r30
    4322:	ff 1f       	adc	r31, r31
    4324:	89 01       	movw	r16, r18
    4326:	0e 0f       	add	r16, r30
    4328:	1f 1f       	adc	r17, r31
    432a:	e8 01       	movw	r28, r16
    432c:	68 83       	st	Y, r22
    TM_Schaltzeit[slot].Wochentag = Wochentag;
    432e:	49 83       	std	Y+1, r20	; 0x01
    TM_Schaltzeit[slot].Zustand.Schalter1 = ptrZustand->Schalter1;
    4330:	9c 91       	ld	r25, X
    4332:	91 70       	andi	r25, 0x01	; 1
    4334:	32 96       	adiw	r30, 0x02	; 2
    4336:	e2 0f       	add	r30, r18
    4338:	f3 1f       	adc	r31, r19
    433a:	80 81       	ld	r24, Z
    433c:	8e 7f       	andi	r24, 0xFE	; 254
    433e:	89 2b       	or	r24, r25
    4340:	80 83       	st	Z, r24
    TM_Schaltzeit[slot].Zustand.Schalter2 = ptrZustand->Schalter2;
    4342:	9c 91       	ld	r25, X
    4344:	92 70       	andi	r25, 0x02	; 2
    4346:	80 81       	ld	r24, Z
    4348:	8d 7f       	andi	r24, 0xFD	; 253
    434a:	89 2b       	or	r24, r25
    434c:	80 83       	st	Z, r24
    TM_Schaltzeit[slot].Zustand.Schalter3 = ptrZustand->Schalter3;
    434e:	9c 91       	ld	r25, X
    4350:	94 70       	andi	r25, 0x04	; 4
    4352:	80 81       	ld	r24, Z
    4354:	8b 7f       	andi	r24, 0xFB	; 251
    4356:	89 2b       	or	r24, r25
    4358:	80 83       	st	Z, r24
    TM_Schaltzeit[slot].Zustand.TReglerWert = ptrZustand->TReglerWert;
    435a:	11 96       	adiw	r26, 0x01	; 1
    435c:	8c 91       	ld	r24, X
    435e:	8b 83       	std	Y+3, r24	; 0x03
}
    4360:	df 91       	pop	r29
    4362:	cf 91       	pop	r28
    4364:	1f 91       	pop	r17
    4366:	0f 91       	pop	r16
    4368:	08 95       	ret

0000436a <TM_ZustandGet>:
/**
 *	\ingroup schedul
 *	gibt den zur vorgegebenen Zeit gltigen Sollzustand des Systems zurck
 */
bool TM_ZustandGet(uint8_t acttime, uint8_t actdow, SOLL_STATUS *ptrZustand)
{
    436a:	cf 92       	push	r12
    436c:	df 92       	push	r13
    436e:	ef 92       	push	r14
    4370:	ff 92       	push	r15
    4372:	0f 93       	push	r16
    4374:	1f 93       	push	r17
    4376:	cf 93       	push	r28
    4378:	df 93       	push	r29
    437a:	ea 01       	movw	r28, r20
    uint8_t i,j;
    uint8_t index = 0;
    uint16_t maxtime = 0;

	uint16_t actTageswert = actdow * 256 + acttime;	// gesuchter Wochentag + Uhrzeit + offset zur Wochentags unterscheidung
    437c:	36 2f       	mov	r19, r22
    437e:	20 e0       	ldi	r18, 0x00	; 0
    4380:	79 01       	movw	r14, r18
    4382:	e8 0e       	add	r14, r24
    4384:	f1 1c       	adc	r15, r1
    4386:	dd 24       	eor	r13, r13
    4388:	00 e0       	ldi	r16, 0x00	; 0
    438a:	10 e0       	ldi	r17, 0x00	; 0
    438c:	60 e0       	ldi	r22, 0x00	; 0
    438e:	70 e0       	ldi	r23, 0x00	; 0
    4390:	c6 2e       	mov	r12, r22
	TIMER_DEBUG("\r\nTM-Debug GetZustand: Tageswert %i",actTageswert);

    // each timer
    for (i=0; i<TM_MAX_SCHALTZEITEN; i++){
        // check if timer > maxtime and timer < actual time
        if ((TM_Schaltzeit[i].Uhrzeit != TM_SCHALTER_AUS) ) {
    4392:	db 01       	movw	r26, r22
    4394:	aa 0f       	add	r26, r26
    4396:	bb 1f       	adc	r27, r27
    4398:	aa 0f       	add	r26, r26
    439a:	bb 1f       	adc	r27, r27
    439c:	ad 5c       	subi	r26, 0xCD	; 205
    439e:	b3 4f       	sbci	r27, 0xF3	; 243
    43a0:	8c 91       	ld	r24, X
    43a2:	8f 3f       	cpi	r24, 0xFF	; 255
    43a4:	01 f1       	breq	.+64     	; 0x43e6 <TM_ZustandGet+0x7c>
    43a6:	40 e0       	ldi	r20, 0x00	; 0
    43a8:	50 e0       	ldi	r21, 0x00	; 0
			for (j=0; j<7; ++j) {										// alle codierten Wochentage durchsuchen
				if (TM_Schaltzeit[i].Wochentag & (1<<j)) {				// falls Wochentag geschaltet wird
    43aa:	fd 01       	movw	r30, r26
    43ac:	31 96       	adiw	r30, 0x01	; 1
    43ae:	80 81       	ld	r24, Z
    43b0:	90 e0       	ldi	r25, 0x00	; 0
    43b2:	04 2e       	mov	r0, r20
    43b4:	02 c0       	rjmp	.+4      	; 0x43ba <TM_ZustandGet+0x50>
    43b6:	95 95       	asr	r25
    43b8:	87 95       	ror	r24
    43ba:	0a 94       	dec	r0
    43bc:	e2 f7       	brpl	.-8      	; 0x43b6 <TM_ZustandGet+0x4c>
    43be:	80 ff       	sbrs	r24, 0
    43c0:	0d c0       	rjmp	.+26     	; 0x43dc <TM_ZustandGet+0x72>
					tstTageswert = TM_Schaltzeit[i].Uhrzeit + 256 * j;
    43c2:	8c 91       	ld	r24, X
    43c4:	34 2f       	mov	r19, r20
    43c6:	22 27       	eor	r18, r18
    43c8:	28 0f       	add	r18, r24
    43ca:	31 1d       	adc	r19, r1

					TIMER_DEBUG("\r\nTM-Debug GetZustand: Testwert %i",tstTageswert);

					if ( (tstTageswert <= actTageswert)
    43cc:	e2 16       	cp	r14, r18
    43ce:	f3 06       	cpc	r15, r19
    43d0:	28 f0       	brcs	.+10     	; 0x43dc <TM_ZustandGet+0x72>
    43d2:	02 17       	cp	r16, r18
    43d4:	13 07       	cpc	r17, r19
    43d6:	10 f4       	brcc	.+4      	; 0x43dc <TM_ZustandGet+0x72>
    43d8:	dc 2c       	mov	r13, r12
    43da:	89 01       	movw	r16, r18
    43dc:	4f 5f       	subi	r20, 0xFF	; 255
    43de:	5f 4f       	sbci	r21, 0xFF	; 255

    // each timer
    for (i=0; i<TM_MAX_SCHALTZEITEN; i++){
        // check if timer > maxtime and timer < actual time
        if ((TM_Schaltzeit[i].Uhrzeit != TM_SCHALTER_AUS) ) {
			for (j=0; j<7; ++j) {										// alle codierten Wochentage durchsuchen
    43e0:	47 30       	cpi	r20, 0x07	; 7
    43e2:	51 05       	cpc	r21, r1
    43e4:	21 f7       	brne	.-56     	; 0x43ae <TM_ZustandGet+0x44>
    43e6:	6f 5f       	subi	r22, 0xFF	; 255
    43e8:	7f 4f       	sbci	r23, 0xFF	; 255
	uint16_t actTageswert = actdow * 256 + acttime;	// gesuchter Wochentag + Uhrzeit + offset zur Wochentags unterscheidung
	uint16_t tstTageswert;
	TIMER_DEBUG("\r\nTM-Debug GetZustand: Tageswert %i",actTageswert);

    // each timer
    for (i=0; i<TM_MAX_SCHALTZEITEN; i++){
    43ea:	60 31       	cpi	r22, 0x10	; 16
    43ec:	71 05       	cpc	r23, r1
    43ee:	81 f6       	brne	.-96     	; 0x4390 <TM_ZustandGet+0x26>
				}
			}
        }
    }

    ptrZustand->Schalter1 = TM_Schaltzeit[index].Zustand.Schalter1;
    43f0:	ed 2d       	mov	r30, r13
    43f2:	f0 e0       	ldi	r31, 0x00	; 0
    43f4:	ee 0f       	add	r30, r30
    43f6:	ff 1f       	adc	r31, r31
    43f8:	ee 0f       	add	r30, r30
    43fa:	ff 1f       	adc	r31, r31
    43fc:	df 01       	movw	r26, r30
    43fe:	ab 5c       	subi	r26, 0xCB	; 203
    4400:	b3 4f       	sbci	r27, 0xF3	; 243
    4402:	9c 91       	ld	r25, X
    4404:	91 70       	andi	r25, 0x01	; 1
    4406:	88 81       	ld	r24, Y
    4408:	8e 7f       	andi	r24, 0xFE	; 254
    440a:	89 2b       	or	r24, r25
    440c:	88 83       	st	Y, r24
    ptrZustand->Schalter2 = TM_Schaltzeit[index].Zustand.Schalter2;
    440e:	9c 91       	ld	r25, X
    4410:	92 70       	andi	r25, 0x02	; 2
    4412:	88 81       	ld	r24, Y
    4414:	8d 7f       	andi	r24, 0xFD	; 253
    4416:	89 2b       	or	r24, r25
    4418:	88 83       	st	Y, r24
    ptrZustand->Schalter3 = TM_Schaltzeit[index].Zustand.Schalter3;
    441a:	9c 91       	ld	r25, X
    441c:	94 70       	andi	r25, 0x04	; 4
    441e:	88 81       	ld	r24, Y
    4420:	8b 7f       	andi	r24, 0xFB	; 251
    4422:	89 2b       	or	r24, r25
    4424:	88 83       	st	Y, r24
    ptrZustand->TReglerWert = TM_Schaltzeit[index].Zustand.TReglerWert;
    4426:	ed 5c       	subi	r30, 0xCD	; 205
    4428:	f3 4f       	sbci	r31, 0xF3	; 243
    442a:	83 81       	ldd	r24, Z+3	; 0x03
    442c:	89 83       	std	Y+1, r24	; 0x01
    return true;
}
    442e:	81 e0       	ldi	r24, 0x01	; 1
    4430:	df 91       	pop	r29
    4432:	cf 91       	pop	r28
    4434:	1f 91       	pop	r17
    4436:	0f 91       	pop	r16
    4438:	ff 90       	pop	r15
    443a:	ef 90       	pop	r14
    443c:	df 90       	pop	r13
    443e:	cf 90       	pop	r12
    4440:	08 95       	ret

00004442 <TM_SollzustandGetAktuell>:
 *	\ingroup schedul
 *	gibt den aktuell gltigen Sollzustand des Systems zurck
 *
 */
bool TM_SollzustandGetAktuell(SOLL_STATUS *ptrZustand)
{
    4442:	ac 01       	movw	r20, r24
    uint8_t acttime = (TM_hh*10)+(TM_mm/10);
    4444:	20 91 75 0c 	lds	r18, 0x0C75
    4448:	80 91 74 0c 	lds	r24, 0x0C74

	TIMER_DEBUG("\r\nTM-Debug GetsollZustand: Zeit %i  Tag %i",acttime, TM_DOW);
	return TM_ZustandGet(acttime, TM_DOW, ptrZustand);
    444c:	e0 91 30 0c 	lds	r30, 0x0C30
    4450:	9a e0       	ldi	r25, 0x0A	; 10
    4452:	29 9f       	mul	r18, r25
    4454:	90 01       	movw	r18, r0
    4456:	11 24       	eor	r1, r1
    4458:	6a e0       	ldi	r22, 0x0A	; 10
    445a:	0e 94 2f 6b 	call	0xd65e	; 0xd65e <__udivmodqi4>
    445e:	82 0f       	add	r24, r18
    4460:	6e 2f       	mov	r22, r30
    4462:	0e 94 b5 21 	call	0x436a	; 0x436a <TM_ZustandGet>
}
    4466:	08 95       	ret

00004468 <__vector_13>:
 * gesetzt. Dadurch eignet sich Timer3 fr Verzgerungszeiten, die zu lange sind um eine
 * Warteroutine (delay_ms) zu nutzen. Bei nderungen an TIMERBASE ist darauf zu achten, dass
 * OCR1A etc. mit sinnvollen Werten geladen werden.
 */
ISR (TIMER1_COMPA_vect)
{
    4468:	1f 92       	push	r1
    446a:	0f 92       	push	r0
    446c:	0f b6       	in	r0, 0x3f	; 63
    446e:	0f 92       	push	r0
    4470:	11 24       	eor	r1, r1
    4472:	8f 93       	push	r24
    4474:	9f 93       	push	r25
    4476:	af 93       	push	r26
    4478:	bf 93       	push	r27
	if ( tmcount-- == 0 ) {
    447a:	80 91 26 01 	lds	r24, 0x0126
    447e:	90 91 27 01 	lds	r25, 0x0127
    4482:	01 97       	sbiw	r24, 0x01	; 1
    4484:	90 93 27 01 	sts	0x0127, r25
    4488:	80 93 26 01 	sts	0x0126, r24
    448c:	01 96       	adiw	r24, 0x01	; 1
    448e:	f1 f4       	brne	.+60     	; 0x44cc <__vector_13+0x64>

		// eine Sekunde ist vergangen - Zhler neu setzen
		tmcount = (1000/TIMERBASE);
    4490:	88 e2       	ldi	r24, 0x28	; 40
    4492:	90 e0       	ldi	r25, 0x00	; 0
    4494:	90 93 27 01 	sts	0x0127, r25
    4498:	80 93 26 01 	sts	0x0126, r24

		// Sekunde hochzhlen
		++time;
    449c:	80 91 77 0c 	lds	r24, 0x0C77
    44a0:	90 91 78 0c 	lds	r25, 0x0C78
    44a4:	a0 91 79 0c 	lds	r26, 0x0C79
    44a8:	b0 91 7a 0c 	lds	r27, 0x0C7A
    44ac:	01 96       	adiw	r24, 0x01	; 1
    44ae:	a1 1d       	adc	r26, r1
    44b0:	b1 1d       	adc	r27, r1
    44b2:	80 93 77 0c 	sts	0x0C77, r24
    44b6:	90 93 78 0c 	sts	0x0C78, r25
    44ba:	a0 93 79 0c 	sts	0x0C79, r26
    44be:	b0 93 7a 0c 	sts	0x0C7A, r27
		machineStatus.timeChanged++;
    44c2:	80 91 3c 06 	lds	r24, 0x063C
    44c6:	8f 5f       	subi	r24, 0xFF	; 255
    44c8:	80 93 3c 06 	sts	0x063C, r24

	}

	// Timer3 im TIMERBASE-Takt runterzhlen
	if (machineStatus.Timer3) {
    44cc:	80 91 4c 06 	lds	r24, 0x064C
    44d0:	88 23       	and	r24, r24
    44d2:	61 f0       	breq	.+24     	; 0x44ec <__vector_13+0x84>
			machineStatus.Timer3--;
    44d4:	80 91 4c 06 	lds	r24, 0x064C
    44d8:	81 50       	subi	r24, 0x01	; 1
    44da:	80 93 4c 06 	sts	0x064C, r24
			if (!machineStatus.Timer3) {	// Zero?
    44de:	80 91 4c 06 	lds	r24, 0x064C
    44e2:	88 23       	and	r24, r24
    44e4:	19 f4       	brne	.+6      	; 0x44ec <__vector_13+0x84>
				machineStatus.Time3Elapsed = true;
    44e6:	81 e0       	ldi	r24, 0x01	; 1
    44e8:	80 93 4d 06 	sts	0x064D, r24
			}
		}

}
    44ec:	bf 91       	pop	r27
    44ee:	af 91       	pop	r26
    44f0:	9f 91       	pop	r25
    44f2:	8f 91       	pop	r24
    44f4:	0f 90       	pop	r0
    44f6:	0f be       	out	0x3f, r0	; 63
    44f8:	0f 90       	pop	r0
    44fa:	1f 90       	pop	r1
    44fc:	18 95       	reti

000044fe <TM_AddOneSecond>:
 *  TM_AddOneSecond zhlt die aktuelle Zeit weiter
 *	und entscheidet auf weiter durchzufhrende Aktionen
 */
void TM_AddOneSecond(void)
{
	if (++TM_ss == 60) {
    44fe:	80 91 73 0c 	lds	r24, 0x0C73
    4502:	8f 5f       	subi	r24, 0xFF	; 255
    4504:	80 93 73 0c 	sts	0x0C73, r24
    4508:	80 91 73 0c 	lds	r24, 0x0C73
    450c:	8c 33       	cpi	r24, 0x3C	; 60
    450e:	09 f0       	breq	.+2      	; 0x4512 <TM_AddOneSecond+0x14>
    4510:	56 c0       	rjmp	.+172    	; 0x45be <TM_AddOneSecond+0xc0>
		TM_ss = 0;
    4512:	10 92 73 0c 	sts	0x0C73, r1
		if (++TM_mm == 60) {
    4516:	80 91 74 0c 	lds	r24, 0x0C74
    451a:	8f 5f       	subi	r24, 0xFF	; 255
    451c:	80 93 74 0c 	sts	0x0C74, r24
    4520:	80 91 74 0c 	lds	r24, 0x0C74
    4524:	8c 33       	cpi	r24, 0x3C	; 60
    4526:	09 f0       	breq	.+2      	; 0x452a <TM_AddOneSecond+0x2c>
    4528:	40 c0       	rjmp	.+128    	; 0x45aa <TM_AddOneSecond+0xac>
			TM_mm = 0;
    452a:	10 92 74 0c 	sts	0x0C74, r1
			// add one hour
			if (++TM_hh == 24) {
    452e:	80 91 75 0c 	lds	r24, 0x0C75
    4532:	8f 5f       	subi	r24, 0xFF	; 255
    4534:	80 93 75 0c 	sts	0x0C75, r24
    4538:	80 91 75 0c 	lds	r24, 0x0C75
    453c:	88 31       	cpi	r24, 0x18	; 24
    453e:	21 f4       	brne	.+8      	; 0x4548 <TM_AddOneSecond+0x4a>
				TM_hh = 0;
    4540:	10 92 75 0c 	sts	0x0C75, r1
				TM_AddOneDay();
    4544:	0e 94 4f 21 	call	0x429e	; 0x429e <TM_AddOneDay>
			}

			// Start der Sommerzeit: Mrz, 2:00:00 ?
			if ((TM_MM==3) && (TM_DOW==0) && (TM_hh==2)) {
    4548:	80 91 32 0c 	lds	r24, 0x0C32
    454c:	83 30       	cpi	r24, 0x03	; 3
    454e:	89 f4       	brne	.+34     	; 0x4572 <TM_AddOneSecond+0x74>
    4550:	80 91 30 0c 	lds	r24, 0x0C30
    4554:	88 23       	and	r24, r24
    4556:	69 f4       	brne	.+26     	; 0x4572 <TM_AddOneSecond+0x74>
    4558:	80 91 75 0c 	lds	r24, 0x0C75
    455c:	82 30       	cpi	r24, 0x02	; 2
    455e:	49 f4       	brne	.+18     	; 0x4572 <TM_AddOneSecond+0x74>
                if (TM_DD >= 25 ){		// letzte 7 Tage im Monat ?
    4560:	80 91 7b 0c 	lds	r24, 0x0C7B
    4564:	89 31       	cpi	r24, 0x19	; 25
    4566:	28 f0       	brcs	.+10     	; 0x4572 <TM_AddOneSecond+0x74>
                    TM_hh++; 			// 2:00 -> 3:00
    4568:	80 91 75 0c 	lds	r24, 0x0C75
    456c:	8f 5f       	subi	r24, 0xFF	; 255
    456e:	80 93 75 0c 	sts	0x0C75, r24
                }
            }
			// Ende der Sommerzeit: Oktober, 03:00
			if ((TM_MM==10)  && (TM_DOW==0) && (TM_hh==3) && (TM_DS==0)){
    4572:	80 91 32 0c 	lds	r24, 0x0C32
    4576:	8a 30       	cpi	r24, 0x0A	; 10
    4578:	c1 f4       	brne	.+48     	; 0x45aa <TM_AddOneSecond+0xac>
    457a:	80 91 30 0c 	lds	r24, 0x0C30
    457e:	88 23       	and	r24, r24
    4580:	a1 f4       	brne	.+40     	; 0x45aa <TM_AddOneSecond+0xac>
    4582:	80 91 75 0c 	lds	r24, 0x0C75
    4586:	83 30       	cpi	r24, 0x03	; 3
    4588:	81 f4       	brne	.+32     	; 0x45aa <TM_AddOneSecond+0xac>
    458a:	80 91 76 0c 	lds	r24, 0x0C76
    458e:	88 23       	and	r24, r24
    4590:	61 f4       	brne	.+24     	; 0x45aa <TM_AddOneSecond+0xac>
                if (TM_DD >= 25){		// letzte 7 Tage im Monat ?
    4592:	80 91 7b 0c 	lds	r24, 0x0C7B
    4596:	89 31       	cpi	r24, 0x19	; 25
    4598:	40 f0       	brcs	.+16     	; 0x45aa <TM_AddOneSecond+0xac>
                    TM_hh--; 			// 3:00 -> 2:00
    459a:	80 91 75 0c 	lds	r24, 0x0C75
    459e:	81 50       	subi	r24, 0x01	; 1
    45a0:	80 93 75 0c 	sts	0x0C75, r24
                    TM_DS=1;			// Marker, dass schon umgestellt ist
    45a4:	81 e0       	ldi	r24, 0x01	; 1
    45a6:	80 93 76 0c 	sts	0x0C76, r24
			}
        }

		#if USE_SCHEDULER
        // Timer check every 10 minutes
        if ((TM_mm % 10) == 0){
    45aa:	80 91 74 0c 	lds	r24, 0x0C74
    45ae:	6a e0       	ldi	r22, 0x0A	; 10
    45b0:	0e 94 2f 6b 	call	0xd65e	; 0xd65e <__udivmodqi4>
    45b4:	99 23       	and	r25, r25
    45b6:	19 f4       	brne	.+6      	; 0x45be <TM_AddOneSecond+0xc0>
			machineStatus.regeln = 1;
    45b8:	81 e0       	ldi	r24, 0x01	; 1
    45ba:	80 93 3f 06 	sts	0x063F, r24
        }
		#endif
 	}

	if (--timerT == 0) {		// Temperaturen messen
    45be:	80 91 2e 0c 	lds	r24, 0x0C2E
    45c2:	90 91 2f 0c 	lds	r25, 0x0C2F
    45c6:	01 97       	sbiw	r24, 0x01	; 1
    45c8:	90 93 2f 0c 	sts	0x0C2F, r25
    45cc:	80 93 2e 0c 	sts	0x0C2E, r24
    45d0:	80 91 2e 0c 	lds	r24, 0x0C2E
    45d4:	90 91 2f 0c 	lds	r25, 0x0C2F
    45d8:	89 2b       	or	r24, r25
    45da:	49 f4       	brne	.+18     	; 0x45ee <TM_AddOneSecond+0xf0>
		machineStatus.Tlesen = 1;
    45dc:	81 e0       	ldi	r24, 0x01	; 1
    45de:	80 93 3e 06 	sts	0x063E, r24
		timerT = TIME_TEMP;
    45e2:	8c e3       	ldi	r24, 0x3C	; 60
    45e4:	90 e0       	ldi	r25, 0x00	; 0
    45e6:	90 93 2f 0c 	sts	0x0C2F, r25
    45ea:	80 93 2e 0c 	sts	0x0C2E, r24
	}


    if((time_watchdog++) > WTT)
    45ee:	80 91 0d 02 	lds	r24, 0x020D
    45f2:	90 91 0e 02 	lds	r25, 0x020E
    45f6:	a0 91 0f 02 	lds	r26, 0x020F
    45fa:	b0 91 10 02 	lds	r27, 0x0210
    45fe:	01 96       	adiw	r24, 0x01	; 1
    4600:	a1 1d       	adc	r26, r1
    4602:	b1 1d       	adc	r27, r1
    4604:	80 93 0d 02 	sts	0x020D, r24
    4608:	90 93 0e 02 	sts	0x020E, r25
    460c:	a0 93 0f 02 	sts	0x020F, r26
    4610:	b0 93 10 02 	sts	0x0210, r27
    4614:	01 97       	sbiw	r24, 0x01	; 1
    4616:	a1 09       	sbc	r26, r1
    4618:	b1 09       	sbc	r27, r1
    461a:	81 5b       	subi	r24, 0xB1	; 177
    461c:	94 40       	sbci	r25, 0x04	; 4
    461e:	a0 40       	sbci	r26, 0x00	; 0
    4620:	b0 40       	sbci	r27, 0x00	; 0
    4622:	50 f0       	brcs	.+20     	; 0x4638 <TM_AddOneSecond+0x13a>
        {
        time_watchdog = 0;
    4624:	10 92 0d 02 	sts	0x020D, r1
    4628:	10 92 0e 02 	sts	0x020E, r1
    462c:	10 92 0f 02 	sts	0x020F, r1
    4630:	10 92 10 02 	sts	0x0210, r1
        stack_init();
    4634:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <stack_init>
        }

	#if USE_NTP
	ntp_timer--;
    4638:	80 91 4a 0b 	lds	r24, 0x0B4A
    463c:	90 91 4b 0b 	lds	r25, 0x0B4B
    4640:	01 97       	sbiw	r24, 0x01	; 1
    4642:	90 93 4b 0b 	sts	0x0B4B, r25
    4646:	80 93 4a 0b 	sts	0x0B4A, r24
	#endif //USE_NTP

}
    464a:	08 95       	ret

0000464c <GetUSdate>:
/**
 *	\ingroup time
 *   GetUSdate gibt Datum kompatibel mit Internet Datumsangabe zurck
 */
char *GetUSdate(char *datestring)
{
    464c:	ef 92       	push	r14
    464e:	ff 92       	push	r15
    4650:	0f 93       	push	r16
    4652:	1f 93       	push	r17
    4654:	df 93       	push	r29
    4656:	cf 93       	push	r28
    4658:	00 d0       	rcall	.+0      	; 0x465a <GetUSdate+0xe>
    465a:	00 d0       	rcall	.+0      	; 0x465c <GetUSdate+0x10>
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
    4660:	f8 2e       	mov	r15, r24
    4662:	e9 2e       	mov	r14, r25
	char month[4];
	strncpy_P(month,&US_Monate[(TM_MM-1)*3],3);
    4664:	80 91 32 0c 	lds	r24, 0x0C32
    4668:	90 e0       	ldi	r25, 0x00	; 0
    466a:	01 97       	sbiw	r24, 0x01	; 1
    466c:	bc 01       	movw	r22, r24
    466e:	66 0f       	add	r22, r22
    4670:	77 1f       	adc	r23, r23
    4672:	68 0f       	add	r22, r24
    4674:	79 1f       	adc	r23, r25
    4676:	6b 5e       	subi	r22, 0xEB	; 235
    4678:	7e 4f       	sbci	r23, 0xFE	; 254
    467a:	8e 01       	movw	r16, r28
    467c:	0f 5f       	subi	r16, 0xFF	; 255
    467e:	1f 4f       	sbci	r17, 0xFF	; 255
    4680:	c8 01       	movw	r24, r16
    4682:	43 e0       	ldi	r20, 0x03	; 3
    4684:	50 e0       	ldi	r21, 0x00	; 0
    4686:	0e 94 15 6e 	call	0xdc2a	; 0xdc2a <strncpy_P>
	month[3] = '\0';
    468a:	1c 82       	std	Y+4, r1	; 0x04
	sprintf_P(datestring,PSTR("%2d %s %4d"),TM_DD,month,GetYearYYYY());
    468c:	40 91 7b 0c 	lds	r20, 0x0C7B
 *	\ingroup time
 *   GetYearYYYY
 */
uint16_t GetYearYYYY(void)
{
    return 2000 + (uint16_t) TM_YY;
    4690:	20 91 31 0c 	lds	r18, 0x0C31
char *GetUSdate(char *datestring)
{
	char month[4];
	strncpy_P(month,&US_Monate[(TM_MM-1)*3],3);
	month[3] = '\0';
	sprintf_P(datestring,PSTR("%2d %s %4d"),TM_DD,month,GetYearYYYY());
    4694:	8d b7       	in	r24, 0x3d	; 61
    4696:	9e b7       	in	r25, 0x3e	; 62
    4698:	0a 97       	sbiw	r24, 0x0a	; 10
    469a:	0f b6       	in	r0, 0x3f	; 63
    469c:	f8 94       	cli
    469e:	9e bf       	out	0x3e, r25	; 62
    46a0:	0f be       	out	0x3f, r0	; 63
    46a2:	8d bf       	out	0x3d, r24	; 61
    46a4:	ed b7       	in	r30, 0x3d	; 61
    46a6:	fe b7       	in	r31, 0x3e	; 62
    46a8:	31 96       	adiw	r30, 0x01	; 1
    46aa:	ad b7       	in	r26, 0x3d	; 61
    46ac:	be b7       	in	r27, 0x3e	; 62
    46ae:	11 96       	adiw	r26, 0x01	; 1
    46b0:	fc 92       	st	X, r15
    46b2:	e1 82       	std	Z+1, r14	; 0x01
    46b4:	8a e3       	ldi	r24, 0x3A	; 58
    46b6:	91 e0       	ldi	r25, 0x01	; 1
    46b8:	93 83       	std	Z+3, r25	; 0x03
    46ba:	82 83       	std	Z+2, r24	; 0x02
    46bc:	44 83       	std	Z+4, r20	; 0x04
    46be:	15 82       	std	Z+5, r1	; 0x05
    46c0:	17 83       	std	Z+7, r17	; 0x07
    46c2:	06 83       	std	Z+6, r16	; 0x06
    46c4:	30 e0       	ldi	r19, 0x00	; 0
    46c6:	20 53       	subi	r18, 0x30	; 48
    46c8:	38 4f       	sbci	r19, 0xF8	; 248
    46ca:	31 87       	std	Z+9, r19	; 0x09
    46cc:	20 87       	std	Z+8, r18	; 0x08
    46ce:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
    46d2:	8d b7       	in	r24, 0x3d	; 61
    46d4:	9e b7       	in	r25, 0x3e	; 62
    46d6:	0a 96       	adiw	r24, 0x0a	; 10
    46d8:	0f b6       	in	r0, 0x3f	; 63
    46da:	f8 94       	cli
    46dc:	9e bf       	out	0x3e, r25	; 62
    46de:	0f be       	out	0x3f, r0	; 63
    46e0:	8d bf       	out	0x3d, r24	; 61
	return datestring;
}
    46e2:	8f 2d       	mov	r24, r15
    46e4:	9e 2d       	mov	r25, r14
    46e6:	0f 90       	pop	r0
    46e8:	0f 90       	pop	r0
    46ea:	0f 90       	pop	r0
    46ec:	0f 90       	pop	r0
    46ee:	cf 91       	pop	r28
    46f0:	df 91       	pop	r29
    46f2:	1f 91       	pop	r17
    46f4:	0f 91       	pop	r16
    46f6:	ff 90       	pop	r15
    46f8:	ef 90       	pop	r14
    46fa:	08 95       	ret

000046fc <decode_base64>:
/**
 *	\ingroup allgfunktionen
 * erzeugt Base64 codierten String
 */
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
    46fc:	cf 93       	push	r28
    46fe:	df 93       	push	r29
    4700:	ec 01       	movw	r28, r24
    4702:	db 01       	movw	r26, r22
    4704:	34 c0       	rjmp	.+104    	; 0x476e <decode_base64+0x72>
	
	strp = str2_out;
	
	while (*str1_in != 0)
	{
		*str2_out++= (*str1_in & 0xFC)>>2;
    4706:	86 95       	lsr	r24
    4708:	86 95       	lsr	r24
    470a:	fd 01       	movw	r30, r26
    470c:	81 93       	st	Z+, r24
		
		*str2_out = (((*str1_in++)&0x03)<<4); 
    470e:	88 81       	ld	r24, Y
    4710:	83 70       	andi	r24, 0x03	; 3
    4712:	82 95       	swap	r24
    4714:	80 7f       	andi	r24, 0xF0	; 240
    4716:	11 96       	adiw	r26, 0x01	; 1
    4718:	8c 93       	st	X, r24
    471a:	11 97       	sbiw	r26, 0x01	; 1
		if (*str1_in==0)
    471c:	99 81       	ldd	r25, Y+1	; 0x01
    471e:	99 23       	and	r25, r25
    4720:	21 f4       	brne	.+8      	; 0x472a <decode_base64+0x2e>
		{
			str2_out++;
    4722:	df 01       	movw	r26, r30
    4724:	11 96       	adiw	r26, 0x01	; 1
    4726:	42 e0       	ldi	r20, 0x02	; 2
    4728:	26 c0       	rjmp	.+76     	; 0x4776 <decode_base64+0x7a>
            end_byte = 2;
			break;
		}
		else
		{
			*str2_out++ += ((*str1_in & 0xF0)>>4);
    472a:	92 95       	swap	r25
    472c:	9f 70       	andi	r25, 0x0F	; 15
    472e:	89 0f       	add	r24, r25
    4730:	11 96       	adiw	r26, 0x01	; 1
    4732:	8c 93       	st	X, r24
    4734:	11 97       	sbiw	r26, 0x01	; 1
			*str2_out = (((*str1_in++)& 0x0F)<<2);
    4736:	89 81       	ldd	r24, Y+1	; 0x01
    4738:	8f 70       	andi	r24, 0x0F	; 15
    473a:	88 0f       	add	r24, r24
    473c:	88 0f       	add	r24, r24
    473e:	12 96       	adiw	r26, 0x02	; 2
    4740:	8c 93       	st	X, r24
    4742:	12 97       	sbiw	r26, 0x02	; 2
			if (*str1_in==0)
    4744:	9a 81       	ldd	r25, Y+2	; 0x02
    4746:	99 23       	and	r25, r25
    4748:	19 f4       	brne	.+6      	; 0x4750 <decode_base64+0x54>
			{
				str2_out++;
    474a:	13 96       	adiw	r26, 0x03	; 3
    474c:	41 e0       	ldi	r20, 0x01	; 1
    474e:	13 c0       	rjmp	.+38     	; 0x4776 <decode_base64+0x7a>
                end_byte = 1;
                break;
			}
			else
			{
				*str2_out++	+= ((*str1_in & 0xC0)>>6);
    4750:	92 95       	swap	r25
    4752:	96 95       	lsr	r25
    4754:	96 95       	lsr	r25
    4756:	93 70       	andi	r25, 0x03	; 3
    4758:	89 0f       	add	r24, r25
    475a:	12 96       	adiw	r26, 0x02	; 2
    475c:	8c 93       	st	X, r24
    475e:	12 97       	sbiw	r26, 0x02	; 2
				*str2_out++= *str1_in++ & 0x3F;
    4760:	8a 81       	ldd	r24, Y+2	; 0x02
    4762:	8f 73       	andi	r24, 0x3F	; 63
    4764:	13 96       	adiw	r26, 0x03	; 3
    4766:	8c 93       	st	X, r24
    4768:	13 97       	sbiw	r26, 0x03	; 3
/**
 *	\ingroup allgfunktionen
 * erzeugt Base64 codierten String
 */
void decode_base64 (unsigned char *str1_in,unsigned char *str2_out)
{
    476a:	14 96       	adiw	r26, 0x04	; 4
    476c:	23 96       	adiw	r28, 0x03	; 3
	unsigned char *strp;
    unsigned char end_byte = 0;
	
	strp = str2_out;
	
	while (*str1_in != 0)
    476e:	88 81       	ld	r24, Y
    4770:	88 23       	and	r24, r24
    4772:	49 f6       	brne	.-110    	; 0x4706 <decode_base64+0xa>
    4774:	40 e0       	ldi	r20, 0x00	; 0
				*str2_out++	+= ((*str1_in & 0xC0)>>6);
				*str2_out++= *str1_in++ & 0x3F;
			}
		}
	}
	*str2_out = 0;
    4776:	1c 92       	st	X, r1
    4778:	eb 01       	movw	r28, r22
    477a:	08 c0       	rjmp	.+16     	; 0x478c <decode_base64+0x90>
    
	while(strp != str2_out)
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
    477c:	e8 81       	ld	r30, Y
    477e:	f0 e0       	ldi	r31, 0x00	; 0
    4780:	ef 73       	andi	r30, 0x3F	; 63
    4782:	f0 70       	andi	r31, 0x00	; 0
    4784:	eb 5b       	subi	r30, 0xBB	; 187
    4786:	fe 4f       	sbci	r31, 0xFE	; 254
    4788:	e4 91       	lpm	r30, Z+
    478a:	e9 93       	st	Y+, r30
			}
		}
	}
	*str2_out = 0;
    
	while(strp != str2_out)
    478c:	ca 17       	cp	r28, r26
    478e:	db 07       	cpc	r29, r27
    4790:	a9 f7       	brne	.-22     	; 0x477c <decode_base64+0x80>
    4792:	fd 01       	movw	r30, r26
    4794:	84 2f       	mov	r24, r20
			strp++;
	}
 
    while (end_byte--)
    {
        *strp = '=';
    4796:	9d e3       	ldi	r25, 0x3D	; 61
    4798:	02 c0       	rjmp	.+4      	; 0x479e <decode_base64+0xa2>
    479a:	91 93       	st	Z+, r25
        strp++;
    479c:	81 50       	subi	r24, 0x01	; 1
	{
			*strp = pgm_read_byte(&BASE64CODE[(*strp) & 0x3F]);
			strp++;
	}
 
    while (end_byte--)
    479e:	88 23       	and	r24, r24
    47a0:	e1 f7       	brne	.-8      	; 0x479a <decode_base64+0x9e>
    {
        *strp = '=';
        strp++;
    }
    *strp = 0; 
    47a2:	a4 0f       	add	r26, r20
    47a4:	b1 1d       	adc	r27, r1
    47a6:	1c 92       	st	X, r1
}
    47a8:	df 91       	pop	r29
    47aa:	cf 91       	pop	r28
    47ac:	08 95       	ret

000047ae <enc_clrbits_reg>:
{
	// no automatic bank switching in this function !!!

	unsigned char addr = reg & ENC_REG_ADDR_MASK;

	enc_select();
    47ae:	2b 98       	cbi	0x05, 3	; 5
	spi_put( ENC_SPI_OP_BFC | addr );
    47b0:	8f 71       	andi	r24, 0x1F	; 31
    47b2:	80 6a       	ori	r24, 0xA0	; 160
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    47b4:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    47b6:	0d b4       	in	r0, 0x2d	; 45
    47b8:	07 fe       	sbrs	r0, 7
    47ba:	fd cf       	rjmp	.-6      	; 0x47b6 <enc_clrbits_reg+0x8>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    47bc:	6e bd       	out	0x2e, r22	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    47be:	0d b4       	in	r0, 0x2d	; 45
    47c0:	07 fe       	sbrs	r0, 7
    47c2:	fd cf       	rjmp	.-6      	; 0x47be <enc_clrbits_reg+0x10>
	unsigned char addr = reg & ENC_REG_ADDR_MASK;

	enc_select();
	spi_put( ENC_SPI_OP_BFC | addr );
	spi_put( bits );
	enc_deselect();
    47c4:	2b 9a       	sbi	0x05, 3	; 5
}
    47c6:	08 95       	ret

000047c8 <enc_setbits_reg>:
{
	// no automatic bank switching in this function !!!

	unsigned char addr = reg & ENC_REG_ADDR_MASK;

	enc_select();
    47c8:	2b 98       	cbi	0x05, 3	; 5
	spi_put( ENC_SPI_OP_BFS | addr );
    47ca:	8f 71       	andi	r24, 0x1F	; 31
    47cc:	80 68       	ori	r24, 0x80	; 128
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    47ce:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    47d0:	0d b4       	in	r0, 0x2d	; 45
    47d2:	07 fe       	sbrs	r0, 7
    47d4:	fd cf       	rjmp	.-6      	; 0x47d0 <enc_setbits_reg+0x8>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    47d6:	6e bd       	out	0x2e, r22	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    47d8:	0d b4       	in	r0, 0x2d	; 45
    47da:	07 fe       	sbrs	r0, 7
    47dc:	fd cf       	rjmp	.-6      	; 0x47d8 <enc_setbits_reg+0x10>
	unsigned char addr = reg & ENC_REG_ADDR_MASK;

	enc_select();
	spi_put( ENC_SPI_OP_BFS | addr );
	spi_put( bits );
	enc_deselect();
    47de:	2b 9a       	sbi	0x05, 3	; 5
}
    47e0:	08 95       	ret

000047e2 <enc_read_reg>:

static unsigned char enc_read_reg( unsigned char reg )
{
    47e2:	ff 92       	push	r15
    47e4:	0f 93       	push	r16
    47e6:	1f 93       	push	r17
    47e8:	cf 93       	push	r28
    47ea:	df 93       	push	r29
    47ec:	18 2f       	mov	r17, r24
	unsigned char value;
	unsigned char addr = reg & ENC_REG_ADDR_MASK;
    47ee:	9f e1       	ldi	r25, 0x1F	; 31
    47f0:	f9 2e       	mov	r15, r25
    47f2:	f8 22       	and	r15, r24

	if( addr < 0x1A ) {
    47f4:	89 e1       	ldi	r24, 0x19	; 25
    47f6:	8f 15       	cp	r24, r15
    47f8:	d0 f0       	brcs	.+52     	; 0x482e <enc_read_reg+0x4c>
		unsigned char bank = (reg & ENC_REG_BANK_MASK) >> ENC_REG_BANK_SHIFT;
    47fa:	c1 2f       	mov	r28, r17
    47fc:	d0 e0       	ldi	r29, 0x00	; 0
    47fe:	c0 76       	andi	r28, 0x60	; 96
    4800:	d0 70       	andi	r29, 0x00	; 0
    4802:	85 e0       	ldi	r24, 0x05	; 5
    4804:	d5 95       	asr	r29
    4806:	c7 95       	ror	r28
    4808:	8a 95       	dec	r24
    480a:	e1 f7       	brne	.-8      	; 0x4804 <enc_read_reg+0x22>
    480c:	0c 2f       	mov	r16, r28
		if( bank != enc_cur_bank ) {
    480e:	80 91 14 02 	lds	r24, 0x0214
    4812:	c8 17       	cp	r28, r24
    4814:	61 f0       	breq	.+24     	; 0x482e <enc_read_reg+0x4c>
			// need to switch bank first
			enc_clrbits_reg( ENC_REG_ECON1, 0x03 << ENC_BIT_BSEL0 );
    4816:	8f e1       	ldi	r24, 0x1F	; 31
    4818:	63 e0       	ldi	r22, 0x03	; 3
    481a:	0e 94 d7 23 	call	0x47ae	; 0x47ae <enc_clrbits_reg>
			if( bank ) {
    481e:	cc 23       	and	r28, r28
    4820:	21 f0       	breq	.+8      	; 0x482a <enc_read_reg+0x48>
				enc_setbits_reg( ENC_REG_ECON1, bank << ENC_BIT_BSEL0 );
    4822:	8f e1       	ldi	r24, 0x1F	; 31
    4824:	6c 2f       	mov	r22, r28
    4826:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>
			}
			enc_cur_bank = bank;
    482a:	00 93 14 02 	sts	0x0214, r16
		}
	}

	enc_select();
    482e:	2b 98       	cbi	0x05, 3	; 5
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    4830:	fe bc       	out	0x2e, r15	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    4832:	0d b4       	in	r0, 0x2d	; 45
    4834:	07 fe       	sbrs	r0, 7
    4836:	fd cf       	rjmp	.-6      	; 0x4832 <enc_read_reg+0x50>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    4838:	1e bc       	out	0x2e, r1	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    483a:	0d b4       	in	r0, 0x2d	; 45
    483c:	07 fe       	sbrs	r0, 7
    483e:	fd cf       	rjmp	.-6      	; 0x483a <enc_read_reg+0x58>
	}

	enc_select();
	spi_put( ENC_SPI_OP_RCR | addr );
	spi_put( 0x00 );
	if( reg & ENC_REG_WAIT_MASK ) spi_put( 0x00 );
    4840:	17 ff       	sbrs	r17, 7
    4842:	04 c0       	rjmp	.+8      	; 0x484c <enc_read_reg+0x6a>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    4844:	1e bc       	out	0x2e, r1	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    4846:	0d b4       	in	r0, 0x2d	; 45
    4848:	07 fe       	sbrs	r0, 7
    484a:	fd cf       	rjmp	.-6      	; 0x4846 <enc_read_reg+0x64>
}

static inline unsigned char spi_get(void)
{
	unsigned char value = SPDR;
    484c:	8e b5       	in	r24, 0x2e	; 46
	enc_select();
	spi_put( ENC_SPI_OP_RCR | addr );
	spi_put( 0x00 );
	if( reg & ENC_REG_WAIT_MASK ) spi_put( 0x00 );
	value = spi_get();
	enc_deselect();
    484e:	2b 9a       	sbi	0x05, 3	; 5

	return value;
}
    4850:	df 91       	pop	r29
    4852:	cf 91       	pop	r28
    4854:	1f 91       	pop	r17
    4856:	0f 91       	pop	r16
    4858:	ff 90       	pop	r15
    485a:	08 95       	ret

0000485c <enc_write_reg>:

static void enc_write_reg( unsigned char reg, unsigned char value )
{
    485c:	ff 92       	push	r15
    485e:	0f 93       	push	r16
    4860:	1f 93       	push	r17
    4862:	cf 93       	push	r28
    4864:	df 93       	push	r29
    4866:	f6 2e       	mov	r15, r22
	unsigned char addr = reg & ENC_REG_ADDR_MASK;
    4868:	18 2f       	mov	r17, r24
    486a:	1f 71       	andi	r17, 0x1F	; 31

	if( addr < 0x1A ) {
    486c:	1a 31       	cpi	r17, 0x1A	; 26
    486e:	d0 f4       	brcc	.+52     	; 0x48a4 <enc_write_reg+0x48>
		unsigned char bank = (reg & ENC_REG_BANK_MASK) >> ENC_REG_BANK_SHIFT;
    4870:	c8 2f       	mov	r28, r24
    4872:	d0 e0       	ldi	r29, 0x00	; 0
    4874:	c0 76       	andi	r28, 0x60	; 96
    4876:	d0 70       	andi	r29, 0x00	; 0
    4878:	25 e0       	ldi	r18, 0x05	; 5
    487a:	d5 95       	asr	r29
    487c:	c7 95       	ror	r28
    487e:	2a 95       	dec	r18
    4880:	e1 f7       	brne	.-8      	; 0x487a <enc_write_reg+0x1e>
    4882:	0c 2f       	mov	r16, r28
		if( bank != enc_cur_bank ) {
    4884:	80 91 14 02 	lds	r24, 0x0214
    4888:	c8 17       	cp	r28, r24
    488a:	61 f0       	breq	.+24     	; 0x48a4 <enc_write_reg+0x48>
			// need to switch bank first
			enc_clrbits_reg( ENC_REG_ECON1, 0x03 << ENC_BIT_BSEL0 );
    488c:	8f e1       	ldi	r24, 0x1F	; 31
    488e:	63 e0       	ldi	r22, 0x03	; 3
    4890:	0e 94 d7 23 	call	0x47ae	; 0x47ae <enc_clrbits_reg>
			if( bank ) {
    4894:	cc 23       	and	r28, r28
    4896:	21 f0       	breq	.+8      	; 0x48a0 <enc_write_reg+0x44>
				enc_setbits_reg( ENC_REG_ECON1, bank << ENC_BIT_BSEL0 );
    4898:	8f e1       	ldi	r24, 0x1F	; 31
    489a:	6c 2f       	mov	r22, r28
    489c:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>
			}
			enc_cur_bank = bank;
    48a0:	00 93 14 02 	sts	0x0214, r16
		}
	}

	enc_select();
    48a4:	2b 98       	cbi	0x05, 3	; 5
	spi_put( ENC_SPI_OP_WCR | addr );
    48a6:	10 64       	ori	r17, 0x40	; 64
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    48a8:	1e bd       	out	0x2e, r17	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    48aa:	0d b4       	in	r0, 0x2d	; 45
    48ac:	07 fe       	sbrs	r0, 7
    48ae:	fd cf       	rjmp	.-6      	; 0x48aa <enc_write_reg+0x4e>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    48b0:	fe bc       	out	0x2e, r15	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    48b2:	0d b4       	in	r0, 0x2d	; 45
    48b4:	07 fe       	sbrs	r0, 7
    48b6:	fd cf       	rjmp	.-6      	; 0x48b2 <enc_write_reg+0x56>
	}

	enc_select();
	spi_put( ENC_SPI_OP_WCR | addr );
	spi_put( value );
	enc_deselect();
    48b8:	2b 9a       	sbi	0x05, 3	; 5
}
    48ba:	df 91       	pop	r29
    48bc:	cf 91       	pop	r28
    48be:	1f 91       	pop	r17
    48c0:	0f 91       	pop	r16
    48c2:	ff 90       	pop	r15
    48c4:	08 95       	ret

000048c6 <enc_read_buf>:
	usdelay(10);
	while( enc_read_reg( ENC_REG_MISTAT ) & (1<<ENC_BIT_BUSY) ) ;
}

static void enc_read_buf( unsigned char *buf, unsigned int len )
{
    48c6:	fc 01       	movw	r30, r24
	enc_select();
    48c8:	2b 98       	cbi	0x05, 3	; 5
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    48ca:	8a e3       	ldi	r24, 0x3A	; 58
    48cc:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    48ce:	0d b4       	in	r0, 0x2d	; 45
    48d0:	07 fe       	sbrs	r0, 7
    48d2:	fd cf       	rjmp	.-6      	; 0x48ce <enc_read_buf+0x8>
    48d4:	08 c0       	rjmp	.+16     	; 0x48e6 <enc_read_buf+0x20>
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    48d6:	1e bc       	out	0x2e, r1	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    48d8:	0d b4       	in	r0, 0x2d	; 45
    48da:	07 fe       	sbrs	r0, 7
    48dc:	fd cf       	rjmp	.-6      	; 0x48d8 <enc_read_buf+0x12>
}

static inline unsigned char spi_get(void)
{
	unsigned char value = SPDR;
    48de:	8e b5       	in	r24, 0x2e	; 46
{
	enc_select();
	spi_put( ENC_SPI_OP_RBM );
	for(; len > 0; len--, buf++ ) {
		spi_put( 0x00 );
		*buf = spi_get();
    48e0:	81 93       	st	Z+, r24

static void enc_read_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
	spi_put( ENC_SPI_OP_RBM );
	for(; len > 0; len--, buf++ ) {
    48e2:	61 50       	subi	r22, 0x01	; 1
    48e4:	70 40       	sbci	r23, 0x00	; 0
    48e6:	61 15       	cp	r22, r1
    48e8:	71 05       	cpc	r23, r1
    48ea:	a9 f7       	brne	.-22     	; 0x48d6 <enc_read_buf+0x10>
		spi_put( 0x00 );
		*buf = spi_get();
	}
	enc_deselect();
    48ec:	2b 9a       	sbi	0x05, 3	; 5
}
    48ee:	08 95       	ret

000048f0 <enc_send_packet>:
/**
 *	\ingroup nic
 *	Ethernet Paket versenden
 */
void enc_send_packet( unsigned int len, unsigned char *buf )
{
    48f0:	cf 92       	push	r12
    48f2:	df 92       	push	r13
    48f4:	ef 92       	push	r14
    48f6:	ff 92       	push	r15
    48f8:	0f 93       	push	r16
    48fa:	1f 93       	push	r17
    48fc:	df 93       	push	r29
    48fe:	cf 93       	push	r28
    4900:	0f 92       	push	r0
    4902:	cd b7       	in	r28, 0x3d	; 61
    4904:	de b7       	in	r29, 0x3e	; 62
    4906:	7c 01       	movw	r14, r24
    4908:	6b 01       	movw	r12, r22
	unsigned char ctrl = 0;
    490a:	19 82       	std	Y+1, r1	; 0x01
    490c:	04 e6       	ldi	r16, 0x64	; 100
    490e:	10 e0       	ldi	r17, 0x00	; 0
    4910:	11 c0       	rjmp	.+34     	; 0x4934 <enc_send_packet+0x44>

	ENC_DEBUG("enc_send: %i bytes\n", len);

	// wait up to 100 ms for the previos tx to finish
	while( ms-- ) {
		if( !(enc_read_reg( ENC_REG_ECON1 ) & (1<<ENC_BIT_TXRTS)) ) break;
    4912:	8f e1       	ldi	r24, 0x1F	; 31
    4914:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
    4918:	83 ff       	sbrs	r24, 3
    491a:	12 c0       	rjmp	.+36     	; 0x4940 <enc_send_packet+0x50>
    491c:	88 ee       	ldi	r24, 0xE8	; 232
    491e:	93 e0       	ldi	r25, 0x03	; 3

//-----------------------------------------------------------------------------

static void usdelay( unsigned int us )
{
	while( us-- ) {
    4920:	01 97       	sbiw	r24, 0x01	; 1
    4922:	2f ef       	ldi	r18, 0xFF	; 255
    4924:	8f 3f       	cpi	r24, 0xFF	; 255
    4926:	92 07       	cpc	r25, r18
    4928:	29 f0       	breq	.+10     	; 0x4934 <enc_send_packet+0x44>
	...
		// 4 times * 4 cycles gives 16 cyles = 1 us with 16 MHz clocking
		unsigned char i=4;
		// this while loop executes with exact 4 cycles:
		while( i-- ) { asm volatile("nop"); }
    4932:	f6 cf       	rjmp	.-20     	; 0x4920 <enc_send_packet+0x30>
	unsigned int ms = 100;

	ENC_DEBUG("enc_send: %i bytes\n", len);

	// wait up to 100 ms for the previos tx to finish
	while( ms-- ) {
    4934:	01 50       	subi	r16, 0x01	; 1
    4936:	10 40       	sbci	r17, 0x00	; 0
    4938:	8f ef       	ldi	r24, 0xFF	; 255
    493a:	0f 3f       	cpi	r16, 0xFF	; 255
    493c:	18 07       	cpc	r17, r24
    493e:	49 f7       	brne	.-46     	; 0x4912 <enc_send_packet+0x22>
		usdelay( 1000 );
	}

	#ifdef FULL_DUPLEX
	// reset tx logic if TXRTS bit is still on
	if( enc_read_reg( ENC_REG_ECON1 ) & (1<<ENC_BIT_TXRTS) ) {
    4940:	8f e1       	ldi	r24, 0x1F	; 31
    4942:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
    4946:	83 ff       	sbrs	r24, 3
    4948:	08 c0       	rjmp	.+16     	; 0x495a <enc_send_packet+0x6a>
	#else
	// errata #12: reset tx logic
	if( 1 ) {
	#endif
		ENC_DEBUG("enc_send: reset tx logic\n");
		enc_setbits_reg( ENC_REG_ECON1, (1<<ENC_BIT_TXRST) );
    494a:	8f e1       	ldi	r24, 0x1F	; 31
    494c:	60 e8       	ldi	r22, 0x80	; 128
    494e:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>
		enc_clrbits_reg( ENC_REG_ECON1, (1<<ENC_BIT_TXRST) );
    4952:	8f e1       	ldi	r24, 0x1F	; 31
    4954:	60 e8       	ldi	r22, 0x80	; 128
    4956:	0e 94 d7 23 	call	0x47ae	; 0x47ae <enc_clrbits_reg>
	}

	// setup write pointer
	enc_write_reg( ENC_REG_EWRPTL, LO8(ENC_TX_BUFFER_START) );
    495a:	82 e0       	ldi	r24, 0x02	; 2
    495c:	60 e0       	ldi	r22, 0x00	; 0
    495e:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_write_reg( ENC_REG_EWRPTH, HI8(ENC_TX_BUFFER_START) );
    4962:	83 e0       	ldi	r24, 0x03	; 3
    4964:	6a e1       	ldi	r22, 0x1A	; 26
    4966:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>

	// end pointer (points to last byte) to start + len
	enc_write_reg( ENC_REG_ETXNDL, LO8(ENC_TX_BUFFER_START+len) );
    496a:	86 e0       	ldi	r24, 0x06	; 6
    496c:	6e 2d       	mov	r22, r14
    496e:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_write_reg( ENC_REG_ETXNDH, HI8(ENC_TX_BUFFER_START+len) );
    4972:	97 01       	movw	r18, r14
    4974:	20 50       	subi	r18, 0x00	; 0
    4976:	36 4e       	sbci	r19, 0xE6	; 230
    4978:	87 e0       	ldi	r24, 0x07	; 7
    497a:	63 2f       	mov	r22, r19
    497c:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_deselect();
}

static void enc_write_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
    4980:	2b 98       	cbi	0x05, 3	; 5
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    4982:	8a e7       	ldi	r24, 0x7A	; 122
    4984:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    4986:	0d b4       	in	r0, 0x2d	; 45
    4988:	07 fe       	sbrs	r0, 7
    498a:	fd cf       	rjmp	.-6      	; 0x4986 <enc_send_packet+0x96>
static void enc_write_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
	spi_put( ENC_SPI_OP_WBM );
	for(; len > 0; len--, buf++ ) {
		spi_put( *buf );
    498c:	89 81       	ldd	r24, Y+1	; 0x01
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    498e:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    4990:	0d b4       	in	r0, 0x2d	; 45
    4992:	07 fe       	sbrs	r0, 7
    4994:	fd cf       	rjmp	.-6      	; 0x4990 <enc_send_packet+0xa0>
	enc_select();
	spi_put( ENC_SPI_OP_WBM );
	for(; len > 0; len--, buf++ ) {
		spi_put( *buf );
	}
	enc_deselect();
    4996:	2b 9a       	sbi	0x05, 3	; 5
	enc_deselect();
}

static void enc_write_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
    4998:	2b 98       	cbi	0x05, 3	; 5
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    499a:	8a e7       	ldi	r24, 0x7A	; 122
    499c:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    499e:	0d b4       	in	r0, 0x2d	; 45
    49a0:	07 fe       	sbrs	r0, 7
    49a2:	fd cf       	rjmp	.-6      	; 0x499e <enc_send_packet+0xae>
    49a4:	0c c0       	rjmp	.+24     	; 0x49be <enc_send_packet+0xce>
static void enc_write_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
	spi_put( ENC_SPI_OP_WBM );
	for(; len > 0; len--, buf++ ) {
		spi_put( *buf );
    49a6:	f6 01       	movw	r30, r12
    49a8:	80 81       	ld	r24, Z
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    49aa:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    49ac:	0d b4       	in	r0, 0x2d	; 45
    49ae:	07 fe       	sbrs	r0, 7
    49b0:	fd cf       	rjmp	.-6      	; 0x49ac <enc_send_packet+0xbc>

static void enc_write_buf( unsigned char *buf, unsigned int len )
{
	enc_select();
	spi_put( ENC_SPI_OP_WBM );
	for(; len > 0; len--, buf++ ) {
    49b2:	08 94       	sec
    49b4:	e1 08       	sbc	r14, r1
    49b6:	f1 08       	sbc	r15, r1
    49b8:	08 94       	sec
    49ba:	c1 1c       	adc	r12, r1
    49bc:	d1 1c       	adc	r13, r1
    49be:	e1 14       	cp	r14, r1
    49c0:	f1 04       	cpc	r15, r1
    49c2:	89 f7       	brne	.-30     	; 0x49a6 <enc_send_packet+0xb6>
		spi_put( *buf );
	}
	enc_deselect();
    49c4:	2b 9a       	sbi	0x05, 3	; 5

	// copy packet to enc buffer
	enc_write_buf( buf, len );

	// clear TXIF flag
	enc_clrbits_reg( ENC_REG_EIR, (1<<ENC_BIT_TXIF) );
    49c6:	8c e1       	ldi	r24, 0x1C	; 28
    49c8:	68 e0       	ldi	r22, 0x08	; 8
    49ca:	0e 94 d7 23 	call	0x47ae	; 0x47ae <enc_clrbits_reg>

	// start transmission by setting the TXRTS bit
	enc_setbits_reg( ENC_REG_ECON1, (1<<ENC_BIT_TXRTS) );
    49ce:	8f e1       	ldi	r24, 0x1F	; 31
    49d0:	68 e0       	ldi	r22, 0x08	; 8
    49d2:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>
}
    49d6:	0f 90       	pop	r0
    49d8:	cf 91       	pop	r28
    49da:	df 91       	pop	r29
    49dc:	1f 91       	pop	r17
    49de:	0f 91       	pop	r16
    49e0:	ff 90       	pop	r15
    49e2:	ef 90       	pop	r14
    49e4:	df 90       	pop	r13
    49e6:	cf 90       	pop	r12
    49e8:	08 95       	ret

000049ea <enc_receive_packet>:
/**
 *	\ingroup nic
 *	Ethernet Paket empfangen
 */
unsigned int enc_receive_packet( unsigned int bufsize, unsigned char *buf )
{
    49ea:	cf 92       	push	r12
    49ec:	df 92       	push	r13
    49ee:	ef 92       	push	r14
    49f0:	ff 92       	push	r15
    49f2:	0f 93       	push	r16
    49f4:	1f 93       	push	r17
    49f6:	df 93       	push	r29
    49f8:	cf 93       	push	r28
    49fa:	00 d0       	rcall	.+0      	; 0x49fc <enc_receive_packet+0x12>
    49fc:	00 d0       	rcall	.+0      	; 0x49fe <enc_receive_packet+0x14>
    49fe:	00 d0       	rcall	.+0      	; 0x4a00 <enc_receive_packet+0x16>
    4a00:	cd b7       	in	r28, 0x3d	; 61
    4a02:	de b7       	in	r29, 0x3e	; 62
    4a04:	7c 01       	movw	r14, r24
    4a06:	6b 01       	movw	r12, r22
	unsigned char rxheader[6];
	unsigned int len, status;
	unsigned char u;

	// check rx packet counter
	u = enc_read_reg( ENC_REG_EPKTCNT );
    4a08:	89 e3       	ldi	r24, 0x39	; 57
    4a0a:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
	ENC_DEBUG("enc_receive: EPKTCNT=%i\n", (int) u);
	if( u == 0 ) {
    4a0e:	88 23       	and	r24, r24
    4a10:	19 f4       	brne	.+6      	; 0x4a18 <enc_receive_packet+0x2e>
    4a12:	00 e0       	ldi	r16, 0x00	; 0
    4a14:	10 e0       	ldi	r17, 0x00	; 0
    4a16:	61 c0       	rjmp	.+194    	; 0x4ada <enc_receive_packet+0xf0>
		// packetcounter is 0, there is nothing to receive, go back
		return 0;
	}

	//set read pointer to next packet
	enc_write_reg( ENC_REG_ERDPTL, LO8(enc_next_packet_ptr) );
    4a18:	60 91 12 02 	lds	r22, 0x0212
    4a1c:	70 91 13 02 	lds	r23, 0x0213
    4a20:	80 e0       	ldi	r24, 0x00	; 0
    4a22:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_write_reg( ENC_REG_ERDPTH, HI8(enc_next_packet_ptr) );
    4a26:	20 91 12 02 	lds	r18, 0x0212
    4a2a:	30 91 13 02 	lds	r19, 0x0213
    4a2e:	81 e0       	ldi	r24, 0x01	; 1
    4a30:	63 2f       	mov	r22, r19
    4a32:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>

	// read enc rx packet header
	enc_read_buf( rxheader, sizeof(rxheader) );
    4a36:	ce 01       	movw	r24, r28
    4a38:	01 96       	adiw	r24, 0x01	; 1
    4a3a:	66 e0       	ldi	r22, 0x06	; 6
    4a3c:	70 e0       	ldi	r23, 0x00	; 0
    4a3e:	0e 94 63 24 	call	0x48c6	; 0x48c6 <enc_read_buf>
	enc_next_packet_ptr  =             rxheader[0];
    4a42:	89 81       	ldd	r24, Y+1	; 0x01
    4a44:	90 e0       	ldi	r25, 0x00	; 0
    4a46:	90 93 13 02 	sts	0x0213, r25
    4a4a:	80 93 12 02 	sts	0x0212, r24
	enc_next_packet_ptr |= ((unsigned)(rxheader[1])) << 8;
    4a4e:	20 91 12 02 	lds	r18, 0x0212
    4a52:	30 91 13 02 	lds	r19, 0x0213
    4a56:	9a 81       	ldd	r25, Y+2	; 0x02
    4a58:	80 e0       	ldi	r24, 0x00	; 0
    4a5a:	82 2b       	or	r24, r18
    4a5c:	93 2b       	or	r25, r19
    4a5e:	90 93 13 02 	sts	0x0213, r25
    4a62:	80 93 12 02 	sts	0x0212, r24
	len                  =             rxheader[2];
    4a66:	8b 81       	ldd	r24, Y+3	; 0x03
    4a68:	08 2f       	mov	r16, r24
    4a6a:	10 e0       	ldi	r17, 0x00	; 0
	len                 |= ((unsigned)(rxheader[3])) << 8;
    4a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6e:	80 e0       	ldi	r24, 0x00	; 0
    4a70:	08 2b       	or	r16, r24
    4a72:	19 2b       	or	r17, r25
	//if( !(status & (1<<7))) {
		ENC_DEBUG("enc_receive: status=%4x\n", (unsigned) status);
	//}

	// skip the checksum (4 bytes) at the end of the buffer
	len -= 4;
    4a74:	04 50       	subi	r16, 0x04	; 4
    4a76:	10 40       	sbci	r17, 0x00	; 0
    4a78:	e0 16       	cp	r14, r16
    4a7a:	f1 06       	cpc	r15, r17
    4a7c:	08 f4       	brcc	.+2      	; 0x4a80 <enc_receive_packet+0x96>
    4a7e:	87 01       	movw	r16, r14

	// if the application buffer is to small, we just truncate
	if( len > bufsize ) len = bufsize;

	// now read the packet data into buffer
	enc_read_buf( buf, len );
    4a80:	c6 01       	movw	r24, r12
    4a82:	b8 01       	movw	r22, r16
    4a84:	0e 94 63 24 	call	0x48c6	; 0x48c6 <enc_read_buf>

	// adjust the ERXRDPT pointer (= free this packet in rx buffer)
	if(    enc_next_packet_ptr-1 > ENC_RX_BUFFER_END
    4a88:	80 91 12 02 	lds	r24, 0x0212
    4a8c:	90 91 13 02 	lds	r25, 0x0213
    4a90:	01 97       	sbiw	r24, 0x01	; 1
    4a92:	80 50       	subi	r24, 0x00	; 0
    4a94:	9a 41       	sbci	r25, 0x1A	; 26
    4a96:	a8 f4       	brcc	.+42     	; 0x4ac2 <enc_receive_packet+0xd8>
    4a98:	80 91 12 02 	lds	r24, 0x0212
    4a9c:	90 91 13 02 	lds	r25, 0x0213
	    || enc_next_packet_ptr-1 < ENC_RX_BUFFER_START ) {
		enc_write_reg( ENC_REG_ERXRDPTL, LO8(ENC_RX_BUFFER_END) );
		enc_write_reg( ENC_REG_ERXRDPTH, HI8(ENC_RX_BUFFER_END) );
	} else {
		enc_write_reg( ENC_REG_ERXRDPTL, LO8(enc_next_packet_ptr-1) );
    4aa0:	60 91 12 02 	lds	r22, 0x0212
    4aa4:	70 91 13 02 	lds	r23, 0x0213
    4aa8:	61 50       	subi	r22, 0x01	; 1
    4aaa:	8c e0       	ldi	r24, 0x0C	; 12
    4aac:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
		enc_write_reg( ENC_REG_ERXRDPTH, HI8(enc_next_packet_ptr-1) );
    4ab0:	20 91 12 02 	lds	r18, 0x0212
    4ab4:	30 91 13 02 	lds	r19, 0x0213
    4ab8:	21 50       	subi	r18, 0x01	; 1
    4aba:	30 40       	sbci	r19, 0x00	; 0
    4abc:	8d e0       	ldi	r24, 0x0D	; 13
    4abe:	63 2f       	mov	r22, r19
    4ac0:	06 c0       	rjmp	.+12     	; 0x4ace <enc_receive_packet+0xe4>
	enc_read_buf( buf, len );

	// adjust the ERXRDPT pointer (= free this packet in rx buffer)
	if(    enc_next_packet_ptr-1 > ENC_RX_BUFFER_END
	    || enc_next_packet_ptr-1 < ENC_RX_BUFFER_START ) {
		enc_write_reg( ENC_REG_ERXRDPTL, LO8(ENC_RX_BUFFER_END) );
    4ac2:	8c e0       	ldi	r24, 0x0C	; 12
    4ac4:	6f ef       	ldi	r22, 0xFF	; 255
    4ac6:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
		enc_write_reg( ENC_REG_ERXRDPTH, HI8(ENC_RX_BUFFER_END) );
    4aca:	8d e0       	ldi	r24, 0x0D	; 13
    4acc:	69 e1       	ldi	r22, 0x19	; 25
    4ace:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
		enc_write_reg( ENC_REG_ERXRDPTH, HI8(enc_next_packet_ptr-1) );
	}

	// trigger a decrement of the rx packet counter
	// this will clear PKTIF if EPKTCNT reaches 0
	enc_setbits_reg( ENC_REG_ECON2, (1<<ENC_BIT_PKTDEC) );
    4ad2:	8e e1       	ldi	r24, 0x1E	; 30
    4ad4:	60 e4       	ldi	r22, 0x40	; 64
    4ad6:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>

	// return number of bytes written to the buffer
	ENC_DEBUG("enc_receive: %i bytes\n", len);
	return len;
}
    4ada:	c8 01       	movw	r24, r16
    4adc:	26 96       	adiw	r28, 0x06	; 6
    4ade:	0f b6       	in	r0, 0x3f	; 63
    4ae0:	f8 94       	cli
    4ae2:	de bf       	out	0x3e, r29	; 62
    4ae4:	0f be       	out	0x3f, r0	; 63
    4ae6:	cd bf       	out	0x3d, r28	; 61
    4ae8:	cf 91       	pop	r28
    4aea:	df 91       	pop	r29
    4aec:	1f 91       	pop	r17
    4aee:	0f 91       	pop	r16
    4af0:	ff 90       	pop	r15
    4af2:	ef 90       	pop	r14
    4af4:	df 90       	pop	r13
    4af6:	cf 90       	pop	r12
    4af8:	08 95       	ret

00004afa <enc_init>:
/**
 *	\ingroup nic
 *	Initialisierung ENC28j60
 */
void enc_init(void)
{
    4afa:	ef 92       	push	r14
    4afc:	ff 92       	push	r15
    4afe:	0f 93       	push	r16
    4b00:	1f 93       	push	r17
    4b02:	cf 93       	push	r28
    4b04:	df 93       	push	r29
	int i=0;
	unsigned int u;
	unsigned char r, d;

	// config enc chip select as output and deselect enc
	ENC_DDR  |= (1<<ENC_CS);
    4b06:	23 9a       	sbi	0x04, 3	; 4
	ENC_PORT |= (1<<ENC_CS);
    4b08:	2b 9a       	sbi	0x05, 3	; 5
//-----------------------------------------------------------------------------

static inline void spi_init(void)
{
	// configure pins MOSI, SCK as output
	SPI_DDR |= (1<<SPI_MOSI) | (1<<SPI_SCK);
    4b0a:	84 b1       	in	r24, 0x04	; 4
    4b0c:	80 6a       	ori	r24, 0xA0	; 160
    4b0e:	84 b9       	out	0x04, r24	; 4
	// pull SCK high
	SPI_PORT |= (1<<SPI_SCK);
    4b10:	2f 9a       	sbi	0x05, 7	; 5

	// configure pin MISO as input
	SPI_DDR &= ~(1<<SPI_MISO);
    4b12:	26 98       	cbi	0x04, 6	; 4
	SPI_DDR |= (1<<SPI_SS);
    4b14:	24 9a       	sbi	0x04, 4	; 4

	//SPI: enable, master, positive clock phase, msb first, SPI speed fosc/2
	SPCR = (1<<SPE) | (1<<MSTR);
    4b16:	80 e5       	ldi	r24, 0x50	; 80
    4b18:	8c bd       	out	0x2c, r24	; 44
	SPSR = (1<<SPI2X);
    4b1a:	81 e0       	ldi	r24, 0x01	; 1
    4b1c:	8d bd       	out	0x2d, r24	; 45
    4b1e:	80 e1       	ldi	r24, 0x10	; 16
    4b20:	97 e2       	ldi	r25, 0x27	; 39

//-----------------------------------------------------------------------------

static void usdelay( unsigned int us )
{
	while( us-- ) {
    4b22:	01 97       	sbiw	r24, 0x01	; 1
    4b24:	2f ef       	ldi	r18, 0xFF	; 255
    4b26:	8f 3f       	cpi	r24, 0xFF	; 255
    4b28:	92 07       	cpc	r25, r18
    4b2a:	29 f0       	breq	.+10     	; 0x4b36 <enc_init+0x3c>
	...
		// 4 times * 4 cycles gives 16 cyles = 1 us with 16 MHz clocking
		unsigned char i=4;
		// this while loop executes with exact 4 cycles:
		while( i-- ) { asm volatile("nop"); }
    4b34:	f6 cf       	rjmp	.-20     	; 0x4b22 <enc_init+0x28>

//-----------------------------------------------------------------------------

static inline void enc_reset(void)
{
	enc_select();
    4b36:	2b 98       	cbi	0x05, 3	; 5
}

static inline void spi_put( unsigned char value )
{
	//ENC_DEBUG("spi_put(%2x)\n", (unsigned) value );
	SPDR = value;
    4b38:	8f ef       	ldi	r24, 0xFF	; 255
    4b3a:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1<<SPIF)) ) ;
    4b3c:	0d b4       	in	r0, 0x2d	; 45
    4b3e:	07 fe       	sbrs	r0, 7
    4b40:	fd cf       	rjmp	.-6      	; 0x4b3c <enc_init+0x42>

static inline void enc_reset(void)
{
	enc_select();
	spi_put( ENC_SPI_OP_SC );
	enc_deselect();
    4b42:	2b 9a       	sbi	0x05, 3	; 5
    4b44:	88 ee       	ldi	r24, 0xE8	; 232
    4b46:	93 e0       	ldi	r25, 0x03	; 3

//-----------------------------------------------------------------------------

static void usdelay( unsigned int us )
{
	while( us-- ) {
    4b48:	01 97       	sbiw	r24, 0x01	; 1
    4b4a:	ef ef       	ldi	r30, 0xFF	; 255
    4b4c:	8f 3f       	cpi	r24, 0xFF	; 255
    4b4e:	9e 07       	cpc	r25, r30
    4b50:	29 f0       	breq	.+10     	; 0x4b5c <enc_init+0x62>
	...
		// 4 times * 4 cycles gives 16 cyles = 1 us with 16 MHz clocking
		unsigned char i=4;
		// this while loop executes with exact 4 cycles:
		while( i-- ) { asm volatile("nop"); }
    4b5a:	f6 cf       	rjmp	.-20     	; 0x4b48 <enc_init+0x4e>

	// send a reset command via spi to the enc
	enc_reset();

	// wait for the CLKRDY bit
	while( !(enc_read_reg( ENC_REG_ESTAT ) & (1<<ENC_BIT_CLKRDY)) ) ;
    4b5c:	8d e1       	ldi	r24, 0x1D	; 29
    4b5e:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
    4b62:	80 ff       	sbrs	r24, 0
    4b64:	fb cf       	rjmp	.-10     	; 0x4b5c <enc_init+0x62>

	// get enc revision id
	enc_revid = enc_read_reg( ENC_REG_EREVID );
    4b66:	82 e7       	ldi	r24, 0x72	; 114
    4b68:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
    4b6c:	80 93 11 02 	sts	0x0211, r24
	ENC_DEBUG("enc revid %x\n", (int) enc_revid);

	// setup mymac variable
	mymac[0] = MYMAC1;
    4b70:	10 92 7c 0c 	sts	0x0C7C, r1
	mymac[1] = MYMAC2;
    4b74:	80 e2       	ldi	r24, 0x20	; 32
    4b76:	80 93 7d 0c 	sts	0x0C7D, r24
	mymac[2] = MYMAC3;
    4b7a:	88 e1       	ldi	r24, 0x18	; 24
    4b7c:	80 93 7e 0c 	sts	0x0C7E, r24
	mymac[3] = MYMAC4;
    4b80:	81 eb       	ldi	r24, 0xB1	; 177
    4b82:	80 93 7f 0c 	sts	0x0C7F, r24
	mymac[4] = MYMAC5;
    4b86:	85 e1       	ldi	r24, 0x15	; 21
    4b88:	80 93 80 0c 	sts	0x0C80, r24
	mymac[5] = MYMAC6;
    4b8c:	8f e3       	ldi	r24, 0x3F	; 63
    4b8e:	80 93 81 0c 	sts	0x0C81, r24
    4b92:	c0 e0       	ldi	r28, 0x00	; 0
    4b94:	d0 e0       	ldi	r29, 0x00	; 0
/**
 *	\ingroup nic
 *	Initialisierung ENC28j60
 */
void enc_init(void)
{
    4b96:	ce 01       	movw	r24, r28
	mymac[4] = MYMAC5;
	mymac[5] = MYMAC6;

	// setup enc registers according to the enc_configdata struct
	while(1) {
		r = pgm_read_byte( &enc_configdata[i++] );
    4b98:	fe 01       	movw	r30, r28
    4b9a:	e9 57       	subi	r30, 0x79	; 121
    4b9c:	fe 4f       	sbci	r31, 0xFE	; 254
    4b9e:	24 91       	lpm	r18, Z+
    4ba0:	22 96       	adiw	r28, 0x02	; 2
		d = pgm_read_byte( &enc_configdata[i++] );
    4ba2:	88 57       	subi	r24, 0x78	; 120
    4ba4:	9e 4f       	sbci	r25, 0xFE	; 254
    4ba6:	fc 01       	movw	r30, r24
    4ba8:	64 91       	lpm	r22, Z+
		if( r == 0xFF && d == 0xFF ) break;
    4baa:	2f 3f       	cpi	r18, 0xFF	; 255
    4bac:	11 f4       	brne	.+4      	; 0x4bb2 <enc_init+0xb8>
    4bae:	6f 3f       	cpi	r22, 0xFF	; 255
    4bb0:	21 f0       	breq	.+8      	; 0x4bba <enc_init+0xc0>
		enc_write_reg( r, d );
    4bb2:	82 2f       	mov	r24, r18
    4bb4:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
    4bb8:	ee cf       	rjmp	.-36     	; 0x4b96 <enc_init+0x9c>
	}
    4bba:	c9 57       	subi	r28, 0x79	; 121
    4bbc:	de 4f       	sbci	r29, 0xFE	; 254
	// now the phy registers
	while(1) {
		r = pgm_read_byte( &enc_configdata[i++] );
    4bbe:	fe 01       	movw	r30, r28
    4bc0:	64 91       	lpm	r22, Z+
		d = pgm_read_byte( &enc_configdata[i++] );
    4bc2:	21 96       	adiw	r28, 0x01	; 1
    4bc4:	fe 01       	movw	r30, r28
    4bc6:	84 91       	lpm	r24, Z+
    4bc8:	21 97       	sbiw	r28, 0x01	; 1
		if( r == 0xFF && d == 0xFF ) break;
    4bca:	6f 3f       	cpi	r22, 0xFF	; 255
    4bcc:	11 f4       	brne	.+4      	; 0x4bd2 <enc_init+0xd8>
    4bce:	8f 3f       	cpi	r24, 0xFF	; 255
    4bd0:	39 f1       	breq	.+78     	; 0x4c20 <enc_init+0x126>
		u = (((unsigned int)d) << 8);
    4bd2:	f8 2e       	mov	r15, r24
    4bd4:	ee 24       	eor	r14, r14
		d = pgm_read_byte( &enc_configdata[i++] );
    4bd6:	22 96       	adiw	r28, 0x02	; 2
    4bd8:	fe 01       	movw	r30, r28
    4bda:	04 91       	lpm	r16, Z+
    4bdc:	22 97       	sbiw	r28, 0x02	; 2
		u |= d;
    4bde:	10 e0       	ldi	r17, 0x00	; 0
    4be0:	0e 29       	or	r16, r14
    4be2:	1f 29       	or	r17, r15
}
#endif

static void enc_write_phyreg( unsigned char phyreg, unsigned int value )
{
	enc_write_reg( ENC_REG_MIREGADR, phyreg );
    4be4:	84 ed       	ldi	r24, 0xD4	; 212
    4be6:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_write_reg( ENC_REG_MIWRL, LO8(value) );
    4bea:	86 ed       	ldi	r24, 0xD6	; 214
    4bec:	60 2f       	mov	r22, r16
    4bee:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
	enc_write_reg( ENC_REG_MIWRH, HI8(value) );
    4bf2:	87 ed       	ldi	r24, 0xD7	; 215
    4bf4:	61 2f       	mov	r22, r17
    4bf6:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
    4bfa:	8a e0       	ldi	r24, 0x0A	; 10
    4bfc:	90 e0       	ldi	r25, 0x00	; 0

//-----------------------------------------------------------------------------

static void usdelay( unsigned int us )
{
	while( us-- ) {
    4bfe:	01 97       	sbiw	r24, 0x01	; 1
    4c00:	ff ef       	ldi	r31, 0xFF	; 255
    4c02:	8f 3f       	cpi	r24, 0xFF	; 255
    4c04:	9f 07       	cpc	r25, r31
    4c06:	29 f0       	breq	.+10     	; 0x4c12 <enc_init+0x118>
	...
		// 4 times * 4 cycles gives 16 cyles = 1 us with 16 MHz clocking
		unsigned char i=4;
		// this while loop executes with exact 4 cycles:
		while( i-- ) { asm volatile("nop"); }
    4c10:	f6 cf       	rjmp	.-20     	; 0x4bfe <enc_init+0x104>
{
	enc_write_reg( ENC_REG_MIREGADR, phyreg );
	enc_write_reg( ENC_REG_MIWRL, LO8(value) );
	enc_write_reg( ENC_REG_MIWRH, HI8(value) );
	usdelay(10);
	while( enc_read_reg( ENC_REG_MISTAT ) & (1<<ENC_BIT_BUSY) ) ;
    4c12:	8a ee       	ldi	r24, 0xEA	; 234
    4c14:	0e 94 f1 23 	call	0x47e2	; 0x47e2 <enc_read_reg>
    4c18:	80 fd       	sbrc	r24, 0
    4c1a:	fb cf       	rjmp	.-10     	; 0x4c12 <enc_init+0x118>
    4c1c:	23 96       	adiw	r28, 0x03	; 3
    4c1e:	cf cf       	rjmp	.-98     	; 0x4bbe <enc_init+0xc4>
		u |= d;
		enc_write_phyreg( r, u );
	}

	// setup receive next packet pointer
	enc_next_packet_ptr = ENC_RX_BUFFER_START;
    4c20:	10 92 13 02 	sts	0x0213, r1
    4c24:	10 92 12 02 	sts	0x0212, r1

	// configure the enc interrupt sources
	enc_write_reg( ENC_REG_EIE, (1 << ENC_BIT_INTIE)  | (1 << ENC_BIT_PKTIE)
    4c28:	8b e1       	ldi	r24, 0x1B	; 27
    4c2a:	60 ec       	ldi	r22, 0xC0	; 192
    4c2c:	0e 94 2e 24 	call	0x485c	; 0x485c <enc_write_reg>
				  | (0 << ENC_BIT_DMAIE)  | (0 << ENC_BIT_LINKIE)
				  | (0 << ENC_BIT_TXIE)   | (0 << ENC_BIT_WOLIE)
				  | (0 << ENC_BIT_TXERIE) | (0 << ENC_BIT_RXERIE));

	// enable receive
	enc_setbits_reg( ENC_REG_ECON1, (1<<ENC_BIT_RXEN) );
    4c30:	8f e1       	ldi	r24, 0x1F	; 31
    4c32:	64 e0       	ldi	r22, 0x04	; 4
    4c34:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <enc_setbits_reg>

	// the enc interrupt on the atmega is still disabled
	// needs to get enabled with ETH_INT_ENABLE;
}
    4c38:	df 91       	pop	r29
    4c3a:	cf 91       	pop	r28
    4c3c:	1f 91       	pop	r17
    4c3e:	0f 91       	pop	r16
    4c40:	ff 90       	pop	r15
    4c42:	ef 90       	pop	r14
    4c44:	08 95       	ret

00004c46 <httpd_stack_clear>:
}

//----------------------------------------------------------------------------
//HTTPD_STACK lschen
void httpd_stack_clear (unsigned char index)
{
    4c46:	cf 93       	push	r28
    4c48:	df 93       	push	r29
	http_entry[index].http_header_type =0;
    4c4a:	90 e0       	ldi	r25, 0x00	; 0
    4c4c:	27 e2       	ldi	r18, 0x27	; 39
    4c4e:	30 e0       	ldi	r19, 0x00	; 0
    4c50:	82 9f       	mul	r24, r18
    4c52:	a0 01       	movw	r20, r0
    4c54:	83 9f       	mul	r24, r19
    4c56:	50 0d       	add	r21, r0
    4c58:	92 9f       	mul	r25, r18
    4c5a:	50 0d       	add	r21, r0
    4c5c:	11 24       	eor	r1, r1
    4c5e:	ae e9       	ldi	r26, 0x9E	; 158
    4c60:	bc e0       	ldi	r27, 0x0C	; 12
    4c62:	9d 01       	movw	r18, r26
    4c64:	24 0f       	add	r18, r20
    4c66:	35 1f       	adc	r19, r21
    4c68:	e9 01       	movw	r28, r18
    4c6a:	88 81       	ld	r24, Y
	http_entry[index].first_switch = 0;
    4c6c:	81 7f       	andi	r24, 0xF1	; 241
	http_entry[index].http_auth = HTTP_AUTH_DEFAULT;
    4c6e:	81 60       	ori	r24, 0x01	; 1
    4c70:	88 83       	st	Y, r24
	http_entry[index].new_page_pointer = 0;
    4c72:	18 97       	sbiw	r26, 0x08	; 8
    4c74:	fd 01       	movw	r30, r26
    4c76:	e4 0f       	add	r30, r20
    4c78:	f5 1f       	adc	r31, r21
    4c7a:	13 82       	std	Z+3, r1	; 0x03
    4c7c:	12 82       	std	Z+2, r1	; 0x02
	http_entry[index].old_page_pointer = 0;
    4c7e:	11 82       	std	Z+1, r1	; 0x01
    4c80:	10 82       	st	Z, r1
	http_entry[index].post = 0;
    4c82:	88 81       	ld	r24, Y
    4c84:	8f 7e       	andi	r24, 0xEF	; 239
    4c86:	88 83       	st	Y, r24
	http_entry[index].auth_ptr = http_auth_passwort;
    4c88:	82 e8       	ldi	r24, 0x82	; 130
    4c8a:	9c e0       	ldi	r25, 0x0C	; 12
    4c8c:	95 83       	std	Z+5, r25	; 0x05
    4c8e:	84 83       	std	Z+4, r24	; 0x04
	http_entry[index].post_ptr = post_in;
    4c90:	89 e3       	ldi	r24, 0x39	; 57
    4c92:	91 e0       	ldi	r25, 0x01	; 1
    4c94:	92 87       	std	Z+10, r25	; 0x0a
    4c96:	81 87       	std	Z+9, r24	; 0x09
	http_entry[index].post_ready_ptr = post_ready;
    4c98:	8e e3       	ldi	r24, 0x3E	; 62
    4c9a:	91 e0       	ldi	r25, 0x01	; 1
    4c9c:	94 87       	std	Z+12, r25	; 0x0c
    4c9e:	83 87       	std	Z+11, r24	; 0x0b
	http_entry[index].hdr_end_pointer = rx_header_end;
    4ca0:	83 e4       	ldi	r24, 0x43	; 67
    4ca2:	91 e0       	ldi	r25, 0x01	; 1
    4ca4:	97 83       	std	Z+7, r25	; 0x07
    4ca6:	86 83       	std	Z+6, r24	; 0x06
	#if USE_CAM
	http_entry[index].cam = 0;
	#endif //USE_CAM				
	#if USE_MMC
	http_entry[index].mmc = 0;
    4ca8:	1d 96       	adiw	r26, 0x0d	; 13
    4caa:	a4 0f       	add	r26, r20
    4cac:	b5 1f       	adc	r27, r21
    4cae:	8c 91       	ld	r24, X
    4cb0:	8e 7f       	andi	r24, 0xFE	; 254
    4cb2:	8c 93       	st	X, r24
	http_entry[index].charcount = 0;
    4cb4:	17 8e       	std	Z+31, r1	; 0x1f
    4cb6:	10 a2       	std	Z+32, r1	; 0x20
    4cb8:	11 a2       	std	Z+33, r1	; 0x21
    4cba:	12 a2       	std	Z+34, r1	; 0x22
	http_entry[index].old_charcount = 0;
    4cbc:	13 a2       	std	Z+35, r1	; 0x23
    4cbe:	14 a2       	std	Z+36, r1	; 0x24
    4cc0:	15 a2       	std	Z+37, r1	; 0x25
    4cc2:	16 a2       	std	Z+38, r1	; 0x26
	#endif //USE_MMC			
	HTTP_DEBUG("\r\n**** NEUE HTTP ANFORDERUNG ****\r\n\r\n");	
	return;
}
    4cc4:	df 91       	pop	r29
    4cc6:	cf 91       	pop	r28
    4cc8:	08 95       	ret

00004cca <httpd_data_send>:
 *	Daten Pakete an Client schicken
 *
 * @param[in] index in der TCP Tabelle tcp_entry
 */
void httpd_data_send (unsigned char index)
{	
    4cca:	2f 92       	push	r2
    4ccc:	3f 92       	push	r3
    4cce:	4f 92       	push	r4
    4cd0:	5f 92       	push	r5
    4cd2:	6f 92       	push	r6
    4cd4:	7f 92       	push	r7
    4cd6:	8f 92       	push	r8
    4cd8:	9f 92       	push	r9
    4cda:	af 92       	push	r10
    4cdc:	bf 92       	push	r11
    4cde:	cf 92       	push	r12
    4ce0:	df 92       	push	r13
    4ce2:	ef 92       	push	r14
    4ce4:	ff 92       	push	r15
    4ce6:	0f 93       	push	r16
    4ce8:	1f 93       	push	r17
    4cea:	df 93       	push	r29
    4cec:	cf 93       	push	r28
    4cee:	cd b7       	in	r28, 0x3d	; 61
    4cf0:	de b7       	in	r29, 0x3e	; 62
    4cf2:	c6 55       	subi	r28, 0x56	; 86
    4cf4:	d0 40       	sbci	r29, 0x00	; 0
    4cf6:	0f b6       	in	r0, 0x3f	; 63
    4cf8:	f8 94       	cli
    4cfa:	de bf       	out	0x3e, r29	; 62
    4cfc:	0f be       	out	0x3f, r0	; 63
    4cfe:	cd bf       	out	0x3d, r28	; 61
    4d00:	67 96       	adiw	r28, 0x17	; 23
    4d02:	8f af       	std	Y+63, r24	; 0x3f
    4d04:	67 97       	sbiw	r28, 0x17	; 23
	//Passwort wurde im Header nicht gefunden
	if(!http_entry[index].http_auth)
    4d06:	88 2e       	mov	r8, r24
    4d08:	99 24       	eor	r9, r9
    4d0a:	87 e2       	ldi	r24, 0x27	; 39
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	88 9e       	mul	r8, r24
    4d10:	90 01       	movw	r18, r0
    4d12:	89 9e       	mul	r8, r25
    4d14:	30 0d       	add	r19, r0
    4d16:	98 9e       	mul	r9, r24
    4d18:	30 0d       	add	r19, r0
    4d1a:	11 24       	eor	r1, r1
    4d1c:	f9 01       	movw	r30, r18
    4d1e:	e2 56       	subi	r30, 0x62	; 98
    4d20:	f3 4f       	sbci	r31, 0xF3	; 243
    4d22:	80 81       	ld	r24, Z
    4d24:	80 fd       	sbrc	r24, 0
    4d26:	07 c0       	rjmp	.+14     	; 0x4d36 <httpd_data_send+0x6c>
	{
		http_entry[index].new_page_pointer = Page0;
    4d28:	f9 01       	movw	r30, r18
    4d2a:	ea 56       	subi	r30, 0x6A	; 106
    4d2c:	f3 4f       	sbci	r31, 0xF3	; 243
    4d2e:	8f ed       	ldi	r24, 0xDF	; 223
    4d30:	95 e1       	ldi	r25, 0x15	; 21
    4d32:	93 83       	std	Z+3, r25	; 0x03
    4d34:	82 83       	std	Z+2, r24	; 0x02
		return;	
	}
	#endif //USE_CAM***************************************************************

	//kein Paket empfangen Retransmission des alten Paketes
	if (tcp_entry[index].status == 0) 
    4d36:	86 e1       	ldi	r24, 0x16	; 22
    4d38:	90 e0       	ldi	r25, 0x00	; 0
    4d3a:	88 9e       	mul	r8, r24
    4d3c:	f0 01       	movw	r30, r0
    4d3e:	89 9e       	mul	r8, r25
    4d40:	f0 0d       	add	r31, r0
    4d42:	98 9e       	mul	r9, r24
    4d44:	f0 0d       	add	r31, r0
    4d46:	11 24       	eor	r1, r1
    4d48:	ec 5a       	subi	r30, 0xAC	; 172
    4d4a:	f4 4f       	sbci	r31, 0xF4	; 244
    4d4c:	80 89       	ldd	r24, Z+16	; 0x10
    4d4e:	88 23       	and	r24, r24
    4d50:	21 f5       	brne	.+72     	; 0x4d9a <httpd_data_send+0xd0>
	{
		http_entry[index].new_page_pointer = http_entry[index].old_page_pointer;
    4d52:	87 e2       	ldi	r24, 0x27	; 39
    4d54:	90 e0       	ldi	r25, 0x00	; 0
    4d56:	88 9e       	mul	r8, r24
    4d58:	f0 01       	movw	r30, r0
    4d5a:	89 9e       	mul	r8, r25
    4d5c:	f0 0d       	add	r31, r0
    4d5e:	98 9e       	mul	r9, r24
    4d60:	f0 0d       	add	r31, r0
    4d62:	11 24       	eor	r1, r1
    4d64:	9f 01       	movw	r18, r30
    4d66:	2a 56       	subi	r18, 0x6A	; 106
    4d68:	33 4f       	sbci	r19, 0xF3	; 243
    4d6a:	d9 01       	movw	r26, r18
    4d6c:	8d 91       	ld	r24, X+
    4d6e:	9c 91       	ld	r25, X
    4d70:	11 97       	sbiw	r26, 0x01	; 1
    4d72:	13 96       	adiw	r26, 0x03	; 3
    4d74:	9c 93       	st	X, r25
    4d76:	8e 93       	st	-X, r24
    4d78:	12 97       	sbiw	r26, 0x02	; 2
		#if USE_MMC
		if (http_entry[index].mmc) {
    4d7a:	ed 55       	subi	r30, 0x5D	; 93
    4d7c:	f3 4f       	sbci	r31, 0xF3	; 243
    4d7e:	80 81       	ld	r24, Z
    4d80:	80 ff       	sbrs	r24, 0
    4d82:	0b c0       	rjmp	.+22     	; 0x4d9a <httpd_data_send+0xd0>
			 http_entry[index].charcount = http_entry[index].old_charcount;
    4d84:	93 96       	adiw	r26, 0x23	; 35
    4d86:	8d 91       	ld	r24, X+
    4d88:	9d 91       	ld	r25, X+
    4d8a:	0d 90       	ld	r0, X+
    4d8c:	bc 91       	ld	r27, X
    4d8e:	a0 2d       	mov	r26, r0
    4d90:	f9 01       	movw	r30, r18
    4d92:	87 8f       	std	Z+31, r24	; 0x1f
    4d94:	90 a3       	std	Z+32, r25	; 0x20
    4d96:	a1 a3       	std	Z+33, r26	; 0x21
    4d98:	b2 a3       	std	Z+34, r27	; 0x22
		}
		#endif
	}


	char *ptr = &eth_buffer[TCP_DATA_START_VAR];
    4d9a:	80 91 84 06 	lds	r24, 0x0684
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	80 7f       	andi	r24, 0xF0	; 240
    4da2:	90 70       	andi	r25, 0x00	; 0
    4da4:	95 95       	asr	r25
    4da6:	87 95       	ror	r24
    4da8:	95 95       	asr	r25
    4daa:	87 95       	ror	r24
    4dac:	88 58       	subi	r24, 0x88	; 136
    4dae:	99 4f       	sbci	r25, 0xF9	; 249
    4db0:	9a 83       	std	Y+2, r25	; 0x02
    4db2:	89 83       	std	Y+1, r24	; 0x01
	uint16_t len = 0;
	char buffer[81];
	uint16_t srclen = 0;
    4db4:	1c 82       	std	Y+4, r1	; 0x04
    4db6:	1b 82       	std	Y+3, r1	; 0x03

	#if USE_MMC
	if (http_entry[index].mmc) {	// falls Datei von SD-Karte
    4db8:	87 e2       	ldi	r24, 0x27	; 39
    4dba:	90 e0       	ldi	r25, 0x00	; 0
    4dbc:	88 9e       	mul	r8, r24
    4dbe:	80 01       	movw	r16, r0
    4dc0:	89 9e       	mul	r8, r25
    4dc2:	10 0d       	add	r17, r0
    4dc4:	98 9e       	mul	r9, r24
    4dc6:	10 0d       	add	r17, r0
    4dc8:	11 24       	eor	r1, r1
    4dca:	63 ea       	ldi	r22, 0xA3	; 163
    4dcc:	e6 2e       	mov	r14, r22
    4dce:	6c e0       	ldi	r22, 0x0C	; 12
    4dd0:	f6 2e       	mov	r15, r22
    4dd2:	e0 0e       	add	r14, r16
    4dd4:	f1 1e       	adc	r15, r17
    4dd6:	d7 01       	movw	r26, r14
    4dd8:	8c 91       	ld	r24, X
    4dda:	80 ff       	sbrs	r24, 0
    4ddc:	9a c0       	rjmp	.+308    	; 0x4f12 <httpd_data_send+0x248>
		/*
		** alte Pointer auf Datenanfang in Datei nachziehen
		*/
		http_entry[index].old_charcount = http_entry[index].charcount;
    4dde:	56 e9       	ldi	r21, 0x96	; 150
    4de0:	c5 2e       	mov	r12, r21
    4de2:	5c e0       	ldi	r21, 0x0C	; 12
    4de4:	d5 2e       	mov	r13, r21
    4de6:	c0 0e       	add	r12, r16
    4de8:	d1 1e       	adc	r13, r17
    4dea:	4f e1       	ldi	r20, 0x1F	; 31
    4dec:	64 2e       	mov	r6, r20
    4dee:	71 2c       	mov	r7, r1
    4df0:	6c 0c       	add	r6, r12
    4df2:	7d 1c       	adc	r7, r13
    4df4:	f6 01       	movw	r30, r12
    4df6:	87 8d       	ldd	r24, Z+31	; 0x1f
    4df8:	90 a1       	ldd	r25, Z+32	; 0x20
    4dfa:	a1 a1       	ldd	r26, Z+33	; 0x21
    4dfc:	b2 a1       	ldd	r27, Z+34	; 0x22
    4dfe:	83 a3       	std	Z+35, r24	; 0x23
    4e00:	94 a3       	std	Z+36, r25	; 0x24
    4e02:	a5 a3       	std	Z+37, r26	; 0x25
    4e04:	b6 a3       	std	Z+38, r27	; 0x26

		File *htmfile = f16_open((char *)http_entry[index].fname,"r");
    4e06:	c8 01       	movw	r24, r16
    4e08:	8c 55       	subi	r24, 0x5C	; 92
    4e0a:	93 4f       	sbci	r25, 0xF3	; 243
    4e0c:	68 e2       	ldi	r22, 0x28	; 40
    4e0e:	71 e0       	ldi	r23, 0x01	; 1
    4e10:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    4e14:	5c 01       	movw	r10, r24

		if (htmfile) {
    4e16:	00 97       	sbiw	r24, 0x00	; 0
    4e18:	09 f4       	brne	.+2      	; 0x4e1c <httpd_data_send+0x152>
    4e1a:	77 c0       	rjmp	.+238    	; 0x4f0a <httpd_data_send+0x240>
			f16_fseek(htmfile,http_entry[index].old_charcount,FAT16_SEEK_SET);
    4e1c:	d6 01       	movw	r26, r12
    4e1e:	93 96       	adiw	r26, 0x23	; 35
    4e20:	4d 91       	ld	r20, X+
    4e22:	5d 91       	ld	r21, X+
    4e24:	6d 91       	ld	r22, X+
    4e26:	7c 91       	ld	r23, X
    4e28:	96 97       	sbiw	r26, 0x26	; 38
    4e2a:	20 e0       	ldi	r18, 0x00	; 0
    4e2c:	0e 94 95 4c 	call	0x992a	; 0x992a <f16_fseek>

			if (http_entry[index].http_header_type == 0) {
    4e30:	f8 01       	movw	r30, r16
    4e32:	e2 56       	subi	r30, 0x62	; 98
    4e34:	f3 4f       	sbci	r31, 0xF3	; 243
    4e36:	80 81       	ld	r24, Z
    4e38:	86 95       	lsr	r24
    4e3a:	83 70       	andi	r24, 0x03	; 3
    4e3c:	b9 f5       	brne	.+110    	; 0x4eac <httpd_data_send+0x1e2>
    4e3e:	ee 24       	eor	r14, r14
    4e40:	ff 24       	eor	r15, r15
				// Datei zeilenweise lesen und vorhandene Variable ersetzen
				while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
					if ( f16_gets(buffer, sizeof(buffer), htmfile) == 0 ) {
    4e42:	35 e0       	ldi	r19, 0x05	; 5
    4e44:	c3 2e       	mov	r12, r19
    4e46:	d1 2c       	mov	r13, r1
    4e48:	cc 0e       	add	r12, r28
    4e4a:	dd 1e       	adc	r13, r29
						tcp_entry[index].app_status = 0xFFFD;
						break;
					}
					HTTP_DEBUG("\r\n>%3i|%s|<",sizeof(buffer),buffer);

					len += translate(buffer, &ptr, &srclen);
    4e4c:	23 e0       	ldi	r18, 0x03	; 3
    4e4e:	22 2e       	mov	r2, r18
    4e50:	31 2c       	mov	r3, r1
    4e52:	2c 0e       	add	r2, r28
    4e54:	3d 1e       	adc	r3, r29
    4e56:	2e 01       	movw	r4, r28
    4e58:	08 94       	sec
    4e5a:	41 1c       	adc	r4, r1
    4e5c:	51 1c       	adc	r5, r1
					http_entry[index].charcount += srclen;
    4e5e:	83 01       	movw	r16, r6
			f16_fseek(htmfile,http_entry[index].old_charcount,FAT16_SEEK_SET);

			if (http_entry[index].http_header_type == 0) {
				// Datei zeilenweise lesen und vorhandene Variable ersetzen
				while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
					if ( f16_gets(buffer, sizeof(buffer), htmfile) == 0 ) {
    4e60:	c6 01       	movw	r24, r12
    4e62:	61 e5       	ldi	r22, 0x51	; 81
    4e64:	70 e0       	ldi	r23, 0x00	; 0
    4e66:	a5 01       	movw	r20, r10
    4e68:	0e 94 4c 4c 	call	0x9898	; 0x9898 <f16_gets>
    4e6c:	89 2b       	or	r24, r25
    4e6e:	d1 f1       	breq	.+116    	; 0x4ee4 <httpd_data_send+0x21a>
						tcp_entry[index].app_status = 0xFFFD;
						break;
					}
					HTTP_DEBUG("\r\n>%3i|%s|<",sizeof(buffer),buffer);

					len += translate(buffer, &ptr, &srclen);
    4e70:	c6 01       	movw	r24, r12
    4e72:	b2 01       	movw	r22, r4
    4e74:	a1 01       	movw	r20, r2
    4e76:	0e 94 00 37 	call	0x6e00	; 0x6e00 <translate>
    4e7a:	e8 0e       	add	r14, r24
    4e7c:	f9 1e       	adc	r15, r25
					http_entry[index].charcount += srclen;
    4e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e80:	9c 81       	ldd	r25, Y+4	; 0x04
    4e82:	a0 e0       	ldi	r26, 0x00	; 0
    4e84:	b0 e0       	ldi	r27, 0x00	; 0
    4e86:	f8 01       	movw	r30, r16
    4e88:	20 81       	ld	r18, Z
    4e8a:	31 81       	ldd	r19, Z+1	; 0x01
    4e8c:	42 81       	ldd	r20, Z+2	; 0x02
    4e8e:	53 81       	ldd	r21, Z+3	; 0x03
    4e90:	82 0f       	add	r24, r18
    4e92:	93 1f       	adc	r25, r19
    4e94:	a4 1f       	adc	r26, r20
    4e96:	b5 1f       	adc	r27, r21
    4e98:	80 83       	st	Z, r24
    4e9a:	91 83       	std	Z+1, r25	; 0x01
    4e9c:	a2 83       	std	Z+2, r26	; 0x02
    4e9e:	b3 83       	std	Z+3, r27	; 0x03
		if (htmfile) {
			f16_fseek(htmfile,http_entry[index].old_charcount,FAT16_SEEK_SET);

			if (http_entry[index].http_header_type == 0) {
				// Datei zeilenweise lesen und vorhandene Variable ersetzen
				while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
    4ea0:	f6 e1       	ldi	r31, 0x16	; 22
    4ea2:	ef 16       	cp	r14, r31
    4ea4:	f4 e0       	ldi	r31, 0x04	; 4
    4ea6:	ff 06       	cpc	r15, r31
    4ea8:	d8 f2       	brcs	.-74     	; 0x4e60 <httpd_data_send+0x196>
    4eaa:	2b c0       	rjmp	.+86     	; 0x4f02 <httpd_data_send+0x238>
					http_entry[index].charcount += srclen;
				}
			}
			else {
				// keine .htm Datei -> kein translate!
				len = fat16_read_file(htmfile, (uint8_t*)ptr, MTU_SIZE-(TCP_DATA_START));
    4eac:	69 81       	ldd	r22, Y+1	; 0x01
    4eae:	7a 81       	ldd	r23, Y+2	; 0x02
    4eb0:	c5 01       	movw	r24, r10
    4eb2:	4a e7       	ldi	r20, 0x7A	; 122
    4eb4:	54 e0       	ldi	r21, 0x04	; 4
    4eb6:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <fat16_read_file>
    4eba:	7c 01       	movw	r14, r24
				http_entry[index].charcount += len;
    4ebc:	a0 e0       	ldi	r26, 0x00	; 0
    4ebe:	b0 e0       	ldi	r27, 0x00	; 0
    4ec0:	f6 01       	movw	r30, r12
    4ec2:	27 8d       	ldd	r18, Z+31	; 0x1f
    4ec4:	30 a1       	ldd	r19, Z+32	; 0x20
    4ec6:	41 a1       	ldd	r20, Z+33	; 0x21
    4ec8:	52 a1       	ldd	r21, Z+34	; 0x22
    4eca:	82 0f       	add	r24, r18
    4ecc:	93 1f       	adc	r25, r19
    4ece:	a4 1f       	adc	r26, r20
    4ed0:	b5 1f       	adc	r27, r21
    4ed2:	87 8f       	std	Z+31, r24	; 0x1f
    4ed4:	90 a3       	std	Z+32, r25	; 0x20
    4ed6:	a1 a3       	std	Z+33, r26	; 0x21
    4ed8:	b2 a3       	std	Z+34, r27	; 0x22
				if (len < MTU_SIZE-(TCP_DATA_START)) {
    4eda:	fa e7       	ldi	r31, 0x7A	; 122
    4edc:	ef 16       	cp	r14, r31
    4ede:	f4 e0       	ldi	r31, 0x04	; 4
    4ee0:	ff 06       	cpc	r15, r31
    4ee2:	78 f4       	brcc	.+30     	; 0x4f02 <httpd_data_send+0x238>
					// alles gelesen
					tcp_entry[index].app_status = 0xFFFD;
    4ee4:	86 e1       	ldi	r24, 0x16	; 22
    4ee6:	90 e0       	ldi	r25, 0x00	; 0
    4ee8:	88 9e       	mul	r8, r24
    4eea:	f0 01       	movw	r30, r0
    4eec:	89 9e       	mul	r8, r25
    4eee:	f0 0d       	add	r31, r0
    4ef0:	98 9e       	mul	r9, r24
    4ef2:	f0 0d       	add	r31, r0
    4ef4:	11 24       	eor	r1, r1
    4ef6:	ec 5a       	subi	r30, 0xAC	; 172
    4ef8:	f4 4f       	sbci	r31, 0xF4	; 244
    4efa:	8d ef       	ldi	r24, 0xFD	; 253
    4efc:	9f ef       	ldi	r25, 0xFF	; 255
    4efe:	92 8b       	std	Z+18, r25	; 0x12
    4f00:	81 8b       	std	Z+17, r24	; 0x11
				}
			}
			f16_close(htmfile);
    4f02:	c5 01       	movw	r24, r10
    4f04:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
    4f08:	06 c0       	rjmp	.+12     	; 0x4f16 <httpd_data_send+0x24c>
		}
		else {
			http_entry[index].mmc = false;
    4f0a:	d7 01       	movw	r26, r14
    4f0c:	8c 91       	ld	r24, X
    4f0e:	8e 7f       	andi	r24, 0xFE	; 254
    4f10:	8c 93       	st	X, r24
    4f12:	ee 24       	eor	r14, r14
    4f14:	ff 24       	eor	r15, r15
		}
	}

	if ( !http_entry[index].mmc) {	// falls Datei von Flash
    4f16:	87 e2       	ldi	r24, 0x27	; 39
    4f18:	90 e0       	ldi	r25, 0x00	; 0
    4f1a:	88 9e       	mul	r8, r24
    4f1c:	90 01       	movw	r18, r0
    4f1e:	89 9e       	mul	r8, r25
    4f20:	30 0d       	add	r19, r0
    4f22:	98 9e       	mul	r9, r24
    4f24:	30 0d       	add	r19, r0
    4f26:	11 24       	eor	r1, r1
    4f28:	f9 01       	movw	r30, r18
    4f2a:	ed 55       	subi	r30, 0x5D	; 93
    4f2c:	f3 4f       	sbci	r31, 0xF3	; 243
    4f2e:	80 81       	ld	r24, Z
    4f30:	80 fd       	sbrc	r24, 0
    4f32:	ba c0       	rjmp	.+372    	; 0x50a8 <httpd_data_send+0x3de>
	#endif

		/*
		** alte Pointer auf Datenanfang in Flash nachziehen
		*/
		http_entry[index].old_page_pointer = http_entry[index].new_page_pointer;
    4f34:	f9 01       	movw	r30, r18
    4f36:	ea 56       	subi	r30, 0x6A	; 106
    4f38:	f3 4f       	sbci	r31, 0xF3	; 243
    4f3a:	bf 01       	movw	r22, r30
    4f3c:	6e 5f       	subi	r22, 0xFE	; 254
    4f3e:	7f 4f       	sbci	r23, 0xFF	; 255
    4f40:	42 81       	ldd	r20, Z+2	; 0x02
    4f42:	53 81       	ldd	r21, Z+3	; 0x03
    4f44:	40 83       	st	Z, r20
    4f46:	51 83       	std	Z+1, r21	; 0x01


		if (http_entry[index].http_header_type == 0) {	// falls html mit Variablen
    4f48:	f9 01       	movw	r30, r18
    4f4a:	e2 56       	subi	r30, 0x62	; 98
    4f4c:	f3 4f       	sbci	r31, 0xF3	; 243
    4f4e:	80 81       	ld	r24, Z
    4f50:	86 95       	lsr	r24
    4f52:	83 70       	andi	r24, 0x03	; 3
    4f54:	09 f4       	brne	.+2      	; 0x4f58 <httpd_data_send+0x28e>
    4f56:	42 c0       	rjmp	.+132    	; 0x4fdc <httpd_data_send+0x312>
    4f58:	64 c0       	rjmp	.+200    	; 0x5022 <httpd_data_send+0x358>
			char *ptr2;

			while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
				memcpy_P(buffer, http_entry[index].new_page_pointer, sizeof(buffer)-1);
    4f5a:	f6 01       	movw	r30, r12
    4f5c:	60 81       	ld	r22, Z
    4f5e:	71 81       	ldd	r23, Z+1	; 0x01
    4f60:	c3 01       	movw	r24, r6
    4f62:	40 e5       	ldi	r20, 0x50	; 80
    4f64:	50 e0       	ldi	r21, 0x00	; 0
    4f66:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
				// Datei zeilenweise lesen und vorhandene Variable ersetzen
				// CRLF suchen
				if ( (ptr2 = strstr_P(buffer,PSTR("\r\n"))) ) {
    4f6a:	c3 01       	movw	r24, r6
    4f6c:	69 ef       	ldi	r22, 0xF9	; 249
    4f6e:	75 e1       	ldi	r23, 0x15	; 21
    4f70:	0e 94 24 6e 	call	0xdc48	; 0xdc48 <strstr_P>
    4f74:	fc 01       	movw	r30, r24
    4f76:	00 97       	sbiw	r24, 0x00	; 0
    4f78:	69 f0       	breq	.+26     	; 0x4f94 <httpd_data_send+0x2ca>
					*(ptr2+2) = 0;
    4f7a:	12 82       	std	Z+2, r1	; 0x02
					http_entry[index].new_page_pointer += (ptr2 - buffer + 2);
    4f7c:	e6 19       	sub	r30, r6
    4f7e:	f7 09       	sbc	r31, r7
    4f80:	32 96       	adiw	r30, 0x02	; 2
    4f82:	d6 01       	movw	r26, r12
    4f84:	8d 91       	ld	r24, X+
    4f86:	9c 91       	ld	r25, X
    4f88:	11 97       	sbiw	r26, 0x01	; 1
    4f8a:	8e 0f       	add	r24, r30
    4f8c:	9f 1f       	adc	r25, r31
    4f8e:	8d 93       	st	X+, r24
    4f90:	9c 93       	st	X, r25
    4f92:	0a c0       	rjmp	.+20     	; 0x4fa8 <httpd_data_send+0x2de>
				}
				else {
					buffer[80] = 0;
    4f94:	66 96       	adiw	r28, 0x16	; 22
    4f96:	1f ae       	std	Y+63, r1	; 0x3f
    4f98:	66 97       	sbiw	r28, 0x16	; 22
					http_entry[index].new_page_pointer += sizeof(buffer)-1;
    4f9a:	f6 01       	movw	r30, r12
    4f9c:	80 81       	ld	r24, Z
    4f9e:	91 81       	ldd	r25, Z+1	; 0x01
    4fa0:	80 5b       	subi	r24, 0xB0	; 176
    4fa2:	9f 4f       	sbci	r25, 0xFF	; 255
    4fa4:	91 83       	std	Z+1, r25	; 0x01
    4fa6:	80 83       	st	Z, r24
				}

				HTTP_DEBUG("\r\n>%i|%s|<",http_entry[index].new_page_pointer,buffer);
				// Ende-Marker vorhanden ?
				if ( (ptr2 = strstr_P(buffer,PSTR("%END"))) ) {
    4fa8:	c3 01       	movw	r24, r6
    4faa:	64 ef       	ldi	r22, 0xF4	; 244
    4fac:	75 e1       	ldi	r23, 0x15	; 21
    4fae:	0e 94 24 6e 	call	0xdc48	; 0xdc48 <strstr_P>
    4fb2:	8c 01       	movw	r16, r24
    4fb4:	00 97       	sbiw	r24, 0x00	; 0
    4fb6:	41 f0       	breq	.+16     	; 0x4fc8 <httpd_data_send+0x2fe>
					HTTP_DEBUG("\r\nFlash-Dateiende.");
					tcp_entry[index].app_status = 0xFFFD;
    4fb8:	ed ef       	ldi	r30, 0xFD	; 253
    4fba:	ff ef       	ldi	r31, 0xFF	; 255
    4fbc:	d5 01       	movw	r26, r10
    4fbe:	11 96       	adiw	r26, 0x01	; 1
    4fc0:	fc 93       	st	X, r31
    4fc2:	ee 93       	st	-X, r30
					*ptr2 = 0;
    4fc4:	dc 01       	movw	r26, r24
    4fc6:	1c 92       	st	X, r1
				}
				// vorhandene Variable ersetzen
				len += translate(buffer, &ptr, &srclen);
    4fc8:	c3 01       	movw	r24, r6
    4fca:	b2 01       	movw	r22, r4
    4fcc:	a1 01       	movw	r20, r2
    4fce:	0e 94 00 37 	call	0x6e00	; 0x6e00 <translate>
    4fd2:	e8 0e       	add	r14, r24
    4fd4:	f9 1e       	adc	r15, r25
				HTTP_DEBUG(" srclen: %3i; len: %i",srclen,len);
				if (ptr2)	// falls %END gefunden wurde -> Ende
    4fd6:	01 2b       	or	r16, r17
    4fd8:	e9 f0       	breq	.+58     	; 0x5014 <httpd_data_send+0x34a>
    4fda:	66 c0       	rjmp	.+204    	; 0x50a8 <httpd_data_send+0x3de>

		if (http_entry[index].http_header_type == 0) {	// falls html mit Variablen
			char *ptr2;

			while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
				memcpy_P(buffer, http_entry[index].new_page_pointer, sizeof(buffer)-1);
    4fdc:	95 e0       	ldi	r25, 0x05	; 5
    4fde:	69 2e       	mov	r6, r25
    4fe0:	71 2c       	mov	r7, r1
    4fe2:	6c 0e       	add	r6, r28
    4fe4:	7d 1e       	adc	r7, r29
    4fe6:	6b 01       	movw	r12, r22

				HTTP_DEBUG("\r\n>%i|%s|<",http_entry[index].new_page_pointer,buffer);
				// Ende-Marker vorhanden ?
				if ( (ptr2 = strstr_P(buffer,PSTR("%END"))) ) {
					HTTP_DEBUG("\r\nFlash-Dateiende.");
					tcp_entry[index].app_status = 0xFFFD;
    4fe8:	86 e1       	ldi	r24, 0x16	; 22
    4fea:	90 e0       	ldi	r25, 0x00	; 0
    4fec:	88 9e       	mul	r8, r24
    4fee:	50 01       	movw	r10, r0
    4ff0:	89 9e       	mul	r8, r25
    4ff2:	b0 0c       	add	r11, r0
    4ff4:	98 9e       	mul	r9, r24
    4ff6:	b0 0c       	add	r11, r0
    4ff8:	11 24       	eor	r1, r1
    4ffa:	e5 e6       	ldi	r30, 0x65	; 101
    4ffc:	fb e0       	ldi	r31, 0x0B	; 11
    4ffe:	ae 0e       	add	r10, r30
    5000:	bf 1e       	adc	r11, r31
					*ptr2 = 0;
				}
				// vorhandene Variable ersetzen
				len += translate(buffer, &ptr, &srclen);
    5002:	83 e0       	ldi	r24, 0x03	; 3
    5004:	28 2e       	mov	r2, r24
    5006:	31 2c       	mov	r3, r1
    5008:	2c 0e       	add	r2, r28
    500a:	3d 1e       	adc	r3, r29
    500c:	2e 01       	movw	r4, r28
    500e:	08 94       	sec
    5010:	41 1c       	adc	r4, r1
    5012:	51 1c       	adc	r5, r1


		if (http_entry[index].http_header_type == 0) {	// falls html mit Variablen
			char *ptr2;

			while ( len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
    5014:	f6 e1       	ldi	r31, 0x16	; 22
    5016:	ef 16       	cp	r14, r31
    5018:	f4 e0       	ldi	r31, 0x04	; 4
    501a:	ff 06       	cpc	r15, r31
    501c:	08 f4       	brcc	.+2      	; 0x5020 <httpd_data_send+0x356>
    501e:	9d cf       	rjmp	.-198    	; 0x4f5a <httpd_data_send+0x290>
    5020:	43 c0       	rjmp	.+134    	; 0x50a8 <httpd_data_send+0x3de>
					break;
			}
		}
		else {
			// umkopieren und auf %END suchen
			PGM_P src = http_entry[index].new_page_pointer;
    5022:	ca 01       	movw	r24, r20
    5024:	6c 01       	movw	r12, r24
    5026:	2e c0       	rjmp	.+92     	; 0x5084 <httpd_data_send+0x3ba>

			while (len < (MTU_SIZE-(TCP_DATA_START)) ) {
    5028:	f6 01       	movw	r30, r12
				*ptr = pgm_read_byte(src++);
    502a:	08 94       	sec
    502c:	c1 1c       	adc	r12, r1
    502e:	d1 1c       	adc	r13, r1
    5030:	e4 91       	lpm	r30, Z+
    5032:	a9 81       	ldd	r26, Y+1	; 0x01
    5034:	ba 81       	ldd	r27, Y+2	; 0x02
    5036:	ec 93       	st	X, r30
				if (*ptr == '%' ) {
    5038:	09 81       	ldd	r16, Y+1	; 0x01
    503a:	1a 81       	ldd	r17, Y+2	; 0x02
    503c:	d8 01       	movw	r26, r16
    503e:	8c 91       	ld	r24, X
    5040:	85 32       	cpi	r24, 0x25	; 37
    5042:	c9 f4       	brne	.+50     	; 0x5076 <httpd_data_send+0x3ac>
					if (strncasecmp_P("END",src,3)==0) {
    5044:	8a e2       	ldi	r24, 0x2A	; 42
    5046:	91 e0       	ldi	r25, 0x01	; 1
    5048:	b6 01       	movw	r22, r12
    504a:	43 e0       	ldi	r20, 0x03	; 3
    504c:	50 e0       	ldi	r21, 0x00	; 0
    504e:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    5052:	89 2b       	or	r24, r25
    5054:	81 f4       	brne	.+32     	; 0x5076 <httpd_data_send+0x3ac>
						HTTP_DEBUG("\r\nFlash-Dateiende.");
						tcp_entry[index].app_status = 0xFFFD;
    5056:	86 e1       	ldi	r24, 0x16	; 22
    5058:	90 e0       	ldi	r25, 0x00	; 0
    505a:	88 9e       	mul	r8, r24
    505c:	f0 01       	movw	r30, r0
    505e:	89 9e       	mul	r8, r25
    5060:	f0 0d       	add	r31, r0
    5062:	98 9e       	mul	r9, r24
    5064:	f0 0d       	add	r31, r0
    5066:	11 24       	eor	r1, r1
    5068:	ec 5a       	subi	r30, 0xAC	; 172
    506a:	f4 4f       	sbci	r31, 0xF4	; 244
    506c:	8d ef       	ldi	r24, 0xFD	; 253
    506e:	9f ef       	ldi	r25, 0xFF	; 255
    5070:	92 8b       	std	Z+18, r25	; 0x12
    5072:	81 8b       	std	Z+17, r24	; 0x11
    5074:	0c c0       	rjmp	.+24     	; 0x508e <httpd_data_send+0x3c4>
						// --src;	// unntig, da sowieso Datenende
						break;
					}
				}
				++len;	// zu sendende Zeichen hochzhlen
    5076:	08 94       	sec
    5078:	e1 1c       	adc	r14, r1
    507a:	f1 1c       	adc	r15, r1
				++ptr;
    507c:	0f 5f       	subi	r16, 0xFF	; 255
    507e:	1f 4f       	sbci	r17, 0xFF	; 255
    5080:	1a 83       	std	Y+2, r17	; 0x02
    5082:	09 83       	std	Y+1, r16	; 0x01
		}
		else {
			// umkopieren und auf %END suchen
			PGM_P src = http_entry[index].new_page_pointer;

			while (len < (MTU_SIZE-(TCP_DATA_START)) ) {
    5084:	ba e7       	ldi	r27, 0x7A	; 122
    5086:	eb 16       	cp	r14, r27
    5088:	b4 e0       	ldi	r27, 0x04	; 4
    508a:	fb 06       	cpc	r15, r27
    508c:	68 f2       	brcs	.-102    	; 0x5028 <httpd_data_send+0x35e>
					}
				}
				++len;	// zu sendende Zeichen hochzhlen
				++ptr;
			}
			http_entry[index].new_page_pointer = src;
    508e:	87 e2       	ldi	r24, 0x27	; 39
    5090:	90 e0       	ldi	r25, 0x00	; 0
    5092:	88 9e       	mul	r8, r24
    5094:	f0 01       	movw	r30, r0
    5096:	89 9e       	mul	r8, r25
    5098:	f0 0d       	add	r31, r0
    509a:	98 9e       	mul	r9, r24
    509c:	f0 0d       	add	r31, r0
    509e:	11 24       	eor	r1, r1
    50a0:	ea 56       	subi	r30, 0x6A	; 106
    50a2:	f3 4f       	sbci	r31, 0xF3	; 243
    50a4:	d3 82       	std	Z+3, r13	; 0x03
    50a6:	c2 82       	std	Z+2, r12	; 0x02
	//	*ptr = 0;
	HTTP_DEBUG("\r\n>|%s|< (length %i; new_ptr %i; old_ptr %i)",
							&eth_buffer[TCP_DATA_START_VAR],
							len,http_entry[index].new_page_pointer,buffer,
							http_entry[index].old_page_pointer);
	tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    50a8:	86 e1       	ldi	r24, 0x16	; 22
    50aa:	90 e0       	ldi	r25, 0x00	; 0
    50ac:	88 9e       	mul	r8, r24
    50ae:	f0 01       	movw	r30, r0
    50b0:	89 9e       	mul	r8, r25
    50b2:	f0 0d       	add	r31, r0
    50b4:	98 9e       	mul	r9, r24
    50b6:	f0 0d       	add	r31, r0
    50b8:	11 24       	eor	r1, r1
    50ba:	ec 5a       	subi	r30, 0xAC	; 172
    50bc:	f4 4f       	sbci	r31, 0xF4	; 244
    50be:	88 e1       	ldi	r24, 0x18	; 24
    50c0:	80 8b       	std	Z+16, r24	; 0x10
	create_new_tcp_packet(len,index);
    50c2:	c7 01       	movw	r24, r14
    50c4:	67 96       	adiw	r28, 0x17	; 23
    50c6:	6f ad       	ldd	r22, Y+63	; 0x3f
    50c8:	67 97       	sbiw	r28, 0x17	; 23
    50ca:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
	return;
}
    50ce:	ca 5a       	subi	r28, 0xAA	; 170
    50d0:	df 4f       	sbci	r29, 0xFF	; 255
    50d2:	0f b6       	in	r0, 0x3f	; 63
    50d4:	f8 94       	cli
    50d6:	de bf       	out	0x3e, r29	; 62
    50d8:	0f be       	out	0x3f, r0	; 63
    50da:	cd bf       	out	0x3d, r28	; 61
    50dc:	cf 91       	pop	r28
    50de:	df 91       	pop	r29
    50e0:	1f 91       	pop	r17
    50e2:	0f 91       	pop	r16
    50e4:	ff 90       	pop	r15
    50e6:	ef 90       	pop	r14
    50e8:	df 90       	pop	r13
    50ea:	cf 90       	pop	r12
    50ec:	bf 90       	pop	r11
    50ee:	af 90       	pop	r10
    50f0:	9f 90       	pop	r9
    50f2:	8f 90       	pop	r8
    50f4:	7f 90       	pop	r7
    50f6:	6f 90       	pop	r6
    50f8:	5f 90       	pop	r5
    50fa:	4f 90       	pop	r4
    50fc:	3f 90       	pop	r3
    50fe:	2f 90       	pop	r2
    5100:	08 95       	ret

00005102 <httpd_header_check>:
 *	Eintreffenden Header vom Client checken
 *
 * @param[in] index in der TCP Tabelle tcp_entry
 */
void httpd_header_check (unsigned char index)
{
    5102:	2f 92       	push	r2
    5104:	3f 92       	push	r3
    5106:	4f 92       	push	r4
    5108:	5f 92       	push	r5
    510a:	6f 92       	push	r6
    510c:	7f 92       	push	r7
    510e:	8f 92       	push	r8
    5110:	9f 92       	push	r9
    5112:	af 92       	push	r10
    5114:	bf 92       	push	r11
    5116:	cf 92       	push	r12
    5118:	df 92       	push	r13
    511a:	ef 92       	push	r14
    511c:	ff 92       	push	r15
    511e:	0f 93       	push	r16
    5120:	1f 93       	push	r17
    5122:	df 93       	push	r29
    5124:	cf 93       	push	r28
    5126:	cd b7       	in	r28, 0x3d	; 61
    5128:	de b7       	in	r29, 0x3e	; 62
    512a:	2e 97       	sbiw	r28, 0x0e	; 14
    512c:	0f b6       	in	r0, 0x3f	; 63
    512e:	f8 94       	cli
    5130:	de bf       	out	0x3e, r29	; 62
    5132:	0f be       	out	0x3f, r0	; 63
    5134:	cd bf       	out	0x3d, r28	; 61
    5136:	58 2e       	mov	r5, r24
	unsigned int a = 0;
	
	if(strcasestr_P((char*)&eth_buffer[TCP_DATA_START_VAR],PSTR("POST"))!=0)
    5138:	80 91 84 06 	lds	r24, 0x0684
    513c:	e8 2e       	mov	r14, r24
    513e:	ff 24       	eor	r15, r15
    5140:	80 ef       	ldi	r24, 0xF0	; 240
    5142:	e8 22       	and	r14, r24
    5144:	ff 24       	eor	r15, r15
    5146:	f5 94       	asr	r15
    5148:	e7 94       	ror	r14
    514a:	f5 94       	asr	r15
    514c:	e7 94       	ror	r14
    514e:	c7 01       	movw	r24, r14
    5150:	88 58       	subi	r24, 0x88	; 136
    5152:	99 4f       	sbci	r25, 0xF9	; 249
    5154:	6d e1       	ldi	r22, 0x1D	; 29
    5156:	76 e1       	ldi	r23, 0x16	; 22
    5158:	0e 94 61 6e 	call	0xdcc2	; 0xdcc2 <strcasestr_P>
    515c:	89 2b       	or	r24, r25
    515e:	81 f0       	breq	.+32     	; 0x5180 <httpd_header_check+0x7e>
		{
		http_entry[index].post = 1;
    5160:	25 2d       	mov	r18, r5
    5162:	30 e0       	ldi	r19, 0x00	; 0
    5164:	87 e2       	ldi	r24, 0x27	; 39
    5166:	90 e0       	ldi	r25, 0x00	; 0
    5168:	28 9f       	mul	r18, r24
    516a:	f0 01       	movw	r30, r0
    516c:	29 9f       	mul	r18, r25
    516e:	f0 0d       	add	r31, r0
    5170:	38 9f       	mul	r19, r24
    5172:	f0 0d       	add	r31, r0
    5174:	11 24       	eor	r1, r1
    5176:	e2 56       	subi	r30, 0x62	; 98
    5178:	f3 4f       	sbci	r31, 0xF3	; 243
    517a:	80 81       	ld	r24, Z
    517c:	80 61       	ori	r24, 0x10	; 16
    517e:	80 83       	st	Z, r24
		}
	
	//finden der Authorization und das Ende im Header auch ber mehrere Pakete hinweg!!	
	if(*http_entry[index].hdr_end_pointer != 0)
    5180:	85 2c       	mov	r8, r5
    5182:	99 24       	eor	r9, r9
    5184:	87 e2       	ldi	r24, 0x27	; 39
    5186:	90 e0       	ldi	r25, 0x00	; 0
    5188:	88 9e       	mul	r8, r24
    518a:	a0 01       	movw	r20, r0
    518c:	89 9e       	mul	r8, r25
    518e:	50 0d       	add	r21, r0
    5190:	98 9e       	mul	r9, r24
    5192:	50 0d       	add	r21, r0
    5194:	11 24       	eor	r1, r1
    5196:	da 01       	movw	r26, r20
    5198:	aa 56       	subi	r26, 0x6A	; 106
    519a:	b3 4f       	sbci	r27, 0xF3	; 243
    519c:	bd 01       	movw	r22, r26
    519e:	6a 5f       	subi	r22, 0xFA	; 250
    51a0:	7f 4f       	sbci	r23, 0xFF	; 255
    51a2:	16 96       	adiw	r26, 0x06	; 6
    51a4:	ed 91       	ld	r30, X+
    51a6:	fc 91       	ld	r31, X
    51a8:	17 97       	sbiw	r26, 0x07	; 7
    51aa:	80 81       	ld	r24, Z
    51ac:	88 23       	and	r24, r24
    51ae:	19 f4       	brne	.+6      	; 0x51b6 <httpd_header_check+0xb4>
    51b0:	aa 24       	eor	r10, r10
    51b2:	bb 24       	eor	r11, r11
    51b4:	5b c0       	rjmp	.+182    	; 0x526c <httpd_header_check+0x16a>
	{		
		for(a=TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    51b6:	12 e2       	ldi	r17, 0x22	; 34
    51b8:	a1 2e       	mov	r10, r17
    51ba:	b1 2c       	mov	r11, r1
    51bc:	ae 0c       	add	r10, r14
    51be:	bf 1c       	adc	r11, r15
    51c0:	80 91 67 06 	lds	r24, 0x0667
    51c4:	28 2f       	mov	r18, r24
    51c6:	30 e0       	ldi	r19, 0x00	; 0
    51c8:	2e 5d       	subi	r18, 0xDE	; 222
    51ca:	3f 4f       	sbci	r19, 0xFF	; 255
    51cc:	90 91 66 06 	lds	r25, 0x0666
    51d0:	80 e0       	ldi	r24, 0x00	; 0
    51d2:	28 0f       	add	r18, r24
    51d4:	39 1f       	adc	r19, r25
    51d6:	2e 19       	sub	r18, r14
    51d8:	3f 09       	sbc	r19, r15
    51da:	85 01       	movw	r16, r10
    51dc:	0a 5a       	subi	r16, 0xAA	; 170
    51de:	19 4f       	sbci	r17, 0xF9	; 249
		{	
			HTTP_DEBUG("%c",eth_buffer[a]);
			
			if(!http_entry[index].http_auth) 
    51e0:	42 56       	subi	r20, 0x62	; 98
    51e2:	53 4f       	sbci	r21, 0xF3	; 243
			{
				if (eth_buffer[a] != *http_entry[index].auth_ptr++)
    51e4:	14 96       	adiw	r26, 0x04	; 4
				{
					http_entry[index].auth_ptr = http_auth_passwort;
    51e6:	f2 e8       	ldi	r31, 0x82	; 130
    51e8:	6f 2e       	mov	r6, r31
    51ea:	fc e0       	ldi	r31, 0x0C	; 12
    51ec:	7f 2e       	mov	r7, r31
				}
			}
			
			if (eth_buffer[a] != *http_entry[index].hdr_end_pointer++)
			{
				http_entry[index].hdr_end_pointer = rx_header_end;
    51ee:	e3 e4       	ldi	r30, 0x43	; 67
    51f0:	ce 2e       	mov	r12, r30
    51f2:	e1 e0       	ldi	r30, 0x01	; 1
    51f4:	de 2e       	mov	r13, r30
    51f6:	37 c0       	rjmp	.+110    	; 0x5266 <httpd_header_check+0x164>
	{		
		for(a=TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
		{	
			HTTP_DEBUG("%c",eth_buffer[a]);
			
			if(!http_entry[index].http_auth) 
    51f8:	fa 01       	movw	r30, r20
    51fa:	80 81       	ld	r24, Z
    51fc:	80 fd       	sbrc	r24, 0
    51fe:	18 c0       	rjmp	.+48     	; 0x5230 <httpd_header_check+0x12e>
			{
				if (eth_buffer[a] != *http_entry[index].auth_ptr++)
    5200:	f8 01       	movw	r30, r16
    5202:	80 81       	ld	r24, Z
    5204:	ed 91       	ld	r30, X+
    5206:	fc 91       	ld	r31, X
    5208:	11 97       	sbiw	r26, 0x01	; 1
    520a:	91 91       	ld	r25, Z+
    520c:	11 96       	adiw	r26, 0x01	; 1
    520e:	fc 93       	st	X, r31
    5210:	ee 93       	st	-X, r30
    5212:	89 17       	cp	r24, r25
    5214:	19 f0       	breq	.+6      	; 0x521c <httpd_header_check+0x11a>
				{
					http_entry[index].auth_ptr = http_auth_passwort;
    5216:	11 96       	adiw	r26, 0x01	; 1
    5218:	7c 92       	st	X, r7
    521a:	6e 92       	st	-X, r6
				}
				if(*http_entry[index].auth_ptr == 0) 
    521c:	ed 91       	ld	r30, X+
    521e:	fc 91       	ld	r31, X
    5220:	11 97       	sbiw	r26, 0x01	; 1
    5222:	80 81       	ld	r24, Z
    5224:	88 23       	and	r24, r24
    5226:	21 f4       	brne	.+8      	; 0x5230 <httpd_header_check+0x12e>
				{
					http_entry[index].http_auth = 1;
    5228:	fa 01       	movw	r30, r20
    522a:	80 81       	ld	r24, Z
    522c:	81 60       	ori	r24, 0x01	; 1
    522e:	80 83       	st	Z, r24
					HTTP_DEBUG("  <---LOGIN OK!--->\r\n");
				}
			}
			
			if (eth_buffer[a] != *http_entry[index].hdr_end_pointer++)
    5230:	f8 01       	movw	r30, r16
    5232:	80 81       	ld	r24, Z
    5234:	fb 01       	movw	r30, r22
    5236:	20 80       	ld	r2, Z
    5238:	31 80       	ldd	r3, Z+1	; 0x01
    523a:	f1 01       	movw	r30, r2
    523c:	91 91       	ld	r25, Z+
    523e:	1f 01       	movw	r2, r30
    5240:	fb 01       	movw	r30, r22
    5242:	31 82       	std	Z+1, r3	; 0x01
    5244:	20 82       	st	Z, r2
    5246:	89 17       	cp	r24, r25
    5248:	11 f0       	breq	.+4      	; 0x524e <httpd_header_check+0x14c>
			{
				http_entry[index].hdr_end_pointer = rx_header_end;
    524a:	d1 82       	std	Z+1, r13	; 0x01
    524c:	c0 82       	st	Z, r12
    524e:	0f 5f       	subi	r16, 0xFF	; 255
    5250:	1f 4f       	sbci	r17, 0xFF	; 255
			}
			
			//Das Headerende wird mit (CR+LF+CR+LF) angezeigt!
			if(*http_entry[index].hdr_end_pointer == 0) 
    5252:	fb 01       	movw	r30, r22
    5254:	80 81       	ld	r24, Z
    5256:	91 81       	ldd	r25, Z+1	; 0x01
    5258:	fc 01       	movw	r30, r24
    525a:	80 81       	ld	r24, Z
    525c:	88 23       	and	r24, r24
    525e:	31 f0       	breq	.+12     	; 0x526c <httpd_header_check+0x16a>
		}
	
	//finden der Authorization und das Ende im Header auch ber mehrere Pakete hinweg!!	
	if(*http_entry[index].hdr_end_pointer != 0)
	{		
		for(a=TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    5260:	08 94       	sec
    5262:	a1 1c       	adc	r10, r1
    5264:	b1 1c       	adc	r11, r1
    5266:	a2 16       	cp	r10, r18
    5268:	b3 06       	cpc	r11, r19
    526a:	30 f2       	brcs	.-116    	; 0x51f8 <httpd_header_check+0xf6>
			}
		}
	}
	
	//Einzelnes Postpaket (z.B. bei firefox)
	if(http_entry[index].http_auth && http_entry[index].post == 1)
    526c:	87 e2       	ldi	r24, 0x27	; 39
    526e:	90 e0       	ldi	r25, 0x00	; 0
    5270:	88 9e       	mul	r8, r24
    5272:	a0 01       	movw	r20, r0
    5274:	89 9e       	mul	r8, r25
    5276:	50 0d       	add	r21, r0
    5278:	98 9e       	mul	r9, r24
    527a:	50 0d       	add	r21, r0
    527c:	11 24       	eor	r1, r1
    527e:	fa 01       	movw	r30, r20
    5280:	e2 56       	subi	r30, 0x62	; 98
    5282:	f3 4f       	sbci	r31, 0xF3	; 243
    5284:	e0 81       	ld	r30, Z
    5286:	e0 ff       	sbrs	r30, 0
    5288:	87 c0       	rjmp	.+270    	; 0x5398 <httpd_header_check+0x296>
    528a:	e4 ff       	sbrs	r30, 4
    528c:	85 c0       	rjmp	.+266    	; 0x5398 <httpd_header_check+0x296>
	{
		PORT_tmp = PORTA;	// aktuellen Status einlesen
    528e:	82 b1       	in	r24, 0x02	; 2
    5290:	80 93 15 02 	sts	0x0215, r24

		for(a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    5294:	62 e2       	ldi	r22, 0x22	; 34
    5296:	a6 2e       	mov	r10, r22
    5298:	b1 2c       	mov	r11, r1
    529a:	ae 0c       	add	r10, r14
    529c:	bf 1c       	adc	r11, r15
    529e:	80 91 67 06 	lds	r24, 0x0667
    52a2:	28 2f       	mov	r18, r24
    52a4:	30 e0       	ldi	r19, 0x00	; 0
    52a6:	2e 5d       	subi	r18, 0xDE	; 222
    52a8:	3f 4f       	sbci	r19, 0xFF	; 255
    52aa:	90 91 66 06 	lds	r25, 0x0666
    52ae:	80 e0       	ldi	r24, 0x00	; 0
    52b0:	28 0f       	add	r18, r24
    52b2:	39 1f       	adc	r19, r25
    52b4:	2e 19       	sub	r18, r14
    52b6:	3f 09       	sbc	r19, r15
    52b8:	b5 01       	movw	r22, r10
    52ba:	6a 5a       	subi	r22, 0xAA	; 170
    52bc:	79 4f       	sbci	r23, 0xF9	; 249
		{	
			//Schaltanweisung finden!
			if (eth_buffer[a] != *http_entry[index].post_ptr++)
    52be:	8a 01       	movw	r16, r20
    52c0:	ca 01       	movw	r24, r20
    52c2:	8a 56       	subi	r24, 0x6A	; 106
    52c4:	93 4f       	sbci	r25, 0xF3	; 243
    52c6:	dc 01       	movw	r26, r24
    52c8:	19 96       	adiw	r26, 0x09	; 9
			{
				http_entry[index].post_ptr = post_in;
    52ca:	59 e3       	ldi	r21, 0x39	; 57
    52cc:	c5 2e       	mov	r12, r21
    52ce:	51 e0       	ldi	r21, 0x01	; 1
    52d0:	d5 2e       	mov	r13, r21
					  PORT_tmp |= (1<<1);	// setzt Ausgang
				      break;
				
				    case ('C'):
					  PORT_tmp |= (1<<2);			// setzt Ausgang
					  machineStatus.Timer1 = 20;	// und timer, der in mainloop runtergezhlt wird
    52d2:	44 e1       	ldi	r20, 0x14	; 20
    52d4:	34 2e       	mov	r3, r20
			if(*http_entry[index].post_ptr == 0) 
			{
				switch (eth_buffer[a+1])
				  {
				    case ('A'):
					  PORT_tmp ^= (1<<0);	// toggle
    52d6:	44 24       	eor	r4, r4
    52d8:	43 94       	inc	r4
				http_entry[index].post_ptr = post_in;
				//Schaltanweisung wurde gefunden
			}
		
			//Submit schliet die suche ab!
			if (eth_buffer[a] != *http_entry[index].post_ready_ptr++)
    52da:	ac 01       	movw	r20, r24
    52dc:	45 5f       	subi	r20, 0xF5	; 245
    52de:	5f 4f       	sbci	r21, 0xFF	; 255
    52e0:	57 c0       	rjmp	.+174    	; 0x5390 <httpd_header_check+0x28e>
		PORT_tmp = PORTA;	// aktuellen Status einlesen

		for(a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
		{	
			//Schaltanweisung finden!
			if (eth_buffer[a] != *http_entry[index].post_ptr++)
    52e2:	fb 01       	movw	r30, r22
    52e4:	90 81       	ld	r25, Z
    52e6:	ed 91       	ld	r30, X+
    52e8:	fc 91       	ld	r31, X
    52ea:	11 97       	sbiw	r26, 0x01	; 1
    52ec:	81 91       	ld	r24, Z+
    52ee:	11 96       	adiw	r26, 0x01	; 1
    52f0:	fc 93       	st	X, r31
    52f2:	ee 93       	st	-X, r30
    52f4:	98 17       	cp	r25, r24
    52f6:	19 f0       	breq	.+6      	; 0x52fe <httpd_header_check+0x1fc>
			{
				http_entry[index].post_ptr = post_in;
    52f8:	11 96       	adiw	r26, 0x01	; 1
    52fa:	dc 92       	st	X, r13
    52fc:	ce 92       	st	-X, r12
			}
			if(*http_entry[index].post_ptr == 0) 
    52fe:	ed 91       	ld	r30, X+
    5300:	fc 91       	ld	r31, X
    5302:	11 97       	sbiw	r26, 0x01	; 1
    5304:	80 81       	ld	r24, Z
    5306:	88 23       	and	r24, r24
    5308:	e1 f4       	brne	.+56     	; 0x5342 <httpd_header_check+0x240>
			{
				switch (eth_buffer[a+1])
    530a:	fb 01       	movw	r30, r22
    530c:	81 81       	ldd	r24, Z+1	; 0x01
    530e:	82 34       	cpi	r24, 0x42	; 66
    5310:	41 f0       	breq	.+16     	; 0x5322 <httpd_header_check+0x220>
    5312:	83 34       	cpi	r24, 0x43	; 67
    5314:	61 f0       	breq	.+24     	; 0x532e <httpd_header_check+0x22c>
    5316:	81 34       	cpi	r24, 0x41	; 65
    5318:	89 f4       	brne	.+34     	; 0x533c <httpd_header_check+0x23a>
				  {
				    case ('A'):
					  PORT_tmp ^= (1<<0);	// toggle
    531a:	80 91 15 02 	lds	r24, 0x0215
    531e:	84 25       	eor	r24, r4
    5320:	03 c0       	rjmp	.+6      	; 0x5328 <httpd_header_check+0x226>
				      break;
				
				    case ('B'):
					  PORT_tmp |= (1<<1);	// setzt Ausgang
    5322:	80 91 15 02 	lds	r24, 0x0215
    5326:	82 60       	ori	r24, 0x02	; 2
    5328:	80 93 15 02 	sts	0x0215, r24
    532c:	07 c0       	rjmp	.+14     	; 0x533c <httpd_header_check+0x23a>
				      break;
				
				    case ('C'):
					  PORT_tmp |= (1<<2);			// setzt Ausgang
    532e:	80 91 15 02 	lds	r24, 0x0215
    5332:	84 60       	ori	r24, 0x04	; 4
    5334:	80 93 15 02 	sts	0x0215, r24
					  machineStatus.Timer1 = 20;	// und timer, der in mainloop runtergezhlt wird
    5338:	30 92 48 06 	sts	0x0648, r3
					**
					** Bereits verwendete Zeichen siehe oben bei den case-Statements.
					*/

				  }
				http_entry[index].post_ptr = post_in;
    533c:	11 96       	adiw	r26, 0x01	; 1
    533e:	dc 92       	st	X, r13
    5340:	ce 92       	st	-X, r12
				//Schaltanweisung wurde gefunden
			}
		
			//Submit schliet die suche ab!
			if (eth_buffer[a] != *http_entry[index].post_ready_ptr++)
    5342:	fa 01       	movw	r30, r20
    5344:	01 90       	ld	r0, Z+
    5346:	f0 81       	ld	r31, Z
    5348:	e0 2d       	mov	r30, r0
    534a:	81 91       	ld	r24, Z+
    534c:	3f 01       	movw	r6, r30
    534e:	fa 01       	movw	r30, r20
    5350:	71 82       	std	Z+1, r7	; 0x01
    5352:	60 82       	st	Z, r6
    5354:	98 17       	cp	r25, r24
    5356:	21 f0       	breq	.+8      	; 0x5360 <httpd_header_check+0x25e>
			{
				http_entry[index].post_ready_ptr = post_ready;
    5358:	8e e3       	ldi	r24, 0x3E	; 62
    535a:	91 e0       	ldi	r25, 0x01	; 1
    535c:	91 83       	std	Z+1, r25	; 0x01
    535e:	80 83       	st	Z, r24
    5360:	6f 5f       	subi	r22, 0xFF	; 255
    5362:	7f 4f       	sbci	r23, 0xFF	; 255
			}
			if(*http_entry[index].post_ready_ptr == 0) 
    5364:	fa 01       	movw	r30, r20
    5366:	80 81       	ld	r24, Z
    5368:	91 81       	ldd	r25, Z+1	; 0x01
    536a:	fc 01       	movw	r30, r24
    536c:	80 81       	ld	r24, Z
    536e:	88 23       	and	r24, r24
    5370:	61 f4       	brne	.+24     	; 0x538a <httpd_header_check+0x288>
			{
				http_entry[index].post = 0;
    5372:	f8 01       	movw	r30, r16
    5374:	e2 56       	subi	r30, 0x62	; 98
    5376:	f3 4f       	sbci	r31, 0xF3	; 243
    5378:	80 81       	ld	r24, Z
    537a:	8f 7e       	andi	r24, 0xEF	; 239
    537c:	80 83       	st	Z, r24
				PORTA = PORT_tmp;
    537e:	80 91 15 02 	lds	r24, 0x0215
    5382:	82 b9       	out	0x02, r24	; 2
                PORT_tmp = 0;
    5384:	10 92 15 02 	sts	0x0215, r1
    5388:	07 c0       	rjmp	.+14     	; 0x5398 <httpd_header_check+0x296>
	//Einzelnes Postpaket (z.B. bei firefox)
	if(http_entry[index].http_auth && http_entry[index].post == 1)
	{
		PORT_tmp = PORTA;	// aktuellen Status einlesen

		for(a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    538a:	08 94       	sec
    538c:	a1 1c       	adc	r10, r1
    538e:	b1 1c       	adc	r11, r1
    5390:	a2 16       	cp	r10, r18
    5392:	b3 06       	cpc	r11, r19
    5394:	08 f4       	brcc	.+2      	; 0x5398 <httpd_header_check+0x296>
    5396:	a5 cf       	rjmp	.-182    	; 0x52e2 <httpd_header_check+0x1e0>
	}	
	
	//Welche datei wird angefordert? Wird diese in der Flashspeichertabelle gefunden?
	unsigned char page_index = 0;
	
	if (!http_entry[index].new_page_pointer
    5398:	87 e2       	ldi	r24, 0x27	; 39
    539a:	90 e0       	ldi	r25, 0x00	; 0
    539c:	88 9e       	mul	r8, r24
    539e:	90 01       	movw	r18, r0
    53a0:	89 9e       	mul	r8, r25
    53a2:	30 0d       	add	r19, r0
    53a4:	98 9e       	mul	r9, r24
    53a6:	30 0d       	add	r19, r0
    53a8:	11 24       	eor	r1, r1
    53aa:	f9 01       	movw	r30, r18
    53ac:	ea 56       	subi	r30, 0x6A	; 106
    53ae:	f3 4f       	sbci	r31, 0xF3	; 243
    53b0:	82 81       	ldd	r24, Z+2	; 0x02
    53b2:	93 81       	ldd	r25, Z+3	; 0x03
    53b4:	89 2b       	or	r24, r25
    53b6:	09 f0       	breq	.+2      	; 0x53ba <httpd_header_check+0x2b8>
    53b8:	64 c1       	rjmp	.+712    	; 0x5682 <httpd_header_check+0x580>
    53ba:	f9 01       	movw	r30, r18
    53bc:	ed 55       	subi	r30, 0x5D	; 93
    53be:	f3 4f       	sbci	r31, 0xF3	; 243
    53c0:	80 81       	ld	r24, Z
    53c2:	80 fd       	sbrc	r24, 0
    53c4:	5e c1       	rjmp	.+700    	; 0x5682 <httpd_header_check+0x580>
	#if USE_MMC
		&& !http_entry[index].mmc	// falls Zeiger noch nicht in Dateipuffer zeigt
	#endif
		)
	{
		for(a = TCP_DATA_START_VAR+5;a<(TCP_DATA_END_VAR);a++)
    53c6:	b7 e2       	ldi	r27, 0x27	; 39
    53c8:	ab 2e       	mov	r10, r27
    53ca:	b1 2c       	mov	r11, r1
    53cc:	ae 0c       	add	r10, r14
    53ce:	bf 1c       	adc	r11, r15
    53d0:	80 91 67 06 	lds	r24, 0x0667
    53d4:	28 2f       	mov	r18, r24
    53d6:	30 e0       	ldi	r19, 0x00	; 0
    53d8:	2e 5d       	subi	r18, 0xDE	; 222
    53da:	3f 4f       	sbci	r19, 0xFF	; 255
    53dc:	90 91 66 06 	lds	r25, 0x0666
    53e0:	80 e0       	ldi	r24, 0x00	; 0
    53e2:	28 0f       	add	r18, r24
    53e4:	39 1f       	adc	r19, r25
    53e6:	2e 19       	sub	r18, r14
    53e8:	3f 09       	sbc	r19, r15
    53ea:	f5 01       	movw	r30, r10
    53ec:	ea 5a       	subi	r30, 0xAA	; 170
    53ee:	f9 4f       	sbci	r31, 0xF9	; 249
    53f0:	0b c0       	rjmp	.+22     	; 0x5408 <httpd_header_check+0x306>
		{
			if (eth_buffer[a] == '\r')
    53f2:	81 91       	ld	r24, Z+
    53f4:	8d 30       	cpi	r24, 0x0D	; 13
    53f6:	29 f4       	brne	.+10     	; 0x5402 <httpd_header_check+0x300>
			{
				eth_buffer[a] = '\0';
    53f8:	f5 01       	movw	r30, r10
    53fa:	ea 5a       	subi	r30, 0xAA	; 170
    53fc:	f9 4f       	sbci	r31, 0xF9	; 249
    53fe:	10 82       	st	Z, r1
    5400:	06 c0       	rjmp	.+12     	; 0x540e <httpd_header_check+0x30c>
	#if USE_MMC
		&& !http_entry[index].mmc	// falls Zeiger noch nicht in Dateipuffer zeigt
	#endif
		)
	{
		for(a = TCP_DATA_START_VAR+5;a<(TCP_DATA_END_VAR);a++)
    5402:	08 94       	sec
    5404:	a1 1c       	adc	r10, r1
    5406:	b1 1c       	adc	r11, r1
    5408:	a2 16       	cp	r10, r18
    540a:	b3 06       	cpc	r11, r19
    540c:	90 f3       	brcs	.-28     	; 0x53f2 <httpd_header_check+0x2f0>

		File *sdfile;

		// Dateinamen ab 6. Stelle extrahieren (am Anfang steht "GET /")
		// falls POST gesendet wurde eins dazuzhlen (ist ein Zeichen lnger)
		char *_ptmp = &eth_buffer[TCP_DATA_START_VAR + 5 + http_entry[index].post];
    540e:	87 e2       	ldi	r24, 0x27	; 39
    5410:	90 e0       	ldi	r25, 0x00	; 0
    5412:	88 9e       	mul	r8, r24
    5414:	90 01       	movw	r18, r0
    5416:	89 9e       	mul	r8, r25
    5418:	30 0d       	add	r19, r0
    541a:	98 9e       	mul	r9, r24
    541c:	30 0d       	add	r19, r0
    541e:	11 24       	eor	r1, r1
    5420:	f9 01       	movw	r30, r18
    5422:	e2 56       	subi	r30, 0x62	; 98
    5424:	f3 4f       	sbci	r31, 0xF3	; 243
    5426:	90 81       	ld	r25, Z
    5428:	92 95       	swap	r25
    542a:	91 70       	andi	r25, 0x01	; 1
    542c:	80 91 84 06 	lds	r24, 0x0684
    5430:	e8 2f       	mov	r30, r24
    5432:	f0 e0       	ldi	r31, 0x00	; 0
    5434:	e0 7f       	andi	r30, 0xF0	; 240
    5436:	f0 70       	andi	r31, 0x00	; 0
    5438:	f5 95       	asr	r31
    543a:	e7 95       	ror	r30
    543c:	f5 95       	asr	r31
    543e:	e7 95       	ror	r30
    5440:	e9 0f       	add	r30, r25
    5442:	f1 1d       	adc	r31, r1
    5444:	e3 58       	subi	r30, 0x83	; 131
    5446:	f9 4f       	sbci	r31, 0xF9	; 249
		unsigned char *_pfn = http_entry[index].fname;
    5448:	74 ea       	ldi	r23, 0xA4	; 164
    544a:	c7 2e       	mov	r12, r23
    544c:	7c e0       	ldi	r23, 0x0C	; 12
    544e:	d7 2e       	mov	r13, r23
    5450:	c2 0e       	add	r12, r18
    5452:	d3 1e       	adc	r13, r19
    5454:	d6 01       	movw	r26, r12
    5456:	20 e0       	ldi	r18, 0x00	; 0
    5458:	30 e0       	ldi	r19, 0x00	; 0
    545a:	8c e0       	ldi	r24, 0x0C	; 12
    545c:	06 c0       	rjmp	.+12     	; 0x546a <httpd_header_check+0x368>
		unsigned char *_dot = NULL;
		int8_t i = 12;		// max 12 Zeichen, da 8.3-Dateinamen

		while (*_ptmp && (*_ptmp != ' ') && i--) {
			if (*_ptmp == '.'){
    545e:	4e 32       	cpi	r20, 0x2E	; 46
    5460:	09 f4       	brne	.+2      	; 0x5464 <httpd_header_check+0x362>
    5462:	9d 01       	movw	r18, r26
		char *_ptmp = &eth_buffer[TCP_DATA_START_VAR + 5 + http_entry[index].post];
		unsigned char *_pfn = http_entry[index].fname;
		unsigned char *_dot = NULL;
		int8_t i = 12;		// max 12 Zeichen, da 8.3-Dateinamen

		while (*_ptmp && (*_ptmp != ' ') && i--) {
    5464:	81 50       	subi	r24, 0x01	; 1
			if (*_ptmp == '.'){
				_dot = _pfn;
			}
			*_pfn++ = *_ptmp++;
    5466:	4d 93       	st	X+, r20
    5468:	31 96       	adiw	r30, 0x01	; 1
		char *_ptmp = &eth_buffer[TCP_DATA_START_VAR + 5 + http_entry[index].post];
		unsigned char *_pfn = http_entry[index].fname;
		unsigned char *_dot = NULL;
		int8_t i = 12;		// max 12 Zeichen, da 8.3-Dateinamen

		while (*_ptmp && (*_ptmp != ' ') && i--) {
    546a:	40 81       	ld	r20, Z
    546c:	44 23       	and	r20, r20
    546e:	21 f0       	breq	.+8      	; 0x5478 <httpd_header_check+0x376>
    5470:	40 32       	cpi	r20, 0x20	; 32
    5472:	11 f0       	breq	.+4      	; 0x5478 <httpd_header_check+0x376>
    5474:	88 23       	and	r24, r24
    5476:	99 f7       	brne	.-26     	; 0x545e <httpd_header_check+0x35c>
			if (*_ptmp == '.'){
				_dot = _pfn;
			}
			*_pfn++ = *_ptmp++;
		}
		*_pfn = 0;	// Dateinamen mit '\0' abschliessen
    5478:	1c 92       	st	X, r1

		if (_dot != NULL) {
    547a:	21 15       	cp	r18, r1
    547c:	31 05       	cpc	r19, r1
    547e:	11 f4       	brne	.+4      	; 0x5484 <httpd_header_check+0x382>
    5480:	7d 01       	movw	r14, r26
    5482:	04 c0       	rjmp	.+8      	; 0x548c <httpd_header_check+0x38a>
			++_dot;			// zeigt auf Beginn der letzen Fileextension
    5484:	79 01       	movw	r14, r18
    5486:	08 94       	sec
    5488:	e1 1c       	adc	r14, r1
    548a:	f1 1c       	adc	r15, r1
		}

		HTTP_DEBUG("\r\n%s (%s)... ",http_entry[index].fname,_dot);


		if (*(http_entry[index].fname) == '\0') {							// falls kein Dateiname angegeben wurde
    548c:	87 e2       	ldi	r24, 0x27	; 39
    548e:	90 e0       	ldi	r25, 0x00	; 0
    5490:	88 9e       	mul	r8, r24
    5492:	80 01       	movw	r16, r0
    5494:	89 9e       	mul	r8, r25
    5496:	10 0d       	add	r17, r0
    5498:	98 9e       	mul	r9, r24
    549a:	10 0d       	add	r17, r0
    549c:	11 24       	eor	r1, r1
    549e:	f8 01       	movw	r30, r16
    54a0:	ea 56       	subi	r30, 0x6A	; 106
    54a2:	f3 4f       	sbci	r31, 0xF3	; 243
    54a4:	86 85       	ldd	r24, Z+14	; 0x0e
    54a6:	88 23       	and	r24, r24
    54a8:	a9 f4       	brne	.+42     	; 0x54d4 <httpd_header_check+0x3d2>
			strcpy_P((char *)http_entry[index].fname, PSTR("INDEX.HTM"));	// Standard setzen
    54aa:	c6 01       	movw	r24, r12
    54ac:	63 e1       	ldi	r22, 0x13	; 19
    54ae:	76 e1       	ldi	r23, 0x16	; 22
    54b0:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
			_dot = http_entry[index].fname + 6;
    54b4:	78 01       	movw	r14, r16
    54b6:	6a ea       	ldi	r22, 0xAA	; 170
    54b8:	66 2e       	mov	r6, r22
    54ba:	6c e0       	ldi	r22, 0x0C	; 12
    54bc:	76 2e       	mov	r7, r22
    54be:	e6 0c       	add	r14, r6
    54c0:	f7 1c       	adc	r15, r7
		
			//Besucher Counter
			var_array[MAX_VAR_ARRAY-1]++;
    54c2:	80 91 12 01 	lds	r24, 0x0112
    54c6:	90 91 13 01 	lds	r25, 0x0113
    54ca:	01 96       	adiw	r24, 0x01	; 1
    54cc:	90 93 13 01 	sts	0x0113, r25
    54d0:	80 93 12 01 	sts	0x0112, r24
		}
		
		sdfile = f16_open((char *)http_entry[index].fname,"r");
    54d4:	c6 01       	movw	r24, r12
    54d6:	68 e2       	ldi	r22, 0x28	; 40
    54d8:	71 e0       	ldi	r23, 0x01	; 1
    54da:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    54de:	6c 01       	movw	r12, r24
		if (sdfile) {
    54e0:	00 97       	sbiw	r24, 0x00	; 0
    54e2:	71 f4       	brne	.+28     	; 0x5500 <httpd_header_check+0x3fe>
		}
		else {
			#endif
			while((char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename))
			{
				if (strcasestr_P((char*)&eth_buffer[TCP_DATA_START_VAR],(char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename))!=0) 
    54e4:	80 91 84 06 	lds	r24, 0x0684
    54e8:	08 2f       	mov	r16, r24
    54ea:	10 e0       	ldi	r17, 0x00	; 0
    54ec:	00 7f       	andi	r16, 0xF0	; 240
    54ee:	10 70       	andi	r17, 0x00	; 0
    54f0:	15 95       	asr	r17
    54f2:	07 95       	ror	r16
    54f4:	15 95       	asr	r17
    54f6:	07 95       	ror	r16
    54f8:	08 58       	subi	r16, 0x88	; 136
    54fa:	19 4f       	sbci	r17, 0xF9	; 249
    54fc:	dd 24       	eor	r13, r13
    54fe:	b2 c0       	rjmp	.+356    	; 0x5664 <httpd_header_check+0x562>
		
		sdfile = f16_open((char *)http_entry[index].fname,"r");
		if (sdfile) {
			HTTP_DEBUG("\r\nDatei %s auf SD-Karte gefunden.",http_entry[index].fname);

			http_entry[index].mmc = 1;									// Eintrag kommt von Speicherkarte
    5500:	87 e2       	ldi	r24, 0x27	; 39
    5502:	90 e0       	ldi	r25, 0x00	; 0
    5504:	88 9e       	mul	r8, r24
    5506:	80 01       	movw	r16, r0
    5508:	89 9e       	mul	r8, r25
    550a:	10 0d       	add	r17, r0
    550c:	98 9e       	mul	r9, r24
    550e:	10 0d       	add	r17, r0
    5510:	11 24       	eor	r1, r1
    5512:	f8 01       	movw	r30, r16
    5514:	ed 55       	subi	r30, 0x5D	; 93
    5516:	f3 4f       	sbci	r31, 0xF3	; 243
    5518:	80 81       	ld	r24, Z
    551a:	81 60       	ori	r24, 0x01	; 1
    551c:	80 83       	st	Z, r24

			if (strncasecmp_P((char *)_dot,PSTR("htm"),3)==0) {			// falls htm-Datei
    551e:	c7 01       	movw	r24, r14
    5520:	6f e0       	ldi	r22, 0x0F	; 15
    5522:	76 e1       	ldi	r23, 0x16	; 22
    5524:	43 e0       	ldi	r20, 0x03	; 3
    5526:	50 e0       	ldi	r21, 0x00	; 0
    5528:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    552c:	89 2b       	or	r24, r25
    552e:	31 f4       	brne	.+12     	; 0x553c <httpd_header_check+0x43a>
				http_entry[index].http_header_type = 0;
    5530:	f8 01       	movw	r30, r16
    5532:	e2 56       	subi	r30, 0x62	; 98
    5534:	f3 4f       	sbci	r31, 0xF3	; 243
    5536:	80 81       	ld	r24, Z
    5538:	89 7f       	andi	r24, 0xF9	; 249
    553a:	16 c0       	rjmp	.+44     	; 0x5568 <httpd_header_check+0x466>
			} else if (strncasecmp_P((char *)_dot,PSTR("csv"),3)==0) {	// falls csv-Datendatei
    553c:	c7 01       	movw	r24, r14
    553e:	6b e0       	ldi	r22, 0x0B	; 11
    5540:	76 e1       	ldi	r23, 0x16	; 22
    5542:	43 e0       	ldi	r20, 0x03	; 3
    5544:	50 e0       	ldi	r21, 0x00	; 0
    5546:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    554a:	89 2b       	or	r24, r25
    554c:	39 f4       	brne	.+14     	; 0x555c <httpd_header_check+0x45a>
				http_entry[index].http_header_type = 2;
    554e:	f8 01       	movw	r30, r16
    5550:	e2 56       	subi	r30, 0x62	; 98
    5552:	f3 4f       	sbci	r31, 0xF3	; 243
    5554:	80 81       	ld	r24, Z
    5556:	89 7f       	andi	r24, 0xF9	; 249
    5558:	84 60       	ori	r24, 0x04	; 4
    555a:	06 c0       	rjmp	.+12     	; 0x5568 <httpd_header_check+0x466>
			} else {
				http_entry[index].http_header_type = 1;					// default ist auch 1
    555c:	f8 01       	movw	r30, r16
    555e:	e2 56       	subi	r30, 0x62	; 98
    5560:	f3 4f       	sbci	r31, 0xF3	; 243
    5562:	80 81       	ld	r24, Z
    5564:	89 7f       	andi	r24, 0xF9	; 249
    5566:	82 60       	ori	r24, 0x02	; 2
    5568:	80 83       	st	Z, r24
			}

			http_entry[index].filesize = sdfile->dir_entry.file_size;
    556a:	87 e2       	ldi	r24, 0x27	; 39
    556c:	90 e0       	ldi	r25, 0x00	; 0
    556e:	88 9e       	mul	r8, r24
    5570:	f0 01       	movw	r30, r0
    5572:	89 9e       	mul	r8, r25
    5574:	f0 0d       	add	r31, r0
    5576:	98 9e       	mul	r9, r24
    5578:	f0 0d       	add	r31, r0
    557a:	11 24       	eor	r1, r1
    557c:	ea 56       	subi	r30, 0x6A	; 106
    557e:	f3 4f       	sbci	r31, 0xF3	; 243
    5580:	d6 01       	movw	r26, r12
    5582:	99 96       	adiw	r26, 0x29	; 41
    5584:	2d 91       	ld	r18, X+
    5586:	3d 91       	ld	r19, X+
    5588:	4d 91       	ld	r20, X+
    558a:	5c 91       	ld	r21, X
    558c:	9c 97       	sbiw	r26, 0x2c	; 44
    558e:	23 8f       	std	Z+27, r18	; 0x1b
    5590:	34 8f       	std	Z+28, r19	; 0x1c
    5592:	45 8f       	std	Z+29, r20	; 0x1d
    5594:	56 8f       	std	Z+30, r21	; 0x1e

			// ersten Datenblock setzen
			http_entry[index].charcount = 0;
    5596:	17 8e       	std	Z+31, r1	; 0x1f
    5598:	10 a2       	std	Z+32, r1	; 0x20
    559a:	11 a2       	std	Z+33, r1	; 0x21
    559c:	12 a2       	std	Z+34, r1	; 0x22
			http_entry[index].old_charcount = 0;
    559e:	13 a2       	std	Z+35, r1	; 0x23
    55a0:	14 a2       	std	Z+36, r1	; 0x24
    55a2:	15 a2       	std	Z+37, r1	; 0x25
    55a4:	16 a2       	std	Z+38, r1	; 0x26
			f16_close(sdfile);
    55a6:	c6 01       	movw	r24, r12
    55a8:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
    55ac:	6a c0       	rjmp	.+212    	; 0x5682 <httpd_header_check+0x580>
		}
		else {
			#endif
			while((char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename))
			{
				if (strcasestr_P((char*)&eth_buffer[TCP_DATA_START_VAR],(char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename))!=0) 
    55ae:	c8 01       	movw	r24, r16
    55b0:	b7 01       	movw	r22, r14
    55b2:	0e 94 61 6e 	call	0xdcc2	; 0xdcc2 <strcasestr_P>
    55b6:	89 2b       	or	r24, r25
    55b8:	09 f4       	brne	.+2      	; 0x55bc <httpd_header_check+0x4ba>
    55ba:	53 c0       	rjmp	.+166    	; 0x5662 <httpd_header_check+0x560>
					{
					char fname[12];
					strncpy_P(fname,(char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename),12);
    55bc:	6e 01       	movw	r12, r28
    55be:	08 94       	sec
    55c0:	c1 1c       	adc	r12, r1
    55c2:	d1 1c       	adc	r13, r1
    55c4:	c6 01       	movw	r24, r12
    55c6:	b7 01       	movw	r22, r14
    55c8:	4c e0       	ldi	r20, 0x0C	; 12
    55ca:	50 e0       	ldi	r21, 0x00	; 0
    55cc:	0e 94 15 6e 	call	0xdc2a	; 0xdc2a <strncpy_P>
					http_entry[index].http_header_type = 1;
    55d0:	87 e2       	ldi	r24, 0x27	; 39
    55d2:	90 e0       	ldi	r25, 0x00	; 0
    55d4:	88 9e       	mul	r8, r24
    55d6:	70 01       	movw	r14, r0
    55d8:	89 9e       	mul	r8, r25
    55da:	f0 0c       	add	r15, r0
    55dc:	98 9e       	mul	r9, r24
    55de:	f0 0c       	add	r15, r0
    55e0:	11 24       	eor	r1, r1
    55e2:	ee e9       	ldi	r30, 0x9E	; 158
    55e4:	fc e0       	ldi	r31, 0x0C	; 12
    55e6:	ee 0e       	add	r14, r30
    55e8:	ff 1e       	adc	r15, r31
    55ea:	d7 01       	movw	r26, r14
    55ec:	0c 91       	ld	r16, X
    55ee:	09 7f       	andi	r16, 0xF9	; 249
    55f0:	02 60       	ori	r16, 0x02	; 2
    55f2:	0c 93       	st	X, r16
					if (strcasestr_P(fname,PSTR(".htm"))!=0) {
    55f4:	c6 01       	movw	r24, r12
    55f6:	66 e0       	ldi	r22, 0x06	; 6
    55f8:	76 e1       	ldi	r23, 0x16	; 22
    55fa:	0e 94 61 6e 	call	0xdcc2	; 0xdcc2 <strcasestr_P>
    55fe:	89 2b       	or	r24, r25
    5600:	11 f0       	breq	.+4      	; 0x5606 <httpd_header_check+0x504>
						http_entry[index].http_header_type = 0;	
    5602:	09 7f       	andi	r16, 0xF9	; 249
    5604:	15 c0       	rjmp	.+42     	; 0x5630 <httpd_header_check+0x52e>
					}	
					else if (strcasestr_P(fname,PSTR(".jpg"))!=0) {
    5606:	c6 01       	movw	r24, r12
    5608:	61 e0       	ldi	r22, 0x01	; 1
    560a:	76 e1       	ldi	r23, 0x16	; 22
    560c:	0e 94 61 6e 	call	0xdcc2	; 0xdcc2 <strcasestr_P>
    5610:	89 2b       	or	r24, r25
    5612:	29 f0       	breq	.+10     	; 0x561e <httpd_header_check+0x51c>
						if (strcasestr_P(fname,PSTR("camera"))!=0)
						{	
							http_entry[index].cam = 1;
						}
						#endif //USE_CAM
						http_entry[index].http_header_type = 1;
    5614:	09 7f       	andi	r16, 0xF9	; 249
    5616:	02 60       	ori	r16, 0x02	; 2
    5618:	d7 01       	movw	r26, r14
    561a:	0c 93       	st	X, r16
    561c:	0b c0       	rjmp	.+22     	; 0x5634 <httpd_header_check+0x532>
					}
					else if (strcasestr_P(fname,PSTR(".gif"))!=0) {
    561e:	c6 01       	movw	r24, r12
    5620:	6c ef       	ldi	r22, 0xFC	; 252
    5622:	75 e1       	ldi	r23, 0x15	; 21
    5624:	0e 94 61 6e 	call	0xdcc2	; 0xdcc2 <strcasestr_P>
    5628:	89 2b       	or	r24, r25
    562a:	21 f0       	breq	.+8      	; 0x5634 <httpd_header_check+0x532>
						http_entry[index].http_header_type = 1;
    562c:	09 7f       	andi	r16, 0xF9	; 249
    562e:	02 60       	ori	r16, 0x02	; 2
    5630:	f7 01       	movw	r30, r14
    5632:	00 83       	st	Z, r16
					}

					http_entry[index].new_page_pointer = (char *)pgm_read_word(&WEBPAGE_TABLE[page_index].page_pointer);
    5634:	f3 01       	movw	r30, r6
    5636:	ee 0f       	add	r30, r30
    5638:	ff 1f       	adc	r31, r31
    563a:	ee 0f       	add	r30, r30
    563c:	ff 1f       	adc	r31, r31
    563e:	eb 5f       	subi	r30, 0xFB	; 251
    5640:	fb 4e       	sbci	r31, 0xEB	; 235
    5642:	25 91       	lpm	r18, Z+
    5644:	34 91       	lpm	r19, Z+
    5646:	87 e2       	ldi	r24, 0x27	; 39
    5648:	90 e0       	ldi	r25, 0x00	; 0
    564a:	88 9e       	mul	r8, r24
    564c:	f0 01       	movw	r30, r0
    564e:	89 9e       	mul	r8, r25
    5650:	f0 0d       	add	r31, r0
    5652:	98 9e       	mul	r9, r24
    5654:	f0 0d       	add	r31, r0
    5656:	11 24       	eor	r1, r1
    5658:	ea 56       	subi	r30, 0x6A	; 106
    565a:	f3 4f       	sbci	r31, 0xF3	; 243
    565c:	33 83       	std	Z+3, r19	; 0x03
    565e:	22 83       	std	Z+2, r18	; 0x02
    5660:	10 c0       	rjmp	.+32     	; 0x5682 <httpd_header_check+0x580>
					break;
				}
				page_index++;
    5662:	d3 94       	inc	r13
			http_entry[index].old_charcount = 0;
			f16_close(sdfile);
		}
		else {
			#endif
			while((char *)pgm_read_word(&WEBPAGE_TABLE[page_index].filename))
    5664:	6d 2c       	mov	r6, r13
    5666:	77 24       	eor	r7, r7
    5668:	f3 01       	movw	r30, r6
    566a:	ee 0f       	add	r30, r30
    566c:	ff 1f       	adc	r31, r31
    566e:	ee 0f       	add	r30, r30
    5670:	ff 1f       	adc	r31, r31
    5672:	ed 5f       	subi	r30, 0xFD	; 253
    5674:	fb 4e       	sbci	r31, 0xEB	; 235
    5676:	e5 90       	lpm	r14, Z+
    5678:	f4 90       	lpm	r15, Z+
    567a:	e1 14       	cp	r14, r1
    567c:	f1 04       	cpc	r15, r1
    567e:	09 f0       	breq	.+2      	; 0x5682 <httpd_header_check+0x580>
    5680:	96 cf       	rjmp	.-212    	; 0x55ae <httpd_header_check+0x4ac>
		#endif
	}

	//Wurde das Ende vom Header nicht erreicht
	//kommen noch weitere Stcke vom Header!
	if ((*http_entry[index].hdr_end_pointer != 0) || (http_entry[index].post == 1))
    5682:	87 e2       	ldi	r24, 0x27	; 39
    5684:	90 e0       	ldi	r25, 0x00	; 0
    5686:	88 9e       	mul	r8, r24
    5688:	90 01       	movw	r18, r0
    568a:	89 9e       	mul	r8, r25
    568c:	30 0d       	add	r19, r0
    568e:	98 9e       	mul	r9, r24
    5690:	30 0d       	add	r19, r0
    5692:	11 24       	eor	r1, r1
    5694:	d9 01       	movw	r26, r18
    5696:	aa 56       	subi	r26, 0x6A	; 106
    5698:	b3 4f       	sbci	r27, 0xF3	; 243
    569a:	16 96       	adiw	r26, 0x06	; 6
    569c:	ed 91       	ld	r30, X+
    569e:	fc 91       	ld	r31, X
    56a0:	17 97       	sbiw	r26, 0x07	; 7
    56a2:	80 81       	ld	r24, Z
    56a4:	88 23       	and	r24, r24
    56a6:	31 f4       	brne	.+12     	; 0x56b4 <httpd_header_check+0x5b2>
    56a8:	f9 01       	movw	r30, r18
    56aa:	e2 56       	subi	r30, 0x62	; 98
    56ac:	f3 4f       	sbci	r31, 0xF3	; 243
    56ae:	e0 81       	ld	r30, Z
    56b0:	e4 ff       	sbrs	r30, 4
    56b2:	17 c0       	rjmp	.+46     	; 0x56e2 <httpd_header_check+0x5e0>
	{
		//Der Empfang wird Quitiert und es wird auf weiteres Headerstck gewartet
		tcp_entry[index].status =  ACK_FLAG;
    56b4:	86 e1       	ldi	r24, 0x16	; 22
    56b6:	90 e0       	ldi	r25, 0x00	; 0
    56b8:	88 9e       	mul	r8, r24
    56ba:	80 01       	movw	r16, r0
    56bc:	89 9e       	mul	r8, r25
    56be:	10 0d       	add	r17, r0
    56c0:	98 9e       	mul	r9, r24
    56c2:	10 0d       	add	r17, r0
    56c4:	11 24       	eor	r1, r1
    56c6:	0c 5a       	subi	r16, 0xAC	; 172
    56c8:	14 4f       	sbci	r17, 0xF4	; 244
    56ca:	80 e1       	ldi	r24, 0x10	; 16
    56cc:	d8 01       	movw	r26, r16
    56ce:	50 96       	adiw	r26, 0x10	; 16
    56d0:	8c 93       	st	X, r24
		create_new_tcp_packet(0,index);
    56d2:	80 e0       	ldi	r24, 0x00	; 0
    56d4:	90 e0       	ldi	r25, 0x00	; 0
    56d6:	65 2d       	mov	r22, r5
    56d8:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		//Warten auf weitere Headerpackete
		tcp_entry[index].app_status = 1;
    56dc:	81 e0       	ldi	r24, 0x01	; 1
    56de:	90 e0       	ldi	r25, 0x00	; 0
    56e0:	33 c0       	rjmp	.+102    	; 0x5748 <httpd_header_check+0x646>
		return;
	}	
	
	//Wurde das Passwort in den ganzen Headerpacketen gefunden?
	//Wenn nicht dann ausfhren und Passwort anfordern!
	if((!http_entry[index].http_auth) && tcp_entry[index].status&PSH_FLAG)
    56e2:	e0 fd       	sbrc	r30, 0
    56e4:	35 c0       	rjmp	.+106    	; 0x5750 <httpd_header_check+0x64e>
    56e6:	86 e1       	ldi	r24, 0x16	; 22
    56e8:	90 e0       	ldi	r25, 0x00	; 0
    56ea:	88 9e       	mul	r8, r24
    56ec:	80 01       	movw	r16, r0
    56ee:	89 9e       	mul	r8, r25
    56f0:	10 0d       	add	r17, r0
    56f2:	98 9e       	mul	r9, r24
    56f4:	10 0d       	add	r17, r0
    56f6:	11 24       	eor	r1, r1
    56f8:	0c 5a       	subi	r16, 0xAC	; 172
    56fa:	14 4f       	sbci	r17, 0xF4	; 244
    56fc:	f8 01       	movw	r30, r16
    56fe:	80 89       	ldd	r24, Z+16	; 0x10
    5700:	83 ff       	sbrs	r24, 3
    5702:	26 c0       	rjmp	.+76     	; 0x5750 <httpd_header_check+0x64e>
	{	
		//HTTP_AUTH_Header senden!
		http_entry[index].new_page_pointer = Page0;
    5704:	8f ed       	ldi	r24, 0xDF	; 223
    5706:	95 e1       	ldi	r25, 0x15	; 21
    5708:	13 96       	adiw	r26, 0x03	; 3
    570a:	9c 93       	st	X, r25
    570c:	8e 93       	st	-X, r24
    570e:	12 97       	sbiw	r26, 0x02	; 2
		memcpy_P((char*)&eth_buffer[TCP_DATA_START_VAR],http_header3,(sizeof(http_header3)-1));
    5710:	80 91 84 06 	lds	r24, 0x0684
    5714:	90 e0       	ldi	r25, 0x00	; 0
    5716:	80 7f       	andi	r24, 0xF0	; 240
    5718:	90 70       	andi	r25, 0x00	; 0
    571a:	95 95       	asr	r25
    571c:	87 95       	ror	r24
    571e:	95 95       	asr	r25
    5720:	87 95       	ror	r24
    5722:	88 58       	subi	r24, 0x88	; 136
    5724:	99 4f       	sbci	r25, 0xF9	; 249
    5726:	6f ec       	ldi	r22, 0xCF	; 207
    5728:	74 e1       	ldi	r23, 0x14	; 20
    572a:	41 e8       	ldi	r20, 0x81	; 129
    572c:	50 e0       	ldi	r21, 0x00	; 0
    572e:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
		tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    5732:	88 e1       	ldi	r24, 0x18	; 24
    5734:	d8 01       	movw	r26, r16
    5736:	50 96       	adiw	r26, 0x10	; 16
    5738:	8c 93       	st	X, r24
		create_new_tcp_packet((sizeof(http_header3)-1),index);
    573a:	81 e8       	ldi	r24, 0x81	; 129
    573c:	90 e0       	ldi	r25, 0x00	; 0
    573e:	65 2d       	mov	r22, r5
    5740:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		tcp_entry[index].app_status = 2;
    5744:	82 e0       	ldi	r24, 0x02	; 2
    5746:	90 e0       	ldi	r25, 0x00	; 0
    5748:	f8 01       	movw	r30, r16
    574a:	92 8b       	std	Z+18, r25	; 0x12
    574c:	81 8b       	std	Z+17, r24	; 0x11
    574e:	9b c0       	rjmp	.+310    	; 0x5886 <httpd_header_check+0x784>
		return;
	}
	
	//Standart INDEX.HTM Seite wenn keine andere gefunden wurde -- oder "404 Not Found" ??
	if (!http_entry[index].new_page_pointer
    5750:	87 e2       	ldi	r24, 0x27	; 39
    5752:	90 e0       	ldi	r25, 0x00	; 0
    5754:	88 9e       	mul	r8, r24
    5756:	90 01       	movw	r18, r0
    5758:	89 9e       	mul	r8, r25
    575a:	30 0d       	add	r19, r0
    575c:	98 9e       	mul	r9, r24
    575e:	30 0d       	add	r19, r0
    5760:	11 24       	eor	r1, r1
    5762:	d9 01       	movw	r26, r18
    5764:	aa 56       	subi	r26, 0x6A	; 106
    5766:	b3 4f       	sbci	r27, 0xF3	; 243
    5768:	12 96       	adiw	r26, 0x02	; 2
    576a:	8d 91       	ld	r24, X+
    576c:	9c 91       	ld	r25, X
    576e:	13 97       	sbiw	r26, 0x03	; 3
    5770:	89 2b       	or	r24, r25
    5772:	d9 f4       	brne	.+54     	; 0x57aa <httpd_header_check+0x6a8>
    5774:	f9 01       	movw	r30, r18
    5776:	ed 55       	subi	r30, 0x5D	; 93
    5778:	f3 4f       	sbci	r31, 0xF3	; 243
    577a:	80 81       	ld	r24, Z
    577c:	80 fd       	sbrc	r24, 0
    577e:	15 c0       	rjmp	.+42     	; 0x57aa <httpd_header_check+0x6a8>
	#if USE_MMC
		&& !http_entry[index].mmc	// falls Zeiger noch nicht in Dateipuffer zeigt
	#endif
		)
	{
		http_entry[index].new_page_pointer = Page1;
    5780:	87 ec       	ldi	r24, 0xC7	; 199
    5782:	91 e0       	ldi	r25, 0x01	; 1
    5784:	13 96       	adiw	r26, 0x03	; 3
    5786:	9c 93       	st	X, r25
    5788:	8e 93       	st	-X, r24
    578a:	12 97       	sbiw	r26, 0x02	; 2
		http_entry[index].http_header_type = 0;
    578c:	f9 01       	movw	r30, r18
    578e:	e2 56       	subi	r30, 0x62	; 98
    5790:	f3 4f       	sbci	r31, 0xF3	; 243
    5792:	80 81       	ld	r24, Z
    5794:	89 7f       	andi	r24, 0xF9	; 249
    5796:	80 83       	st	Z, r24
		//Besucher Counter
		var_array[MAX_VAR_ARRAY-1]++;
    5798:	80 91 12 01 	lds	r24, 0x0112
    579c:	90 91 13 01 	lds	r25, 0x0113
    57a0:	01 96       	adiw	r24, 0x01	; 1
    57a2:	90 93 13 01 	sts	0x0113, r25
    57a6:	80 93 12 01 	sts	0x0112, r24
	}	
	
	tcp_entry[index].app_status = 2;
    57aa:	86 e1       	ldi	r24, 0x16	; 22
    57ac:	90 e0       	ldi	r25, 0x00	; 0
    57ae:	88 9e       	mul	r8, r24
    57b0:	f0 01       	movw	r30, r0
    57b2:	89 9e       	mul	r8, r25
    57b4:	f0 0d       	add	r31, r0
    57b6:	98 9e       	mul	r9, r24
    57b8:	f0 0d       	add	r31, r0
    57ba:	11 24       	eor	r1, r1
    57bc:	ec 5a       	subi	r30, 0xAC	; 172
    57be:	f4 4f       	sbci	r31, 0xF4	; 244
    57c0:	82 e0       	ldi	r24, 0x02	; 2
    57c2:	90 e0       	ldi	r25, 0x00	; 0
    57c4:	92 8b       	std	Z+18, r25	; 0x12
    57c6:	81 8b       	std	Z+17, r24	; 0x11
	/*
	**	Seiten Header wird gesendet
	*/
	switch (http_entry[index].http_header_type) {
    57c8:	87 e2       	ldi	r24, 0x27	; 39
    57ca:	90 e0       	ldi	r25, 0x00	; 0
    57cc:	88 9e       	mul	r8, r24
    57ce:	f0 01       	movw	r30, r0
    57d0:	89 9e       	mul	r8, r25
    57d2:	f0 0d       	add	r31, r0
    57d4:	98 9e       	mul	r9, r24
    57d6:	f0 0d       	add	r31, r0
    57d8:	11 24       	eor	r1, r1
    57da:	e2 56       	subi	r30, 0x62	; 98
    57dc:	f3 4f       	sbci	r31, 0xF3	; 243
    57de:	80 81       	ld	r24, Z
    57e0:	86 95       	lsr	r24
    57e2:	83 70       	andi	r24, 0x03	; 3
    57e4:	90 e0       	ldi	r25, 0x00	; 0
    57e6:	81 30       	cpi	r24, 0x01	; 1
    57e8:	91 05       	cpc	r25, r1
    57ea:	99 f0       	breq	.+38     	; 0x5812 <httpd_header_check+0x710>
    57ec:	82 30       	cpi	r24, 0x02	; 2
    57ee:	91 05       	cpc	r25, r1
    57f0:	29 f1       	breq	.+74     	; 0x583c <httpd_header_check+0x73a>
    57f2:	89 2b       	or	r24, r25
    57f4:	b9 f5       	brne	.+110    	; 0x5864 <httpd_header_check+0x762>

		case	0 :
			a = (sizeof(http_header1)-1);
			memcpy_P((char*)&eth_buffer[TCP_DATA_START_VAR],http_header1,a);
    57f6:	80 91 84 06 	lds	r24, 0x0684
    57fa:	90 e0       	ldi	r25, 0x00	; 0
    57fc:	80 7f       	andi	r24, 0xF0	; 240
    57fe:	90 70       	andi	r25, 0x00	; 0
    5800:	95 95       	asr	r25
    5802:	87 95       	ror	r24
    5804:	95 95       	asr	r25
    5806:	87 95       	ror	r24
    5808:	88 58       	subi	r24, 0x88	; 136
    580a:	99 4f       	sbci	r25, 0xF9	; 249
    580c:	6f e1       	ldi	r22, 0x1F	; 31
    580e:	74 e1       	ldi	r23, 0x14	; 20
    5810:	0d c0       	rjmp	.+26     	; 0x582c <httpd_header_check+0x72a>
			HTTP_DEBUG("\r\nsende OK fr text/html");
			break;
	
		case	1 :
			a = (sizeof(http_header2)-1);
			memcpy_P((char*)&eth_buffer[TCP_DATA_START_VAR],http_header2,a);
    5812:	80 91 84 06 	lds	r24, 0x0684
    5816:	90 e0       	ldi	r25, 0x00	; 0
    5818:	80 7f       	andi	r24, 0xF0	; 240
    581a:	90 70       	andi	r25, 0x00	; 0
    581c:	95 95       	asr	r25
    581e:	87 95       	ror	r24
    5820:	95 95       	asr	r25
    5822:	87 95       	ror	r24
    5824:	88 58       	subi	r24, 0x88	; 136
    5826:	99 4f       	sbci	r25, 0xF9	; 249
    5828:	67 e7       	ldi	r22, 0x77	; 119
    582a:	74 e1       	ldi	r23, 0x14	; 20
    582c:	47 e5       	ldi	r20, 0x57	; 87
    582e:	50 e0       	ldi	r21, 0x00	; 0
    5830:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
    5834:	a7 e5       	ldi	r26, 0x57	; 87
    5836:	aa 2e       	mov	r10, r26
    5838:	b1 2c       	mov	r11, r1
    583a:	14 c0       	rjmp	.+40     	; 0x5864 <httpd_header_check+0x762>
			HTTP_DEBUG("\r\nsende OK fr image/jpg");
			break;

		case	2 :
			a = (sizeof(http_csv_header)-1);
			memcpy_P((char*)&eth_buffer[TCP_DATA_START_VAR],http_csv_header,a);
    583c:	80 91 84 06 	lds	r24, 0x0684
    5840:	90 e0       	ldi	r25, 0x00	; 0
    5842:	80 7f       	andi	r24, 0xF0	; 240
    5844:	90 70       	andi	r25, 0x00	; 0
    5846:	95 95       	asr	r25
    5848:	87 95       	ror	r24
    584a:	95 95       	asr	r25
    584c:	87 95       	ror	r24
    584e:	88 58       	subi	r24, 0x88	; 136
    5850:	99 4f       	sbci	r25, 0xF9	; 249
    5852:	61 e5       	ldi	r22, 0x51	; 81
    5854:	75 e1       	ldi	r23, 0x15	; 21
    5856:	4d e8       	ldi	r20, 0x8D	; 141
    5858:	50 e0       	ldi	r21, 0x00	; 0
    585a:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
    585e:	ed e8       	ldi	r30, 0x8D	; 141
    5860:	ae 2e       	mov	r10, r30
    5862:	b1 2c       	mov	r11, r1
			HTTP_DEBUG("\r\nsende OK fr csv-header");
			break;
	}

	HTTP_DEBUG("\r\nmit Header antworten. Index %i L:%i",index,a);
	tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    5864:	86 e1       	ldi	r24, 0x16	; 22
    5866:	90 e0       	ldi	r25, 0x00	; 0
    5868:	88 9e       	mul	r8, r24
    586a:	f0 01       	movw	r30, r0
    586c:	89 9e       	mul	r8, r25
    586e:	f0 0d       	add	r31, r0
    5870:	98 9e       	mul	r9, r24
    5872:	f0 0d       	add	r31, r0
    5874:	11 24       	eor	r1, r1
    5876:	ec 5a       	subi	r30, 0xAC	; 172
    5878:	f4 4f       	sbci	r31, 0xF4	; 244
    587a:	88 e1       	ldi	r24, 0x18	; 24
    587c:	80 8b       	std	Z+16, r24	; 0x10
	create_new_tcp_packet(a,index);
    587e:	c5 01       	movw	r24, r10
    5880:	65 2d       	mov	r22, r5
    5882:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
	return;	
}
    5886:	2e 96       	adiw	r28, 0x0e	; 14
    5888:	0f b6       	in	r0, 0x3f	; 63
    588a:	f8 94       	cli
    588c:	de bf       	out	0x3e, r29	; 62
    588e:	0f be       	out	0x3f, r0	; 63
    5890:	cd bf       	out	0x3d, r28	; 61
    5892:	cf 91       	pop	r28
    5894:	df 91       	pop	r29
    5896:	1f 91       	pop	r17
    5898:	0f 91       	pop	r16
    589a:	ff 90       	pop	r15
    589c:	ef 90       	pop	r14
    589e:	df 90       	pop	r13
    58a0:	cf 90       	pop	r12
    58a2:	bf 90       	pop	r11
    58a4:	af 90       	pop	r10
    58a6:	9f 90       	pop	r9
    58a8:	8f 90       	pop	r8
    58aa:	7f 90       	pop	r7
    58ac:	6f 90       	pop	r6
    58ae:	5f 90       	pop	r5
    58b0:	4f 90       	pop	r4
    58b2:	3f 90       	pop	r3
    58b4:	2f 90       	pop	r2
    58b6:	08 95       	ret

000058b8 <httpd>:
 *	der http daemon
 *
 * @param[in] index in der TCP Tabelle tcp_entry
 */
void httpd (unsigned char index)
{
    58b8:	1f 93       	push	r17
    58ba:	cf 93       	push	r28
    58bc:	df 93       	push	r29
    58be:	18 2f       	mov	r17, r24
	if (tcp_entry[index].status & FIN_FLAG) {	// Wird Verbindungsabbau signalisiert?
    58c0:	c8 2f       	mov	r28, r24
    58c2:	d0 e0       	ldi	r29, 0x00	; 0
    58c4:	86 e1       	ldi	r24, 0x16	; 22
    58c6:	90 e0       	ldi	r25, 0x00	; 0
    58c8:	c8 9f       	mul	r28, r24
    58ca:	f0 01       	movw	r30, r0
    58cc:	c9 9f       	mul	r28, r25
    58ce:	f0 0d       	add	r31, r0
    58d0:	d8 9f       	mul	r29, r24
    58d2:	f0 0d       	add	r31, r0
    58d4:	11 24       	eor	r1, r1
    58d6:	ec 5a       	subi	r30, 0xAC	; 172
    58d8:	f4 4f       	sbci	r31, 0xF4	; 244
    58da:	80 89       	ldd	r24, Z+16	; 0x10
    58dc:	80 fd       	sbrc	r24, 0
    58de:	3e c0       	rjmp	.+124    	; 0x595c <httpd+0xa4>
		return;
	}

	//Allererste Aufruf des Ports fr diese Anwendung
	//HTTPD_Anwendungsstack lschen
	if(tcp_entry[index].app_status==1)
    58e0:	81 89       	ldd	r24, Z+17	; 0x11
    58e2:	92 89       	ldd	r25, Z+18	; 0x12
    58e4:	01 97       	sbiw	r24, 0x01	; 1
    58e6:	19 f4       	brne	.+6      	; 0x58ee <httpd+0x36>
	{
		httpd_stack_clear(index);
    58e8:	81 2f       	mov	r24, r17
    58ea:	0e 94 23 26 	call	0x4c46	; 0x4c46 <httpd_stack_clear>
	}
	
	//HTTP wurde bei dieser Verbindung zum ersten mal aufgerufen oder
	//HTML Header Retransmission!
	if (tcp_entry[index].app_status <= 2)
    58ee:	86 e1       	ldi	r24, 0x16	; 22
    58f0:	90 e0       	ldi	r25, 0x00	; 0
    58f2:	c8 9f       	mul	r28, r24
    58f4:	f0 01       	movw	r30, r0
    58f6:	c9 9f       	mul	r28, r25
    58f8:	f0 0d       	add	r31, r0
    58fa:	d8 9f       	mul	r29, r24
    58fc:	f0 0d       	add	r31, r0
    58fe:	11 24       	eor	r1, r1
    5900:	ec 5a       	subi	r30, 0xAC	; 172
    5902:	f4 4f       	sbci	r31, 0xF4	; 244
    5904:	81 89       	ldd	r24, Z+17	; 0x11
    5906:	92 89       	ldd	r25, Z+18	; 0x12
    5908:	03 97       	sbiw	r24, 0x03	; 3
    590a:	20 f4       	brcc	.+8      	; 0x5914 <httpd+0x5c>
	{	
		httpd_header_check (index);
    590c:	81 2f       	mov	r24, r17
    590e:	0e 94 81 28 	call	0x5102	; 0x5102 <httpd_header_check>
    5912:	24 c0       	rjmp	.+72     	; 0x595c <httpd+0xa4>
		return;
	}
	
	//Der Header wurde gesendet und mit ACK besttigt (tcp_entry[index].app_status+1)
	//war das HTML Paket fertig, oder mssen weitere Daten gesendet werden, oder Retransmission?
	if (tcp_entry[index].app_status > 2 && tcp_entry[index].app_status < 0xFFFE)
    5914:	81 89       	ldd	r24, Z+17	; 0x11
    5916:	92 89       	ldd	r25, Z+18	; 0x12
    5918:	03 97       	sbiw	r24, 0x03	; 3
    591a:	48 f0       	brcs	.+18     	; 0x592e <httpd+0x76>
    591c:	81 89       	ldd	r24, Z+17	; 0x11
    591e:	92 89       	ldd	r25, Z+18	; 0x12
    5920:	8e 5f       	subi	r24, 0xFE	; 254
    5922:	9f 4f       	sbci	r25, 0xFF	; 255
    5924:	20 f4       	brcc	.+8      	; 0x592e <httpd+0x76>
	{
		httpd_data_send (index);
    5926:	81 2f       	mov	r24, r17
    5928:	0e 94 65 26 	call	0x4cca	; 0x4cca <httpd_data_send>
    592c:	17 c0       	rjmp	.+46     	; 0x595c <httpd+0xa4>
		return;
	}
	
	//Verbindung kann geschlossen werden! Alle HTML Daten wurden gesendet TCP Port kann
	//geschlossen werden (tcp_entry[index].app_status >= 0xFFFE)!!
	if (tcp_entry[index].app_status >= 0xFFFE)
    592e:	86 e1       	ldi	r24, 0x16	; 22
    5930:	90 e0       	ldi	r25, 0x00	; 0
    5932:	c8 9f       	mul	r28, r24
    5934:	f0 01       	movw	r30, r0
    5936:	c9 9f       	mul	r28, r25
    5938:	f0 0d       	add	r31, r0
    593a:	d8 9f       	mul	r29, r24
    593c:	f0 0d       	add	r31, r0
    593e:	11 24       	eor	r1, r1
    5940:	ec 5a       	subi	r30, 0xAC	; 172
    5942:	f4 4f       	sbci	r31, 0xF4	; 244
    5944:	81 89       	ldd	r24, Z+17	; 0x11
    5946:	92 89       	ldd	r25, Z+18	; 0x12
    5948:	8e 5f       	subi	r24, 0xFE	; 254
    594a:	9f 4f       	sbci	r25, 0xFF	; 255
    594c:	38 f0       	brcs	.+14     	; 0x595c <httpd+0xa4>
	{
		tcp_entry[index].app_status = 0xFFFE;
    594e:	8e ef       	ldi	r24, 0xFE	; 254
    5950:	9f ef       	ldi	r25, 0xFF	; 255
    5952:	92 8b       	std	Z+18, r25	; 0x12
    5954:	81 8b       	std	Z+17, r24	; 0x11
		tcp_Port_close(index);
    5956:	81 2f       	mov	r24, r17
    5958:	0e 94 12 1a 	call	0x3424	; 0x3424 <tcp_Port_close>
		return;
	}
	return;
}
    595c:	df 91       	pop	r29
    595e:	cf 91       	pop	r28
    5960:	1f 91       	pop	r17
    5962:	08 95       	ret

00005964 <httpd_init>:
 *
 */
void httpd_init (void)
{
	//HTTP_AUTH_STRING 
	decode_base64((unsigned char*)HTTP_AUTH_STRING,http_auth_passwort);
    5964:	8e e2       	ldi	r24, 0x2E	; 46
    5966:	91 e0       	ldi	r25, 0x01	; 1
    5968:	62 e8       	ldi	r22, 0x82	; 130
    596a:	7c e0       	ldi	r23, 0x0C	; 12
    596c:	0e 94 7e 23 	call	0x46fc	; 0x46fc <decode_base64>

	//Serverport und Anwendung eintragen
	add_tcp_app (HTTPD_PORT, (void(*)(unsigned char))httpd);
    5970:	80 e5       	ldi	r24, 0x50	; 80
    5972:	90 e0       	ldi	r25, 0x00	; 0
    5974:	6c e5       	ldi	r22, 0x5C	; 92
    5976:	7c e2       	ldi	r23, 0x2C	; 44
    5978:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
}
    597c:	08 95       	ret

0000597e <telnetd_send_data>:
 *	\ingroup telnet
 *	telnet Daten senden
 */
//telnet Testserver
void telnetd_send_data (void)
{
    597e:	ff 92       	push	r15
    5980:	0f 93       	push	r16
    5982:	1f 93       	push	r17
    5984:	cf 93       	push	r28
    5986:	df 93       	push	r29
	unsigned char index;
	if (rx_buffer_pointer_in != retransmission_pointer)
    5988:	c0 91 22 01 	lds	r28, 0x0122
    598c:	d0 91 23 01 	lds	r29, 0x0123
    5990:	80 91 43 0b 	lds	r24, 0x0B43
    5994:	90 91 44 0b 	lds	r25, 0x0B44
    5998:	c8 17       	cp	r28, r24
    599a:	d9 07       	cpc	r29, r25
    599c:	09 f4       	brne	.+2      	; 0x59a0 <telnetd_send_data+0x22>
    599e:	69 c0       	rjmp	.+210    	; 0x5a72 <telnetd_send_data+0xf4>
    59a0:	60 e0       	ldi	r22, 0x00	; 0
    59a2:	70 e0       	ldi	r23, 0x00	; 0
	{
		for (index = 0;index<MAX_TCP_ENTRY;index++)
		{
			if(tcp_entry[index].dest_port == HTONS(23))
    59a4:	26 e1       	ldi	r18, 0x16	; 22
    59a6:	30 e0       	ldi	r19, 0x00	; 0
 */
//telnet Testserver
void telnetd_send_data (void)
{
	unsigned char index;
	if (rx_buffer_pointer_in != retransmission_pointer)
    59a8:	f6 2e       	mov	r15, r22
	{
		for (index = 0;index<MAX_TCP_ENTRY;index++)
		{
			if(tcp_entry[index].dest_port == HTONS(23))
    59aa:	62 9f       	mul	r22, r18
    59ac:	f0 01       	movw	r30, r0
    59ae:	63 9f       	mul	r22, r19
    59b0:	f0 0d       	add	r31, r0
    59b2:	72 9f       	mul	r23, r18
    59b4:	f0 0d       	add	r31, r0
    59b6:	11 24       	eor	r1, r1
    59b8:	ec 5a       	subi	r30, 0xAC	; 172
    59ba:	f4 4f       	sbci	r31, 0xF4	; 244
    59bc:	86 81       	ldd	r24, Z+6	; 0x06
    59be:	97 81       	ldd	r25, Z+7	; 0x07
    59c0:	80 50       	subi	r24, 0x00	; 0
    59c2:	97 41       	sbci	r25, 0x17	; 23
    59c4:	09 f0       	breq	.+2      	; 0x59c8 <telnetd_send_data+0x4a>
    59c6:	46 c0       	rjmp	.+140    	; 0x5a54 <telnetd_send_data+0xd6>
			{
				if(!telnetd_status.ack_wait)
    59c8:	80 91 d8 0b 	lds	r24, 0x0BD8
    59cc:	80 fd       	sbrc	r24, 0
    59ce:	51 c0       	rjmp	.+162    	; 0x5a72 <telnetd_send_data+0xf4>
					{
					telnetd_status.ack_wait = 1;
    59d0:	80 91 d8 0b 	lds	r24, 0x0BD8
    59d4:	81 60       	ori	r24, 0x01	; 1
    59d6:	80 93 d8 0b 	sts	0x0BD8, r24
					unsigned int count = 0;
					retransmission_pointer = rx_buffer_pointer_out; 
    59da:	80 91 24 01 	lds	r24, 0x0124
    59de:	90 91 25 01 	lds	r25, 0x0125
    59e2:	90 93 44 0b 	sts	0x0B44, r25
    59e6:	80 93 43 0b 	sts	0x0B43, r24
    59ea:	40 e0       	ldi	r20, 0x00	; 0
    59ec:	50 e0       	ldi	r21, 0x00	; 0
    59ee:	15 c0       	rjmp	.+42     	; 0x5a1a <telnetd_send_data+0x9c>
					
					while(rx_buffer_pointer_in != retransmission_pointer)
					{
						eth_buffer[TCP_DATA_START+count] = *retransmission_pointer++;
    59f0:	fa 01       	movw	r30, r20
    59f2:	ea 5a       	subi	r30, 0xAA	; 170
    59f4:	f9 4f       	sbci	r31, 0xF9	; 249
    59f6:	d9 01       	movw	r26, r18
    59f8:	8d 91       	ld	r24, X+
    59fa:	86 ab       	std	Z+54, r24	; 0x36
    59fc:	b0 93 44 0b 	sts	0x0B44, r27
    5a00:	a0 93 43 0b 	sts	0x0B43, r26
						count++;
						if (retransmission_pointer == &usart_rx_buffer[BUFFER_SIZE-1])
    5a04:	a7 52       	subi	r26, 0x27	; 39
    5a06:	bc 40       	sbci	r27, 0x0C	; 12
    5a08:	31 f4       	brne	.+12     	; 0x5a16 <telnetd_send_data+0x98>
						{
							retransmission_pointer = &usart_rx_buffer[0];
    5a0a:	20 53       	subi	r18, 0x30	; 48
    5a0c:	30 40       	sbci	r19, 0x00	; 0
    5a0e:	30 93 44 0b 	sts	0x0B44, r19
    5a12:	20 93 43 0b 	sts	0x0B43, r18
					retransmission_pointer = rx_buffer_pointer_out; 
					
					while(rx_buffer_pointer_in != retransmission_pointer)
					{
						eth_buffer[TCP_DATA_START+count] = *retransmission_pointer++;
						count++;
    5a16:	4f 5f       	subi	r20, 0xFF	; 255
    5a18:	5f 4f       	sbci	r21, 0xFF	; 255
					{
					telnetd_status.ack_wait = 1;
					unsigned int count = 0;
					retransmission_pointer = rx_buffer_pointer_out; 
					
					while(rx_buffer_pointer_in != retransmission_pointer)
    5a1a:	20 91 43 0b 	lds	r18, 0x0B43
    5a1e:	30 91 44 0b 	lds	r19, 0x0B44
    5a22:	c2 17       	cp	r28, r18
    5a24:	d3 07       	cpc	r29, r19
    5a26:	21 f7       	brne	.-56     	; 0x59f0 <telnetd_send_data+0x72>
						if (retransmission_pointer == &usart_rx_buffer[BUFFER_SIZE-1])
						{
							retransmission_pointer = &usart_rx_buffer[0];
						}
					}
					tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    5a28:	86 e1       	ldi	r24, 0x16	; 22
    5a2a:	90 e0       	ldi	r25, 0x00	; 0
    5a2c:	68 9f       	mul	r22, r24
    5a2e:	80 01       	movw	r16, r0
    5a30:	69 9f       	mul	r22, r25
    5a32:	10 0d       	add	r17, r0
    5a34:	78 9f       	mul	r23, r24
    5a36:	10 0d       	add	r17, r0
    5a38:	11 24       	eor	r1, r1
    5a3a:	0c 5a       	subi	r16, 0xAC	; 172
    5a3c:	14 4f       	sbci	r17, 0xF4	; 244
    5a3e:	88 e1       	ldi	r24, 0x18	; 24
    5a40:	f8 01       	movw	r30, r16
    5a42:	80 8b       	std	Z+16, r24	; 0x10
					create_new_tcp_packet(count,index);
    5a44:	ca 01       	movw	r24, r20
    5a46:	6f 2d       	mov	r22, r15
    5a48:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
					tcp_entry[index].time = TCP_MAX_ENTRY_TIME;
    5a4c:	83 e0       	ldi	r24, 0x03	; 3
    5a4e:	f8 01       	movw	r30, r16
    5a50:	83 8b       	std	Z+19, r24	; 0x13
    5a52:	0f c0       	rjmp	.+30     	; 0x5a72 <telnetd_send_data+0xf4>
					return;
    5a54:	6f 5f       	subi	r22, 0xFF	; 255
    5a56:	7f 4f       	sbci	r23, 0xFF	; 255
void telnetd_send_data (void)
{
	unsigned char index;
	if (rx_buffer_pointer_in != retransmission_pointer)
	{
		for (index = 0;index<MAX_TCP_ENTRY;index++)
    5a58:	65 30       	cpi	r22, 0x05	; 5
    5a5a:	71 05       	cpc	r23, r1
    5a5c:	09 f0       	breq	.+2      	; 0x5a60 <telnetd_send_data+0xe2>
    5a5e:	a4 cf       	rjmp	.-184    	; 0x59a8 <telnetd_send_data+0x2a>
				}
			}
		}
		if (index >= MAX_TCP_ENTRY)
		{
			if(usart_status.usart_disable)
    5a60:	80 91 f5 0b 	lds	r24, 0x0BF5
    5a64:	82 ff       	sbrs	r24, 2
    5a66:	05 c0       	rjmp	.+10     	; 0x5a72 <telnetd_send_data+0xf4>
			{
				usart_status.usart_disable = 0;
    5a68:	80 91 f5 0b 	lds	r24, 0x0BF5
    5a6c:	8b 7f       	andi	r24, 0xFB	; 251
    5a6e:	80 93 f5 0b 	sts	0x0BF5, r24
			}
		}
	}
}
    5a72:	df 91       	pop	r29
    5a74:	cf 91       	pop	r28
    5a76:	1f 91       	pop	r17
    5a78:	0f 91       	pop	r16
    5a7a:	ff 90       	pop	r15
    5a7c:	08 95       	ret

00005a7e <telnetd>:
/**
 *	\ingroup telnet
 *	telnet Serverprozess
 */
void telnetd (unsigned char index)
{
    5a7e:	ff 92       	push	r15
    5a80:	0f 93       	push	r16
    5a82:	1f 93       	push	r17
    5a84:	f8 2e       	mov	r15, r24
	TELNET_DEBUG("TELNET Anwendung gestartet\r\n");
	
    //Verbindung wurde abgebaut!
    if (tcp_entry[index].status & FIN_FLAG)
    5a86:	a8 2f       	mov	r26, r24
    5a88:	b0 e0       	ldi	r27, 0x00	; 0
    5a8a:	86 e1       	ldi	r24, 0x16	; 22
    5a8c:	90 e0       	ldi	r25, 0x00	; 0
    5a8e:	a8 9f       	mul	r26, r24
    5a90:	f0 01       	movw	r30, r0
    5a92:	a9 9f       	mul	r26, r25
    5a94:	f0 0d       	add	r31, r0
    5a96:	b8 9f       	mul	r27, r24
    5a98:	f0 0d       	add	r31, r0
    5a9a:	11 24       	eor	r1, r1
    5a9c:	ec 5a       	subi	r30, 0xAC	; 172
    5a9e:	f4 4f       	sbci	r31, 0xF4	; 244
    5aa0:	80 89       	ldd	r24, Z+16	; 0x10
    5aa2:	80 ff       	sbrs	r24, 0
    5aa4:	06 c0       	rjmp	.+12     	; 0x5ab2 <telnetd+0x34>
    {
        usart_status.usart_disable = 0;
    5aa6:	80 91 f5 0b 	lds	r24, 0x0BF5
    5aaa:	8b 7f       	andi	r24, 0xFB	; 251
    5aac:	80 93 f5 0b 	sts	0x0BF5, r24
    5ab0:	b6 c0       	rjmp	.+364    	; 0x5c1e <telnetd+0x1a0>
        return;
    }
    
	if (tcp_entry[index].app_status == 0 || tcp_entry[index].app_status == 1)
    5ab2:	81 89       	ldd	r24, Z+17	; 0x11
    5ab4:	92 89       	ldd	r25, Z+18	; 0x12
    5ab6:	89 2b       	or	r24, r25
    5ab8:	21 f0       	breq	.+8      	; 0x5ac2 <telnetd+0x44>
    5aba:	81 89       	ldd	r24, Z+17	; 0x11
    5abc:	92 89       	ldd	r25, Z+18	; 0x12
    5abe:	01 97       	sbiw	r24, 0x01	; 1
    5ac0:	59 f5       	brne	.+86     	; 0x5b18 <telnetd+0x9a>
	{
		tcp_entry[index].app_status = 1; 
    5ac2:	86 e1       	ldi	r24, 0x16	; 22
    5ac4:	90 e0       	ldi	r25, 0x00	; 0
    5ac6:	a8 9f       	mul	r26, r24
    5ac8:	80 01       	movw	r16, r0
    5aca:	a9 9f       	mul	r26, r25
    5acc:	10 0d       	add	r17, r0
    5ace:	b8 9f       	mul	r27, r24
    5ad0:	10 0d       	add	r17, r0
    5ad2:	11 24       	eor	r1, r1
    5ad4:	0c 5a       	subi	r16, 0xAC	; 172
    5ad6:	14 4f       	sbci	r17, 0xF4	; 244
    5ad8:	81 e0       	ldi	r24, 0x01	; 1
    5ada:	90 e0       	ldi	r25, 0x00	; 0
    5adc:	f8 01       	movw	r30, r16
    5ade:	92 8b       	std	Z+18, r25	; 0x12
    5ae0:	81 8b       	std	Z+17, r24	; 0x11
		memcpy_P(&eth_buffer[TCP_DATA_START],PSTR("Start Telnet Server:\r\n"),22);
    5ae2:	8c e8       	ldi	r24, 0x8C	; 140
    5ae4:	96 e0       	ldi	r25, 0x06	; 6
    5ae6:	62 e2       	ldi	r22, 0x22	; 34
    5ae8:	76 e1       	ldi	r23, 0x16	; 22
    5aea:	46 e1       	ldi	r20, 0x16	; 22
    5aec:	50 e0       	ldi	r21, 0x00	; 0
    5aee:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
		create_new_tcp_packet(22,index);
    5af2:	86 e1       	ldi	r24, 0x16	; 22
    5af4:	90 e0       	ldi	r25, 0x00	; 0
    5af6:	6f 2d       	mov	r22, r15
    5af8:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		usart_status.usart_disable = 1;
    5afc:	80 91 f5 0b 	lds	r24, 0x0BF5
    5b00:	84 60       	ori	r24, 0x04	; 4
    5b02:	80 93 f5 0b 	sts	0x0BF5, r24
		telnetd_status.ack_wait = 0;
    5b06:	80 91 d8 0b 	lds	r24, 0x0BD8
    5b0a:	8e 7f       	andi	r24, 0xFE	; 254
    5b0c:	80 93 d8 0b 	sts	0x0BD8, r24
		tcp_entry[index].time = TCP_TIME_OFF;
    5b10:	8f ef       	ldi	r24, 0xFF	; 255
    5b12:	f8 01       	movw	r30, r16
    5b14:	83 8b       	std	Z+19, r24	; 0x13
    5b16:	83 c0       	rjmp	.+262    	; 0x5c1e <telnetd+0x1a0>
		return;
	}	

	if ((tcp_entry[index].app_status > 1) && (tcp_entry[index].status&PSH_FLAG))
    5b18:	81 89       	ldd	r24, Z+17	; 0x11
    5b1a:	92 89       	ldd	r25, Z+18	; 0x12
    5b1c:	02 97       	sbiw	r24, 0x02	; 2
    5b1e:	08 f4       	brcc	.+2      	; 0x5b22 <telnetd+0xa4>
    5b20:	43 c0       	rjmp	.+134    	; 0x5ba8 <telnetd+0x12a>
    5b22:	80 89       	ldd	r24, Z+16	; 0x10
    5b24:	83 ff       	sbrs	r24, 3
    5b26:	40 c0       	rjmp	.+128    	; 0x5ba8 <telnetd+0x12a>
	{
		tcp_entry[index].app_status = 2;	
    5b28:	82 e0       	ldi	r24, 0x02	; 2
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
    5b2c:	92 8b       	std	Z+18, r25	; 0x12
    5b2e:	81 8b       	std	Z+17, r24	; 0x11
		for (int a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    5b30:	20 91 84 06 	lds	r18, 0x0684
    5b34:	30 e0       	ldi	r19, 0x00	; 0
    5b36:	20 7f       	andi	r18, 0xF0	; 240
    5b38:	30 70       	andi	r19, 0x00	; 0
    5b3a:	35 95       	asr	r19
    5b3c:	27 95       	ror	r18
    5b3e:	35 95       	asr	r19
    5b40:	27 95       	ror	r18
    5b42:	b9 01       	movw	r22, r18
    5b44:	6e 5d       	subi	r22, 0xDE	; 222
    5b46:	7f 4f       	sbci	r23, 0xFF	; 255
    5b48:	80 91 67 06 	lds	r24, 0x0667
    5b4c:	48 2f       	mov	r20, r24
    5b4e:	50 e0       	ldi	r21, 0x00	; 0
    5b50:	4e 5d       	subi	r20, 0xDE	; 222
    5b52:	5f 4f       	sbci	r21, 0xFF	; 255
    5b54:	90 91 66 06 	lds	r25, 0x0666
    5b58:	80 e0       	ldi	r24, 0x00	; 0
    5b5a:	48 0f       	add	r20, r24
    5b5c:	59 1f       	adc	r21, r25
    5b5e:	42 1b       	sub	r20, r18
    5b60:	53 0b       	sbc	r21, r19
    5b62:	fb 01       	movw	r30, r22
    5b64:	ea 5a       	subi	r30, 0xAA	; 170
    5b66:	f9 4f       	sbci	r31, 0xF9	; 249
    5b68:	09 c0       	rjmp	.+18     	; 0x5b7c <telnetd+0xfe>
                    usart_rx_buffer[buffercounter++] = receive_char;    
                }
            #else
                #if defined (__AVR_ATmega644P__) || !USE_CAM  
                    //Warten solange bis Zeichen gesendet wurde
                    while(!(USR & (1<<UDRE)));
    5b6a:	80 91 c0 00 	lds	r24, 0x00C0
    5b6e:	85 ff       	sbrs	r24, 5
    5b70:	fc cf       	rjmp	.-8      	; 0x5b6a <telnetd+0xec>
                    //Ausgabe des Zeichens
                    UDR = eth_buffer[a];
    5b72:	81 91       	ld	r24, Z+
    5b74:	80 93 c6 00 	sts	0x00C6, r24
	}	

	if ((tcp_entry[index].app_status > 1) && (tcp_entry[index].status&PSH_FLAG))
	{
		tcp_entry[index].app_status = 2;	
		for (int a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++)
    5b78:	6f 5f       	subi	r22, 0xFF	; 255
    5b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    5b7c:	64 17       	cp	r22, r20
    5b7e:	75 07       	cpc	r23, r21
    5b80:	a4 f3       	brlt	.-24     	; 0x5b6a <telnetd+0xec>
                    //Ausgabe des Zeichens
                    UDR = eth_buffer[a];
                #endif
            #endif
		}	
		tcp_entry[index].status =  ACK_FLAG;
    5b82:	86 e1       	ldi	r24, 0x16	; 22
    5b84:	90 e0       	ldi	r25, 0x00	; 0
    5b86:	a8 9f       	mul	r26, r24
    5b88:	f0 01       	movw	r30, r0
    5b8a:	a9 9f       	mul	r26, r25
    5b8c:	f0 0d       	add	r31, r0
    5b8e:	b8 9f       	mul	r27, r24
    5b90:	f0 0d       	add	r31, r0
    5b92:	11 24       	eor	r1, r1
    5b94:	ec 5a       	subi	r30, 0xAC	; 172
    5b96:	f4 4f       	sbci	r31, 0xF4	; 244
    5b98:	80 e1       	ldi	r24, 0x10	; 16
    5b9a:	80 8b       	std	Z+16, r24	; 0x10
		create_new_tcp_packet(0,index);
    5b9c:	80 e0       	ldi	r24, 0x00	; 0
    5b9e:	90 e0       	ldi	r25, 0x00	; 0
    5ba0:	6f 2d       	mov	r22, r15
    5ba2:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
    5ba6:	3b c0       	rjmp	.+118    	; 0x5c1e <telnetd+0x1a0>
		return;
	}
	
	//Ack erhalten vom gesendeten Packet
	if ((tcp_entry[index].app_status > 1)&&(tcp_entry[index].status&ACK_FLAG)&&(telnetd_status.ack_wait))
    5ba8:	86 e1       	ldi	r24, 0x16	; 22
    5baa:	90 e0       	ldi	r25, 0x00	; 0
    5bac:	a8 9f       	mul	r26, r24
    5bae:	f0 01       	movw	r30, r0
    5bb0:	a9 9f       	mul	r26, r25
    5bb2:	f0 0d       	add	r31, r0
    5bb4:	b8 9f       	mul	r27, r24
    5bb6:	f0 0d       	add	r31, r0
    5bb8:	11 24       	eor	r1, r1
    5bba:	ec 5a       	subi	r30, 0xAC	; 172
    5bbc:	f4 4f       	sbci	r31, 0xF4	; 244
    5bbe:	81 89       	ldd	r24, Z+17	; 0x11
    5bc0:	92 89       	ldd	r25, Z+18	; 0x12
    5bc2:	02 97       	sbiw	r24, 0x02	; 2
    5bc4:	b8 f0       	brcs	.+46     	; 0x5bf4 <telnetd+0x176>
    5bc6:	80 89       	ldd	r24, Z+16	; 0x10
    5bc8:	84 ff       	sbrs	r24, 4
    5bca:	14 c0       	rjmp	.+40     	; 0x5bf4 <telnetd+0x176>
    5bcc:	80 91 d8 0b 	lds	r24, 0x0BD8
    5bd0:	80 ff       	sbrs	r24, 0
    5bd2:	10 c0       	rjmp	.+32     	; 0x5bf4 <telnetd+0x176>
	{
		tcp_entry[index].time = TCP_TIME_OFF;
    5bd4:	8f ef       	ldi	r24, 0xFF	; 255
    5bd6:	83 8b       	std	Z+19, r24	; 0x13
		rx_buffer_pointer_out = retransmission_pointer;
    5bd8:	80 91 43 0b 	lds	r24, 0x0B43
    5bdc:	90 91 44 0b 	lds	r25, 0x0B44
    5be0:	90 93 25 01 	sts	0x0125, r25
    5be4:	80 93 24 01 	sts	0x0124, r24
		telnetd_status.ack_wait = 0;
    5be8:	80 91 d8 0b 	lds	r24, 0x0BD8
    5bec:	8e 7f       	andi	r24, 0xFE	; 254
    5bee:	80 93 d8 0b 	sts	0x0BD8, r24
    5bf2:	15 c0       	rjmp	.+42     	; 0x5c1e <telnetd+0x1a0>
		return;
	}
	
	//Time out kein ack angekommen
	if (tcp_entry[index].status == 0) 
    5bf4:	86 e1       	ldi	r24, 0x16	; 22
    5bf6:	90 e0       	ldi	r25, 0x00	; 0
    5bf8:	a8 9f       	mul	r26, r24
    5bfa:	f0 01       	movw	r30, r0
    5bfc:	a9 9f       	mul	r26, r25
    5bfe:	f0 0d       	add	r31, r0
    5c00:	b8 9f       	mul	r27, r24
    5c02:	f0 0d       	add	r31, r0
    5c04:	11 24       	eor	r1, r1
    5c06:	ec 5a       	subi	r30, 0xAC	; 172
    5c08:	f4 4f       	sbci	r31, 0xF4	; 244
    5c0a:	80 89       	ldd	r24, Z+16	; 0x10
    5c0c:	88 23       	and	r24, r24
    5c0e:	39 f4       	brne	.+14     	; 0x5c1e <telnetd+0x1a0>
	{
		//Daten nochmal senden
		telnetd_status.ack_wait = 0;
    5c10:	80 91 d8 0b 	lds	r24, 0x0BD8
    5c14:	8e 7f       	andi	r24, 0xFE	; 254
    5c16:	80 93 d8 0b 	sts	0x0BD8, r24
		telnetd_send_data ();
    5c1a:	0e 94 bf 2c 	call	0x597e	; 0x597e <telnetd_send_data>
		return;
	}
	
	return;
}
    5c1e:	1f 91       	pop	r17
    5c20:	0f 91       	pop	r16
    5c22:	ff 90       	pop	r15
    5c24:	08 95       	ret

00005c26 <telnetd_init>:
 * Initialisierung des telnet Servers
 */
void telnetd_init (void)
{
	//Serverport und Anwendung in TCP Anwendungsliste eintragen
	add_tcp_app (TELNET_APP_PORT, (void(*)(unsigned char))telnetd);
    5c26:	87 e1       	ldi	r24, 0x17	; 23
    5c28:	90 e0       	ldi	r25, 0x00	; 0
    5c2a:	6f e3       	ldi	r22, 0x3F	; 63
    5c2c:	7d e2       	ldi	r23, 0x2D	; 45
    5c2e:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
}
    5c32:	08 95       	ret

00005c34 <ntp_get>:
 *
 *	\param[in]	index Zeiger auf den verwendeten Eintrag in der UDP-Tabelle
 *
 */
void ntp_get (unsigned char index)
{
    5c34:	ef 92       	push	r14
    5c36:	ff 92       	push	r15
    5c38:	0f 93       	push	r16
    5c3a:	1f 93       	push	r17
	NTP_DEBUG("** NTP DATA GET! **\r\n");
		
	struct NTP_GET_Header *ntp;
	ntp = (struct NTP_GET_Header *)&eth_buffer[UDP_DATA_START];

	ntp->rx_timestamp = HTONL(ntp->rx_timestamp);
    5c3c:	e0 90 a8 06 	lds	r14, 0x06A8
    5c40:	f0 90 a9 06 	lds	r15, 0x06A9
    5c44:	00 91 aa 06 	lds	r16, 0x06AA
    5c48:	10 91 ab 06 	lds	r17, 0x06AB
	ntp->rx_timestamp += GMT_TIME_CORRECTION; //  UTC +1h
    5c4c:	21 2f       	mov	r18, r17
    5c4e:	33 27       	eor	r19, r19
    5c50:	44 27       	eor	r20, r20
    5c52:	55 27       	eor	r21, r21
    5c54:	be 2d       	mov	r27, r14
    5c56:	aa 27       	eor	r26, r26
    5c58:	99 27       	eor	r25, r25
    5c5a:	88 27       	eor	r24, r24
    5c5c:	28 0f       	add	r18, r24
    5c5e:	39 1f       	adc	r19, r25
    5c60:	4a 1f       	adc	r20, r26
    5c62:	5b 1f       	adc	r21, r27
    5c64:	20 5f       	subi	r18, 0xF0	; 240
    5c66:	31 4f       	sbci	r19, 0xF1	; 241
    5c68:	4f 4f       	sbci	r20, 0xFF	; 255
    5c6a:	5f 4f       	sbci	r21, 0xFF	; 255
    5c6c:	d8 01       	movw	r26, r16
    5c6e:	c7 01       	movw	r24, r14
    5c70:	80 70       	andi	r24, 0x00	; 0
    5c72:	90 70       	andi	r25, 0x00	; 0
    5c74:	b0 70       	andi	r27, 0x00	; 0
    5c76:	89 2f       	mov	r24, r25
    5c78:	9a 2f       	mov	r25, r26
    5c7a:	ab 2f       	mov	r26, r27
    5c7c:	bb 27       	eor	r27, r27
    5c7e:	28 0f       	add	r18, r24
    5c80:	39 1f       	adc	r19, r25
    5c82:	4a 1f       	adc	r20, r26
    5c84:	5b 1f       	adc	r21, r27
    5c86:	80 e0       	ldi	r24, 0x00	; 0
    5c88:	9f ef       	ldi	r25, 0xFF	; 255
    5c8a:	a0 e0       	ldi	r26, 0x00	; 0
    5c8c:	b0 e0       	ldi	r27, 0x00	; 0
    5c8e:	e8 22       	and	r14, r24
    5c90:	f9 22       	and	r15, r25
    5c92:	0a 23       	and	r16, r26
    5c94:	1b 23       	and	r17, r27
    5c96:	10 2f       	mov	r17, r16
    5c98:	0f 2d       	mov	r16, r15
    5c9a:	fe 2c       	mov	r15, r14
    5c9c:	ee 24       	eor	r14, r14
    5c9e:	2e 0d       	add	r18, r14
    5ca0:	3f 1d       	adc	r19, r15
    5ca2:	40 1f       	adc	r20, r16
    5ca4:	51 1f       	adc	r21, r17
    5ca6:	20 93 a8 06 	sts	0x06A8, r18
    5caa:	30 93 a9 06 	sts	0x06A9, r19
    5cae:	40 93 aa 06 	sts	0x06AA, r20
    5cb2:	50 93 ab 06 	sts	0x06AB, r21
	time = ntp->rx_timestamp;
    5cb6:	20 93 77 0c 	sts	0x0C77, r18
    5cba:	30 93 78 0c 	sts	0x0C78, r19
    5cbe:	40 93 79 0c 	sts	0x0C79, r20
    5cc2:	50 93 7a 0c 	sts	0x0C7A, r21
	
	uint16_t tage = (unsigned long)(time/86400);	// Tage seit 1.1.1900
    5cc6:	60 91 77 0c 	lds	r22, 0x0C77
    5cca:	70 91 78 0c 	lds	r23, 0x0C78
    5cce:	80 91 79 0c 	lds	r24, 0x0C79
    5cd2:	90 91 7a 0c 	lds	r25, 0x0C7A
    5cd6:	20 e8       	ldi	r18, 0x80	; 128
    5cd8:	31 e5       	ldi	r19, 0x51	; 81
    5cda:	41 e0       	ldi	r20, 0x01	; 1
    5cdc:	50 e0       	ldi	r21, 0x00	; 0
    5cde:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
	tage -= 39445;	// 108 Jahre abziehen -> Tag 0 ist 31.12.2007
    5ce2:	25 51       	subi	r18, 0x15	; 21
    5ce4:	3a 49       	sbci	r19, 0x9A	; 154
    5ce6:	48 e0       	ldi	r20, 0x08	; 8
    5ce8:	0b c0       	rjmp	.+22     	; 0x5d00 <ntp_get+0xcc>

	unsigned char yy = 8;		// 2008 ist Offset
	while (tage > 365) {
		tage -= 365;
    5cea:	2d 56       	subi	r18, 0x6D	; 109
    5cec:	31 40       	sbci	r19, 0x01	; 1
		if ( yy % 4 == 0) {
    5cee:	84 2f       	mov	r24, r20
    5cf0:	90 e0       	ldi	r25, 0x00	; 0
    5cf2:	83 70       	andi	r24, 0x03	; 3
    5cf4:	90 70       	andi	r25, 0x00	; 0
    5cf6:	89 2b       	or	r24, r25
    5cf8:	11 f4       	brne	.+4      	; 0x5cfe <ntp_get+0xca>
			tage--;		// Schaltjahr
    5cfa:	21 50       	subi	r18, 0x01	; 1
    5cfc:	30 40       	sbci	r19, 0x00	; 0
		}
		++yy;
    5cfe:	4f 5f       	subi	r20, 0xFF	; 255
	
	uint16_t tage = (unsigned long)(time/86400);	// Tage seit 1.1.1900
	tage -= 39445;	// 108 Jahre abziehen -> Tag 0 ist 31.12.2007

	unsigned char yy = 8;		// 2008 ist Offset
	while (tage > 365) {
    5d00:	91 e0       	ldi	r25, 0x01	; 1
    5d02:	2e 36       	cpi	r18, 0x6E	; 110
    5d04:	39 07       	cpc	r19, r25
    5d06:	88 f7       	brcc	.-30     	; 0x5cea <ntp_get+0xb6>
		if ( yy % 4 == 0) {
			tage--;		// Schaltjahr
		}
		++yy;
	}
	TM_YY = yy;
    5d08:	40 93 31 0c 	sts	0x0C31, r20

	NTP_DEBUG("\r\nJahr:%i Rest: %i\r\n",yy,tage);
	TM_SetDayofYear(tage);		// die restlichen Tage werden direkt gesetzt.
    5d0c:	c9 01       	movw	r24, r18
    5d0e:	0e 94 d1 20 	call	0x41a2	; 0x41a2 <TM_SetDayofYear>
 
	TM_hh = (time/3600)%24;
    5d12:	60 91 77 0c 	lds	r22, 0x0C77
    5d16:	70 91 78 0c 	lds	r23, 0x0C78
    5d1a:	80 91 79 0c 	lds	r24, 0x0C79
    5d1e:	90 91 7a 0c 	lds	r25, 0x0C7A
    5d22:	20 e1       	ldi	r18, 0x10	; 16
    5d24:	3e e0       	ldi	r19, 0x0E	; 14
    5d26:	40 e0       	ldi	r20, 0x00	; 0
    5d28:	50 e0       	ldi	r21, 0x00	; 0
    5d2a:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    5d2e:	ca 01       	movw	r24, r20
    5d30:	b9 01       	movw	r22, r18
    5d32:	28 e1       	ldi	r18, 0x18	; 24
    5d34:	30 e0       	ldi	r19, 0x00	; 0
    5d36:	40 e0       	ldi	r20, 0x00	; 0
    5d38:	50 e0       	ldi	r21, 0x00	; 0
    5d3a:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    5d3e:	60 93 75 0c 	sts	0x0C75, r22
	TM_mm = (time/60)%60;
    5d42:	60 91 77 0c 	lds	r22, 0x0C77
    5d46:	70 91 78 0c 	lds	r23, 0x0C78
    5d4a:	80 91 79 0c 	lds	r24, 0x0C79
    5d4e:	90 91 7a 0c 	lds	r25, 0x0C7A
    5d52:	2c e3       	ldi	r18, 0x3C	; 60
    5d54:	30 e0       	ldi	r19, 0x00	; 0
    5d56:	40 e0       	ldi	r20, 0x00	; 0
    5d58:	50 e0       	ldi	r21, 0x00	; 0
    5d5a:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    5d5e:	ca 01       	movw	r24, r20
    5d60:	b9 01       	movw	r22, r18
    5d62:	2c e3       	ldi	r18, 0x3C	; 60
    5d64:	30 e0       	ldi	r19, 0x00	; 0
    5d66:	40 e0       	ldi	r20, 0x00	; 0
    5d68:	50 e0       	ldi	r21, 0x00	; 0
    5d6a:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    5d6e:	60 93 74 0c 	sts	0x0C74, r22
	TM_ss = time %60;
    5d72:	60 91 77 0c 	lds	r22, 0x0C77
    5d76:	70 91 78 0c 	lds	r23, 0x0C78
    5d7a:	80 91 79 0c 	lds	r24, 0x0C79
    5d7e:	90 91 7a 0c 	lds	r25, 0x0C7A
    5d82:	2c e3       	ldi	r18, 0x3C	; 60
    5d84:	30 e0       	ldi	r19, 0x00	; 0
    5d86:	40 e0       	ldi	r20, 0x00	; 0
    5d88:	50 e0       	ldi	r21, 0x00	; 0
    5d8a:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    5d8e:	60 93 73 0c 	sts	0x0C73, r22
	NTP_DEBUG("\n\rNTP TIME: %2i:%2i:%2i\r\n",TM_hh,TM_mm,TM_ss);

	// auf Sommerzeit korrigieren
	if(TM_MM > 2 && TM_MM < 11) {	// 11, 12, 1 und 2 haben keine Sommerzeit
    5d92:	80 91 32 0c 	lds	r24, 0x0C32
    5d96:	83 30       	cpi	r24, 0x03	; 3
    5d98:	88 f1       	brcs	.+98     	; 0x5dfc <ntp_get+0x1c8>
    5d9a:	80 91 32 0c 	lds	r24, 0x0C32
    5d9e:	8b 30       	cpi	r24, 0x0B	; 11
    5da0:	68 f5       	brcc	.+90     	; 0x5dfc <ntp_get+0x1c8>

		uint8_t sommerzeit = 1;		// restliche Monate haben prinzipiell Sommerzeit

		if( (TM_DD - TM_DOW >= 25) && (TM_DOW || TM_hh >= 2) ) {
    5da2:	80 91 7b 0c 	lds	r24, 0x0C7B
    5da6:	20 91 30 0c 	lds	r18, 0x0C30
    5daa:	90 e0       	ldi	r25, 0x00	; 0
    5dac:	82 1b       	sub	r24, r18
    5dae:	91 09       	sbc	r25, r1
    5db0:	49 97       	sbiw	r24, 0x19	; 25
    5db2:	74 f0       	brlt	.+28     	; 0x5dd0 <ntp_get+0x19c>
    5db4:	80 91 30 0c 	lds	r24, 0x0C30
    5db8:	88 23       	and	r24, r24
    5dba:	21 f4       	brne	.+8      	; 0x5dc4 <ntp_get+0x190>
    5dbc:	80 91 75 0c 	lds	r24, 0x0C75
    5dc0:	82 30       	cpi	r24, 0x02	; 2
    5dc2:	30 f0       	brcs	.+12     	; 0x5dd0 <ntp_get+0x19c>
			// nach 02h00 (UTC+01) des letzten Sonntags im Monat
			if( TM_MM == 10) {	// Oktober
    5dc4:	80 91 32 0c 	lds	r24, 0x0C32
    5dc8:	90 e0       	ldi	r25, 0x00	; 0
    5dca:	8a 30       	cpi	r24, 0x0A	; 10
    5dcc:	31 f4       	brne	.+12     	; 0x5dda <ntp_get+0x1a6>
    5dce:	06 c0       	rjmp	.+12     	; 0x5ddc <ntp_get+0x1a8>
				sommerzeit = 0;	// bereits Winter
			}
		}
		else {
			// vor 02h00 (UTC+01) des letzten Sonntags im Monat
			if( TM_MM == 3) {	// Mrz
    5dd0:	80 91 32 0c 	lds	r24, 0x0C32
    5dd4:	90 e0       	ldi	r25, 0x00	; 0
    5dd6:	83 30       	cpi	r24, 0x03	; 3
    5dd8:	09 f0       	breq	.+2      	; 0x5ddc <ntp_get+0x1a8>
    5dda:	91 e0       	ldi	r25, 0x01	; 1
				sommerzeit = 0;	// noch Winter
			}
		}

		TM_hh += sommerzeit;	// Offset addieren
    5ddc:	80 91 75 0c 	lds	r24, 0x0C75
    5de0:	98 0f       	add	r25, r24
    5de2:	90 93 75 0c 	sts	0x0C75, r25

		// falls whrend der Sommerzeit zwischen 23h00 und 24h00 die Zeit neu gestellt wurde ...
		if (TM_hh > 23) {
    5de6:	80 91 75 0c 	lds	r24, 0x0C75
    5dea:	88 31       	cpi	r24, 0x18	; 24
    5dec:	38 f0       	brcs	.+14     	; 0x5dfc <ntp_get+0x1c8>
			TM_hh -= 24;
    5dee:	80 91 75 0c 	lds	r24, 0x0C75
    5df2:	88 51       	subi	r24, 0x18	; 24
    5df4:	80 93 75 0c 	sts	0x0C75, r24
			TM_AddOneDay();
    5df8:	0e 94 4f 21 	call	0x429e	; 0x429e <TM_AddOneDay>
		}
	}

	machineStatus.LogInit = true;		// neue Logdatei initialisieren - wird in Mainloop erledigt
    5dfc:	81 e0       	ldi	r24, 0x01	; 1
    5dfe:	80 93 40 06 	sts	0x0640, r24

}
    5e02:	1f 91       	pop	r17
    5e04:	0f 91       	pop	r16
    5e06:	ff 90       	pop	r15
    5e08:	ef 90       	pop	r14
    5e0a:	08 95       	ret

00005e0c <ntp_request>:
 *	\ingroup time
 *	Anforderung der aktuellen Zeitinformationen von einem NTP Server
 *
 */
void ntp_request (void)
{
    5e0c:	cf 92       	push	r12
    5e0e:	df 92       	push	r13
    5e10:	ef 92       	push	r14
    5e12:	ff 92       	push	r15
    5e14:	0f 93       	push	r16
    5e16:	1f 93       	push	r17
    5e18:	cf 93       	push	r28
    5e1a:	df 93       	push	r29
	//oeffnet eine Verbindung zu einem NTP Server
	unsigned int byte_count;
	uint32_t tmp_ip = (*(uint32_t*)&ntp_server_ip[0]);
    5e1c:	c0 90 50 06 	lds	r12, 0x0650
    5e20:	d0 90 51 06 	lds	r13, 0x0651
    5e24:	e0 90 52 06 	lds	r14, 0x0652
    5e28:	f0 90 53 06 	lds	r15, 0x0653
		
	if ( tmp_ip == 0L ) {
    5e2c:	c1 14       	cp	r12, r1
    5e2e:	d1 04       	cpc	r13, r1
    5e30:	e1 04       	cpc	r14, r1
    5e32:	f1 04       	cpc	r15, r1
    5e34:	69 f4       	brne	.+26     	; 0x5e50 <ntp_request+0x44>
		dns_request(NTP_SERVER, (uint32_t *)&ntp_server_ip[0]);
    5e36:	88 e4       	ldi	r24, 0x48	; 72
    5e38:	91 e0       	ldi	r25, 0x01	; 1
    5e3a:	60 e5       	ldi	r22, 0x50	; 80
    5e3c:	76 e0       	ldi	r23, 0x06	; 6
    5e3e:	0e 94 8c 36 	call	0x6d18	; 0x6d18 <dns_request>
		ntp_timer = 4; // neuer Versuch nach 4 Sekunden
    5e42:	84 e0       	ldi	r24, 0x04	; 4
    5e44:	90 e0       	ldi	r25, 0x00	; 0
    5e46:	90 93 4b 0b 	sts	0x0B4B, r25
    5e4a:	80 93 4a 0b 	sts	0x0B4A, r24
    5e4e:	51 c0       	rjmp	.+162    	; 0x5ef2 <ntp_request+0xe6>
		NTP_DEBUG(" no IP **\r\n");
		return;
	}
	else {
		uint32_t ee_ip = get_eeprom_value(NTP_IP_EEPROM_STORE,NTP_IP);
    5e50:	82 e3       	ldi	r24, 0x32	; 50
    5e52:	90 e0       	ldi	r25, 0x00	; 0
    5e54:	45 e5       	ldi	r20, 0x55	; 85
    5e56:	5a e0       	ldi	r21, 0x0A	; 10
    5e58:	64 ec       	ldi	r22, 0xC4	; 196
    5e5a:	78 eb       	ldi	r23, 0xB8	; 184
    5e5c:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
		NTP_DEBUG("IP: %1i.%1i.%1i.%1i",ntp_server_ip[0],ntp_server_ip[1],ntp_server_ip[2],ntp_server_ip[3]);
		if (tmp_ip != ee_ip) {
    5e60:	c6 16       	cp	r12, r22
    5e62:	d7 06       	cpc	r13, r23
    5e64:	e8 06       	cpc	r14, r24
    5e66:	f9 06       	cpc	r15, r25
    5e68:	79 f0       	breq	.+30     	; 0x5e88 <ntp_request+0x7c>
    5e6a:	c2 e3       	ldi	r28, 0x32	; 50
    5e6c:	d0 e0       	ldi	r29, 0x00	; 0
			//value ins EEPROM schreiben
			for (uint16_t count = 0; count<4; count++)
			{
				eeprom_busy_wait ();
    5e6e:	f9 99       	sbic	0x1f, 1	; 31
    5e70:	fe cf       	rjmp	.-4      	; 0x5e6e <ntp_request+0x62>
				eeprom_write_byte((unsigned char *)(count+NTP_IP_EEPROM_STORE),ntp_server_ip[count]);
    5e72:	fe 01       	movw	r30, r28
    5e74:	e2 5e       	subi	r30, 0xE2	; 226
    5e76:	f9 4f       	sbci	r31, 0xF9	; 249
    5e78:	ce 01       	movw	r24, r28
    5e7a:	60 81       	ld	r22, Z
    5e7c:	0e 94 47 71 	call	0xe28e	; 0xe28e <__eewr_byte_m644p>
    5e80:	21 96       	adiw	r28, 0x01	; 1
	else {
		uint32_t ee_ip = get_eeprom_value(NTP_IP_EEPROM_STORE,NTP_IP);
		NTP_DEBUG("IP: %1i.%1i.%1i.%1i",ntp_server_ip[0],ntp_server_ip[1],ntp_server_ip[2],ntp_server_ip[3]);
		if (tmp_ip != ee_ip) {
			//value ins EEPROM schreiben
			for (uint16_t count = 0; count<4; count++)
    5e82:	c6 33       	cpi	r28, 0x36	; 54
    5e84:	d1 05       	cpc	r29, r1
    5e86:	99 f7       	brne	.-26     	; 0x5e6e <ntp_request+0x62>
			NTP_DEBUG(" saved");
		}
	}

	//ARP Request senden
	if (arp_request(tmp_ip) == 1)
    5e88:	c7 01       	movw	r24, r14
    5e8a:	b6 01       	movw	r22, r12
    5e8c:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <arp_request>
    5e90:	81 30       	cpi	r24, 0x01	; 1
    5e92:	79 f5       	brne	.+94     	; 0x5ef2 <ntp_request+0xe6>
    5e94:	c0 e0       	ldi	r28, 0x00	; 0
    5e96:	d0 e0       	ldi	r29, 0x00	; 0
    5e98:	09 e3       	ldi	r16, 0x39	; 57
    5e9a:	16 e1       	ldi	r17, 0x16	; 22
    5e9c:	f8 01       	movw	r30, r16
		//ETH_INT_DISABLE;
		PGM_P ntp_data_pointer = NTP_Request;
		for (byte_count = 0;byte_count<(MTU_SIZE-(UDP_DATA_START));byte_count++)
		{
			unsigned char b;
			b = pgm_read_byte(ntp_data_pointer++);
    5e9e:	0f 5f       	subi	r16, 0xFF	; 255
    5ea0:	1f 4f       	sbci	r17, 0xFF	; 255
    5ea2:	e4 91       	lpm	r30, Z+
			eth_buffer[UDP_DATA_START + byte_count] = b;
    5ea4:	de 01       	movw	r26, r28
    5ea6:	aa 5a       	subi	r26, 0xAA	; 170
    5ea8:	b9 4f       	sbci	r27, 0xF9	; 249
    5eaa:	9a 96       	adiw	r26, 0x2a	; 42
    5eac:	ec 93       	st	X, r30
			//wurde das Ende des Packetes erreicht?
			//Schleife wird abgebrochen keine Daten mehr!!
			if (strncasecmp_P("%END",ntp_data_pointer,4)==0)
    5eae:	8a e5       	ldi	r24, 0x5A	; 90
    5eb0:	91 e0       	ldi	r25, 0x01	; 1
    5eb2:	b8 01       	movw	r22, r16
    5eb4:	44 e0       	ldi	r20, 0x04	; 4
    5eb6:	50 e0       	ldi	r21, 0x00	; 0
    5eb8:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    5ebc:	9e 01       	movw	r18, r28
    5ebe:	2f 5f       	subi	r18, 0xFF	; 255
    5ec0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec2:	89 2b       	or	r24, r25
    5ec4:	29 f0       	breq	.+10     	; 0x5ed0 <ntp_request+0xc4>
	if (arp_request(tmp_ip) == 1)
	{	
		//Interrupt Deaktivieren da Buffer gerade zum senden benutzt wird!
		//ETH_INT_DISABLE;
		PGM_P ntp_data_pointer = NTP_Request;
		for (byte_count = 0;byte_count<(MTU_SIZE-(UDP_DATA_START));byte_count++)
    5ec6:	e9 01       	movw	r28, r18
    5ec8:	84 e0       	ldi	r24, 0x04	; 4
    5eca:	26 38       	cpi	r18, 0x86	; 134
    5ecc:	38 07       	cpc	r19, r24
    5ece:	31 f7       	brne	.-52     	; 0x5e9c <ntp_request+0x90>
				byte_count++;
				break;
			}
		}
		
		create_new_udp_packet(byte_count,NTP_CLIENT_PORT,NTP_SERVER_PORT,tmp_ip);
    5ed0:	c9 01       	movw	r24, r18
    5ed2:	6c ef       	ldi	r22, 0xFC	; 252
    5ed4:	78 e0       	ldi	r23, 0x08	; 8
    5ed6:	4b e7       	ldi	r20, 0x7B	; 123
    5ed8:	50 e0       	ldi	r21, 0x00	; 0
    5eda:	97 01       	movw	r18, r14
    5edc:	86 01       	movw	r16, r12
    5ede:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <create_new_udp_packet>
		//ETH_INT_ENABLE;
		NTP_DEBUG("** NTP Request gesendet! **\r\n");
		(*(unsigned long*)&ntp_server_ip[0]) = 0L;	// neuen DNS request bei nchster NTP Abfrage erzwingen
    5ee2:	10 92 50 06 	sts	0x0650, r1
    5ee6:	10 92 51 06 	sts	0x0651, r1
    5eea:	10 92 52 06 	sts	0x0652, r1
    5eee:	10 92 53 06 	sts	0x0653, r1
		return;
	}
	NTP_DEBUG("Kein NTP Server gefunden!!\r\n");
	return;
}
    5ef2:	df 91       	pop	r29
    5ef4:	cf 91       	pop	r28
    5ef6:	1f 91       	pop	r17
    5ef8:	0f 91       	pop	r16
    5efa:	ff 90       	pop	r15
    5efc:	ef 90       	pop	r14
    5efe:	df 90       	pop	r13
    5f00:	cf 90       	pop	r12
    5f02:	08 95       	ret

00005f04 <ntp_init>:
 *
 */
void ntp_init (void)
{
	//Port in Anwendungstabelle eintragen fr eingehende NTP Daten!
	add_udp_app (NTP_CLIENT_PORT, (void(*)(unsigned char))ntp_get);
    5f04:	8c ef       	ldi	r24, 0xFC	; 252
    5f06:	98 e0       	ldi	r25, 0x08	; 8
    5f08:	6a e1       	ldi	r22, 0x1A	; 26
    5f0a:	7e e2       	ldi	r23, 0x2E	; 46
    5f0c:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <add_udp_app>
	
	// DNS Auflsung erzwingen
	(*((unsigned long*)&ntp_server_ip[0])) = 0L;
    5f10:	10 92 50 06 	sts	0x0650, r1
    5f14:	10 92 51 06 	sts	0x0651, r1
    5f18:	10 92 52 06 	sts	0x0652, r1
    5f1c:	10 92 53 06 	sts	0x0653, r1
	ntp_request();
    5f20:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <ntp_request>

	return;
}
    5f24:	08 95       	ret

00005f26 <http_request>:
}

//----------------------------------------------------------------------------
//HTTP Request an einen Webserver stelle
void http_request (void)
{
    5f26:	df 92       	push	r13
    5f28:	ef 92       	push	r14
    5f2a:	ff 92       	push	r15
    5f2c:	0f 93       	push	r16
    5f2e:	1f 93       	push	r17
    5f30:	cf 93       	push	r28
    5f32:	df 93       	push	r29
    unsigned long index = MAX_TCP_ENTRY;
    
    if (http_get_state > 1 && http_get_state < 20) http_get_state++;
    5f34:	80 91 16 02 	lds	r24, 0x0216
    5f38:	90 91 17 02 	lds	r25, 0x0217
    5f3c:	02 97       	sbiw	r24, 0x02	; 2
    5f3e:	78 f0       	brcs	.+30     	; 0x5f5e <http_request+0x38>
    5f40:	80 91 16 02 	lds	r24, 0x0216
    5f44:	90 91 17 02 	lds	r25, 0x0217
    5f48:	44 97       	sbiw	r24, 0x14	; 20
    5f4a:	48 f4       	brcc	.+18     	; 0x5f5e <http_request+0x38>
    5f4c:	80 91 16 02 	lds	r24, 0x0216
    5f50:	90 91 17 02 	lds	r25, 0x0217
    5f54:	01 96       	adiw	r24, 0x01	; 1
    5f56:	90 93 17 02 	sts	0x0217, r25
    5f5a:	80 93 16 02 	sts	0x0216, r24

    if (http_get_state == 0)
    5f5e:	80 91 16 02 	lds	r24, 0x0216
    5f62:	90 91 17 02 	lds	r25, 0x0217
    5f66:	89 2b       	or	r24, r25
    5f68:	09 f0       	breq	.+2      	; 0x5f6c <http_request+0x46>
    5f6a:	95 c0       	rjmp	.+298    	; 0x6096 <http_request+0x170>
    {
        //offnet eine Verbindung zu meinem Webserver
        HTTPC_DEBUG("ARP Request\n\r");
    5f6c:	00 d0       	rcall	.+0      	; 0x5f6e <http_request+0x48>
    5f6e:	82 e7       	ldi	r24, 0x72	; 114
    5f70:	97 e1       	ldi	r25, 0x17	; 23
    5f72:	ed b7       	in	r30, 0x3d	; 61
    5f74:	fe b7       	in	r31, 0x3e	; 62
    5f76:	92 83       	std	Z+2, r25	; 0x02
    5f78:	81 83       	std	Z+1, r24	; 0x01
    5f7a:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
        unsigned int my_http_cp = 2354;
        add_tcp_app (my_http_cp, (void(*)(unsigned char))test);
    5f7e:	0f 90       	pop	r0
    5f80:	0f 90       	pop	r0
    5f82:	82 e3       	ldi	r24, 0x32	; 50
    5f84:	99 e0       	ldi	r25, 0x09	; 9
    5f86:	6f e8       	ldi	r22, 0x8F	; 143
    5f88:	70 e3       	ldi	r23, 0x30	; 48
    5f8a:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
        
        //ARP Request senden
        if(arp_request (WEATHER_SERVER_IP))
    5f8e:	61 ed       	ldi	r22, 0xD1	; 209
    5f90:	72 ea       	ldi	r23, 0xA2	; 162
    5f92:	8a eb       	ldi	r24, 0xBA	; 186
    5f94:	9c e3       	ldi	r25, 0x3C	; 60
    5f96:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <arp_request>
    5f9a:	88 23       	and	r24, r24
    5f9c:	09 f4       	brne	.+2      	; 0x5fa0 <http_request+0x7a>
    5f9e:	75 c0       	rjmp	.+234    	; 0x608a <http_request+0x164>
    5fa0:	80 e0       	ldi	r24, 0x00	; 0
    5fa2:	90 e0       	ldi	r25, 0x00	; 0
    5fa4:	a0 e0       	ldi	r26, 0x00	; 0
    5fa6:	b0 e0       	ldi	r27, 0x00	; 0
        {
            for(unsigned long a=0;a<2000000;a++){asm("nop");};
    5fa8:	00 00       	nop
    5faa:	01 96       	adiw	r24, 0x01	; 1
    5fac:	a1 1d       	adc	r26, r1
    5fae:	b1 1d       	adc	r27, r1
    5fb0:	80 38       	cpi	r24, 0x80	; 128
    5fb2:	f4 e8       	ldi	r31, 0x84	; 132
    5fb4:	9f 07       	cpc	r25, r31
    5fb6:	fe e1       	ldi	r31, 0x1E	; 30
    5fb8:	af 07       	cpc	r26, r31
    5fba:	f0 e0       	ldi	r31, 0x00	; 0
    5fbc:	bf 07       	cpc	r27, r31
    5fbe:	a1 f7       	brne	.-24     	; 0x5fa8 <http_request+0x82>
            
            tcp_port_open (WEATHER_SERVER_IP,HTONS(80),htons(my_http_cp));
    5fc0:	82 e3       	ldi	r24, 0x32	; 50
    5fc2:	99 e0       	ldi	r25, 0x09	; 9
    5fc4:	0e 94 67 14 	call	0x28ce	; 0x28ce <htons>
    5fc8:	9c 01       	movw	r18, r24
    5fca:	61 ed       	ldi	r22, 0xD1	; 209
    5fcc:	72 ea       	ldi	r23, 0xA2	; 162
    5fce:	8a eb       	ldi	r24, 0xBA	; 186
    5fd0:	9c e3       	ldi	r25, 0x3C	; 60
    5fd2:	40 e0       	ldi	r20, 0x00	; 0
    5fd4:	50 e5       	ldi	r21, 0x50	; 80
    5fd6:	0e 94 a7 19 	call	0x334e	; 0x334e <tcp_port_open>
    5fda:	85 e0       	ldi	r24, 0x05	; 5
    5fdc:	e8 2e       	mov	r14, r24
    5fde:	f1 2c       	mov	r15, r1
    5fe0:	01 2d       	mov	r16, r1
    5fe2:	11 2d       	mov	r17, r1
    5fe4:	dd 24       	eor	r13, r13
               
            unsigned char tmp_counter = 0;
            while((index >= MAX_ARP_ENTRY) && (tcp_entry[index].app_status != 1))
    5fe6:	c6 e1       	ldi	r28, 0x16	; 22
    5fe8:	d0 e0       	ldi	r29, 0x00	; 0
    5fea:	22 c0       	rjmp	.+68     	; 0x6030 <http_request+0x10a>
            {
                index = tcp_entry_search (WEATHER_SERVER_IP,HTONS(80));
    5fec:	61 ed       	ldi	r22, 0xD1	; 209
    5fee:	72 ea       	ldi	r23, 0xA2	; 162
    5ff0:	8a eb       	ldi	r24, 0xBA	; 186
    5ff2:	9c e3       	ldi	r25, 0x3C	; 60
    5ff4:	40 e0       	ldi	r20, 0x00	; 0
    5ff6:	50 e5       	ldi	r21, 0x50	; 80
    5ff8:	0e 94 34 18 	call	0x3068	; 0x3068 <tcp_entry_search>
                if (tmp_counter++ > 30)
    5ffc:	2f e1       	ldi	r18, 0x1F	; 31
    5ffe:	d2 16       	cp	r13, r18
    6000:	61 f4       	brne	.+24     	; 0x601a <http_request+0xf4>
                {
                    HTTPC_DEBUG("TCP Eintrag nicht gefunden (HTTP_CLIENT)!\r\n");
    6002:	00 d0       	rcall	.+0      	; 0x6004 <http_request+0xde>
    6004:	86 e4       	ldi	r24, 0x46	; 70
    6006:	97 e1       	ldi	r25, 0x17	; 23
    6008:	ed b7       	in	r30, 0x3d	; 61
    600a:	fe b7       	in	r31, 0x3e	; 62
    600c:	92 83       	std	Z+2, r25	; 0x02
    600e:	81 83       	std	Z+1, r24	; 0x01
    6010:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    6014:	0f 90       	pop	r0
    6016:	0f 90       	pop	r0
    6018:	7a c0       	rjmp	.+244    	; 0x610e <http_request+0x1e8>
            tcp_port_open (WEATHER_SERVER_IP,HTONS(80),htons(my_http_cp));
               
            unsigned char tmp_counter = 0;
            while((index >= MAX_ARP_ENTRY) && (tcp_entry[index].app_status != 1))
            {
                index = tcp_entry_search (WEATHER_SERVER_IP,HTONS(80));
    601a:	e8 2e       	mov	r14, r24
    601c:	ff 24       	eor	r15, r15
    601e:	00 e0       	ldi	r16, 0x00	; 0
    6020:	10 e0       	ldi	r17, 0x00	; 0
            for(unsigned long a=0;a<2000000;a++){asm("nop");};
            
            tcp_port_open (WEATHER_SERVER_IP,HTONS(80),htons(my_http_cp));
               
            unsigned char tmp_counter = 0;
            while((index >= MAX_ARP_ENTRY) && (tcp_entry[index].app_status != 1))
    6022:	f5 e0       	ldi	r31, 0x05	; 5
    6024:	ef 16       	cp	r14, r31
    6026:	f1 04       	cpc	r15, r1
    6028:	01 05       	cpc	r16, r1
    602a:	11 05       	cpc	r17, r1
    602c:	70 f0       	brcs	.+28     	; 0x604a <http_request+0x124>
            {
                index = tcp_entry_search (WEATHER_SERVER_IP,HTONS(80));
                if (tmp_counter++ > 30)
    602e:	d3 94       	inc	r13
            for(unsigned long a=0;a<2000000;a++){asm("nop");};
            
            tcp_port_open (WEATHER_SERVER_IP,HTONS(80),htons(my_http_cp));
               
            unsigned char tmp_counter = 0;
            while((index >= MAX_ARP_ENTRY) && (tcp_entry[index].app_status != 1))
    6030:	ec 9e       	mul	r14, r28
    6032:	f0 01       	movw	r30, r0
    6034:	ed 9e       	mul	r14, r29
    6036:	f0 0d       	add	r31, r0
    6038:	fc 9e       	mul	r15, r28
    603a:	f0 0d       	add	r31, r0
    603c:	11 24       	eor	r1, r1
    603e:	ec 5a       	subi	r30, 0xAC	; 172
    6040:	f4 4f       	sbci	r31, 0xF4	; 244
    6042:	81 89       	ldd	r24, Z+17	; 0x11
    6044:	92 89       	ldd	r25, Z+18	; 0x12
    6046:	01 97       	sbiw	r24, 0x01	; 1
    6048:	89 f6       	brne	.-94     	; 0x5fec <http_request+0xc6>
                    HTTPC_DEBUG("TCP Eintrag nicht gefunden (HTTP_CLIENT)!\r\n");
                    return;
                }
            }
             
            HTTPC_DEBUG("TCP Eintrag gefunden (HTTP_CLIENT)!\r\n");
    604a:	00 d0       	rcall	.+0      	; 0x604c <http_request+0x126>
    604c:	80 e2       	ldi	r24, 0x20	; 32
    604e:	97 e1       	ldi	r25, 0x17	; 23
    6050:	ed b7       	in	r30, 0x3d	; 61
    6052:	fe b7       	in	r31, 0x3e	; 62
    6054:	92 83       	std	Z+2, r25	; 0x02
    6056:	81 83       	std	Z+1, r24	; 0x01
    6058:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
            tcp_entry[index].first_ack = 1;
    605c:	86 e1       	ldi	r24, 0x16	; 22
    605e:	90 e0       	ldi	r25, 0x00	; 0
    6060:	e8 9e       	mul	r14, r24
    6062:	f0 01       	movw	r30, r0
    6064:	e9 9e       	mul	r14, r25
    6066:	f0 0d       	add	r31, r0
    6068:	f8 9e       	mul	r15, r24
    606a:	f0 0d       	add	r31, r0
    606c:	11 24       	eor	r1, r1
    606e:	e7 59       	subi	r30, 0x97	; 151
    6070:	f4 4f       	sbci	r31, 0xF4	; 244
    6072:	80 81       	ld	r24, Z
    6074:	81 60       	ori	r24, 0x01	; 1
    6076:	80 83       	st	Z, r24
            http_get_state = 2;
    6078:	82 e0       	ldi	r24, 0x02	; 2
    607a:	90 e0       	ldi	r25, 0x00	; 0
    607c:	90 93 17 02 	sts	0x0217, r25
    6080:	80 93 16 02 	sts	0x0216, r24
    6084:	0f 90       	pop	r0
    6086:	0f 90       	pop	r0
    6088:	06 c0       	rjmp	.+12     	; 0x6096 <http_request+0x170>
        }
        else
        {
            http_get_state = 1;
    608a:	81 e0       	ldi	r24, 0x01	; 1
    608c:	90 e0       	ldi	r25, 0x00	; 0
    608e:	90 93 17 02 	sts	0x0217, r25
    6092:	80 93 16 02 	sts	0x0216, r24
        }
    }
    
    if (http_get_state > 10 && http_get_state < 20)  
    6096:	80 91 16 02 	lds	r24, 0x0216
    609a:	90 91 17 02 	lds	r25, 0x0217
    609e:	0b 97       	sbiw	r24, 0x0b	; 11
    60a0:	b0 f1       	brcs	.+108    	; 0x610e <http_request+0x1e8>
    60a2:	80 91 16 02 	lds	r24, 0x0216
    60a6:	90 91 17 02 	lds	r25, 0x0217
    60aa:	44 97       	sbiw	r24, 0x14	; 20
    60ac:	80 f5       	brcc	.+96     	; 0x610e <http_request+0x1e8>
    {
        HTTPC_DEBUG("\r\n\r\n\r\nDaten Anfordern\r\n");
    60ae:	00 d0       	rcall	.+0      	; 0x60b0 <http_request+0x18a>
    60b0:	88 e0       	ldi	r24, 0x08	; 8
    60b2:	97 e1       	ldi	r25, 0x17	; 23
    60b4:	ed b7       	in	r30, 0x3d	; 61
    60b6:	fe b7       	in	r31, 0x3e	; 62
    60b8:	92 83       	std	Z+2, r25	; 0x02
    60ba:	81 83       	std	Z+1, r24	; 0x01
    60bc:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
        index = tcp_entry_search (WEATHER_SERVER_IP,HTONS(80));
    60c0:	0f 90       	pop	r0
    60c2:	0f 90       	pop	r0
    60c4:	61 ed       	ldi	r22, 0xD1	; 209
    60c6:	72 ea       	ldi	r23, 0xA2	; 162
    60c8:	8a eb       	ldi	r24, 0xBA	; 186
    60ca:	9c e3       	ldi	r25, 0x3C	; 60
    60cc:	40 e0       	ldi	r20, 0x00	; 0
    60ce:	50 e5       	ldi	r21, 0x50	; 80
    60d0:	0e 94 34 18 	call	0x3068	; 0x3068 <tcp_entry_search>
    60d4:	d8 2e       	mov	r13, r24
    60d6:	e8 2e       	mov	r14, r24
    60d8:	ff 24       	eor	r15, r15
        memcpy_P(&eth_buffer[TCP_DATA_START],WEATHER_GET_STRING,(sizeof(WEATHER_GET_STRING)-1));
    60da:	8c e8       	ldi	r24, 0x8C	; 140
    60dc:	96 e0       	ldi	r25, 0x06	; 6
    60de:	6d e6       	ldi	r22, 0x6D	; 109
    60e0:	76 e1       	ldi	r23, 0x16	; 22
    60e2:	4a e9       	ldi	r20, 0x9A	; 154
    60e4:	50 e0       	ldi	r21, 0x00	; 0
    60e6:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
        tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    60ea:	86 e1       	ldi	r24, 0x16	; 22
    60ec:	90 e0       	ldi	r25, 0x00	; 0
    60ee:	e8 9e       	mul	r14, r24
    60f0:	f0 01       	movw	r30, r0
    60f2:	e9 9e       	mul	r14, r25
    60f4:	f0 0d       	add	r31, r0
    60f6:	f8 9e       	mul	r15, r24
    60f8:	f0 0d       	add	r31, r0
    60fa:	11 24       	eor	r1, r1
    60fc:	ec 5a       	subi	r30, 0xAC	; 172
    60fe:	f4 4f       	sbci	r31, 0xF4	; 244
    6100:	88 e1       	ldi	r24, 0x18	; 24
    6102:	80 8b       	std	Z+16, r24	; 0x10
        create_new_tcp_packet((sizeof(WEATHER_GET_STRING)-1),index);
    6104:	8a e9       	ldi	r24, 0x9A	; 154
    6106:	90 e0       	ldi	r25, 0x00	; 0
    6108:	6d 2d       	mov	r22, r13
    610a:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
    }
}
    610e:	df 91       	pop	r29
    6110:	cf 91       	pop	r28
    6112:	1f 91       	pop	r17
    6114:	0f 91       	pop	r16
    6116:	ff 90       	pop	r15
    6118:	ef 90       	pop	r14
    611a:	df 90       	pop	r13
    611c:	08 95       	ret

0000611e <test>:
volatile unsigned int http_get_state = 0;

//----------------------------------------------------------------------------
//Daten kommen von einem Webserver an!!
void test (unsigned char index)
{
    611e:	bf 92       	push	r11
    6120:	cf 92       	push	r12
    6122:	df 92       	push	r13
    6124:	ef 92       	push	r14
    6126:	ff 92       	push	r15
    6128:	0f 93       	push	r16
    612a:	1f 93       	push	r17
    612c:	cf 93       	push	r28
    612e:	df 93       	push	r29
    6130:	b8 2e       	mov	r11, r24
	for (int a = TCP_DATA_START_VAR;a < TCP_DATA_END_VAR;a++)
    6132:	80 91 84 06 	lds	r24, 0x0684
    6136:	c8 2f       	mov	r28, r24
    6138:	d0 e0       	ldi	r29, 0x00	; 0
    613a:	c0 7f       	andi	r28, 0xF0	; 240
    613c:	d0 70       	andi	r29, 0x00	; 0
    613e:	d5 95       	asr	r29
    6140:	c7 95       	ror	r28
    6142:	d5 95       	asr	r29
    6144:	c7 95       	ror	r28
    6146:	a2 96       	adiw	r28, 0x22	; 34
    6148:	66 e5       	ldi	r22, 0x56	; 86
    614a:	e6 2e       	mov	r14, r22
    614c:	66 e0       	ldi	r22, 0x06	; 6
    614e:	f6 2e       	mov	r15, r22
    6150:	ec 0e       	add	r14, r28
    6152:	fd 1e       	adc	r15, r29
	{
		HTTPC_DEBUG("%c",eth_buffer[a]);
    6154:	50 e8       	ldi	r21, 0x80	; 128
    6156:	c5 2e       	mov	r12, r21
    6158:	57 e1       	ldi	r21, 0x17	; 23
    615a:	d5 2e       	mov	r13, r21
    615c:	17 c0       	rjmp	.+46     	; 0x618c <test+0x6e>
    615e:	00 d0       	rcall	.+0      	; 0x6160 <test+0x42>
    6160:	00 d0       	rcall	.+0      	; 0x6162 <test+0x44>
    6162:	ed b7       	in	r30, 0x3d	; 61
    6164:	fe b7       	in	r31, 0x3e	; 62
    6166:	31 96       	adiw	r30, 0x01	; 1
    6168:	ad b7       	in	r26, 0x3d	; 61
    616a:	be b7       	in	r27, 0x3e	; 62
    616c:	12 96       	adiw	r26, 0x02	; 2
    616e:	dc 92       	st	X, r13
    6170:	ce 92       	st	-X, r12
    6172:	11 97       	sbiw	r26, 0x01	; 1
    6174:	d7 01       	movw	r26, r14
    6176:	8d 91       	ld	r24, X+
    6178:	7d 01       	movw	r14, r26
    617a:	82 83       	std	Z+2, r24	; 0x02
    617c:	13 82       	std	Z+3, r1	; 0x03
    617e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>

//----------------------------------------------------------------------------
//Daten kommen von einem Webserver an!!
void test (unsigned char index)
{
	for (int a = TCP_DATA_START_VAR;a < TCP_DATA_END_VAR;a++)
    6182:	21 96       	adiw	r28, 0x01	; 1
    6184:	0f 90       	pop	r0
    6186:	0f 90       	pop	r0
    6188:	0f 90       	pop	r0
    618a:	0f 90       	pop	r0
    618c:	20 91 67 06 	lds	r18, 0x0667
    6190:	30 e0       	ldi	r19, 0x00	; 0
    6192:	2e 5d       	subi	r18, 0xDE	; 222
    6194:	3f 4f       	sbci	r19, 0xFF	; 255
    6196:	10 91 66 06 	lds	r17, 0x0666
    619a:	00 e0       	ldi	r16, 0x00	; 0
    619c:	20 0f       	add	r18, r16
    619e:	31 1f       	adc	r19, r17
    61a0:	80 91 84 06 	lds	r24, 0x0684
    61a4:	90 e0       	ldi	r25, 0x00	; 0
    61a6:	80 7f       	andi	r24, 0xF0	; 240
    61a8:	90 70       	andi	r25, 0x00	; 0
    61aa:	95 95       	asr	r25
    61ac:	87 95       	ror	r24
    61ae:	95 95       	asr	r25
    61b0:	87 95       	ror	r24
    61b2:	28 1b       	sub	r18, r24
    61b4:	39 0b       	sbc	r19, r25
    61b6:	c2 17       	cp	r28, r18
    61b8:	d3 07       	cpc	r29, r19
    61ba:	8c f2       	brlt	.-94     	; 0x615e <test+0x40>
	{
		HTTPC_DEBUG("%c",eth_buffer[a]);
	}
	tcp_entry[index].time = TCP_TIME_OFF;
    61bc:	2b 2d       	mov	r18, r11
    61be:	30 e0       	ldi	r19, 0x00	; 0
    61c0:	86 e1       	ldi	r24, 0x16	; 22
    61c2:	90 e0       	ldi	r25, 0x00	; 0
    61c4:	28 9f       	mul	r18, r24
    61c6:	f0 01       	movw	r30, r0
    61c8:	29 9f       	mul	r18, r25
    61ca:	f0 0d       	add	r31, r0
    61cc:	38 9f       	mul	r19, r24
    61ce:	f0 0d       	add	r31, r0
    61d0:	11 24       	eor	r1, r1
    61d2:	ec 5a       	subi	r30, 0xAC	; 172
    61d4:	f4 4f       	sbci	r31, 0xF4	; 244
    61d6:	8f ef       	ldi	r24, 0xFF	; 255
    61d8:	83 8b       	std	Z+19, r24	; 0x13
	tcp_entry[index].status = ACK_FLAG;
    61da:	80 e1       	ldi	r24, 0x10	; 16
    61dc:	80 8b       	std	Z+16, r24	; 0x10
	create_new_tcp_packet(0,index);
    61de:	80 e0       	ldi	r24, 0x00	; 0
    61e0:	90 e0       	ldi	r25, 0x00	; 0
    61e2:	6b 2d       	mov	r22, r11
    61e4:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
}
    61e8:	df 91       	pop	r29
    61ea:	cf 91       	pop	r28
    61ec:	1f 91       	pop	r17
    61ee:	0f 91       	pop	r16
    61f0:	ff 90       	pop	r15
    61f2:	ef 90       	pop	r14
    61f4:	df 90       	pop	r13
    61f6:	cf 90       	pop	r12
    61f8:	bf 90       	pop	r11
    61fa:	08 95       	ret

000061fc <read_maildata>:
/**
 *	\ingroup mailintern
 *	Daten fr E-Mail einlesen
*/
uint16_t read_maildata(uint8_t mailno)
{
    61fc:	8f 92       	push	r8
    61fe:	9f 92       	push	r9
    6200:	af 92       	push	r10
    6202:	bf 92       	push	r11
    6204:	cf 92       	push	r12
    6206:	df 92       	push	r13
    6208:	ef 92       	push	r14
    620a:	ff 92       	push	r15
    620c:	0f 93       	push	r16
    620e:	1f 93       	push	r17
    6210:	df 93       	push	r29
    6212:	cf 93       	push	r28
    6214:	cd b7       	in	r28, 0x3d	; 61
    6216:	de b7       	in	r29, 0x3e	; 62
    6218:	c5 55       	subi	r28, 0x55	; 85
    621a:	d0 40       	sbci	r29, 0x00	; 0
    621c:	0f b6       	in	r0, 0x3f	; 63
    621e:	f8 94       	cli
    6220:	de bf       	out	0x3e, r29	; 62
    6222:	0f be       	out	0x3f, r0	; 63
    6224:	cd bf       	out	0x3d, r28	; 61
    6226:	18 2f       	mov	r17, r24
	char *ptr = (char *)&eth_buffer[TCP_DATA_START_VAR];
    6228:	80 91 84 06 	lds	r24, 0x0684
    622c:	90 e0       	ldi	r25, 0x00	; 0
    622e:	80 7f       	andi	r24, 0xF0	; 240
    6230:	90 70       	andi	r25, 0x00	; 0
    6232:	95 95       	asr	r25
    6234:	87 95       	ror	r24
    6236:	95 95       	asr	r25
    6238:	87 95       	ror	r24
    623a:	88 58       	subi	r24, 0x88	; 136
    623c:	99 4f       	sbci	r25, 0xF9	; 249
    623e:	9a 83       	std	Y+2, r25	; 0x02
    6240:	89 83       	std	Y+1, r24	; 0x01
	uint16_t len = 0;
	uint16_t srclen;
	char buffer[81];

	File *inifile = f16_open(MAIL_DATAFILE,"r");
    6242:	8f e5       	ldi	r24, 0x5F	; 95
    6244:	91 e0       	ldi	r25, 0x01	; 1
    6246:	68 e6       	ldi	r22, 0x68	; 104
    6248:	71 e0       	ldi	r23, 0x01	; 1
    624a:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    624e:	7c 01       	movw	r14, r24
	if (!inifile)
    6250:	00 97       	sbiw	r24, 0x00	; 0
    6252:	99 f4       	brne	.+38     	; 0x627a <read_maildata+0x7e>
    6254:	00 e0       	ldi	r16, 0x00	; 0
    6256:	10 e0       	ldi	r17, 0x00	; 0
    6258:	55 c0       	rjmp	.+170    	; 0x6304 <read_maildata+0x108>
		return 0;

	while ( f16_gets(buffer, sizeof(buffer), inifile) ) {
		MAIL_DEBUG("\r\n<|%s|>",buffer);

		if (!strncmp_P(buffer,PSTR("##"),2)) {
    625a:	c6 01       	movw	r24, r12
    625c:	6e eb       	ldi	r22, 0xBE	; 190
    625e:	77 e1       	ldi	r23, 0x17	; 23
    6260:	42 e0       	ldi	r20, 0x02	; 2
    6262:	50 e0       	ldi	r21, 0x00	; 0
    6264:	0e 94 07 6e 	call	0xdc0e	; 0xdc0e <strncmp_P>
    6268:	89 2b       	or	r24, r25
    626a:	99 f4       	brne	.+38     	; 0x6292 <read_maildata+0x96>
			if ( mailno == atoi(&buffer[2]) )
    626c:	c5 01       	movw	r24, r10
    626e:	0e 94 87 6d 	call	0xdb0e	; 0xdb0e <atoi>
    6272:	08 17       	cp	r16, r24
    6274:	19 07       	cpc	r17, r25
    6276:	69 f4       	brne	.+26     	; 0x6292 <read_maildata+0x96>
    6278:	26 c0       	rjmp	.+76     	; 0x62c6 <read_maildata+0xca>

	File *inifile = f16_open(MAIL_DATAFILE,"r");
	if (!inifile)
		return 0;

	while ( f16_gets(buffer, sizeof(buffer), inifile) ) {
    627a:	35 e0       	ldi	r19, 0x05	; 5
    627c:	c3 2e       	mov	r12, r19
    627e:	d1 2c       	mov	r13, r1
    6280:	cc 0e       	add	r12, r28
    6282:	dd 1e       	adc	r13, r29
		MAIL_DEBUG("\r\n<|%s|>",buffer);

		if (!strncmp_P(buffer,PSTR("##"),2)) {
			if ( mailno == atoi(&buffer[2]) )
    6284:	27 e0       	ldi	r18, 0x07	; 7
    6286:	a2 2e       	mov	r10, r18
    6288:	b1 2c       	mov	r11, r1
    628a:	ac 0e       	add	r10, r28
    628c:	bd 1e       	adc	r11, r29
    628e:	01 2f       	mov	r16, r17
    6290:	10 e0       	ldi	r17, 0x00	; 0

	File *inifile = f16_open(MAIL_DATAFILE,"r");
	if (!inifile)
		return 0;

	while ( f16_gets(buffer, sizeof(buffer), inifile) ) {
    6292:	c6 01       	movw	r24, r12
    6294:	61 e5       	ldi	r22, 0x51	; 81
    6296:	70 e0       	ldi	r23, 0x00	; 0
    6298:	a7 01       	movw	r20, r14
    629a:	0e 94 4c 4c 	call	0x9898	; 0x9898 <f16_gets>
    629e:	89 2b       	or	r24, r25
    62a0:	e1 f6       	brne	.-72     	; 0x625a <read_maildata+0x5e>
    62a2:	11 c0       	rjmp	.+34     	; 0x62c6 <read_maildata+0xca>
	}

	while ( f16_gets(buffer, sizeof(buffer), inifile) && len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
		MAIL_DEBUG("\r\n>|%s|<",buffer);

		if (!strncmp_P(buffer,PSTR("##"),2)) {
    62a4:	c6 01       	movw	r24, r12
    62a6:	6b eb       	ldi	r22, 0xBB	; 187
    62a8:	77 e1       	ldi	r23, 0x17	; 23
    62aa:	42 e0       	ldi	r20, 0x02	; 2
    62ac:	50 e0       	ldi	r21, 0x00	; 0
    62ae:	0e 94 07 6e 	call	0xdc0e	; 0xdc0e <strncmp_P>
    62b2:	89 2b       	or	r24, r25
    62b4:	21 f1       	breq	.+72     	; 0x62fe <read_maildata+0x102>
			break;	// nchste Mail beginnt
		}
		len += translate(buffer, &ptr, &srclen);
    62b6:	c6 01       	movw	r24, r12
    62b8:	b5 01       	movw	r22, r10
    62ba:	a4 01       	movw	r20, r8
    62bc:	0e 94 00 37 	call	0x6e00	; 0x6e00 <translate>
    62c0:	08 0f       	add	r16, r24
    62c2:	19 1f       	adc	r17, r25
    62c4:	10 c0       	rjmp	.+32     	; 0x62e6 <read_maildata+0xea>
    62c6:	00 e0       	ldi	r16, 0x00	; 0
    62c8:	10 e0       	ldi	r17, 0x00	; 0
			if ( mailno == atoi(&buffer[2]) )
				break;
		}
	}

	while ( f16_gets(buffer, sizeof(buffer), inifile) && len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
    62ca:	95 e0       	ldi	r25, 0x05	; 5
    62cc:	c9 2e       	mov	r12, r25
    62ce:	d1 2c       	mov	r13, r1
    62d0:	cc 0e       	add	r12, r28
    62d2:	dd 1e       	adc	r13, r29
		MAIL_DEBUG("\r\n>|%s|<",buffer);

		if (!strncmp_P(buffer,PSTR("##"),2)) {
			break;	// nchste Mail beginnt
		}
		len += translate(buffer, &ptr, &srclen);
    62d4:	83 e0       	ldi	r24, 0x03	; 3
    62d6:	88 2e       	mov	r8, r24
    62d8:	91 2c       	mov	r9, r1
    62da:	8c 0e       	add	r8, r28
    62dc:	9d 1e       	adc	r9, r29
    62de:	5e 01       	movw	r10, r28
    62e0:	08 94       	sec
    62e2:	a1 1c       	adc	r10, r1
    62e4:	b1 1c       	adc	r11, r1
			if ( mailno == atoi(&buffer[2]) )
				break;
		}
	}

	while ( f16_gets(buffer, sizeof(buffer), inifile) && len < (MTU_SIZE-(TCP_DATA_START)-100) ) {
    62e6:	c6 01       	movw	r24, r12
    62e8:	61 e5       	ldi	r22, 0x51	; 81
    62ea:	70 e0       	ldi	r23, 0x00	; 0
    62ec:	a7 01       	movw	r20, r14
    62ee:	0e 94 4c 4c 	call	0x9898	; 0x9898 <f16_gets>
    62f2:	89 2b       	or	r24, r25
    62f4:	21 f0       	breq	.+8      	; 0x62fe <read_maildata+0x102>
    62f6:	84 e0       	ldi	r24, 0x04	; 4
    62f8:	06 31       	cpi	r16, 0x16	; 22
    62fa:	18 07       	cpc	r17, r24
    62fc:	98 f2       	brcs	.-90     	; 0x62a4 <read_maildata+0xa8>
			break;	// nchste Mail beginnt
		}
		len += translate(buffer, &ptr, &srclen);
	}

	f16_close(inifile);
    62fe:	c7 01       	movw	r24, r14
    6300:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
	return len;
}
    6304:	c8 01       	movw	r24, r16
    6306:	cb 5a       	subi	r28, 0xAB	; 171
    6308:	df 4f       	sbci	r29, 0xFF	; 255
    630a:	0f b6       	in	r0, 0x3f	; 63
    630c:	f8 94       	cli
    630e:	de bf       	out	0x3e, r29	; 62
    6310:	0f be       	out	0x3f, r0	; 63
    6312:	cd bf       	out	0x3d, r28	; 61
    6314:	cf 91       	pop	r28
    6316:	df 91       	pop	r29
    6318:	1f 91       	pop	r17
    631a:	0f 91       	pop	r16
    631c:	ff 90       	pop	r15
    631e:	ef 90       	pop	r14
    6320:	df 90       	pop	r13
    6322:	cf 90       	pop	r12
    6324:	bf 90       	pop	r11
    6326:	af 90       	pop	r10
    6328:	9f 90       	pop	r9
    632a:	8f 90       	pop	r8
    632c:	08 95       	ret

0000632e <read_mailparam>:
/**
 *	\ingroup mailintern
 *	einzelnen Parameter aus Mail-Ini-Datei lesen
*/
char *read_mailparam(const char *parm, char *buffer, uint16_t len)
{
    632e:	af 92       	push	r10
    6330:	bf 92       	push	r11
    6332:	cf 92       	push	r12
    6334:	df 92       	push	r13
    6336:	ef 92       	push	r14
    6338:	ff 92       	push	r15
    633a:	0f 93       	push	r16
    633c:	1f 93       	push	r17
    633e:	cf 93       	push	r28
    6340:	df 93       	push	r29
    6342:	5c 01       	movw	r10, r24
    6344:	eb 01       	movw	r28, r22
    6346:	6a 01       	movw	r12, r20
	char *ptr = (char *)0;

	File *inifile = f16_open(MAIL_DATAFILE,"r");
    6348:	8f e5       	ldi	r24, 0x5F	; 95
    634a:	91 e0       	ldi	r25, 0x01	; 1
    634c:	68 e6       	ldi	r22, 0x68	; 104
    634e:	71 e0       	ldi	r23, 0x01	; 1
    6350:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    6354:	8c 01       	movw	r16, r24
	if (!inifile)
    6356:	00 97       	sbiw	r24, 0x00	; 0
    6358:	d9 f4       	brne	.+54     	; 0x6390 <read_mailparam+0x62>
    635a:	c0 e0       	ldi	r28, 0x00	; 0
    635c:	d0 e0       	ldi	r29, 0x00	; 0
    635e:	36 c0       	rjmp	.+108    	; 0x63cc <read_mailparam+0x9e>
		return ptr;

	while ( f16_gets(buffer, len, inifile) ) {
		MAIL_DEBUG("\r\n<|%s|>",buffer);

		if (!strncmp_P(buffer,parm,2)) {
    6360:	ce 01       	movw	r24, r28
    6362:	b5 01       	movw	r22, r10
    6364:	42 e0       	ldi	r20, 0x02	; 2
    6366:	50 e0       	ldi	r21, 0x00	; 0
    6368:	0e 94 07 6e 	call	0xdc0e	; 0xdc0e <strncmp_P>
    636c:	89 2b       	or	r24, r25
    636e:	a9 f4       	brne	.+42     	; 0x639a <read_mailparam+0x6c>
			if (*buffer == '#') {	// E-Mail no.
    6370:	88 81       	ld	r24, Y
    6372:	83 32       	cpi	r24, 0x23	; 35
    6374:	59 f4       	brne	.+22     	; 0x638c <read_mailparam+0x5e>
				if ( sm_status.mailno == atoi(&buffer[2]) ) {
    6376:	c7 01       	movw	r24, r14
    6378:	0e 94 87 6d 	call	0xdb0e	; 0xdb0e <atoi>
    637c:	20 91 5b 0d 	lds	r18, 0x0D5B
    6380:	30 e0       	ldi	r19, 0x00	; 0
    6382:	28 17       	cp	r18, r24
    6384:	39 07       	cpc	r19, r25
    6386:	49 f4       	brne	.+18     	; 0x639a <read_mailparam+0x6c>
					ptr = buffer + 4;
    6388:	24 96       	adiw	r28, 0x04	; 4
    638a:	10 c0       	rjmp	.+32     	; 0x63ac <read_mailparam+0x7e>
					break;
				}
			}
			else {		// normaler Parameter
				ptr = buffer + 3;
    638c:	23 96       	adiw	r28, 0x03	; 3
    638e:	0e c0       	rjmp	.+28     	; 0x63ac <read_mailparam+0x7e>
	while ( f16_gets(buffer, len, inifile) ) {
		MAIL_DEBUG("\r\n<|%s|>",buffer);

		if (!strncmp_P(buffer,parm,2)) {
			if (*buffer == '#') {	// E-Mail no.
				if ( sm_status.mailno == atoi(&buffer[2]) ) {
    6390:	52 e0       	ldi	r21, 0x02	; 2
    6392:	e5 2e       	mov	r14, r21
    6394:	f1 2c       	mov	r15, r1
    6396:	ec 0e       	add	r14, r28
    6398:	fd 1e       	adc	r15, r29

	File *inifile = f16_open(MAIL_DATAFILE,"r");
	if (!inifile)
		return ptr;

	while ( f16_gets(buffer, len, inifile) ) {
    639a:	ce 01       	movw	r24, r28
    639c:	b6 01       	movw	r22, r12
    639e:	a8 01       	movw	r20, r16
    63a0:	0e 94 4c 4c 	call	0x9898	; 0x9898 <f16_gets>
    63a4:	89 2b       	or	r24, r25
    63a6:	e1 f6       	brne	.-72     	; 0x6360 <read_mailparam+0x32>
    63a8:	c0 e0       	ldi	r28, 0x00	; 0
    63aa:	d0 e0       	ldi	r29, 0x00	; 0
				break;
			}
		}
	}

	f16_close(inifile);
    63ac:	c8 01       	movw	r24, r16
    63ae:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
	if (*(ptr+strlen(ptr)-2) == '\r')	// CRLF abschneiden
    63b2:	de 01       	movw	r26, r28
    63b4:	0d 90       	ld	r0, X+
    63b6:	00 20       	and	r0, r0
    63b8:	e9 f7       	brne	.-6      	; 0x63b4 <read_mailparam+0x86>
    63ba:	ac 1b       	sub	r26, r28
    63bc:	bd 0b       	sbc	r27, r29
    63be:	13 97       	sbiw	r26, 0x03	; 3
    63c0:	ac 0f       	add	r26, r28
    63c2:	bd 1f       	adc	r27, r29
    63c4:	8c 91       	ld	r24, X
    63c6:	8d 30       	cpi	r24, 0x0D	; 13
    63c8:	09 f4       	brne	.+2      	; 0x63cc <read_mailparam+0x9e>
		*(ptr+strlen(ptr)-2) = 0;
    63ca:	1c 92       	st	X, r1
	return ptr;
}
    63cc:	ce 01       	movw	r24, r28
    63ce:	df 91       	pop	r29
    63d0:	cf 91       	pop	r28
    63d2:	1f 91       	pop	r17
    63d4:	0f 91       	pop	r16
    63d6:	ff 90       	pop	r15
    63d8:	ef 90       	pop	r14
    63da:	df 90       	pop	r13
    63dc:	cf 90       	pop	r12
    63de:	bf 90       	pop	r11
    63e0:	af 90       	pop	r10
    63e2:	08 95       	ret

000063e4 <sendmail>:
 *	\b mailno falls bereits ein Mailversand aktiv und noch nicht
 *	beendet ist, oder die DNS-Auflsung des SMPT-Servers noch nicht
 *	erfolgreich war.
 */
uint8_t sendmail(uint8_t mailno)
{
    63e4:	0f 93       	push	r16
    63e6:	1f 93       	push	r17
    63e8:	df 93       	push	r29
    63ea:	cf 93       	push	r28
    63ec:	cd b7       	in	r28, 0x3d	; 61
    63ee:	de b7       	in	r29, 0x3e	; 62
    63f0:	c1 55       	subi	r28, 0x51	; 81
    63f2:	d0 40       	sbci	r29, 0x00	; 0
    63f4:	0f b6       	in	r0, 0x3f	; 63
    63f6:	f8 94       	cli
    63f8:	de bf       	out	0x3e, r29	; 62
    63fa:	0f be       	out	0x3f, r0	; 63
    63fc:	cd bf       	out	0x3d, r28	; 61
    63fe:	18 2f       	mov	r17, r24
	// DNS-Auflsung des SMTP-Servers
	if (!sm_status.server_ip) {
    6400:	80 91 5c 0d 	lds	r24, 0x0D5C
    6404:	90 91 5d 0d 	lds	r25, 0x0D5D
    6408:	a0 91 5e 0d 	lds	r26, 0x0D5E
    640c:	b0 91 5f 0d 	lds	r27, 0x0D5F
    6410:	00 97       	sbiw	r24, 0x00	; 0
    6412:	a1 05       	cpc	r26, r1
    6414:	b1 05       	cpc	r27, r1
    6416:	09 f0       	breq	.+2      	; 0x641a <sendmail+0x36>
    6418:	41 c0       	rjmp	.+130    	; 0x649c <sendmail+0xb8>
		if (sm_status.status == 1) {
    641a:	80 91 5a 0d 	lds	r24, 0x0D5A
    641e:	81 30       	cpi	r24, 0x01	; 1
    6420:	b1 f4       	brne	.+44     	; 0x644e <sendmail+0x6a>
			// wir warten auf die DNS Antwort
			if ( time < sm_status.timeout )
    6422:	20 91 77 0c 	lds	r18, 0x0C77
    6426:	30 91 78 0c 	lds	r19, 0x0C78
    642a:	40 91 79 0c 	lds	r20, 0x0C79
    642e:	50 91 7a 0c 	lds	r21, 0x0C7A
    6432:	80 91 62 0d 	lds	r24, 0x0D62
    6436:	90 91 63 0d 	lds	r25, 0x0D63
    643a:	a0 91 64 0d 	lds	r26, 0x0D64
    643e:	b0 91 65 0d 	lds	r27, 0x0D65
    6442:	28 17       	cp	r18, r24
    6444:	39 07       	cpc	r19, r25
    6446:	4a 07       	cpc	r20, r26
    6448:	5b 07       	cpc	r21, r27
    644a:	08 f4       	brcc	.+2      	; 0x644e <sendmail+0x6a>
    644c:	7f c0       	rjmp	.+254    	; 0x654c <sendmail+0x168>

		char zeile[81];
		char *ptr;

		// SMTP Hostnamen aus Ini-Datei lesen
		if ( (ptr = read_mailparam(PSTR("MX"),zeile,sizeof(zeile))) )
    644e:	81 ec       	ldi	r24, 0xC1	; 193
    6450:	97 e1       	ldi	r25, 0x17	; 23
    6452:	be 01       	movw	r22, r28
    6454:	6f 5f       	subi	r22, 0xFF	; 255
    6456:	7f 4f       	sbci	r23, 0xFF	; 255
    6458:	41 e5       	ldi	r20, 0x51	; 81
    645a:	50 e0       	ldi	r21, 0x00	; 0
    645c:	0e 94 97 31 	call	0x632e	; 0x632e <read_mailparam>
    6460:	00 97       	sbiw	r24, 0x00	; 0
    6462:	09 f4       	brne	.+2      	; 0x6466 <sendmail+0x82>
    6464:	72 c0       	rjmp	.+228    	; 0x654a <sendmail+0x166>
			dns_request(ptr, &sm_status.server_ip);
    6466:	6c e5       	ldi	r22, 0x5C	; 92
    6468:	7d e0       	ldi	r23, 0x0D	; 13
    646a:	0e 94 8c 36 	call	0x6d18	; 0x6d18 <dns_request>
		else
			return 0;	// kein SMTP-Server angegeben

		sm_status.status = 1;
    646e:	81 e0       	ldi	r24, 0x01	; 1
    6470:	80 93 5a 0d 	sts	0x0D5A, r24
		sm_status.timeout = time + 3;	// 3 sec. Timeout
    6474:	80 91 77 0c 	lds	r24, 0x0C77
    6478:	90 91 78 0c 	lds	r25, 0x0C78
    647c:	a0 91 79 0c 	lds	r26, 0x0C79
    6480:	b0 91 7a 0c 	lds	r27, 0x0C7A
    6484:	03 96       	adiw	r24, 0x03	; 3
    6486:	a1 1d       	adc	r26, r1
    6488:	b1 1d       	adc	r27, r1
    648a:	80 93 62 0d 	sts	0x0D62, r24
    648e:	90 93 63 0d 	sts	0x0D63, r25
    6492:	a0 93 64 0d 	sts	0x0D64, r26
    6496:	b0 93 65 0d 	sts	0x0D65, r27
    649a:	58 c0       	rjmp	.+176    	; 0x654c <sendmail+0x168>
		return mailno;
	}

	if (sm_status.aktiv) {		// E-Mail ist aktiv
    649c:	80 91 59 0d 	lds	r24, 0x0D59
    64a0:	80 fd       	sbrc	r24, 0
    64a2:	54 c0       	rjmp	.+168    	; 0x654c <sendmail+0x168>
		return mailno;			// warten bis vorherige E-Mail verschickt
	}

	sm_status.mailno = mailno;	// # der Nachricht merken
    64a4:	10 93 5b 0d 	sts	0x0D5B, r17

	// Absender Port zufllig auswhlen
    unsigned int my_mail_cp_new = sm_status.client_port + time;
    64a8:	20 91 60 0d 	lds	r18, 0x0D60
    64ac:	30 91 61 0d 	lds	r19, 0x0D61
    64b0:	80 91 77 0c 	lds	r24, 0x0C77
    64b4:	90 91 78 0c 	lds	r25, 0x0C78
    64b8:	a0 91 79 0c 	lds	r26, 0x0C79
    64bc:	b0 91 7a 0c 	lds	r27, 0x0C7A
    64c0:	89 01       	movw	r16, r18
    64c2:	08 0f       	add	r16, r24
    64c4:	19 1f       	adc	r17, r25
    if (my_mail_cp_new < 1000) my_mail_cp_new +=1000;
    64c6:	83 e0       	ldi	r24, 0x03	; 3
    64c8:	08 3e       	cpi	r16, 0xE8	; 232
    64ca:	18 07       	cpc	r17, r24
    64cc:	10 f4       	brcc	.+4      	; 0x64d2 <sendmail+0xee>
    64ce:	08 51       	subi	r16, 0x18	; 24
    64d0:	1c 4f       	sbci	r17, 0xFC	; 252
    change_port_tcp_app (sm_status.client_port, my_mail_cp_new);
    64d2:	c9 01       	movw	r24, r18
    64d4:	b8 01       	movw	r22, r16
    64d6:	0e 94 fd 14 	call	0x29fa	; 0x29fa <change_port_tcp_app>
    sm_status.client_port = my_mail_cp_new;
    64da:	10 93 61 0d 	sts	0x0D61, r17
    64de:	00 93 60 0d 	sts	0x0D60, r16

	// ARP Request senden
	// und Socket ffnen
	if (arp_request(sm_status.server_ip))
    64e2:	60 91 5c 0d 	lds	r22, 0x0D5C
    64e6:	70 91 5d 0d 	lds	r23, 0x0D5D
    64ea:	80 91 5e 0d 	lds	r24, 0x0D5E
    64ee:	90 91 5f 0d 	lds	r25, 0x0D5F
    64f2:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <arp_request>
    64f6:	88 23       	and	r24, r24
    64f8:	41 f1       	breq	.+80     	; 0x654a <sendmail+0x166>
    64fa:	80 e0       	ldi	r24, 0x00	; 0
    64fc:	90 e0       	ldi	r25, 0x00	; 0
    64fe:	a0 e0       	ldi	r26, 0x00	; 0
    6500:	b0 e0       	ldi	r27, 0x00	; 0
    {
        for(unsigned long a=0;a<2000000;a++){asm("nop");}; 	// das ist noch etwas "unschn", 
    6502:	00 00       	nop
    6504:	01 96       	adiw	r24, 0x01	; 1
    6506:	a1 1d       	adc	r26, r1
    6508:	b1 1d       	adc	r27, r1
    650a:	80 38       	cpi	r24, 0x80	; 128
    650c:	24 e8       	ldi	r18, 0x84	; 132
    650e:	92 07       	cpc	r25, r18
    6510:	2e e1       	ldi	r18, 0x1E	; 30
    6512:	a2 07       	cpc	r26, r18
    6514:	20 e0       	ldi	r18, 0x00	; 0
    6516:	b2 07       	cpc	r27, r18
    6518:	a1 f7       	brne	.-24     	; 0x6502 <sendmail+0x11e>
															// besser flag setzen und dann in mainloop pollen
        
        MAIL_DEBUG("\r\nMail empfang am Clientport (%u)",(uint32_t)sm_status.client_port);
        tcp_port_open (sm_status.server_ip,HTONS(SMTP_PORT),HTONS(sm_status.client_port));
    651a:	60 91 5c 0d 	lds	r22, 0x0D5C
    651e:	70 91 5d 0d 	lds	r23, 0x0D5D
    6522:	80 91 5e 0d 	lds	r24, 0x0D5E
    6526:	90 91 5f 0d 	lds	r25, 0x0D5F
    652a:	30 91 60 0d 	lds	r19, 0x0D60
    652e:	20 91 61 0d 	lds	r18, 0x0D61
    6532:	40 e0       	ldi	r20, 0x00	; 0
    6534:	59 e1       	ldi	r21, 0x19	; 25
    6536:	0e 94 a7 19 	call	0x334e	; 0x334e <tcp_port_open>
		sm_status.status = MX_WAIT_FOR_220;
    653a:	8a e0       	ldi	r24, 0x0A	; 10
    653c:	80 93 5a 0d 	sts	0x0D5A, r24
		sm_status.aktiv = 1;	// Versand ist aktiv
    6540:	80 91 59 0d 	lds	r24, 0x0D59
    6544:	81 60       	ori	r24, 0x01	; 1
    6546:	80 93 59 0d 	sts	0x0D59, r24
    654a:	10 e0       	ldi	r17, 0x00	; 0
    }

	return 0;	// E-Mail Versand ist gestartet -> diese Routine nicht mehr aufrufen
}
    654c:	81 2f       	mov	r24, r17
    654e:	cf 5a       	subi	r28, 0xAF	; 175
    6550:	df 4f       	sbci	r29, 0xFF	; 255
    6552:	0f b6       	in	r0, 0x3f	; 63
    6554:	f8 94       	cli
    6556:	de bf       	out	0x3e, r29	; 62
    6558:	0f be       	out	0x3f, r0	; 63
    655a:	cd bf       	out	0x3d, r28	; 61
    655c:	cf 91       	pop	r28
    655e:	df 91       	pop	r29
    6560:	1f 91       	pop	r17
    6562:	0f 91       	pop	r16
    6564:	08 95       	ret

00006566 <sendmail_data>:
/**
*	\ingroup mailintern
*	Response vom SMTP-Server erhalten
*/
void sendmail_data(uint8_t index)
{
    6566:	cf 92       	push	r12
    6568:	df 92       	push	r13
    656a:	ff 92       	push	r15
    656c:	0f 93       	push	r16
    656e:	1f 93       	push	r17
    6570:	df 93       	push	r29
    6572:	cf 93       	push	r28
    6574:	cd b7       	in	r28, 0x3d	; 61
    6576:	de b7       	in	r29, 0x3e	; 62
    6578:	c1 55       	subi	r28, 0x51	; 81
    657a:	d0 40       	sbci	r29, 0x00	; 0
    657c:	0f b6       	in	r0, 0x3f	; 63
    657e:	f8 94       	cli
    6580:	de bf       	out	0x3e, r29	; 62
    6582:	0f be       	out	0x3f, r0	; 63
    6584:	cd bf       	out	0x3d, r28	; 61
    6586:	f8 2e       	mov	r15, r24
	MAIL_DEBUG("\r\nsendmail_data %i",index);
    if (tcp_entry[index].status & FIN_FLAG) {	// Verbindungsabbau
    6588:	c8 2e       	mov	r12, r24
    658a:	dd 24       	eor	r13, r13
    658c:	86 e1       	ldi	r24, 0x16	; 22
    658e:	90 e0       	ldi	r25, 0x00	; 0
    6590:	c8 9e       	mul	r12, r24
    6592:	f0 01       	movw	r30, r0
    6594:	c9 9e       	mul	r12, r25
    6596:	f0 0d       	add	r31, r0
    6598:	d8 9e       	mul	r13, r24
    659a:	f0 0d       	add	r31, r0
    659c:	11 24       	eor	r1, r1
    659e:	ec 5a       	subi	r30, 0xAC	; 172
    65a0:	f4 4f       	sbci	r31, 0xF4	; 244
    65a2:	80 89       	ldd	r24, Z+16	; 0x10
    65a4:	80 fd       	sbrc	r24, 0
    65a6:	3e c0       	rjmp	.+124    	; 0x6624 <sendmail_data+0xbe>
		sm_status.aktiv = 0;
        return;
    }

	char *ptr = (char *)&eth_buffer[TCP_DATA_START_VAR];
    65a8:	80 91 84 06 	lds	r24, 0x0684
    65ac:	08 2f       	mov	r16, r24
    65ae:	10 e0       	ldi	r17, 0x00	; 0
    65b0:	00 7f       	andi	r16, 0xF0	; 240
    65b2:	10 70       	andi	r17, 0x00	; 0
    65b4:	15 95       	asr	r17
    65b6:	07 95       	ror	r16
    65b8:	15 95       	asr	r17
    65ba:	07 95       	ror	r16
    65bc:	08 58       	subi	r16, 0x88	; 136
    65be:	19 4f       	sbci	r17, 0xF9	; 249
	uint16_t status;

	if ( isdigit(*ptr) && isdigit(*(ptr+1)) && isdigit(*(ptr+2)) ) {
    65c0:	f8 01       	movw	r30, r16
    65c2:	80 81       	ld	r24, Z
    65c4:	90 e0       	ldi	r25, 0x00	; 0
    65c6:	c0 97       	sbiw	r24, 0x30	; 48
    65c8:	0a 97       	sbiw	r24, 0x0a	; 10
    65ca:	08 f0       	brcs	.+2      	; 0x65ce <sendmail_data+0x68>
    65cc:	30 c1       	rjmp	.+608    	; 0x682e <sendmail_data+0x2c8>
    65ce:	81 81       	ldd	r24, Z+1	; 0x01
    65d0:	90 e0       	ldi	r25, 0x00	; 0
    65d2:	c0 97       	sbiw	r24, 0x30	; 48
    65d4:	0a 97       	sbiw	r24, 0x0a	; 10
    65d6:	08 f0       	brcs	.+2      	; 0x65da <sendmail_data+0x74>
    65d8:	2a c1       	rjmp	.+596    	; 0x682e <sendmail_data+0x2c8>
    65da:	82 81       	ldd	r24, Z+2	; 0x02
    65dc:	90 e0       	ldi	r25, 0x00	; 0
    65de:	c0 97       	sbiw	r24, 0x30	; 48
    65e0:	0a 97       	sbiw	r24, 0x0a	; 10
    65e2:	08 f0       	brcs	.+2      	; 0x65e6 <sendmail_data+0x80>
    65e4:	24 c1       	rjmp	.+584    	; 0x682e <sendmail_data+0x2c8>
		status = atoi(ptr);
    65e6:	c8 01       	movw	r24, r16
    65e8:	0e 94 87 6d 	call	0xdb0e	; 0xdb0e <atoi>
    65ec:	ac 01       	movw	r20, r24
		MAIL_DEBUG("\r\nStatus-Code %i %s",status,ptr);
	}
	else
		return;	// kein Statuscode in Antwort -> verwerfen

	if (sm_status.status == 12 && status == 503) {
    65ee:	80 91 5a 0d 	lds	r24, 0x0D5A
    65f2:	8c 30       	cpi	r24, 0x0C	; 12
    65f4:	49 f4       	brne	.+18     	; 0x6608 <sendmail_data+0xa2>
    65f6:	f1 e0       	ldi	r31, 0x01	; 1
    65f8:	47 3f       	cpi	r20, 0xF7	; 247
    65fa:	5f 07       	cpc	r21, r31
    65fc:	29 f4       	brne	.+10     	; 0x6608 <sendmail_data+0xa2>
		// die Kiste will kein login -> bei MAIL FROM weitermachen
		status = 235;
		sm_status.status = 14;
    65fe:	8e e0       	ldi	r24, 0x0E	; 14
    6600:	80 93 5a 0d 	sts	0x0D5A, r24
    6604:	4b ee       	ldi	r20, 0xEB	; 235
    6606:	50 e0       	ldi	r21, 0x00	; 0
	}

    if (sm_status.status != 19 && (status >= 500 || status == 451) ) {
    6608:	20 91 5a 0d 	lds	r18, 0x0D5A
    660c:	23 31       	cpi	r18, 0x13	; 19
    660e:	81 f0       	breq	.+32     	; 0x6630 <sendmail_data+0xca>
    6610:	81 e0       	ldi	r24, 0x01	; 1
    6612:	44 3f       	cpi	r20, 0xF4	; 244
    6614:	58 07       	cpc	r21, r24
    6616:	20 f4       	brcc	.+8      	; 0x6620 <sendmail_data+0xba>
    6618:	e1 e0       	ldi	r30, 0x01	; 1
    661a:	43 3c       	cpi	r20, 0xC3	; 195
    661c:	5e 07       	cpc	r21, r30
    661e:	41 f4       	brne	.+16     	; 0x6630 <sendmail_data+0xca>

	    MAIL_DEBUG("\r\n\r\n*** Error: Mail wurde nicht versendet ***\r\n");
        MAIL_DEBUG("\r\nStatus-Code: %i",status);
		// TODO: eventuell trotzdem noch QUIT senden ?
        sm_status.status = 0;
    6620:	10 92 5a 0d 	sts	0x0D5A, r1
		sm_status.aktiv = 0;
    6624:	80 91 59 0d 	lds	r24, 0x0D59
    6628:	8e 7f       	andi	r24, 0xFE	; 254
    662a:	80 93 59 0d 	sts	0x0D59, r24
    662e:	ff c0       	rjmp	.+510    	; 0x682e <sendmail_data+0x2c8>
        return;
    }

	tcp_entry[index].status = ACK_FLAG | PSH_FLAG;
    6630:	86 e1       	ldi	r24, 0x16	; 22
    6632:	90 e0       	ldi	r25, 0x00	; 0
    6634:	c8 9e       	mul	r12, r24
    6636:	f0 01       	movw	r30, r0
    6638:	c9 9e       	mul	r12, r25
    663a:	f0 0d       	add	r31, r0
    663c:	d8 9e       	mul	r13, r24
    663e:	f0 0d       	add	r31, r0
    6640:	11 24       	eor	r1, r1
    6642:	ec 5a       	subi	r30, 0xAC	; 172
    6644:	f4 4f       	sbci	r31, 0xF4	; 244
    6646:	88 e1       	ldi	r24, 0x18	; 24
    6648:	80 8b       	std	Z+16, r24	; 0x10

	switch (sm_status.status) {
    664a:	2f 30       	cpi	r18, 0x0F	; 15
    664c:	09 f4       	brne	.+2      	; 0x6650 <sendmail_data+0xea>
    664e:	97 c0       	rjmp	.+302    	; 0x677e <sendmail_data+0x218>
    6650:	20 31       	cpi	r18, 0x10	; 16
    6652:	90 f4       	brcc	.+36     	; 0x6678 <sendmail_data+0x112>
    6654:	2c 30       	cpi	r18, 0x0C	; 12
    6656:	09 f4       	brne	.+2      	; 0x665a <sendmail_data+0xf4>
    6658:	46 c0       	rjmp	.+140    	; 0x66e6 <sendmail_data+0x180>
    665a:	2d 30       	cpi	r18, 0x0D	; 13
    665c:	30 f4       	brcc	.+12     	; 0x666a <sendmail_data+0x104>
    665e:	2a 30       	cpi	r18, 0x0A	; 10
    6660:	f1 f0       	breq	.+60     	; 0x669e <sendmail_data+0x138>
    6662:	2b 30       	cpi	r18, 0x0B	; 11
    6664:	09 f0       	breq	.+2      	; 0x6668 <sendmail_data+0x102>
    6666:	d6 c0       	rjmp	.+428    	; 0x6814 <sendmail_data+0x2ae>
    6668:	28 c0       	rjmp	.+80     	; 0x66ba <sendmail_data+0x154>
    666a:	2d 30       	cpi	r18, 0x0D	; 13
    666c:	09 f4       	brne	.+2      	; 0x6670 <sendmail_data+0x10a>
    666e:	4f c0       	rjmp	.+158    	; 0x670e <sendmail_data+0x1a8>
    6670:	2e 30       	cpi	r18, 0x0E	; 14
    6672:	09 f0       	breq	.+2      	; 0x6676 <sendmail_data+0x110>
    6674:	cf c0       	rjmp	.+414    	; 0x6814 <sendmail_data+0x2ae>
    6676:	69 c0       	rjmp	.+210    	; 0x674a <sendmail_data+0x1e4>
    6678:	22 31       	cpi	r18, 0x12	; 18
    667a:	09 f4       	brne	.+2      	; 0x667e <sendmail_data+0x118>
    667c:	b0 c0       	rjmp	.+352    	; 0x67de <sendmail_data+0x278>
    667e:	23 31       	cpi	r18, 0x13	; 19
    6680:	38 f4       	brcc	.+14     	; 0x6690 <sendmail_data+0x12a>
    6682:	20 31       	cpi	r18, 0x10	; 16
    6684:	09 f4       	brne	.+2      	; 0x6688 <sendmail_data+0x122>
    6686:	9f c0       	rjmp	.+318    	; 0x67c6 <sendmail_data+0x260>
    6688:	21 31       	cpi	r18, 0x11	; 17
    668a:	09 f0       	breq	.+2      	; 0x668e <sendmail_data+0x128>
    668c:	c3 c0       	rjmp	.+390    	; 0x6814 <sendmail_data+0x2ae>
    668e:	a2 c0       	rjmp	.+324    	; 0x67d4 <sendmail_data+0x26e>
    6690:	23 31       	cpi	r18, 0x13	; 19
    6692:	09 f4       	brne	.+2      	; 0x6696 <sendmail_data+0x130>
    6694:	ae c0       	rjmp	.+348    	; 0x67f2 <sendmail_data+0x28c>
    6696:	24 31       	cpi	r18, 0x14	; 20
    6698:	09 f0       	breq	.+2      	; 0x669c <sendmail_data+0x136>
    669a:	bc c0       	rjmp	.+376    	; 0x6814 <sendmail_data+0x2ae>
    669c:	b4 c0       	rjmp	.+360    	; 0x6806 <sendmail_data+0x2a0>

        case MX_WAIT_FOR_220:	// auf erste Meldung des SMTP-Servers warten
            if (status == 220)
    669e:	4c 3d       	cpi	r20, 0xDC	; 220
    66a0:	51 05       	cpc	r21, r1
    66a2:	09 f0       	breq	.+2      	; 0x66a6 <sendmail_data+0x140>
    66a4:	b7 c0       	rjmp	.+366    	; 0x6814 <sendmail_data+0x2ae>
            {
                MAIL_DEBUG("0: SMTP_HELO\n\r");
                memcpy_P(ptr,SMTP_HELO,sizeof(SMTP_HELO));		
    66a6:	c8 01       	movw	r24, r16
    66a8:	63 e8       	ldi	r22, 0x83	; 131
    66aa:	77 e1       	ldi	r23, 0x17	; 23
    66ac:	42 e1       	ldi	r20, 0x12	; 18
    66ae:	50 e0       	ldi	r21, 0x00	; 0
    66b0:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
                create_new_tcp_packet(sizeof(SMTP_HELO)-1,index);
    66b4:	81 e1       	ldi	r24, 0x11	; 17
    66b6:	90 e0       	ldi	r25, 0x00	; 0
    66b8:	0d c0       	rjmp	.+26     	; 0x66d4 <sendmail_data+0x16e>
                sm_status.status++;  
            }
            break;

        case 11:	// 
            if (status == 250)
    66ba:	4a 3f       	cpi	r20, 0xFA	; 250
    66bc:	51 05       	cpc	r21, r1
    66be:	09 f0       	breq	.+2      	; 0x66c2 <sendmail_data+0x15c>
    66c0:	a9 c0       	rjmp	.+338    	; 0x6814 <sendmail_data+0x2ae>
            {
                MAIL_DEBUG("1: SMTP_AUTH\n\r");
                memcpy_P(ptr,SMTP_AUTH,sizeof(SMTP_AUTH));
    66c2:	c8 01       	movw	r24, r16
    66c4:	65 e9       	ldi	r22, 0x95	; 149
    66c6:	77 e1       	ldi	r23, 0x17	; 23
    66c8:	4d e0       	ldi	r20, 0x0D	; 13
    66ca:	50 e0       	ldi	r21, 0x00	; 0
    66cc:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
					
                create_new_tcp_packet(sizeof(SMTP_AUTH)-1,index);  
    66d0:	8c e0       	ldi	r24, 0x0C	; 12
    66d2:	90 e0       	ldi	r25, 0x00	; 0
    66d4:	6f 2d       	mov	r22, r15
    66d6:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
                sm_status.status++;  
    66da:	80 91 5a 0d 	lds	r24, 0x0D5A
    66de:	8f 5f       	subi	r24, 0xFF	; 255
    66e0:	80 93 5a 0d 	sts	0x0D5A, r24
    66e4:	97 c0       	rjmp	.+302    	; 0x6814 <sendmail_data+0x2ae>
            }
            break; 
            
        case 12:
            if (status == 334)
    66e6:	4e 54       	subi	r20, 0x4E	; 78
    66e8:	51 40       	sbci	r21, 0x01	; 1
    66ea:	09 f0       	breq	.+2      	; 0x66ee <sendmail_data+0x188>
    66ec:	93 c0       	rjmp	.+294    	; 0x6814 <sendmail_data+0x2ae>
            {
				char zeile[81];

                MAIL_DEBUG("2: Send Username: ");
                decode_base64( (unsigned char *)read_mailparam(PSTR("US"),zeile,80),(unsigned char *)ptr);
    66ee:	8d ee       	ldi	r24, 0xED	; 237
    66f0:	97 e1       	ldi	r25, 0x17	; 23
    66f2:	be 01       	movw	r22, r28
    66f4:	6f 5f       	subi	r22, 0xFF	; 255
    66f6:	7f 4f       	sbci	r23, 0xFF	; 255
    66f8:	40 e5       	ldi	r20, 0x50	; 80
    66fa:	50 e0       	ldi	r21, 0x00	; 0
    66fc:	0e 94 97 31 	call	0x632e	; 0x632e <read_mailparam>
    6700:	b8 01       	movw	r22, r16
    6702:	0e 94 7e 23 	call	0x46fc	; 0x46fc <decode_base64>
				strcat_P(ptr,PSTR("\r\n"));
    6706:	c8 01       	movw	r24, r16
    6708:	6a ee       	ldi	r22, 0xEA	; 234
    670a:	77 e1       	ldi	r23, 0x17	; 23
    670c:	13 c0       	rjmp	.+38     	; 0x6734 <sendmail_data+0x1ce>
                sm_status.status++;  
            }
            break;
            
        case 13:
            if (status == 334)
    670e:	4e 54       	subi	r20, 0x4E	; 78
    6710:	51 40       	sbci	r21, 0x01	; 1
    6712:	09 f0       	breq	.+2      	; 0x6716 <sendmail_data+0x1b0>
    6714:	7f c0       	rjmp	.+254    	; 0x6814 <sendmail_data+0x2ae>
            {
				char zeile[81];

                MAIL_DEBUG("3: Send Password: ");
                decode_base64( (unsigned char *)read_mailparam(PSTR("PW"),zeile,80),(unsigned char *)ptr);
    6716:	87 ee       	ldi	r24, 0xE7	; 231
    6718:	97 e1       	ldi	r25, 0x17	; 23
    671a:	be 01       	movw	r22, r28
    671c:	6f 5f       	subi	r22, 0xFF	; 255
    671e:	7f 4f       	sbci	r23, 0xFF	; 255
    6720:	40 e5       	ldi	r20, 0x50	; 80
    6722:	50 e0       	ldi	r21, 0x00	; 0
    6724:	0e 94 97 31 	call	0x632e	; 0x632e <read_mailparam>
    6728:	b8 01       	movw	r22, r16
    672a:	0e 94 7e 23 	call	0x46fc	; 0x46fc <decode_base64>
				strcat_P(ptr,PSTR("\r\n"));
    672e:	c8 01       	movw	r24, r16
    6730:	64 ee       	ldi	r22, 0xE4	; 228
    6732:	77 e1       	ldi	r23, 0x17	; 23
    6734:	0e 94 d4 6d 	call	0xdba8	; 0xdba8 <strcat_P>
                MAIL_DEBUG("%s",ptr);
                
                create_new_tcp_packet(strlen(ptr),index);   
    6738:	d8 01       	movw	r26, r16
    673a:	0d 90       	ld	r0, X+
    673c:	00 20       	and	r0, r0
    673e:	e9 f7       	brne	.-6      	; 0x673a <sendmail_data+0x1d4>
    6740:	11 97       	sbiw	r26, 0x01	; 1
    6742:	cd 01       	movw	r24, r26
    6744:	80 1b       	sub	r24, r16
    6746:	91 0b       	sbc	r25, r17
    6748:	c5 cf       	rjmp	.-118    	; 0x66d4 <sendmail_data+0x16e>
                sm_status.status++;
            }
            break;
            
        case 14:
            if (status == 235)
    674a:	4b 3e       	cpi	r20, 0xEB	; 235
    674c:	51 05       	cpc	r21, r1
    674e:	09 f0       	breq	.+2      	; 0x6752 <sendmail_data+0x1ec>
    6750:	61 c0       	rjmp	.+194    	; 0x6814 <sendmail_data+0x2ae>
            {
				char zeile[81];

                MAIL_DEBUG("4: SMTP_MAIL_FROM\n\r");
                strcpy_P(ptr,PSTR("MAIL FROM:"));
    6752:	c8 01       	movw	r24, r16
    6754:	69 ed       	ldi	r22, 0xD9	; 217
    6756:	77 e1       	ldi	r23, 0x17	; 23
    6758:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
				strcat(ptr,read_mailparam(PSTR("FR"),zeile,80));
    675c:	86 ed       	ldi	r24, 0xD6	; 214
    675e:	97 e1       	ldi	r25, 0x17	; 23
    6760:	be 01       	movw	r22, r28
    6762:	6f 5f       	subi	r22, 0xFF	; 255
    6764:	7f 4f       	sbci	r23, 0xFF	; 255
    6766:	40 e5       	ldi	r20, 0x50	; 80
    6768:	50 e0       	ldi	r21, 0x00	; 0
    676a:	0e 94 97 31 	call	0x632e	; 0x632e <read_mailparam>
    676e:	bc 01       	movw	r22, r24
    6770:	c8 01       	movw	r24, r16
    6772:	0e 94 86 6e 	call	0xdd0c	; 0xdd0c <strcat>
				strcat_P(ptr,PSTR("\r\n"));
    6776:	c8 01       	movw	r24, r16
    6778:	63 ed       	ldi	r22, 0xD3	; 211
    677a:	77 e1       	ldi	r23, 0x17	; 23
    677c:	19 c0       	rjmp	.+50     	; 0x67b0 <sendmail_data+0x24a>
                sm_status.status++;
            }
            break;
         
        case 15:
            if (status == 250)
    677e:	4a 3f       	cpi	r20, 0xFA	; 250
    6780:	51 05       	cpc	r21, r1
    6782:	09 f0       	breq	.+2      	; 0x6786 <sendmail_data+0x220>
    6784:	47 c0       	rjmp	.+142    	; 0x6814 <sendmail_data+0x2ae>
            {
				char zeile[81];

                MAIL_DEBUG("5: SMTP_MAIL_RCPT_TO\n\r");
                strcpy_P(ptr,PSTR("RCPT TO:"));
    6786:	c8 01       	movw	r24, r16
    6788:	6a ec       	ldi	r22, 0xCA	; 202
    678a:	77 e1       	ldi	r23, 0x17	; 23
    678c:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
				strcat(ptr,read_mailparam(PSTR("##"),zeile,80));
    6790:	87 ec       	ldi	r24, 0xC7	; 199
    6792:	97 e1       	ldi	r25, 0x17	; 23
    6794:	be 01       	movw	r22, r28
    6796:	6f 5f       	subi	r22, 0xFF	; 255
    6798:	7f 4f       	sbci	r23, 0xFF	; 255
    679a:	40 e5       	ldi	r20, 0x50	; 80
    679c:	50 e0       	ldi	r21, 0x00	; 0
    679e:	0e 94 97 31 	call	0x632e	; 0x632e <read_mailparam>
    67a2:	bc 01       	movw	r22, r24
    67a4:	c8 01       	movw	r24, r16
    67a6:	0e 94 86 6e 	call	0xdd0c	; 0xdd0c <strcat>
				strcat_P(ptr,PSTR("\r\n"));
    67aa:	c8 01       	movw	r24, r16
    67ac:	64 ec       	ldi	r22, 0xC4	; 196
    67ae:	77 e1       	ldi	r23, 0x17	; 23
    67b0:	0e 94 d4 6d 	call	0xdba8	; 0xdba8 <strcat_P>

                create_new_tcp_packet(strlen(ptr),index);
    67b4:	f8 01       	movw	r30, r16
    67b6:	01 90       	ld	r0, Z+
    67b8:	00 20       	and	r0, r0
    67ba:	e9 f7       	brne	.-6      	; 0x67b6 <sendmail_data+0x250>
    67bc:	31 97       	sbiw	r30, 0x01	; 1
    67be:	cf 01       	movw	r24, r30
    67c0:	80 1b       	sub	r24, r16
    67c2:	91 0b       	sbc	r25, r17
    67c4:	87 cf       	rjmp	.-242    	; 0x66d4 <sendmail_data+0x16e>
                sm_status.status++;
            }
            break;
            
        case 16:
            if (status == 250)
    67c6:	4a 3f       	cpi	r20, 0xFA	; 250
    67c8:	51 05       	cpc	r21, r1
    67ca:	21 f5       	brne	.+72     	; 0x6814 <sendmail_data+0x2ae>
            {
                MAIL_DEBUG("6: SMTP_MAIL_DATA\n\r");
                memcpy_P(ptr,SMTP_DATA,sizeof(SMTP_DATA));
    67cc:	c8 01       	movw	r24, r16
    67ce:	69 ea       	ldi	r22, 0xA9	; 169
    67d0:	77 e1       	ldi	r23, 0x17	; 23
    67d2:	12 c0       	rjmp	.+36     	; 0x67f8 <sendmail_data+0x292>
            }
            break;
            
        case 17:
            MAIL_DEBUG("7: SMTP_MAIL_TEXT\n\r");
			create_new_tcp_packet(read_maildata(sm_status.mailno),index);
    67d4:	80 91 5b 0d 	lds	r24, 0x0D5B
    67d8:	0e 94 fe 30 	call	0x61fc	; 0x61fc <read_maildata>
    67dc:	7b cf       	rjmp	.-266    	; 0x66d4 <sendmail_data+0x16e>
            MAIL_DEBUG("\r\nTEXT\r\n%s",&eth_buffer[TCP_DATA_START_VAR]);
            break;

        case 18:
            MAIL_DEBUG("8: SMTP_MAIL_END\n\r");
            memcpy_P(&eth_buffer[TCP_DATA_START_VAR],SMTP_END,sizeof(SMTP_END));	
    67de:	c8 01       	movw	r24, r16
    67e0:	60 eb       	ldi	r22, 0xB0	; 176
    67e2:	77 e1       	ldi	r23, 0x17	; 23
    67e4:	44 e0       	ldi	r20, 0x04	; 4
    67e6:	50 e0       	ldi	r21, 0x00	; 0
    67e8:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
            create_new_tcp_packet(sizeof(SMTP_END)-1,index);  
    67ec:	83 e0       	ldi	r24, 0x03	; 3
    67ee:	90 e0       	ldi	r25, 0x00	; 0
    67f0:	71 cf       	rjmp	.-286    	; 0x66d4 <sendmail_data+0x16e>
            
        case 19:
            //if (status == 250)
            {
                MAIL_DEBUG("9: SMTP_MAIL_QUIT\n\r");
                memcpy_P(&eth_buffer[TCP_DATA_START_VAR],SMTP_QUIT,sizeof(SMTP_QUIT));	
    67f2:	c8 01       	movw	r24, r16
    67f4:	64 eb       	ldi	r22, 0xB4	; 180
    67f6:	77 e1       	ldi	r23, 0x17	; 23
    67f8:	47 e0       	ldi	r20, 0x07	; 7
    67fa:	50 e0       	ldi	r21, 0x00	; 0
    67fc:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
                create_new_tcp_packet(sizeof(SMTP_QUIT)-1,index);  
    6800:	86 e0       	ldi	r24, 0x06	; 6
    6802:	90 e0       	ldi	r25, 0x00	; 0
    6804:	67 cf       	rjmp	.-306    	; 0x66d4 <sendmail_data+0x16e>
            }
            break;
            
        case 20:
            MAIL_DEBUG("\r\n20: Mail wurde versendet!!\r\n");
			sm_status.aktiv = 0;
    6806:	80 91 59 0d 	lds	r24, 0x0D59
    680a:	8e 7f       	andi	r24, 0xFE	; 254
    680c:	80 93 59 0d 	sts	0x0D59, r24
			sm_status.status = 0;
    6810:	10 92 5a 0d 	sts	0x0D5A, r1
			break;
	}

	tcp_entry[index].time = TCP_TIME_OFF;
    6814:	86 e1       	ldi	r24, 0x16	; 22
    6816:	90 e0       	ldi	r25, 0x00	; 0
    6818:	c8 9e       	mul	r12, r24
    681a:	f0 01       	movw	r30, r0
    681c:	c9 9e       	mul	r12, r25
    681e:	f0 0d       	add	r31, r0
    6820:	d8 9e       	mul	r13, r24
    6822:	f0 0d       	add	r31, r0
    6824:	11 24       	eor	r1, r1
    6826:	ec 5a       	subi	r30, 0xAC	; 172
    6828:	f4 4f       	sbci	r31, 0xF4	; 244
    682a:	8f ef       	ldi	r24, 0xFF	; 255
    682c:	83 8b       	std	Z+19, r24	; 0x13
}
    682e:	cf 5a       	subi	r28, 0xAF	; 175
    6830:	df 4f       	sbci	r29, 0xFF	; 255
    6832:	0f b6       	in	r0, 0x3f	; 63
    6834:	f8 94       	cli
    6836:	de bf       	out	0x3e, r29	; 62
    6838:	0f be       	out	0x3f, r0	; 63
    683a:	cd bf       	out	0x3d, r28	; 61
    683c:	cf 91       	pop	r28
    683e:	df 91       	pop	r29
    6840:	1f 91       	pop	r17
    6842:	0f 91       	pop	r16
    6844:	ff 90       	pop	r15
    6846:	df 90       	pop	r13
    6848:	cf 90       	pop	r12
    684a:	08 95       	ret

0000684c <sendmail_init>:
 *	\ingroup mail
 *	Initialisierung des sendmail clients
 */
void sendmail_init (void)
{
	sm_status.aktiv			= 0;
    684c:	80 91 59 0d 	lds	r24, 0x0D59
    6850:	8e 7f       	andi	r24, 0xFE	; 254
    6852:	80 93 59 0d 	sts	0x0D59, r24
	sm_status.status		= 0;
    6856:	10 92 5a 0d 	sts	0x0D5A, r1
	sm_status.server_ip		= 0;
    685a:	10 92 5c 0d 	sts	0x0D5C, r1
    685e:	10 92 5d 0d 	sts	0x0D5D, r1
    6862:	10 92 5e 0d 	sts	0x0D5E, r1
    6866:	10 92 5f 0d 	sts	0x0D5F, r1
    sm_status.client_port 	= 63210;
    686a:	8a ee       	ldi	r24, 0xEA	; 234
    686c:	96 ef       	ldi	r25, 0xF6	; 246
    686e:	90 93 61 0d 	sts	0x0D61, r25
    6872:	80 93 60 0d 	sts	0x0D60, r24
	sm_status.timeout		= -1;
    6876:	8f ef       	ldi	r24, 0xFF	; 255
    6878:	9f ef       	ldi	r25, 0xFF	; 255
    687a:	af ef       	ldi	r26, 0xFF	; 255
    687c:	bf ef       	ldi	r27, 0xFF	; 255
    687e:	80 93 62 0d 	sts	0x0D62, r24
    6882:	90 93 63 0d 	sts	0x0D63, r25
    6886:	a0 93 64 0d 	sts	0x0D64, r26
    688a:	b0 93 65 0d 	sts	0x0D65, r27

	add_tcp_app(sm_status.client_port, sendmail_data);
    688e:	8a ee       	ldi	r24, 0xEA	; 234
    6890:	96 ef       	ldi	r25, 0xF6	; 246
    6892:	63 eb       	ldi	r22, 0xB3	; 179
    6894:	72 e3       	ldi	r23, 0x32	; 50
    6896:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
}
    689a:	08 95       	ret

0000689c <dns_get>:
/**
*	\ingroup dnsintern
*	Empfang der DNS Informationen von einem DNS-Server
*/
void dns_get(unsigned char index)
{
    689c:	2f 92       	push	r2
    689e:	3f 92       	push	r3
    68a0:	4f 92       	push	r4
    68a2:	5f 92       	push	r5
    68a4:	6f 92       	push	r6
    68a6:	7f 92       	push	r7
    68a8:	8f 92       	push	r8
    68aa:	9f 92       	push	r9
    68ac:	af 92       	push	r10
    68ae:	bf 92       	push	r11
    68b0:	cf 92       	push	r12
    68b2:	df 92       	push	r13
    68b4:	ef 92       	push	r14
    68b6:	ff 92       	push	r15
    68b8:	0f 93       	push	r16
    68ba:	1f 93       	push	r17
    68bc:	df 93       	push	r29
    68be:	cf 93       	push	r28
    68c0:	00 d0       	rcall	.+0      	; 0x68c2 <dns_get+0x26>
    68c2:	0f 92       	push	r0
    68c4:	cd b7       	in	r28, 0x3d	; 61
    68c6:	de b7       	in	r29, 0x3e	; 62
	DNS_DEBUG("** DNS DATA GET! **\r\n");
    68c8:	00 d0       	rcall	.+0      	; 0x68ca <dns_get+0x2e>
    68ca:	89 ed       	ldi	r24, 0xD9	; 217
    68cc:	98 e1       	ldi	r25, 0x18	; 24
    68ce:	ad b7       	in	r26, 0x3d	; 61
    68d0:	be b7       	in	r27, 0x3e	; 62
    68d2:	12 96       	adiw	r26, 0x02	; 2
    68d4:	9c 93       	st	X, r25
    68d6:	8e 93       	st	-X, r24
    68d8:	11 97       	sbiw	r26, 0x01	; 1
    68da:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>

	uint16_t id = (uint16_t)((eth_buffer[UDP_DATA_START+0]<<8) + eth_buffer[UDP_DATA_START+1]);
    68de:	90 91 80 06 	lds	r25, 0x0680
    68e2:	80 e0       	ldi	r24, 0x00	; 0
    68e4:	20 91 81 06 	lds	r18, 0x0681
    68e8:	7c 01       	movw	r14, r24
    68ea:	e2 0e       	add	r14, r18
    68ec:	f1 1c       	adc	r15, r1

	if (id != dnsQueryId) {
    68ee:	20 91 18 02 	lds	r18, 0x0218
    68f2:	30 91 19 02 	lds	r19, 0x0219
    68f6:	0f 90       	pop	r0
    68f8:	0f 90       	pop	r0
    68fa:	e2 16       	cp	r14, r18
    68fc:	f3 06       	cpc	r15, r19
    68fe:	e9 f0       	breq	.+58     	; 0x693a <dns_get+0x9e>
		DNS_DEBUG("\r\n** DNS falsche ID: 0x%x 0x%x", dnsQueryId, id);
    6900:	00 d0       	rcall	.+0      	; 0x6902 <dns_get+0x66>
    6902:	00 d0       	rcall	.+0      	; 0x6904 <dns_get+0x68>
    6904:	00 d0       	rcall	.+0      	; 0x6906 <dns_get+0x6a>
    6906:	ed b7       	in	r30, 0x3d	; 61
    6908:	fe b7       	in	r31, 0x3e	; 62
    690a:	31 96       	adiw	r30, 0x01	; 1
    690c:	8a eb       	ldi	r24, 0xBA	; 186
    690e:	98 e1       	ldi	r25, 0x18	; 24
    6910:	ad b7       	in	r26, 0x3d	; 61
    6912:	be b7       	in	r27, 0x3e	; 62
    6914:	12 96       	adiw	r26, 0x02	; 2
    6916:	9c 93       	st	X, r25
    6918:	8e 93       	st	-X, r24
    691a:	11 97       	sbiw	r26, 0x01	; 1
    691c:	33 83       	std	Z+3, r19	; 0x03
    691e:	22 83       	std	Z+2, r18	; 0x02
    6920:	f5 82       	std	Z+5, r15	; 0x05
    6922:	e4 82       	std	Z+4, r14	; 0x04
    6924:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    6928:	ed b7       	in	r30, 0x3d	; 61
    692a:	fe b7       	in	r31, 0x3e	; 62
    692c:	36 96       	adiw	r30, 0x06	; 6
    692e:	0f b6       	in	r0, 0x3f	; 63
    6930:	f8 94       	cli
    6932:	fe bf       	out	0x3e, r31	; 62
    6934:	0f be       	out	0x3f, r0	; 63
    6936:	ed bf       	out	0x3d, r30	; 61
    6938:	3e c1       	rjmp	.+636    	; 0x6bb6 <dns_get+0x31a>
		return;			// das war nicht meine Anfrage
	}

	// assume max. 255 resource records in the answer section
	// MX Anfragen senden hostnamen und IPs in additional records section
	uint8_t ancount = eth_buffer[UDP_DATA_START+7] + eth_buffer[UDP_DATA_START+11];
    693a:	00 91 8b 06 	lds	r16, 0x068B
    693e:	80 91 87 06 	lds	r24, 0x0687
    6942:	08 0f       	add	r16, r24
	DNS_DEBUG("\r\n** DNS: %i RRs",ancount);
    6944:	00 d0       	rcall	.+0      	; 0x6946 <dns_get+0xaa>
    6946:	00 d0       	rcall	.+0      	; 0x6948 <dns_get+0xac>
    6948:	ed b7       	in	r30, 0x3d	; 61
    694a:	fe b7       	in	r31, 0x3e	; 62
    694c:	31 96       	adiw	r30, 0x01	; 1
    694e:	89 ea       	ldi	r24, 0xA9	; 169
    6950:	98 e1       	ldi	r25, 0x18	; 24
    6952:	ad b7       	in	r26, 0x3d	; 61
    6954:	be b7       	in	r27, 0x3e	; 62
    6956:	12 96       	adiw	r26, 0x02	; 2
    6958:	9c 93       	st	X, r25
    695a:	8e 93       	st	-X, r24
    695c:	11 97       	sbiw	r26, 0x01	; 1
    695e:	02 83       	std	Z+2, r16	; 0x02
    6960:	13 82       	std	Z+3, r1	; 0x03
    6962:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    6966:	ec e8       	ldi	r30, 0x8C	; 140
    6968:	f6 e0       	ldi	r31, 0x06	; 6
    696a:	0f 90       	pop	r0
    696c:	0f 90       	pop	r0
    696e:	0f 90       	pop	r0
    6970:	0f 90       	pop	r0
		
	// Zeiger auf Question section setzen
	char *ptr = &eth_buffer[UDP_DATA_START + DNS_HEADER_LEN];

	while (*ptr++);	// ans Ende des hostnamen zhlen
    6972:	81 91       	ld	r24, Z+
    6974:	88 23       	and	r24, r24
    6976:	e9 f7       	brne	.-6      	; 0x6972 <dns_get+0xd6>
	ptr += 4;		// QTYPE und QCLASS berspringen
    6978:	cf 01       	movw	r24, r30
    697a:	04 96       	adiw	r24, 0x04	; 4
    697c:	9b 83       	std	Y+3, r25	; 0x03
    697e:	8a 83       	std	Y+2, r24	; 0x02
    6980:	99 24       	eor	r9, r9
		else if (qtype == 6) {	// SOA		: 6 marks the start of a zone of authority
			DNS_DEBUG("\r\n** SOA empfangen: %s",ptr);
		}
		else if (qtype == 12) {	// PTR		: 12 a domain name pointer
			// QNAME zu "dotted hostname" umwandeln
			char *hostname = (char *)id;
    6982:	e9 82       	std	Y+1, r14	; 0x01
    6984:	8f 2c       	mov	r8, r15
			uint32_t *ip = (uint32_t *)id;
			*ip = IP(*(ptr+0), *(ptr+1), *(ptr+2),  *(ptr+3));
			// dnsQueryIP = IP(*(ptr+0), *(ptr+1), *(ptr+2),  *(ptr+3));
		}
		else if (qtype == 2) {	// NS		: 2 an authoritative name server
			DNS_DEBUG("\r\n** NS empfangen: %s",ptr);
    6986:	2d e4       	ldi	r18, 0x4D	; 77
    6988:	22 2e       	mov	r2, r18
    698a:	28 e1       	ldi	r18, 0x18	; 24
    698c:	32 2e       	mov	r3, r18
		ptr += 10;	// Type (2); Class (2); TTL (4); RDLength (2)
		DNS_DEBUG("\r\n** DNS TYPE %i CLASS %i RDLen %i",qtype, qclass, rdlen);

		if (qtype == 1) {		// A		: 1 a host address
			// die nchsten 4 Bytes sind die IP des host
			DNS_DEBUG("\r\n** DNS IP empfangen: %i.%i.%i.%i",(int)*ptr,(int)*(ptr+1),(int)*(ptr+2),(int)*(ptr+3));
    698e:	93 e6       	ldi	r25, 0x63	; 99
    6990:	49 2e       	mov	r4, r25
    6992:	98 e1       	ldi	r25, 0x18	; 24
    6994:	59 2e       	mov	r5, r25
    6996:	0c c1       	rjmp	.+536    	; 0x6bb0 <dns_get+0x314>
	uint8_t qclass;	// RR class
	uint16_t rdlen;	// RDLength

	// Schleife ber alle RR in answer section
	for (uint8_t i=0; i<ancount; ++i) {
		if (*ptr >= 0xc0) {
    6998:	aa 81       	ldd	r26, Y+2	; 0x02
    699a:	bb 81       	ldd	r27, Y+3	; 0x03
    699c:	8c 91       	ld	r24, X
    699e:	80 3c       	cpi	r24, 0xC0	; 192
    69a0:	20 f0       	brcs	.+8      	; 0x69aa <dns_get+0x10e>
			ptr += 2;		// Message compression offset berspringen
    69a2:	12 96       	adiw	r26, 0x02	; 2
    69a4:	bb 83       	std	Y+3, r27	; 0x03
    69a6:	aa 83       	std	Y+2, r26	; 0x02
    69a8:	07 c0       	rjmp	.+14     	; 0x69b8 <dns_get+0x11c>
		}
		else {
			while (*ptr++);	// ans Ende des hostnamen zhlen
    69aa:	ea 81       	ldd	r30, Y+2	; 0x02
    69ac:	fb 81       	ldd	r31, Y+3	; 0x03
    69ae:	81 91       	ld	r24, Z+
    69b0:	fb 83       	std	Y+3, r31	; 0x03
    69b2:	ea 83       	std	Y+2, r30	; 0x02
    69b4:	88 23       	and	r24, r24
    69b6:	c9 f7       	brne	.-14     	; 0x69aa <dns_get+0x10e>
		}

		qtype	= *(ptr+1);
    69b8:	aa 81       	ldd	r26, Y+2	; 0x02
    69ba:	bb 81       	ldd	r27, Y+3	; 0x03
    69bc:	11 96       	adiw	r26, 0x01	; 1
    69be:	1c 91       	ld	r17, X
    69c0:	11 97       	sbiw	r26, 0x01	; 1
		qclass	= *(ptr+3);
		rdlen	= *(ptr+9) + ((*(ptr+8))<<8);
    69c2:	18 96       	adiw	r26, 0x08	; 8
    69c4:	bc 90       	ld	r11, X
    69c6:	18 97       	sbiw	r26, 0x08	; 8
    69c8:	aa 24       	eor	r10, r10
    69ca:	19 96       	adiw	r26, 0x09	; 9
    69cc:	8c 91       	ld	r24, X
    69ce:	19 97       	sbiw	r26, 0x09	; 9
    69d0:	35 01       	movw	r6, r10
    69d2:	68 0e       	add	r6, r24
    69d4:	71 1c       	adc	r7, r1
		ptr += 10;	// Type (2); Class (2); TTL (4); RDLength (2)
    69d6:	8a e0       	ldi	r24, 0x0A	; 10
    69d8:	c8 2e       	mov	r12, r24
    69da:	d1 2c       	mov	r13, r1
    69dc:	ca 0e       	add	r12, r26
    69de:	db 1e       	adc	r13, r27
		DNS_DEBUG("\r\n** DNS TYPE %i CLASS %i RDLen %i",qtype, qclass, rdlen);
    69e0:	ed b7       	in	r30, 0x3d	; 61
    69e2:	fe b7       	in	r31, 0x3e	; 62
    69e4:	38 97       	sbiw	r30, 0x08	; 8
    69e6:	0f b6       	in	r0, 0x3f	; 63
    69e8:	f8 94       	cli
    69ea:	fe bf       	out	0x3e, r31	; 62
    69ec:	0f be       	out	0x3f, r0	; 63
    69ee:	ed bf       	out	0x3d, r30	; 61
    69f0:	31 96       	adiw	r30, 0x01	; 1
    69f2:	86 e8       	ldi	r24, 0x86	; 134
    69f4:	98 e1       	ldi	r25, 0x18	; 24
    69f6:	ad b7       	in	r26, 0x3d	; 61
    69f8:	be b7       	in	r27, 0x3e	; 62
    69fa:	12 96       	adiw	r26, 0x02	; 2
    69fc:	9c 93       	st	X, r25
    69fe:	8e 93       	st	-X, r24
    6a00:	11 97       	sbiw	r26, 0x01	; 1
    6a02:	12 83       	std	Z+2, r17	; 0x02
    6a04:	13 82       	std	Z+3, r1	; 0x03
    6a06:	aa 81       	ldd	r26, Y+2	; 0x02
    6a08:	bb 81       	ldd	r27, Y+3	; 0x03
    6a0a:	13 96       	adiw	r26, 0x03	; 3
    6a0c:	8c 91       	ld	r24, X
    6a0e:	84 83       	std	Z+4, r24	; 0x04
    6a10:	15 82       	std	Z+5, r1	; 0x05
    6a12:	77 82       	std	Z+7, r7	; 0x07
    6a14:	66 82       	std	Z+6, r6	; 0x06
    6a16:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>

		if (qtype == 1) {		// A		: 1 a host address
    6a1a:	ed b7       	in	r30, 0x3d	; 61
    6a1c:	fe b7       	in	r31, 0x3e	; 62
    6a1e:	38 96       	adiw	r30, 0x08	; 8
    6a20:	0f b6       	in	r0, 0x3f	; 63
    6a22:	f8 94       	cli
    6a24:	fe bf       	out	0x3e, r31	; 62
    6a26:	0f be       	out	0x3f, r0	; 63
    6a28:	ed bf       	out	0x3d, r30	; 61
    6a2a:	11 30       	cpi	r17, 0x01	; 1
    6a2c:	09 f0       	breq	.+2      	; 0x6a30 <dns_get+0x194>
    6a2e:	5d c0       	rjmp	.+186    	; 0x6aea <dns_get+0x24e>
			// die nchsten 4 Bytes sind die IP des host
			DNS_DEBUG("\r\n** DNS IP empfangen: %i.%i.%i.%i",(int)*ptr,(int)*(ptr+1),(int)*(ptr+2),(int)*(ptr+3));
    6a30:	8d b7       	in	r24, 0x3d	; 61
    6a32:	9e b7       	in	r25, 0x3e	; 62
    6a34:	0a 97       	sbiw	r24, 0x0a	; 10
    6a36:	0f b6       	in	r0, 0x3f	; 63
    6a38:	f8 94       	cli
    6a3a:	9e bf       	out	0x3e, r25	; 62
    6a3c:	0f be       	out	0x3f, r0	; 63
    6a3e:	8d bf       	out	0x3d, r24	; 61
    6a40:	ed b7       	in	r30, 0x3d	; 61
    6a42:	fe b7       	in	r31, 0x3e	; 62
    6a44:	31 96       	adiw	r30, 0x01	; 1
    6a46:	ad b7       	in	r26, 0x3d	; 61
    6a48:	be b7       	in	r27, 0x3e	; 62
    6a4a:	12 96       	adiw	r26, 0x02	; 2
    6a4c:	5c 92       	st	X, r5
    6a4e:	4e 92       	st	-X, r4
    6a50:	11 97       	sbiw	r26, 0x01	; 1
    6a52:	aa 81       	ldd	r26, Y+2	; 0x02
    6a54:	bb 81       	ldd	r27, Y+3	; 0x03
    6a56:	1a 96       	adiw	r26, 0x0a	; 10
    6a58:	8c 91       	ld	r24, X
    6a5a:	1a 97       	sbiw	r26, 0x0a	; 10
    6a5c:	82 83       	std	Z+2, r24	; 0x02
    6a5e:	13 82       	std	Z+3, r1	; 0x03
    6a60:	1b 96       	adiw	r26, 0x0b	; 11
    6a62:	8c 91       	ld	r24, X
    6a64:	1b 97       	sbiw	r26, 0x0b	; 11
    6a66:	84 83       	std	Z+4, r24	; 0x04
    6a68:	15 82       	std	Z+5, r1	; 0x05
    6a6a:	1c 96       	adiw	r26, 0x0c	; 12
    6a6c:	8c 91       	ld	r24, X
    6a6e:	1c 97       	sbiw	r26, 0x0c	; 12
    6a70:	86 83       	std	Z+6, r24	; 0x06
    6a72:	17 82       	std	Z+7, r1	; 0x07
    6a74:	1d 96       	adiw	r26, 0x0d	; 13
    6a76:	8c 91       	ld	r24, X
    6a78:	80 87       	std	Z+8, r24	; 0x08
    6a7a:	11 86       	std	Z+9, r1	; 0x09
    6a7c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
			uint32_t *ip = (uint32_t *)id;
			*ip = IP(*(ptr+0), *(ptr+1), *(ptr+2),  *(ptr+3));
    6a80:	ea 81       	ldd	r30, Y+2	; 0x02
    6a82:	fb 81       	ldd	r31, Y+3	; 0x03
    6a84:	25 85       	ldd	r18, Z+13	; 0x0d
    6a86:	30 e0       	ldi	r19, 0x00	; 0
    6a88:	40 e0       	ldi	r20, 0x00	; 0
    6a8a:	50 e0       	ldi	r21, 0x00	; 0
    6a8c:	52 2f       	mov	r21, r18
    6a8e:	44 27       	eor	r20, r20
    6a90:	33 27       	eor	r19, r19
    6a92:	22 27       	eor	r18, r18
    6a94:	84 85       	ldd	r24, Z+12	; 0x0c
    6a96:	90 e0       	ldi	r25, 0x00	; 0
    6a98:	a0 e0       	ldi	r26, 0x00	; 0
    6a9a:	b0 e0       	ldi	r27, 0x00	; 0
    6a9c:	dc 01       	movw	r26, r24
    6a9e:	99 27       	eor	r25, r25
    6aa0:	88 27       	eor	r24, r24
    6aa2:	28 0f       	add	r18, r24
    6aa4:	39 1f       	adc	r19, r25
    6aa6:	4a 1f       	adc	r20, r26
    6aa8:	5b 1f       	adc	r21, r27
    6aaa:	82 85       	ldd	r24, Z+10	; 0x0a
    6aac:	28 0f       	add	r18, r24
    6aae:	31 1d       	adc	r19, r1
    6ab0:	41 1d       	adc	r20, r1
    6ab2:	51 1d       	adc	r21, r1
    6ab4:	83 85       	ldd	r24, Z+11	; 0x0b
    6ab6:	90 e0       	ldi	r25, 0x00	; 0
    6ab8:	a0 e0       	ldi	r26, 0x00	; 0
    6aba:	b0 e0       	ldi	r27, 0x00	; 0
    6abc:	ba 2f       	mov	r27, r26
    6abe:	a9 2f       	mov	r26, r25
    6ac0:	98 2f       	mov	r25, r24
    6ac2:	88 27       	eor	r24, r24
    6ac4:	28 0f       	add	r18, r24
    6ac6:	39 1f       	adc	r19, r25
    6ac8:	4a 1f       	adc	r20, r26
    6aca:	5b 1f       	adc	r21, r27
    6acc:	d7 01       	movw	r26, r14
    6ace:	2d 93       	st	X+, r18
    6ad0:	3d 93       	st	X+, r19
    6ad2:	4d 93       	st	X+, r20
    6ad4:	5c 93       	st	X, r21
    6ad6:	13 97       	sbiw	r26, 0x03	; 3
    6ad8:	ed b7       	in	r30, 0x3d	; 61
    6ada:	fe b7       	in	r31, 0x3e	; 62
    6adc:	3a 96       	adiw	r30, 0x0a	; 10
    6ade:	0f b6       	in	r0, 0x3f	; 63
    6ae0:	f8 94       	cli
    6ae2:	fe bf       	out	0x3e, r31	; 62
    6ae4:	0f be       	out	0x3f, r0	; 63
    6ae6:	ed bf       	out	0x3d, r30	; 61
    6ae8:	5d c0       	rjmp	.+186    	; 0x6ba4 <dns_get+0x308>
			// dnsQueryIP = IP(*(ptr+0), *(ptr+1), *(ptr+2),  *(ptr+3));
		}
		else if (qtype == 2) {	// NS		: 2 an authoritative name server
    6aea:	12 30       	cpi	r17, 0x02	; 2
    6aec:	49 f4       	brne	.+18     	; 0x6b00 <dns_get+0x264>
			DNS_DEBUG("\r\n** NS empfangen: %s",ptr);
    6aee:	00 d0       	rcall	.+0      	; 0x6af0 <dns_get+0x254>
    6af0:	00 d0       	rcall	.+0      	; 0x6af2 <dns_get+0x256>
    6af2:	ad b7       	in	r26, 0x3d	; 61
    6af4:	be b7       	in	r27, 0x3e	; 62
    6af6:	12 96       	adiw	r26, 0x02	; 2
    6af8:	3c 92       	st	X, r3
    6afa:	2e 92       	st	-X, r2
    6afc:	11 97       	sbiw	r26, 0x01	; 1
    6afe:	48 c0       	rjmp	.+144    	; 0x6b90 <dns_get+0x2f4>
		}
		else if (qtype == 5) {	// CNAME	: 5 the canonical name for an alias
    6b00:	15 30       	cpi	r17, 0x05	; 5
    6b02:	59 f4       	brne	.+22     	; 0x6b1a <dns_get+0x27e>
			DNS_DEBUG("\r\n** CNAME empfangen: %s",ptr);
    6b04:	00 d0       	rcall	.+0      	; 0x6b06 <dns_get+0x26a>
    6b06:	00 d0       	rcall	.+0      	; 0x6b08 <dns_get+0x26c>
    6b08:	84 e3       	ldi	r24, 0x34	; 52
    6b0a:	98 e1       	ldi	r25, 0x18	; 24
    6b0c:	ed b7       	in	r30, 0x3d	; 61
    6b0e:	fe b7       	in	r31, 0x3e	; 62
    6b10:	92 83       	std	Z+2, r25	; 0x02
    6b12:	81 83       	std	Z+1, r24	; 0x01
    6b14:	d4 82       	std	Z+4, r13	; 0x04
    6b16:	c3 82       	std	Z+3, r12	; 0x03
    6b18:	3f c0       	rjmp	.+126    	; 0x6b98 <dns_get+0x2fc>
		}
		else if (qtype == 6) {	// SOA		: 6 marks the start of a zone of authority
    6b1a:	16 30       	cpi	r17, 0x06	; 6
    6b1c:	29 f4       	brne	.+10     	; 0x6b28 <dns_get+0x28c>
			DNS_DEBUG("\r\n** SOA empfangen: %s",ptr);
    6b1e:	00 d0       	rcall	.+0      	; 0x6b20 <dns_get+0x284>
    6b20:	00 d0       	rcall	.+0      	; 0x6b22 <dns_get+0x286>
    6b22:	ed e1       	ldi	r30, 0x1D	; 29
    6b24:	f8 e1       	ldi	r31, 0x18	; 24
    6b26:	2e c0       	rjmp	.+92     	; 0x6b84 <dns_get+0x2e8>
		}
		else if (qtype == 12) {	// PTR		: 12 a domain name pointer
    6b28:	1c 30       	cpi	r17, 0x0C	; 12
    6b2a:	31 f5       	brne	.+76     	; 0x6b78 <dns_get+0x2dc>
			// QNAME zu "dotted hostname" umwandeln
			char *hostname = (char *)id;
    6b2c:	f7 01       	movw	r30, r14
    6b2e:	d6 01       	movw	r26, r12
    6b30:	90 e2       	ldi	r25, 0x20	; 32
    6b32:	0a c0       	rjmp	.+20     	; 0x6b48 <dns_get+0x2ac>
			uint8_t pdot;
			char *host = ptr;
			uint8_t max = 32;

			while( *host && --max>0) {
				pdot = *host++;
    6b34:	11 96       	adiw	r26, 0x01	; 1
    6b36:	04 c0       	rjmp	.+8      	; 0x6b40 <dns_get+0x2a4>
				while(pdot>0 && --max>0) {
					*hostname++ = *host++;
    6b38:	8d 91       	ld	r24, X+
    6b3a:	81 93       	st	Z+, r24
					--pdot;
    6b3c:	21 50       	subi	r18, 0x01	; 1
			char *host = ptr;
			uint8_t max = 32;

			while( *host && --max>0) {
				pdot = *host++;
				while(pdot>0 && --max>0) {
    6b3e:	11 f0       	breq	.+4      	; 0x6b44 <dns_get+0x2a8>
    6b40:	91 50       	subi	r25, 0x01	; 1
    6b42:	d1 f7       	brne	.-12     	; 0x6b38 <dns_get+0x29c>
					*hostname++ = *host++;
					--pdot;
				}
			*hostname++ = '.';
    6b44:	8e e2       	ldi	r24, 0x2E	; 46
    6b46:	81 93       	st	Z+, r24
			char *hostname = (char *)id;
			uint8_t pdot;
			char *host = ptr;
			uint8_t max = 32;

			while( *host && --max>0) {
    6b48:	2c 91       	ld	r18, X
    6b4a:	22 23       	and	r18, r18
    6b4c:	11 f0       	breq	.+4      	; 0x6b52 <dns_get+0x2b6>
    6b4e:	91 50       	subi	r25, 0x01	; 1
    6b50:	89 f7       	brne	.-30     	; 0x6b34 <dns_get+0x298>
				}
			*hostname++ = '.';
			}

			--hostname;
			*hostname = '\0';
    6b52:	31 97       	sbiw	r30, 0x01	; 1
    6b54:	10 82       	st	Z, r1

			DNS_DEBUG("\r\n** PTR empfangen: %s",(char *)id);
    6b56:	00 d0       	rcall	.+0      	; 0x6b58 <dns_get+0x2bc>
    6b58:	00 d0       	rcall	.+0      	; 0x6b5a <dns_get+0x2be>
    6b5a:	ed b7       	in	r30, 0x3d	; 61
    6b5c:	fe b7       	in	r31, 0x3e	; 62
    6b5e:	31 96       	adiw	r30, 0x01	; 1
    6b60:	86 e0       	ldi	r24, 0x06	; 6
    6b62:	98 e1       	ldi	r25, 0x18	; 24
    6b64:	ad b7       	in	r26, 0x3d	; 61
    6b66:	be b7       	in	r27, 0x3e	; 62
    6b68:	12 96       	adiw	r26, 0x02	; 2
    6b6a:	9c 93       	st	X, r25
    6b6c:	8e 93       	st	-X, r24
    6b6e:	11 97       	sbiw	r26, 0x01	; 1
    6b70:	99 81       	ldd	r25, Y+1	; 0x01
    6b72:	92 83       	std	Z+2, r25	; 0x02
    6b74:	83 82       	std	Z+3, r8	; 0x03
    6b76:	10 c0       	rjmp	.+32     	; 0x6b98 <dns_get+0x2fc>
		}
		else if (qtype == 15) {	// MX		: 15 mail exchange
    6b78:	1f 30       	cpi	r17, 0x0F	; 15
    6b7a:	a1 f4       	brne	.+40     	; 0x6ba4 <dns_get+0x308>
			DNS_DEBUG("\r\n** MX empfangen: %s",ptr);
    6b7c:	00 d0       	rcall	.+0      	; 0x6b7e <dns_get+0x2e2>
    6b7e:	00 d0       	rcall	.+0      	; 0x6b80 <dns_get+0x2e4>
    6b80:	e0 ef       	ldi	r30, 0xF0	; 240
    6b82:	f7 e1       	ldi	r31, 0x17	; 23
    6b84:	ad b7       	in	r26, 0x3d	; 61
    6b86:	be b7       	in	r27, 0x3e	; 62
    6b88:	12 96       	adiw	r26, 0x02	; 2
    6b8a:	fc 93       	st	X, r31
    6b8c:	ee 93       	st	-X, r30
    6b8e:	11 97       	sbiw	r26, 0x01	; 1
    6b90:	14 96       	adiw	r26, 0x04	; 4
    6b92:	dc 92       	st	X, r13
    6b94:	ce 92       	st	-X, r12
    6b96:	13 97       	sbiw	r26, 0x03	; 3
    6b98:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    6b9c:	0f 90       	pop	r0
    6b9e:	0f 90       	pop	r0
    6ba0:	0f 90       	pop	r0
    6ba2:	0f 90       	pop	r0
		}

		ptr += rdlen;
    6ba4:	c6 01       	movw	r24, r12
    6ba6:	86 0d       	add	r24, r6
    6ba8:	97 1d       	adc	r25, r7
    6baa:	9b 83       	std	Y+3, r25	; 0x03
    6bac:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t qtype;	// RR typedns
	uint8_t qclass;	// RR class
	uint16_t rdlen;	// RDLength

	// Schleife ber alle RR in answer section
	for (uint8_t i=0; i<ancount; ++i) {
    6bae:	93 94       	inc	r9
    6bb0:	90 16       	cp	r9, r16
    6bb2:	08 f4       	brcc	.+2      	; 0x6bb6 <dns_get+0x31a>
    6bb4:	f1 ce       	rjmp	.-542    	; 0x6998 <dns_get+0xfc>
			DNS_DEBUG("\r\n** MX empfangen: %s",ptr);
		}

		ptr += rdlen;
	}
}
    6bb6:	0f 90       	pop	r0
    6bb8:	0f 90       	pop	r0
    6bba:	0f 90       	pop	r0
    6bbc:	cf 91       	pop	r28
    6bbe:	df 91       	pop	r29
    6bc0:	1f 91       	pop	r17
    6bc2:	0f 91       	pop	r16
    6bc4:	ff 90       	pop	r15
    6bc6:	ef 90       	pop	r14
    6bc8:	df 90       	pop	r13
    6bca:	cf 90       	pop	r12
    6bcc:	bf 90       	pop	r11
    6bce:	af 90       	pop	r10
    6bd0:	9f 90       	pop	r9
    6bd2:	8f 90       	pop	r8
    6bd4:	7f 90       	pop	r7
    6bd6:	6f 90       	pop	r6
    6bd8:	5f 90       	pop	r5
    6bda:	4f 90       	pop	r4
    6bdc:	3f 90       	pop	r3
    6bde:	2f 90       	pop	r2
    6be0:	08 95       	ret

00006be2 <_dns_qry>:
 *	\param[in] qtype QTYPE Anfragerecord
 *	\param[in] hostname FQDN des gesuchten Servers
 *	\param[in] dest Speicherplatz fr gefundene IP
*/
void _dns_qry(uint8_t qtype, char *hostname, void *dest)
{
    6be2:	9f 92       	push	r9
    6be4:	af 92       	push	r10
    6be6:	bf 92       	push	r11
    6be8:	cf 92       	push	r12
    6bea:	df 92       	push	r13
    6bec:	ef 92       	push	r14
    6bee:	ff 92       	push	r15
    6bf0:	0f 93       	push	r16
    6bf2:	1f 93       	push	r17
    6bf4:	cf 93       	push	r28
    6bf6:	df 93       	push	r29
    6bf8:	98 2e       	mov	r9, r24
    6bfa:	b6 2e       	mov	r11, r22
    6bfc:	a7 2e       	mov	r10, r23
    6bfe:	8a 01       	movw	r16, r20
	DNS_DEBUG("\r\nDNS Anfrage: %s",hostname);
    6c00:	00 d0       	rcall	.+0      	; 0x6c02 <_dns_qry+0x20>
    6c02:	00 d0       	rcall	.+0      	; 0x6c04 <_dns_qry+0x22>
    6c04:	ed b7       	in	r30, 0x3d	; 61
    6c06:	fe b7       	in	r31, 0x3e	; 62
    6c08:	31 96       	adiw	r30, 0x01	; 1
    6c0a:	8c e2       	ldi	r24, 0x2C	; 44
    6c0c:	99 e1       	ldi	r25, 0x19	; 25
    6c0e:	ad b7       	in	r26, 0x3d	; 61
    6c10:	be b7       	in	r27, 0x3e	; 62
    6c12:	12 96       	adiw	r26, 0x02	; 2
    6c14:	9c 93       	st	X, r25
    6c16:	8e 93       	st	-X, r24
    6c18:	11 97       	sbiw	r26, 0x01	; 1
    6c1a:	62 83       	std	Z+2, r22	; 0x02
    6c1c:	73 83       	std	Z+3, r23	; 0x03
    6c1e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
	// ARP Request senden
	unsigned long tmp_ip = (*(unsigned long*)&dns_server_ip[0]);
    6c22:	c0 90 6a 0d 	lds	r12, 0x0D6A
    6c26:	d0 90 6b 0d 	lds	r13, 0x0D6B
    6c2a:	e0 90 6c 0d 	lds	r14, 0x0D6C
    6c2e:	f0 90 6d 0d 	lds	r15, 0x0D6D
	if (arp_request(tmp_ip) == 1) {
    6c32:	0f 90       	pop	r0
    6c34:	0f 90       	pop	r0
    6c36:	0f 90       	pop	r0
    6c38:	0f 90       	pop	r0
    6c3a:	c7 01       	movw	r24, r14
    6c3c:	b6 01       	movw	r22, r12
    6c3e:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <arp_request>
    6c42:	98 2f       	mov	r25, r24
    6c44:	81 30       	cpi	r24, 0x01	; 1
    6c46:	09 f0       	breq	.+2      	; 0x6c4a <_dns_qry+0x68>
    6c48:	4e c0       	rjmp	.+156    	; 0x6ce6 <_dns_qry+0x104>

		memset(&eth_buffer[UDP_DATA_START], 0, DNS_HEADER_LEN);
    6c4a:	e0 e8       	ldi	r30, 0x80	; 128
    6c4c:	f6 e0       	ldi	r31, 0x06	; 6
    6c4e:	8c e0       	ldi	r24, 0x0C	; 12
    6c50:	df 01       	movw	r26, r30
    6c52:	1d 92       	st	X+, r1
    6c54:	8a 95       	dec	r24
    6c56:	e9 f7       	brne	.-6      	; 0x6c52 <_dns_qry+0x70>

		// dnsQueryId = (uint16_t)(time & 0xffff);		// Zufallszahl
		// Speicheradresse fr aufgelste IP/hostname
		// als QueryID mitgeben
		dnsQueryId = (uint16_t)dest;
    6c58:	00 93 18 02 	sts	0x0218, r16
    6c5c:	10 93 19 02 	sts	0x0219, r17
		eth_buffer[UDP_DATA_START+0] = (uint8_t)(dnsQueryId>>8 & 0xff);
    6c60:	10 93 80 06 	sts	0x0680, r17
		eth_buffer[UDP_DATA_START+1] = (uint8_t)(dnsQueryId & 0xff);
    6c64:	00 93 81 06 	sts	0x0681, r16
		eth_buffer[UDP_DATA_START+2] = 1;	// Recursion Desired
    6c68:	90 93 82 06 	sts	0x0682, r25
		eth_buffer[UDP_DATA_START+5] = 1;	// eine Anfrage
    6c6c:	90 93 85 06 	sts	0x0685, r25
    6c70:	2b 2d       	mov	r18, r11
    6c72:	3a 2d       	mov	r19, r10
    6c74:	c9 01       	movw	r24, r18
    6c76:	ec 01       	movw	r28, r24
    6c78:	8f 01       	movw	r16, r30
    6c7a:	04 5f       	subi	r16, 0xF4	; 244
    6c7c:	1f 4f       	sbci	r17, 0xFF	; 255
		uint8_t *src = (uint8_t *)hostname;		// Namen kopieren
		uint8_t *pdot;
		
		// aus "dotted" hostname den QNAME erstellen
		do {
			pdot = (uint8_t *)strchrnul((char *)src,'.');
    6c7e:	ce 01       	movw	r24, r28
    6c80:	6e e2       	ldi	r22, 0x2E	; 46
    6c82:	70 e0       	ldi	r23, 0x00	; 0
    6c84:	0e 94 9c 6e 	call	0xdd38	; 0xdd38 <strchrnul>
    6c88:	fc 01       	movw	r30, r24
			*ptr++ = (uint8_t)(pdot-src);
    6c8a:	8c 1b       	sub	r24, r28
    6c8c:	01 c0       	rjmp	.+2      	; 0x6c90 <_dns_qry+0xae>
			while (src < pdot)
				*ptr++ = *src++;
    6c8e:	89 91       	ld	r24, Y+
    6c90:	d8 01       	movw	r26, r16
    6c92:	8d 93       	st	X+, r24
    6c94:	8d 01       	movw	r16, r26
		
		// aus "dotted" hostname den QNAME erstellen
		do {
			pdot = (uint8_t *)strchrnul((char *)src,'.');
			*ptr++ = (uint8_t)(pdot-src);
			while (src < pdot)
    6c96:	ce 17       	cp	r28, r30
    6c98:	df 07       	cpc	r29, r31
    6c9a:	c8 f3       	brcs	.-14     	; 0x6c8e <_dns_qry+0xac>
				*ptr++ = *src++;
			src++;
		} while ( *pdot );
    6c9c:	80 81       	ld	r24, Z
    6c9e:	88 23       	and	r24, r24
    6ca0:	11 f0       	breq	.+4      	; 0x6ca6 <_dns_qry+0xc4>
		do {
			pdot = (uint8_t *)strchrnul((char *)src,'.');
			*ptr++ = (uint8_t)(pdot-src);
			while (src < pdot)
				*ptr++ = *src++;
			src++;
    6ca2:	21 96       	adiw	r28, 0x01	; 1
    6ca4:	ec cf       	rjmp	.-40     	; 0x6c7e <_dns_qry+0x9c>
		} while ( *pdot );
		*ptr++ = 0;
    6ca6:	fd 01       	movw	r30, r26
    6ca8:	11 92       	st	Z+, r1

		*ptr++ = 0;		// Question type
    6caa:	11 96       	adiw	r26, 0x01	; 1
    6cac:	1c 92       	st	X, r1
    6cae:	df 01       	movw	r26, r30
    6cb0:	11 96       	adiw	r26, 0x01	; 1
		*ptr++ = qtype;
    6cb2:	91 82       	std	Z+1, r9	; 0x01
    6cb4:	fd 01       	movw	r30, r26
    6cb6:	31 96       	adiw	r30, 0x01	; 1

		*ptr++ = 0;		// Question class
    6cb8:	11 96       	adiw	r26, 0x01	; 1
    6cba:	1c 92       	st	X, r1
		*ptr++ = 1;		// IN - Internet
    6cbc:	81 e0       	ldi	r24, 0x01	; 1
    6cbe:	81 83       	std	Z+1, r24	; 0x01

		create_new_udp_packet((unsigned int)(ptr - &eth_buffer[UDP_DATA_START]),
    6cc0:	cf 01       	movw	r24, r30
    6cc2:	8e 57       	subi	r24, 0x7E	; 126
    6cc4:	96 40       	sbci	r25, 0x06	; 6
    6cc6:	64 eb       	ldi	r22, 0xB4	; 180
    6cc8:	74 e1       	ldi	r23, 0x14	; 20
    6cca:	45 e3       	ldi	r20, 0x35	; 53
    6ccc:	50 e0       	ldi	r21, 0x00	; 0
    6cce:	97 01       	movw	r18, r14
    6cd0:	86 01       	movw	r16, r12
    6cd2:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <create_new_udp_packet>
								DNS_CLIENT_PORT,DNS_SERVER_PORT,tmp_ip);
		DNS_DEBUG("\r\n** DNS Request gesendet! **");
    6cd6:	00 d0       	rcall	.+0      	; 0x6cd8 <_dns_qry+0xf6>
    6cd8:	8e e0       	ldi	r24, 0x0E	; 14
    6cda:	99 e1       	ldi	r25, 0x19	; 25
    6cdc:	ed b7       	in	r30, 0x3d	; 61
    6cde:	fe b7       	in	r31, 0x3e	; 62
    6ce0:	92 83       	std	Z+2, r25	; 0x02
    6ce2:	81 83       	std	Z+1, r24	; 0x01
    6ce4:	09 c0       	rjmp	.+18     	; 0x6cf8 <_dns_qry+0x116>
		return;
	}

	DNS_DEBUG("\r\nKeinen DNS Server gefunden!!");
    6ce6:	00 d0       	rcall	.+0      	; 0x6ce8 <_dns_qry+0x106>
    6ce8:	8f ee       	ldi	r24, 0xEF	; 239
    6cea:	98 e1       	ldi	r25, 0x18	; 24
    6cec:	ad b7       	in	r26, 0x3d	; 61
    6cee:	be b7       	in	r27, 0x3e	; 62
    6cf0:	12 96       	adiw	r26, 0x02	; 2
    6cf2:	9c 93       	st	X, r25
    6cf4:	8e 93       	st	-X, r24
    6cf6:	11 97       	sbiw	r26, 0x01	; 1
    6cf8:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    6cfc:	0f 90       	pop	r0
    6cfe:	0f 90       	pop	r0
}
    6d00:	df 91       	pop	r29
    6d02:	cf 91       	pop	r28
    6d04:	1f 91       	pop	r17
    6d06:	0f 91       	pop	r16
    6d08:	ff 90       	pop	r15
    6d0a:	ef 90       	pop	r14
    6d0c:	df 90       	pop	r13
    6d0e:	cf 90       	pop	r12
    6d10:	bf 90       	pop	r11
    6d12:	af 90       	pop	r10
    6d14:	9f 90       	pop	r9
    6d16:	08 95       	ret

00006d18 <dns_request>:
 *
 *	\param[in] hostname FQDN des gesuchten Servers
 *	\param[in] ip Speicherplatz fr gefundene IP
*/
void dns_request(char *hostname, uint32_t *ip)
{
    6d18:	9c 01       	movw	r18, r24
    6d1a:	ab 01       	movw	r20, r22
	_dns_qry(1, hostname, ip);	// A-Record anfragen
    6d1c:	81 e0       	ldi	r24, 0x01	; 1
    6d1e:	b9 01       	movw	r22, r18
    6d20:	0e 94 f1 35 	call	0x6be2	; 0x6be2 <_dns_qry>
}
    6d24:	08 95       	ret

00006d26 <dns_reverse_request>:
 *
 *	\param[in] ip aufzulsende IP Adresse
 *	\param[in] hostname Speicherplatz fr hostnamen des gesuchten Servers
*/
void dns_reverse_request(uint32_t ip, char *hostname)
{
    6d26:	ef 92       	push	r14
    6d28:	ff 92       	push	r15
    6d2a:	0f 93       	push	r16
    6d2c:	1f 93       	push	r17
    6d2e:	df 93       	push	r29
    6d30:	cf 93       	push	r28
    6d32:	cd b7       	in	r28, 0x3d	; 61
    6d34:	de b7       	in	r29, 0x3e	; 62
    6d36:	6e 97       	sbiw	r28, 0x1e	; 30
    6d38:	0f b6       	in	r0, 0x3f	; 63
    6d3a:	f8 94       	cli
    6d3c:	de bf       	out	0x3e, r29	; 62
    6d3e:	0f be       	out	0x3f, r0	; 63
    6d40:	cd bf       	out	0x3d, r28	; 61
    6d42:	7a 01       	movw	r14, r20
	char ipstring[30];

	sprintf_P(ipstring,PSTR("%i.%i.%i.%i.in-addr.arpa"),(uint16_t)((ip&0xFF000000)>>24),
    6d44:	2d b7       	in	r18, 0x3d	; 61
    6d46:	3e b7       	in	r19, 0x3e	; 62
    6d48:	2c 50       	subi	r18, 0x0C	; 12
    6d4a:	30 40       	sbci	r19, 0x00	; 0
    6d4c:	0f b6       	in	r0, 0x3f	; 63
    6d4e:	f8 94       	cli
    6d50:	3e bf       	out	0x3e, r19	; 62
    6d52:	0f be       	out	0x3f, r0	; 63
    6d54:	2d bf       	out	0x3d, r18	; 61
    6d56:	ed b7       	in	r30, 0x3d	; 61
    6d58:	fe b7       	in	r31, 0x3e	; 62
    6d5a:	31 96       	adiw	r30, 0x01	; 1
    6d5c:	8e 01       	movw	r16, r28
    6d5e:	0f 5f       	subi	r16, 0xFF	; 255
    6d60:	1f 4f       	sbci	r17, 0xFF	; 255
    6d62:	ad b7       	in	r26, 0x3d	; 61
    6d64:	be b7       	in	r27, 0x3e	; 62
    6d66:	12 96       	adiw	r26, 0x02	; 2
    6d68:	1c 93       	st	X, r17
    6d6a:	0e 93       	st	-X, r16
    6d6c:	11 97       	sbiw	r26, 0x01	; 1
    6d6e:	2e e3       	ldi	r18, 0x3E	; 62
    6d70:	39 e1       	ldi	r19, 0x19	; 25
    6d72:	33 83       	std	Z+3, r19	; 0x03
    6d74:	22 83       	std	Z+2, r18	; 0x02
    6d76:	29 2f       	mov	r18, r25
    6d78:	33 27       	eor	r19, r19
    6d7a:	44 27       	eor	r20, r20
    6d7c:	55 27       	eor	r21, r21
    6d7e:	35 83       	std	Z+5, r19	; 0x05
    6d80:	24 83       	std	Z+4, r18	; 0x04
    6d82:	28 2f       	mov	r18, r24
    6d84:	30 e0       	ldi	r19, 0x00	; 0
    6d86:	37 83       	std	Z+7, r19	; 0x07
    6d88:	26 83       	std	Z+6, r18	; 0x06
    6d8a:	27 2f       	mov	r18, r23
    6d8c:	30 e0       	ldi	r19, 0x00	; 0
    6d8e:	31 87       	std	Z+9, r19	; 0x09
    6d90:	20 87       	std	Z+8, r18	; 0x08
    6d92:	70 70       	andi	r23, 0x00	; 0
    6d94:	73 87       	std	Z+11, r23	; 0x0b
    6d96:	62 87       	std	Z+10, r22	; 0x0a
    6d98:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
													    (uint16_t)((ip&0x00FF0000)>>16),
													    (uint16_t)((ip&0x0000FF00)>>8),
													    (uint16_t)(ip&0x000000FF));
	_dns_qry(12, ipstring, hostname);	// PTR-Record anfragen
    6d9c:	2d b7       	in	r18, 0x3d	; 61
    6d9e:	3e b7       	in	r19, 0x3e	; 62
    6da0:	24 5f       	subi	r18, 0xF4	; 244
    6da2:	3f 4f       	sbci	r19, 0xFF	; 255
    6da4:	0f b6       	in	r0, 0x3f	; 63
    6da6:	f8 94       	cli
    6da8:	3e bf       	out	0x3e, r19	; 62
    6daa:	0f be       	out	0x3f, r0	; 63
    6dac:	2d bf       	out	0x3d, r18	; 61
    6dae:	8c e0       	ldi	r24, 0x0C	; 12
    6db0:	b8 01       	movw	r22, r16
    6db2:	a7 01       	movw	r20, r14
    6db4:	0e 94 f1 35 	call	0x6be2	; 0x6be2 <_dns_qry>
}
    6db8:	6e 96       	adiw	r28, 0x1e	; 30
    6dba:	0f b6       	in	r0, 0x3f	; 63
    6dbc:	f8 94       	cli
    6dbe:	de bf       	out	0x3e, r29	; 62
    6dc0:	0f be       	out	0x3f, r0	; 63
    6dc2:	cd bf       	out	0x3d, r28	; 61
    6dc4:	cf 91       	pop	r28
    6dc6:	df 91       	pop	r29
    6dc8:	1f 91       	pop	r17
    6dca:	0f 91       	pop	r16
    6dcc:	ff 90       	pop	r15
    6dce:	ef 90       	pop	r14
    6dd0:	08 95       	ret

00006dd2 <dns_init>:
*	Initialisierung des DNS Client Ports (fr Datenempfang)
*/
void dns_init (void)
{
	// Port in Anwendungstabelle eintragen fr eingehende DNS Daten!
	add_udp_app(DNS_CLIENT_PORT, dns_get);
    6dd2:	84 eb       	ldi	r24, 0xB4	; 180
    6dd4:	94 e1       	ldi	r25, 0x14	; 20
    6dd6:	6e e4       	ldi	r22, 0x4E	; 78
    6dd8:	74 e3       	ldi	r23, 0x34	; 52
    6dda:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <add_udp_app>
	
	// DNS IP aus EEPROM auslesen
	(*((unsigned long*)&dns_server_ip[0])) = get_eeprom_value(DNS_IP_EEPROM_STORE,DNS_IP);
    6dde:	8a e2       	ldi	r24, 0x2A	; 42
    6de0:	90 e0       	ldi	r25, 0x00	; 0
    6de2:	40 ec       	ldi	r20, 0xC0	; 192
    6de4:	58 ea       	ldi	r21, 0xA8	; 168
    6de6:	60 e0       	ldi	r22, 0x00	; 0
    6de8:	71 e0       	ldi	r23, 0x01	; 1
    6dea:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    6dee:	60 93 6a 0d 	sts	0x0D6A, r22
    6df2:	70 93 6b 0d 	sts	0x0D6B, r23
    6df6:	80 93 6c 0d 	sts	0x0D6C, r24
    6dfa:	90 93 6d 0d 	sts	0x0D6D, r25
	
	return;
}
    6dfe:	08 95       	ret

00006e00 <translate>:
 *	\param[in,out] ptr Speicherplatz des konvertierten Strings
 *	\param[out] nbytes Anzahl verarbeiteter Bytes
 *	\returns Anzahl der Bytes im konvertierten String
*/
uint16_t translate(char *buffer, char **ptr, uint16_t *nbytes )
{
    6e00:	2f 92       	push	r2
    6e02:	3f 92       	push	r3
    6e04:	4f 92       	push	r4
    6e06:	5f 92       	push	r5
    6e08:	6f 92       	push	r6
    6e0a:	7f 92       	push	r7
    6e0c:	8f 92       	push	r8
    6e0e:	9f 92       	push	r9
    6e10:	af 92       	push	r10
    6e12:	bf 92       	push	r11
    6e14:	cf 92       	push	r12
    6e16:	df 92       	push	r13
    6e18:	ef 92       	push	r14
    6e1a:	ff 92       	push	r15
    6e1c:	0f 93       	push	r16
    6e1e:	1f 93       	push	r17
    6e20:	df 93       	push	r29
    6e22:	cf 93       	push	r28
    6e24:	cd b7       	in	r28, 0x3d	; 61
    6e26:	de b7       	in	r29, 0x3e	; 62
    6e28:	29 97       	sbiw	r28, 0x09	; 9
    6e2a:	0f b6       	in	r0, 0x3f	; 63
    6e2c:	f8 94       	cli
    6e2e:	de bf       	out	0x3e, r29	; 62
    6e30:	0f be       	out	0x3f, r0	; 63
    6e32:	cd bf       	out	0x3d, r28	; 61
    6e34:	1c 01       	movw	r2, r24
    6e36:	2b 01       	movw	r4, r22
    6e38:	59 87       	std	Y+9, r21	; 0x09
    6e3a:	48 87       	std	Y+8, r20	; 0x08
	uint16_t len = 0;
	char *src = buffer;
	char *dest = *ptr;
    6e3c:	db 01       	movw	r26, r22
    6e3e:	ad 90       	ld	r10, X+
    6e40:	bc 90       	ld	r11, X
    6e42:	6c 01       	movw	r12, r24
    6e44:	88 24       	eor	r8, r8
    6e46:	99 24       	eor	r9, r9
				switch(*(src+3)) {
					case 'A':
						b = (PINA & (1<<pin));
						break;
					case 'B':
						b = (PINB & (1<<pin));
    6e48:	f1 e0       	ldi	r31, 0x01	; 1
    6e4a:	6f 2e       	mov	r6, r31
    6e4c:	71 2c       	mov	r7, r1
    6e4e:	6c c1       	rjmp	.+728    	; 0x7128 <translate+0x328>
    6e50:	76 01       	movw	r14, r12
    6e52:	08 94       	sec
    6e54:	e1 1c       	adc	r14, r1
    6e56:	f1 1c       	adc	r15, r1
	char *src = buffer;
	char *dest = *ptr;

	while (*src) {
		
		if (*src != '%') {
    6e58:	15 32       	cpi	r17, 0x25	; 37
    6e5a:	41 f0       	breq	.+16     	; 0x6e6c <translate+0x6c>
			*dest++ = *src++;
    6e5c:	f5 01       	movw	r30, r10
    6e5e:	11 93       	st	Z+, r17
    6e60:	5f 01       	movw	r10, r30
    6e62:	67 01       	movw	r12, r14
			++len;
    6e64:	08 94       	sec
    6e66:	81 1c       	adc	r8, r1
    6e68:	91 1c       	adc	r9, r1
    6e6a:	5e c1       	rjmp	.+700    	; 0x7128 <translate+0x328>
		}
		else {
			++src;
    6e6c:	67 01       	movw	r12, r14

			if (strncasecmp_P(src,PSTR("TIME"),4)==0) {
    6e6e:	c7 01       	movw	r24, r14
    6e70:	63 ed       	ldi	r22, 0xD3	; 211
    6e72:	79 e1       	ldi	r23, 0x19	; 25
    6e74:	44 e0       	ldi	r20, 0x04	; 4
    6e76:	50 e0       	ldi	r21, 0x00	; 0
    6e78:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    6e7c:	89 2b       	or	r24, r25
    6e7e:	a1 f5       	brne	.+104    	; 0x6ee8 <translate+0xe8>
				uint16_t year;
				uint8_t month, day, hour, min, sec;
				FUNCS_DEBUG(" - Zeit");
				get_datetime(&year, &month, &day, &hour, &min, &sec);
    6e80:	ce 01       	movw	r24, r28
    6e82:	06 96       	adiw	r24, 0x06	; 6
    6e84:	be 01       	movw	r22, r28
    6e86:	6b 5f       	subi	r22, 0xFB	; 251
    6e88:	7f 4f       	sbci	r23, 0xFF	; 255
    6e8a:	ae 01       	movw	r20, r28
    6e8c:	4c 5f       	subi	r20, 0xFC	; 252
    6e8e:	5f 4f       	sbci	r21, 0xFF	; 255
    6e90:	9e 01       	movw	r18, r28
    6e92:	2d 5f       	subi	r18, 0xFD	; 253
    6e94:	3f 4f       	sbci	r19, 0xFF	; 255
    6e96:	8e 01       	movw	r16, r28
    6e98:	0e 5f       	subi	r16, 0xFE	; 254
    6e9a:	1f 4f       	sbci	r17, 0xFF	; 255
    6e9c:	7e 01       	movw	r14, r28
    6e9e:	08 94       	sec
    6ea0:	e1 1c       	adc	r14, r1
    6ea2:	f1 1c       	adc	r15, r1
    6ea4:	0e 94 4e 20 	call	0x409c	; 0x409c <get_datetime>
				sprintf_P(dest,PSTR("%2.2d:%2.2d:%2.2d"),hour,min,sec);
    6ea8:	4d b7       	in	r20, 0x3d	; 61
    6eaa:	5e b7       	in	r21, 0x3e	; 62
    6eac:	4a 50       	subi	r20, 0x0A	; 10
    6eae:	50 40       	sbci	r21, 0x00	; 0
    6eb0:	0f b6       	in	r0, 0x3f	; 63
    6eb2:	f8 94       	cli
    6eb4:	5e bf       	out	0x3e, r21	; 62
    6eb6:	0f be       	out	0x3f, r0	; 63
    6eb8:	4d bf       	out	0x3d, r20	; 61
    6eba:	ed b7       	in	r30, 0x3d	; 61
    6ebc:	fe b7       	in	r31, 0x3e	; 62
    6ebe:	31 96       	adiw	r30, 0x01	; 1
    6ec0:	ad b7       	in	r26, 0x3d	; 61
    6ec2:	be b7       	in	r27, 0x3e	; 62
    6ec4:	12 96       	adiw	r26, 0x02	; 2
    6ec6:	bc 92       	st	X, r11
    6ec8:	ae 92       	st	-X, r10
    6eca:	11 97       	sbiw	r26, 0x01	; 1
    6ecc:	41 ec       	ldi	r20, 0xC1	; 193
    6ece:	59 e1       	ldi	r21, 0x19	; 25
    6ed0:	53 83       	std	Z+3, r21	; 0x03
    6ed2:	42 83       	std	Z+2, r20	; 0x02
    6ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    6ed6:	84 83       	std	Z+4, r24	; 0x04
    6ed8:	15 82       	std	Z+5, r1	; 0x05
    6eda:	8a 81       	ldd	r24, Y+2	; 0x02
    6edc:	86 83       	std	Z+6, r24	; 0x06
    6ede:	17 82       	std	Z+7, r1	; 0x07
    6ee0:	89 81       	ldd	r24, Y+1	; 0x01
    6ee2:	80 87       	std	Z+8, r24	; 0x08
    6ee4:	11 86       	std	Z+9, r1	; 0x09
    6ee6:	3c c0       	rjmp	.+120    	; 0x6f60 <translate+0x160>
				src += 4;
			}

			else if (strncasecmp_P(src,PSTR("DATE"),4)==0) {
    6ee8:	c7 01       	movw	r24, r14
    6eea:	6c eb       	ldi	r22, 0xBC	; 188
    6eec:	79 e1       	ldi	r23, 0x19	; 25
    6eee:	44 e0       	ldi	r20, 0x04	; 4
    6ef0:	50 e0       	ldi	r21, 0x00	; 0
    6ef2:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    6ef6:	89 2b       	or	r24, r25
    6ef8:	09 f0       	breq	.+2      	; 0x6efc <translate+0xfc>
    6efa:	41 c0       	rjmp	.+130    	; 0x6f7e <translate+0x17e>
				uint16_t year;
				uint8_t month, day, hour, min, sec;
				FUNCS_DEBUG(" - Datum");
				get_datetime(&year, &month, &day, &hour, &min, &sec);
    6efc:	ce 01       	movw	r24, r28
    6efe:	06 96       	adiw	r24, 0x06	; 6
    6f00:	be 01       	movw	r22, r28
    6f02:	6f 5f       	subi	r22, 0xFF	; 255
    6f04:	7f 4f       	sbci	r23, 0xFF	; 255
    6f06:	ae 01       	movw	r20, r28
    6f08:	4e 5f       	subi	r20, 0xFE	; 254
    6f0a:	5f 4f       	sbci	r21, 0xFF	; 255
    6f0c:	9e 01       	movw	r18, r28
    6f0e:	2d 5f       	subi	r18, 0xFD	; 253
    6f10:	3f 4f       	sbci	r19, 0xFF	; 255
    6f12:	8e 01       	movw	r16, r28
    6f14:	0c 5f       	subi	r16, 0xFC	; 252
    6f16:	1f 4f       	sbci	r17, 0xFF	; 255
    6f18:	e5 e0       	ldi	r30, 0x05	; 5
    6f1a:	ee 2e       	mov	r14, r30
    6f1c:	f1 2c       	mov	r15, r1
    6f1e:	ec 0e       	add	r14, r28
    6f20:	fd 1e       	adc	r15, r29
    6f22:	0e 94 4e 20 	call	0x409c	; 0x409c <get_datetime>
				sprintf_P(dest,PSTR("%2.2d.%2.2d.%4d"),day,month,year);
    6f26:	ed b7       	in	r30, 0x3d	; 61
    6f28:	fe b7       	in	r31, 0x3e	; 62
    6f2a:	3a 97       	sbiw	r30, 0x0a	; 10
    6f2c:	0f b6       	in	r0, 0x3f	; 63
    6f2e:	f8 94       	cli
    6f30:	fe bf       	out	0x3e, r31	; 62
    6f32:	0f be       	out	0x3f, r0	; 63
    6f34:	ed bf       	out	0x3d, r30	; 61
    6f36:	31 96       	adiw	r30, 0x01	; 1
    6f38:	ad b7       	in	r26, 0x3d	; 61
    6f3a:	be b7       	in	r27, 0x3e	; 62
    6f3c:	12 96       	adiw	r26, 0x02	; 2
    6f3e:	bc 92       	st	X, r11
    6f40:	ae 92       	st	-X, r10
    6f42:	11 97       	sbiw	r26, 0x01	; 1
    6f44:	4c ea       	ldi	r20, 0xAC	; 172
    6f46:	59 e1       	ldi	r21, 0x19	; 25
    6f48:	53 83       	std	Z+3, r21	; 0x03
    6f4a:	42 83       	std	Z+2, r20	; 0x02
    6f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    6f4e:	84 83       	std	Z+4, r24	; 0x04
    6f50:	15 82       	std	Z+5, r1	; 0x05
    6f52:	89 81       	ldd	r24, Y+1	; 0x01
    6f54:	86 83       	std	Z+6, r24	; 0x06
    6f56:	17 82       	std	Z+7, r1	; 0x07
    6f58:	8e 81       	ldd	r24, Y+6	; 0x06
    6f5a:	9f 81       	ldd	r25, Y+7	; 0x07
    6f5c:	91 87       	std	Z+9, r25	; 0x09
    6f5e:	80 87       	std	Z+8, r24	; 0x08
    6f60:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
				src += 4;
    6f64:	84 e0       	ldi	r24, 0x04	; 4
    6f66:	90 e0       	ldi	r25, 0x00	; 0
    6f68:	c8 0e       	add	r12, r24
    6f6a:	d9 1e       	adc	r13, r25
    6f6c:	ad b7       	in	r26, 0x3d	; 61
    6f6e:	be b7       	in	r27, 0x3e	; 62
    6f70:	1a 96       	adiw	r26, 0x0a	; 10
    6f72:	0f b6       	in	r0, 0x3f	; 63
    6f74:	f8 94       	cli
    6f76:	be bf       	out	0x3e, r27	; 62
    6f78:	0f be       	out	0x3f, r0	; 63
    6f7a:	ad bf       	out	0x3d, r26	; 61
    6f7c:	ce c0       	rjmp	.+412    	; 0x711a <translate+0x31a>
			}

			else if (strncasecmp_P(src,PSTR("USDATE"),6)==0) {
    6f7e:	c7 01       	movw	r24, r14
    6f80:	65 ea       	ldi	r22, 0xA5	; 165
    6f82:	79 e1       	ldi	r23, 0x19	; 25
    6f84:	46 e0       	ldi	r20, 0x06	; 6
    6f86:	50 e0       	ldi	r21, 0x00	; 0
    6f88:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    6f8c:	89 2b       	or	r24, r25
    6f8e:	31 f4       	brne	.+12     	; 0x6f9c <translate+0x19c>
				FUNCS_DEBUG(" - USDatum");
				GetUSdate(dest);
    6f90:	c5 01       	movw	r24, r10
    6f92:	0e 94 26 23 	call	0x464c	; 0x464c <GetUSdate>
				src += 6;
    6f96:	e6 e0       	ldi	r30, 0x06	; 6
    6f98:	f0 e0       	ldi	r31, 0x00	; 0
    6f9a:	1e c0       	rjmp	.+60     	; 0x6fd8 <translate+0x1d8>
			}

			else if (strncasecmp_P(src,PSTR("WDAY"),4)==0) {
    6f9c:	c7 01       	movw	r24, r14
    6f9e:	60 ea       	ldi	r22, 0xA0	; 160
    6fa0:	79 e1       	ldi	r23, 0x19	; 25
    6fa2:	44 e0       	ldi	r20, 0x04	; 4
    6fa4:	50 e0       	ldi	r21, 0x00	; 0
    6fa6:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    6faa:	89 2b       	or	r24, r25
    6fac:	c1 f4       	brne	.+48     	; 0x6fde <translate+0x1de>
				FUNCS_DEBUG(" - Wochentag");
				memcpy_P(dest,&Tagesnamen[TM_DOW*3],3);
    6fae:	60 91 30 0c 	lds	r22, 0x0C30
    6fb2:	f3 e0       	ldi	r31, 0x03	; 3
    6fb4:	6f 9f       	mul	r22, r31
    6fb6:	b0 01       	movw	r22, r0
    6fb8:	11 24       	eor	r1, r1
    6fba:	69 5a       	subi	r22, 0xA9	; 169
    6fbc:	76 4e       	sbci	r23, 0xE6	; 230
    6fbe:	c5 01       	movw	r24, r10
    6fc0:	43 e0       	ldi	r20, 0x03	; 3
    6fc2:	50 e0       	ldi	r21, 0x00	; 0
    6fc4:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
				dest += 3;
    6fc8:	43 e0       	ldi	r20, 0x03	; 3
    6fca:	50 e0       	ldi	r21, 0x00	; 0
    6fcc:	a4 0e       	add	r10, r20
    6fce:	b5 1e       	adc	r11, r21
				*dest = '\0';
    6fd0:	d5 01       	movw	r26, r10
    6fd2:	1c 92       	st	X, r1
				src += 4;
    6fd4:	e4 e0       	ldi	r30, 0x04	; 4
    6fd6:	f0 e0       	ldi	r31, 0x00	; 0
    6fd8:	ce 0e       	add	r12, r30
    6fda:	df 1e       	adc	r13, r31
    6fdc:	9e c0       	rjmp	.+316    	; 0x711a <translate+0x31a>
			}
#endif

			//Einsetzen des Port Status %PORTxy durch "checked" wenn Portx.Piny = 1
			//x: A..G  y: 0..7 
			else if (strncasecmp_P(src,PSTR("PORT"),4)==0) {
    6fde:	c7 01       	movw	r24, r14
    6fe0:	6b e9       	ldi	r22, 0x9B	; 155
    6fe2:	79 e1       	ldi	r23, 0x19	; 25
    6fe4:	44 e0       	ldi	r20, 0x04	; 4
    6fe6:	50 e0       	ldi	r21, 0x00	; 0
    6fe8:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    6fec:	89 2b       	or	r24, r25
    6fee:	09 f0       	breq	.+2      	; 0x6ff2 <translate+0x1f2>
    6ff0:	3e c0       	rjmp	.+124    	; 0x706e <translate+0x26e>
				FUNCS_DEBUG(" - Portstatus");
				uint8_t pin  = (*(src+5)-48);	
    6ff2:	d7 01       	movw	r26, r14
    6ff4:	15 96       	adiw	r26, 0x05	; 5
    6ff6:	9c 91       	ld	r25, X
    6ff8:	15 97       	sbiw	r26, 0x05	; 5
    6ffa:	90 53       	subi	r25, 0x30	; 48
				uint8_t b = 0;
				switch(*(src+4)) {
    6ffc:	14 96       	adiw	r26, 0x04	; 4
    6ffe:	8c 91       	ld	r24, X
    7000:	82 34       	cpi	r24, 0x42	; 66
    7002:	61 f0       	breq	.+24     	; 0x701c <translate+0x21c>
    7004:	83 34       	cpi	r24, 0x43	; 67
    7006:	18 f4       	brcc	.+6      	; 0x700e <translate+0x20e>
    7008:	81 34       	cpi	r24, 0x41	; 65
    700a:	41 f5       	brne	.+80     	; 0x705c <translate+0x25c>
    700c:	05 c0       	rjmp	.+10     	; 0x7018 <translate+0x218>
    700e:	83 34       	cpi	r24, 0x43	; 67
    7010:	71 f0       	breq	.+28     	; 0x702e <translate+0x22e>
    7012:	84 34       	cpi	r24, 0x44	; 68
    7014:	19 f5       	brne	.+70     	; 0x705c <translate+0x25c>
    7016:	14 c0       	rjmp	.+40     	; 0x7040 <translate+0x240>
					case 'A':
						b = (PORTA & (1<<pin));
    7018:	22 b1       	in	r18, 0x02	; 2
    701a:	13 c0       	rjmp	.+38     	; 0x7042 <translate+0x242>
						break;
					case 'B':
						b = (PORTB & (1<<pin));
    701c:	25 b1       	in	r18, 0x05	; 5
    701e:	a3 01       	movw	r20, r6
    7020:	02 c0       	rjmp	.+4      	; 0x7026 <translate+0x226>
    7022:	44 0f       	add	r20, r20
    7024:	55 1f       	adc	r21, r21
    7026:	9a 95       	dec	r25
    7028:	e2 f7       	brpl	.-8      	; 0x7022 <translate+0x222>
    702a:	ca 01       	movw	r24, r20
    702c:	11 c0       	rjmp	.+34     	; 0x7050 <translate+0x250>
						break;
					case 'C':
						b = (PORTC & (1<<pin));
    702e:	28 b1       	in	r18, 0x08	; 8
    7030:	d3 01       	movw	r26, r6
    7032:	02 c0       	rjmp	.+4      	; 0x7038 <translate+0x238>
    7034:	aa 0f       	add	r26, r26
    7036:	bb 1f       	adc	r27, r27
    7038:	9a 95       	dec	r25
    703a:	e2 f7       	brpl	.-8      	; 0x7034 <translate+0x234>
    703c:	cd 01       	movw	r24, r26
    703e:	08 c0       	rjmp	.+16     	; 0x7050 <translate+0x250>
						break;
					case 'D':
						b = (PORTD & (1<<pin));
    7040:	2b b1       	in	r18, 0x0b	; 11
    7042:	f3 01       	movw	r30, r6
    7044:	02 c0       	rjmp	.+4      	; 0x704a <translate+0x24a>
    7046:	ee 0f       	add	r30, r30
    7048:	ff 1f       	adc	r31, r31
    704a:	9a 95       	dec	r25
    704c:	e2 f7       	brpl	.-8      	; 0x7046 <translate+0x246>
    704e:	cf 01       	movw	r24, r30
    7050:	28 23       	and	r18, r24
						break; 
				}
				
				if(b) {
    7052:	21 f0       	breq	.+8      	; 0x705c <translate+0x25c>
					//strcpy_P(dest, PSTR("checked"));
					strcpy_P(dest, PSTR("ledon.gif"));
    7054:	c5 01       	movw	r24, r10
    7056:	61 e9       	ldi	r22, 0x91	; 145
    7058:	79 e1       	ldi	r23, 0x19	; 25
    705a:	03 c0       	rjmp	.+6      	; 0x7062 <translate+0x262>
				}
				else {
					//strcpy_P(dest, PSTR("unchecked"));
					strcpy_P(dest, PSTR("ledoff.gif"));
    705c:	c5 01       	movw	r24, r10
    705e:	66 e8       	ldi	r22, 0x86	; 134
    7060:	79 e1       	ldi	r23, 0x19	; 25
    7062:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
				}

				src += 6;
    7066:	96 e0       	ldi	r25, 0x06	; 6
    7068:	c9 2e       	mov	r12, r25
    706a:	d1 2c       	mov	r13, r1
    706c:	47 c0       	rjmp	.+142    	; 0x70fc <translate+0x2fc>
			}
			
			//Einsetzen des Pin Status %PI@xy bis %PI@xy durch "ledon" oder "ledoff"
			//x = 0 : PINA / x = 1 : PINB / x = 2 : PINC / x = 3 : PIND
			else if (strncasecmp_P(src,PSTR("PIN"),3)==0) {
    706e:	c7 01       	movw	r24, r14
    7070:	62 e8       	ldi	r22, 0x82	; 130
    7072:	79 e1       	ldi	r23, 0x19	; 25
    7074:	43 e0       	ldi	r20, 0x03	; 3
    7076:	50 e0       	ldi	r21, 0x00	; 0
    7078:	0e 94 ef 6d 	call	0xdbde	; 0xdbde <strncasecmp_P>
    707c:	89 2b       	or	r24, r25
    707e:	09 f0       	breq	.+2      	; 0x7082 <translate+0x282>
    7080:	40 c0       	rjmp	.+128    	; 0x7102 <translate+0x302>
				FUNCS_DEBUG(" - Eingangswert");
				uint8_t pin  = (*(src+4)-48);	
    7082:	d7 01       	movw	r26, r14
    7084:	14 96       	adiw	r26, 0x04	; 4
    7086:	9c 91       	ld	r25, X
    7088:	14 97       	sbiw	r26, 0x04	; 4
    708a:	90 53       	subi	r25, 0x30	; 48
				uint8_t b = 0;
				switch(*(src+3)) {
    708c:	13 96       	adiw	r26, 0x03	; 3
    708e:	8c 91       	ld	r24, X
    7090:	82 34       	cpi	r24, 0x42	; 66
    7092:	61 f0       	breq	.+24     	; 0x70ac <translate+0x2ac>
    7094:	83 34       	cpi	r24, 0x43	; 67
    7096:	18 f4       	brcc	.+6      	; 0x709e <translate+0x29e>
    7098:	81 34       	cpi	r24, 0x41	; 65
    709a:	41 f5       	brne	.+80     	; 0x70ec <translate+0x2ec>
    709c:	05 c0       	rjmp	.+10     	; 0x70a8 <translate+0x2a8>
    709e:	83 34       	cpi	r24, 0x43	; 67
    70a0:	71 f0       	breq	.+28     	; 0x70be <translate+0x2be>
    70a2:	84 34       	cpi	r24, 0x44	; 68
    70a4:	19 f5       	brne	.+70     	; 0x70ec <translate+0x2ec>
    70a6:	14 c0       	rjmp	.+40     	; 0x70d0 <translate+0x2d0>
					case 'A':
						b = (PINA & (1<<pin));
    70a8:	20 b1       	in	r18, 0x00	; 0
    70aa:	13 c0       	rjmp	.+38     	; 0x70d2 <translate+0x2d2>
						break;
					case 'B':
						b = (PINB & (1<<pin));
    70ac:	23 b1       	in	r18, 0x03	; 3
    70ae:	a3 01       	movw	r20, r6
    70b0:	02 c0       	rjmp	.+4      	; 0x70b6 <translate+0x2b6>
    70b2:	44 0f       	add	r20, r20
    70b4:	55 1f       	adc	r21, r21
    70b6:	9a 95       	dec	r25
    70b8:	e2 f7       	brpl	.-8      	; 0x70b2 <translate+0x2b2>
    70ba:	ca 01       	movw	r24, r20
    70bc:	11 c0       	rjmp	.+34     	; 0x70e0 <translate+0x2e0>
						break;
					case 'C':
						b = (PINC & (1<<pin));
    70be:	26 b1       	in	r18, 0x06	; 6
    70c0:	d3 01       	movw	r26, r6
    70c2:	02 c0       	rjmp	.+4      	; 0x70c8 <translate+0x2c8>
    70c4:	aa 0f       	add	r26, r26
    70c6:	bb 1f       	adc	r27, r27
    70c8:	9a 95       	dec	r25
    70ca:	e2 f7       	brpl	.-8      	; 0x70c4 <translate+0x2c4>
    70cc:	cd 01       	movw	r24, r26
    70ce:	08 c0       	rjmp	.+16     	; 0x70e0 <translate+0x2e0>
						break;
					case 'D':
						b = (PIND & (1<<pin));
    70d0:	29 b1       	in	r18, 0x09	; 9
    70d2:	f3 01       	movw	r30, r6
    70d4:	02 c0       	rjmp	.+4      	; 0x70da <translate+0x2da>
    70d6:	ee 0f       	add	r30, r30
    70d8:	ff 1f       	adc	r31, r31
    70da:	9a 95       	dec	r25
    70dc:	e2 f7       	brpl	.-8      	; 0x70d6 <translate+0x2d6>
    70de:	cf 01       	movw	r24, r30
    70e0:	28 23       	and	r18, r24
						break;    
				}
				
				if(b) {	// gesetztes bit bedeutet: nix dran, da Pullup Widerstand
    70e2:	21 f0       	breq	.+8      	; 0x70ec <translate+0x2ec>
					strcpy_P(dest, PSTR("ledoff.gif"));
    70e4:	c5 01       	movw	r24, r10
    70e6:	67 e7       	ldi	r22, 0x77	; 119
    70e8:	79 e1       	ldi	r23, 0x19	; 25
    70ea:	03 c0       	rjmp	.+6      	; 0x70f2 <translate+0x2f2>
				} else {
					strcpy_P(dest, PSTR("ledon.gif"));	// Schalter auf Masse geschlossen
    70ec:	c5 01       	movw	r24, r10
    70ee:	6d e6       	ldi	r22, 0x6D	; 109
    70f0:	79 e1       	ldi	r23, 0x19	; 25
    70f2:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
				}

				src += 5;
    70f6:	85 e0       	ldi	r24, 0x05	; 5
    70f8:	c8 2e       	mov	r12, r24
    70fa:	d1 2c       	mov	r13, r1
    70fc:	ce 0c       	add	r12, r14
    70fe:	df 1c       	adc	r13, r15
    7100:	0c c0       	rjmp	.+24     	; 0x711a <translate+0x31a>
			}
			else {	// nix gefunden -> '%' speichern
				*dest++ = '%';
    7102:	d5 01       	movw	r26, r10
    7104:	1d 93       	st	X+, r17
    7106:	5d 01       	movw	r10, r26
				*dest = 0;
    7108:	1c 92       	st	X, r1
				++len;
    710a:	08 94       	sec
    710c:	81 1c       	adc	r8, r1
    710e:	91 1c       	adc	r9, r1
    7110:	04 c0       	rjmp	.+8      	; 0x711a <translate+0x31a>
			}

			while (*dest++)	// neues Ende finden
				++len;
    7112:	08 94       	sec
    7114:	81 1c       	adc	r8, r1
    7116:	91 1c       	adc	r9, r1
    7118:	59 01       	movw	r10, r18
				*dest++ = '%';
				*dest = 0;
				++len;
			}

			while (*dest++)	// neues Ende finden
    711a:	95 01       	movw	r18, r10
    711c:	2f 5f       	subi	r18, 0xFF	; 255
    711e:	3f 4f       	sbci	r19, 0xFF	; 255
    7120:	f5 01       	movw	r30, r10
    7122:	80 81       	ld	r24, Z
    7124:	88 23       	and	r24, r24
    7126:	a9 f7       	brne	.-22     	; 0x7112 <translate+0x312>
{
	uint16_t len = 0;
	char *src = buffer;
	char *dest = *ptr;

	while (*src) {
    7128:	d6 01       	movw	r26, r12
    712a:	1c 91       	ld	r17, X
    712c:	11 23       	and	r17, r17
    712e:	09 f0       	breq	.+2      	; 0x7132 <translate+0x332>
    7130:	8f ce       	rjmp	.-738    	; 0x6e50 <translate+0x50>
				++len;
			--dest;
		}

	}
	*ptr = dest;
    7132:	f2 01       	movw	r30, r4
    7134:	b1 82       	std	Z+1, r11	; 0x01
    7136:	a0 82       	st	Z, r10
	*nbytes = (uint16_t)(src - buffer);
    7138:	c2 18       	sub	r12, r2
    713a:	d3 08       	sbc	r13, r3
    713c:	a8 85       	ldd	r26, Y+8	; 0x08
    713e:	b9 85       	ldd	r27, Y+9	; 0x09
    7140:	cd 92       	st	X+, r12
    7142:	dc 92       	st	X, r13
	return len;
}
    7144:	c4 01       	movw	r24, r8
    7146:	29 96       	adiw	r28, 0x09	; 9
    7148:	0f b6       	in	r0, 0x3f	; 63
    714a:	f8 94       	cli
    714c:	de bf       	out	0x3e, r29	; 62
    714e:	0f be       	out	0x3f, r0	; 63
    7150:	cd bf       	out	0x3d, r28	; 61
    7152:	cf 91       	pop	r28
    7154:	df 91       	pop	r29
    7156:	1f 91       	pop	r17
    7158:	0f 91       	pop	r16
    715a:	ff 90       	pop	r15
    715c:	ef 90       	pop	r14
    715e:	df 90       	pop	r13
    7160:	cf 90       	pop	r12
    7162:	bf 90       	pop	r11
    7164:	af 90       	pop	r10
    7166:	9f 90       	pop	r9
    7168:	8f 90       	pop	r8
    716a:	7f 90       	pop	r7
    716c:	6f 90       	pop	r6
    716e:	5f 90       	pop	r5
    7170:	4f 90       	pop	r4
    7172:	3f 90       	pop	r3
    7174:	2f 90       	pop	r2
    7176:	08 95       	ret

00007178 <cmd_quit>:
 * \returns (-1)
 */
int16_t cmd_quit(char *outbuffer)
{
	return (-1);
}
    7178:	8f ef       	ldi	r24, 0xFF	; 255
    717a:	9f ef       	ldi	r25, 0xFF	; 255
    717c:	08 95       	ret

0000717e <command_reset>:
 * \ingroup tcpcmdcommon
 * \b Reset-Befehl ausfhren
 */
int16_t command_reset (char *outbuffer)
{
	RESET();
    717e:	e0 e0       	ldi	r30, 0x00	; 0
    7180:	f0 e0       	ldi	r31, 0x00	; 0
    7182:	09 94       	ijmp
	return 0;	// never executed
}
    7184:	80 e0       	ldi	r24, 0x00	; 0
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	08 95       	ret

0000718a <command_setvar>:
	else {
		usart_write("Inhalt der Variable[%2i] = %2u\r\n",i,(uint32_t)var_array[i]);
	}
#endif
	return 0;
}
    718a:	80 e0       	ldi	r24, 0x00	; 0
    718c:	90 e0       	ldi	r25, 0x00	; 0
    718e:	08 95       	ret

00007190 <cmd_PASV>:
 * \b PASV-Befehl
 *
 * passiver mode auf Port 2100 (8 * 256 + 52)
 */
int16_t cmd_PASV(char *outbuffer)
{
    7190:	cf 93       	push	r28
    7192:	df 93       	push	r29
    7194:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7196:	00 97       	sbiw	r24, 0x00	; 0
    7198:	19 f4       	brne	.+6      	; 0x71a0 <cmd_PASV+0x10>
    719a:	a0 e0       	ldi	r26, 0x00	; 0
    719c:	b0 e0       	ldi	r27, 0x00	; 0
    719e:	36 c0       	rjmp	.+108    	; 0x720c <cmd_PASV+0x7c>
		sprintf_P(outbuffer,PSTR("227 Entering Passive Mode (%i,%i,%i,%i,8,52)\r\n"),myip[0],myip[1],myip[2],myip[3]);
    71a0:	8d b7       	in	r24, 0x3d	; 61
    71a2:	9e b7       	in	r25, 0x3e	; 62
    71a4:	0c 97       	sbiw	r24, 0x0c	; 12
    71a6:	0f b6       	in	r0, 0x3f	; 63
    71a8:	f8 94       	cli
    71aa:	9e bf       	out	0x3e, r25	; 62
    71ac:	0f be       	out	0x3f, r0	; 63
    71ae:	8d bf       	out	0x3d, r24	; 61
    71b0:	ed b7       	in	r30, 0x3d	; 61
    71b2:	fe b7       	in	r31, 0x3e	; 62
    71b4:	31 96       	adiw	r30, 0x01	; 1
    71b6:	ad b7       	in	r26, 0x3d	; 61
    71b8:	be b7       	in	r27, 0x3e	; 62
    71ba:	12 96       	adiw	r26, 0x02	; 2
    71bc:	dc 93       	st	X, r29
    71be:	ce 93       	st	-X, r28
    71c0:	11 97       	sbiw	r26, 0x01	; 1
    71c2:	86 e1       	ldi	r24, 0x16	; 22
    71c4:	9e e1       	ldi	r25, 0x1E	; 30
    71c6:	93 83       	std	Z+3, r25	; 0x03
    71c8:	82 83       	std	Z+2, r24	; 0x02
    71ca:	80 91 46 0b 	lds	r24, 0x0B46
    71ce:	84 83       	std	Z+4, r24	; 0x04
    71d0:	15 82       	std	Z+5, r1	; 0x05
    71d2:	80 91 47 0b 	lds	r24, 0x0B47
    71d6:	86 83       	std	Z+6, r24	; 0x06
    71d8:	17 82       	std	Z+7, r1	; 0x07
    71da:	80 91 48 0b 	lds	r24, 0x0B48
    71de:	80 87       	std	Z+8, r24	; 0x08
    71e0:	11 86       	std	Z+9, r1	; 0x09
    71e2:	80 91 49 0b 	lds	r24, 0x0B49
    71e6:	82 87       	std	Z+10, r24	; 0x0a
    71e8:	13 86       	std	Z+11, r1	; 0x0b
    71ea:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    71ee:	de 01       	movw	r26, r28
    71f0:	0d 90       	ld	r0, X+
    71f2:	00 20       	and	r0, r0
    71f4:	e9 f7       	brne	.-6      	; 0x71f0 <cmd_PASV+0x60>
    71f6:	11 97       	sbiw	r26, 0x01	; 1
    71f8:	ac 1b       	sub	r26, r28
    71fa:	bd 0b       	sbc	r27, r29
    71fc:	8d b7       	in	r24, 0x3d	; 61
    71fe:	9e b7       	in	r25, 0x3e	; 62
    7200:	0c 96       	adiw	r24, 0x0c	; 12
    7202:	0f b6       	in	r0, 0x3f	; 63
    7204:	f8 94       	cli
    7206:	9e bf       	out	0x3e, r25	; 62
    7208:	0f be       	out	0x3f, r0	; 63
    720a:	8d bf       	out	0x3d, r24	; 61
	}
	else {
		return 0;
	}
}
    720c:	cd 01       	movw	r24, r26
    720e:	df 91       	pop	r29
    7210:	cf 91       	pop	r28
    7212:	08 95       	ret

00007214 <cmd_PWD>:
/**
 * \ingroup tcpftp
 * \b PWD-Befehl aktuelles Verzeichnis anzeigen
 */
int16_t cmd_PWD(char *outbuffer)
{
    7214:	cf 93       	push	r28
    7216:	df 93       	push	r29
    7218:	ec 01       	movw	r28, r24
	#if !FTP_ANONYMOUS
	if (outbuffer && !tcpsrv_status.loginOK)
		return cmd_530(outbuffer);
	#endif

	if (outbuffer) {
    721a:	00 97       	sbiw	r24, 0x00	; 0
    721c:	19 f4       	brne	.+6      	; 0x7224 <cmd_PWD+0x10>
    721e:	a0 e0       	ldi	r26, 0x00	; 0
    7220:	b0 e0       	ldi	r27, 0x00	; 0
    7222:	25 c0       	rjmp	.+74     	; 0x726e <cmd_PWD+0x5a>
		sprintf_P(outbuffer,PSTR("257 \"%s\" is your current location\r\n"),cwdirectory);
    7224:	00 d0       	rcall	.+0      	; 0x7226 <cmd_PWD+0x12>
    7226:	00 d0       	rcall	.+0      	; 0x7228 <cmd_PWD+0x14>
    7228:	00 d0       	rcall	.+0      	; 0x722a <cmd_PWD+0x16>
    722a:	ed b7       	in	r30, 0x3d	; 61
    722c:	fe b7       	in	r31, 0x3e	; 62
    722e:	31 96       	adiw	r30, 0x01	; 1
    7230:	ad b7       	in	r26, 0x3d	; 61
    7232:	be b7       	in	r27, 0x3e	; 62
    7234:	12 96       	adiw	r26, 0x02	; 2
    7236:	9c 93       	st	X, r25
    7238:	8e 93       	st	-X, r24
    723a:	11 97       	sbiw	r26, 0x01	; 1
    723c:	89 e9       	ldi	r24, 0x99	; 153
    723e:	9f e1       	ldi	r25, 0x1F	; 31
    7240:	93 83       	std	Z+3, r25	; 0x03
    7242:	82 83       	std	Z+2, r24	; 0x02
    7244:	88 e7       	ldi	r24, 0x78	; 120
    7246:	91 e0       	ldi	r25, 0x01	; 1
    7248:	95 83       	std	Z+5, r25	; 0x05
    724a:	84 83       	std	Z+4, r24	; 0x04
    724c:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    7250:	de 01       	movw	r26, r28
    7252:	0d 90       	ld	r0, X+
    7254:	00 20       	and	r0, r0
    7256:	e9 f7       	brne	.-6      	; 0x7252 <cmd_PWD+0x3e>
    7258:	11 97       	sbiw	r26, 0x01	; 1
    725a:	ac 1b       	sub	r26, r28
    725c:	bd 0b       	sbc	r27, r29
    725e:	8d b7       	in	r24, 0x3d	; 61
    7260:	9e b7       	in	r25, 0x3e	; 62
    7262:	06 96       	adiw	r24, 0x06	; 6
    7264:	0f b6       	in	r0, 0x3f	; 63
    7266:	f8 94       	cli
    7268:	9e bf       	out	0x3e, r25	; 62
    726a:	0f be       	out	0x3f, r0	; 63
    726c:	8d bf       	out	0x3d, r24	; 61
	}
	else {
		return 0;
	}
#endif
}
    726e:	cd 01       	movw	r24, r26
    7270:	df 91       	pop	r29
    7272:	cf 91       	pop	r28
    7274:	08 95       	ret

00007276 <command_time>:
/**
 * \ingroup tcpcmdcommon
 * TIME-Befehl: aktuelle Uhrzeit des Moduls ausgeben
 */
int16_t command_time (char *outbuffer)
{
    7276:	0f 93       	push	r16
    7278:	1f 93       	push	r17
    727a:	cf 93       	push	r28
    727c:	df 93       	push	r29
    727e:	ec 01       	movw	r28, r24
	unsigned char hh = (time/3600)%24;
    7280:	60 91 77 0c 	lds	r22, 0x0C77
    7284:	70 91 78 0c 	lds	r23, 0x0C78
    7288:	80 91 79 0c 	lds	r24, 0x0C79
    728c:	90 91 7a 0c 	lds	r25, 0x0C7A
    7290:	20 e1       	ldi	r18, 0x10	; 16
    7292:	3e e0       	ldi	r19, 0x0E	; 14
    7294:	40 e0       	ldi	r20, 0x00	; 0
    7296:	50 e0       	ldi	r21, 0x00	; 0
    7298:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    729c:	ca 01       	movw	r24, r20
    729e:	b9 01       	movw	r22, r18
    72a0:	28 e1       	ldi	r18, 0x18	; 24
    72a2:	30 e0       	ldi	r19, 0x00	; 0
    72a4:	40 e0       	ldi	r20, 0x00	; 0
    72a6:	50 e0       	ldi	r21, 0x00	; 0
    72a8:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    72ac:	06 2f       	mov	r16, r22
	unsigned char mm = (time/60)%60;
    72ae:	60 91 77 0c 	lds	r22, 0x0C77
    72b2:	70 91 78 0c 	lds	r23, 0x0C78
    72b6:	80 91 79 0c 	lds	r24, 0x0C79
    72ba:	90 91 7a 0c 	lds	r25, 0x0C7A
    72be:	2c e3       	ldi	r18, 0x3C	; 60
    72c0:	30 e0       	ldi	r19, 0x00	; 0
    72c2:	40 e0       	ldi	r20, 0x00	; 0
    72c4:	50 e0       	ldi	r21, 0x00	; 0
    72c6:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    72ca:	ca 01       	movw	r24, r20
    72cc:	b9 01       	movw	r22, r18
    72ce:	2c e3       	ldi	r18, 0x3C	; 60
    72d0:	30 e0       	ldi	r19, 0x00	; 0
    72d2:	40 e0       	ldi	r20, 0x00	; 0
    72d4:	50 e0       	ldi	r21, 0x00	; 0
    72d6:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    72da:	16 2f       	mov	r17, r22
	unsigned char ss = time %60;
    72dc:	60 91 77 0c 	lds	r22, 0x0C77
    72e0:	70 91 78 0c 	lds	r23, 0x0C78
    72e4:	80 91 79 0c 	lds	r24, 0x0C79
    72e8:	90 91 7a 0c 	lds	r25, 0x0C7A
    72ec:	2c e3       	ldi	r18, 0x3C	; 60
    72ee:	30 e0       	ldi	r19, 0x00	; 0
    72f0:	40 e0       	ldi	r20, 0x00	; 0
    72f2:	50 e0       	ldi	r21, 0x00	; 0
    72f4:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
	if (outbuffer) {
    72f8:	20 97       	sbiw	r28, 0x00	; 0
    72fa:	41 f1       	breq	.+80     	; 0x734c <command_time+0xd6>
		sprintf_P(outbuffer,PSTR("250 ok. Time: %2i:%2i:%2i\r\n"),hh,mm,ss);
    72fc:	8d b7       	in	r24, 0x3d	; 61
    72fe:	9e b7       	in	r25, 0x3e	; 62
    7300:	0a 97       	sbiw	r24, 0x0a	; 10
    7302:	0f b6       	in	r0, 0x3f	; 63
    7304:	f8 94       	cli
    7306:	9e bf       	out	0x3e, r25	; 62
    7308:	0f be       	out	0x3f, r0	; 63
    730a:	8d bf       	out	0x3d, r24	; 61
    730c:	ed b7       	in	r30, 0x3d	; 61
    730e:	fe b7       	in	r31, 0x3e	; 62
    7310:	31 96       	adiw	r30, 0x01	; 1
    7312:	ad b7       	in	r26, 0x3d	; 61
    7314:	be b7       	in	r27, 0x3e	; 62
    7316:	12 96       	adiw	r26, 0x02	; 2
    7318:	dc 93       	st	X, r29
    731a:	ce 93       	st	-X, r28
    731c:	11 97       	sbiw	r26, 0x01	; 1
    731e:	81 e8       	ldi	r24, 0x81	; 129
    7320:	90 e2       	ldi	r25, 0x20	; 32
    7322:	93 83       	std	Z+3, r25	; 0x03
    7324:	82 83       	std	Z+2, r24	; 0x02
    7326:	04 83       	std	Z+4, r16	; 0x04
    7328:	15 82       	std	Z+5, r1	; 0x05
    732a:	16 83       	std	Z+6, r17	; 0x06
    732c:	17 82       	std	Z+7, r1	; 0x07
    732e:	60 87       	std	Z+8, r22	; 0x08
    7330:	11 86       	std	Z+9, r1	; 0x09
    7332:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    7336:	de 01       	movw	r26, r28
    7338:	0d 90       	ld	r0, X+
    733a:	00 20       	and	r0, r0
    733c:	e9 f7       	brne	.-6      	; 0x7338 <command_time+0xc2>
    733e:	11 97       	sbiw	r26, 0x01	; 1
    7340:	ac 1b       	sub	r26, r28
    7342:	bd 0b       	sbc	r27, r29
    7344:	8d b7       	in	r24, 0x3d	; 61
    7346:	9e b7       	in	r25, 0x3e	; 62
    7348:	0a 96       	adiw	r24, 0x0a	; 10
    734a:	1e c0       	rjmp	.+60     	; 0x7388 <command_time+0x112>
	}
	else {
		usart_write ("\n\rTIME: %2i:%2i:%2i\r\n",hh,mm,ss);
    734c:	ad b7       	in	r26, 0x3d	; 61
    734e:	be b7       	in	r27, 0x3e	; 62
    7350:	18 97       	sbiw	r26, 0x08	; 8
    7352:	0f b6       	in	r0, 0x3f	; 63
    7354:	f8 94       	cli
    7356:	be bf       	out	0x3e, r27	; 62
    7358:	0f be       	out	0x3f, r0	; 63
    735a:	ad bf       	out	0x3d, r26	; 61
    735c:	ed b7       	in	r30, 0x3d	; 61
    735e:	fe b7       	in	r31, 0x3e	; 62
    7360:	31 96       	adiw	r30, 0x01	; 1
    7362:	8b e6       	ldi	r24, 0x6B	; 107
    7364:	90 e2       	ldi	r25, 0x20	; 32
    7366:	12 96       	adiw	r26, 0x02	; 2
    7368:	9c 93       	st	X, r25
    736a:	8e 93       	st	-X, r24
    736c:	11 97       	sbiw	r26, 0x01	; 1
    736e:	02 83       	std	Z+2, r16	; 0x02
    7370:	13 82       	std	Z+3, r1	; 0x03
    7372:	14 83       	std	Z+4, r17	; 0x04
    7374:	15 82       	std	Z+5, r1	; 0x05
    7376:	66 83       	std	Z+6, r22	; 0x06
    7378:	17 82       	std	Z+7, r1	; 0x07
    737a:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    737e:	a0 e0       	ldi	r26, 0x00	; 0
    7380:	b0 e0       	ldi	r27, 0x00	; 0
    7382:	8d b7       	in	r24, 0x3d	; 61
    7384:	9e b7       	in	r25, 0x3e	; 62
    7386:	08 96       	adiw	r24, 0x08	; 8
    7388:	0f b6       	in	r0, 0x3f	; 63
    738a:	f8 94       	cli
    738c:	9e bf       	out	0x3e, r25	; 62
    738e:	0f be       	out	0x3f, r0	; 63
    7390:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
}
    7392:	cd 01       	movw	r24, r26
    7394:	df 91       	pop	r29
    7396:	cf 91       	pop	r28
    7398:	1f 91       	pop	r17
    739a:	0f 91       	pop	r16
    739c:	08 95       	ret

0000739e <command_ver>:
/**
 * \ingroup tcpcmdcommon
 * \b Ver-Befehl zeige enc28j60 chip version
 */
int16_t command_ver (char *outbuffer)
{
    739e:	cf 93       	push	r28
    73a0:	df 93       	push	r29
    73a2:	ec 01       	movw	r28, r24
#if USE_ENC28J60
	if (outbuffer) {
    73a4:	00 97       	sbiw	r24, 0x00	; 0
    73a6:	31 f1       	breq	.+76     	; 0x73f4 <command_ver+0x56>
		sprintf_P(outbuffer,PSTR("250 ok. ENC28J60-Version: %1x\r\n"), enc28j60_revision);
    73a8:	00 d0       	rcall	.+0      	; 0x73aa <command_ver+0xc>
    73aa:	00 d0       	rcall	.+0      	; 0x73ac <command_ver+0xe>
    73ac:	00 d0       	rcall	.+0      	; 0x73ae <command_ver+0x10>
    73ae:	ed b7       	in	r30, 0x3d	; 61
    73b0:	fe b7       	in	r31, 0x3e	; 62
    73b2:	31 96       	adiw	r30, 0x01	; 1
    73b4:	ad b7       	in	r26, 0x3d	; 61
    73b6:	be b7       	in	r27, 0x3e	; 62
    73b8:	12 96       	adiw	r26, 0x02	; 2
    73ba:	9c 93       	st	X, r25
    73bc:	8e 93       	st	-X, r24
    73be:	11 97       	sbiw	r26, 0x01	; 1
    73c0:	85 e4       	ldi	r24, 0x45	; 69
    73c2:	91 e2       	ldi	r25, 0x21	; 33
    73c4:	93 83       	std	Z+3, r25	; 0x03
    73c6:	82 83       	std	Z+2, r24	; 0x02
    73c8:	80 91 11 02 	lds	r24, 0x0211
    73cc:	84 83       	std	Z+4, r24	; 0x04
    73ce:	15 82       	std	Z+5, r1	; 0x05
    73d0:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    73d4:	de 01       	movw	r26, r28
    73d6:	0d 90       	ld	r0, X+
    73d8:	00 20       	and	r0, r0
    73da:	e9 f7       	brne	.-6      	; 0x73d6 <command_ver+0x38>
    73dc:	11 97       	sbiw	r26, 0x01	; 1
    73de:	ac 1b       	sub	r26, r28
    73e0:	bd 0b       	sbc	r27, r29
    73e2:	8d b7       	in	r24, 0x3d	; 61
    73e4:	9e b7       	in	r25, 0x3e	; 62
    73e6:	06 96       	adiw	r24, 0x06	; 6
    73e8:	0f b6       	in	r0, 0x3f	; 63
    73ea:	f8 94       	cli
    73ec:	9e bf       	out	0x3e, r25	; 62
    73ee:	0f be       	out	0x3f, r0	; 63
    73f0:	8d bf       	out	0x3d, r24	; 61
    73f2:	19 c0       	rjmp	.+50     	; 0x7426 <command_ver+0x88>
	}
	else {
		usart_write("ENC28J60-Version: %1x\r\n", enc28j60_revision);
    73f4:	00 d0       	rcall	.+0      	; 0x73f6 <command_ver+0x58>
    73f6:	00 d0       	rcall	.+0      	; 0x73f8 <command_ver+0x5a>
    73f8:	ed b7       	in	r30, 0x3d	; 61
    73fa:	fe b7       	in	r31, 0x3e	; 62
    73fc:	31 96       	adiw	r30, 0x01	; 1
    73fe:	8d e2       	ldi	r24, 0x2D	; 45
    7400:	91 e2       	ldi	r25, 0x21	; 33
    7402:	ad b7       	in	r26, 0x3d	; 61
    7404:	be b7       	in	r27, 0x3e	; 62
    7406:	12 96       	adiw	r26, 0x02	; 2
    7408:	9c 93       	st	X, r25
    740a:	8e 93       	st	-X, r24
    740c:	11 97       	sbiw	r26, 0x01	; 1
    740e:	80 91 11 02 	lds	r24, 0x0211
    7412:	82 83       	std	Z+2, r24	; 0x02
    7414:	13 82       	std	Z+3, r1	; 0x03
    7416:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    741a:	a0 e0       	ldi	r26, 0x00	; 0
    741c:	b0 e0       	ldi	r27, 0x00	; 0
    741e:	0f 90       	pop	r0
    7420:	0f 90       	pop	r0
    7422:	0f 90       	pop	r0
    7424:	0f 90       	pop	r0
#endif

#if USE_RTL8019
	usart_write("RTL8019 Ethernetcard\r\n");
#endif
}
    7426:	cd 01       	movw	r24, r26
    7428:	df 91       	pop	r29
    742a:	cf 91       	pop	r28
    742c:	08 95       	ret

0000742e <command_mac>:
/**
 * \ingroup tcpcmdcommon
 * \b MAC-Befehl zeige eigene MAC-Adresse
 */
int16_t command_mac (char *outbuffer)
{
    742e:	cf 93       	push	r28
    7430:	df 93       	push	r29
    7432:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7434:	00 97       	sbiw	r24, 0x00	; 0
    7436:	d1 f1       	breq	.+116    	; 0x74ac <command_mac+0x7e>
		sprintf_P(outbuffer,PSTR("250 ok. My MAC: %2x:%2x:%2x:%2x:%2x:%2x\r\n"),mymac[0],mymac[1],mymac[2],mymac[3],mymac[4],mymac[5]);
    7438:	8d b7       	in	r24, 0x3d	; 61
    743a:	9e b7       	in	r25, 0x3e	; 62
    743c:	40 97       	sbiw	r24, 0x10	; 16
    743e:	0f b6       	in	r0, 0x3f	; 63
    7440:	f8 94       	cli
    7442:	9e bf       	out	0x3e, r25	; 62
    7444:	0f be       	out	0x3f, r0	; 63
    7446:	8d bf       	out	0x3d, r24	; 61
    7448:	ed b7       	in	r30, 0x3d	; 61
    744a:	fe b7       	in	r31, 0x3e	; 62
    744c:	31 96       	adiw	r30, 0x01	; 1
    744e:	ad b7       	in	r26, 0x3d	; 61
    7450:	be b7       	in	r27, 0x3e	; 62
    7452:	12 96       	adiw	r26, 0x02	; 2
    7454:	dc 93       	st	X, r29
    7456:	ce 93       	st	-X, r28
    7458:	11 97       	sbiw	r26, 0x01	; 1
    745a:	87 e8       	ldi	r24, 0x87	; 135
    745c:	91 e2       	ldi	r25, 0x21	; 33
    745e:	93 83       	std	Z+3, r25	; 0x03
    7460:	82 83       	std	Z+2, r24	; 0x02
    7462:	80 91 7c 0c 	lds	r24, 0x0C7C
    7466:	84 83       	std	Z+4, r24	; 0x04
    7468:	15 82       	std	Z+5, r1	; 0x05
    746a:	80 91 7d 0c 	lds	r24, 0x0C7D
    746e:	86 83       	std	Z+6, r24	; 0x06
    7470:	17 82       	std	Z+7, r1	; 0x07
    7472:	80 91 7e 0c 	lds	r24, 0x0C7E
    7476:	80 87       	std	Z+8, r24	; 0x08
    7478:	11 86       	std	Z+9, r1	; 0x09
    747a:	80 91 7f 0c 	lds	r24, 0x0C7F
    747e:	82 87       	std	Z+10, r24	; 0x0a
    7480:	13 86       	std	Z+11, r1	; 0x0b
    7482:	80 91 80 0c 	lds	r24, 0x0C80
    7486:	84 87       	std	Z+12, r24	; 0x0c
    7488:	15 86       	std	Z+13, r1	; 0x0d
    748a:	80 91 81 0c 	lds	r24, 0x0C81
    748e:	86 87       	std	Z+14, r24	; 0x0e
    7490:	17 86       	std	Z+15, r1	; 0x0f
    7492:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    7496:	de 01       	movw	r26, r28
    7498:	0d 90       	ld	r0, X+
    749a:	00 20       	and	r0, r0
    749c:	e9 f7       	brne	.-6      	; 0x7498 <command_mac+0x6a>
    749e:	11 97       	sbiw	r26, 0x01	; 1
    74a0:	ac 1b       	sub	r26, r28
    74a2:	bd 0b       	sbc	r27, r29
    74a4:	8d b7       	in	r24, 0x3d	; 61
    74a6:	9e b7       	in	r25, 0x3e	; 62
    74a8:	40 96       	adiw	r24, 0x10	; 16
    74aa:	30 c0       	rjmp	.+96     	; 0x750c <command_mac+0xde>
	}
	else {
		usart_write("My MAC: %2x:%2x:%2x:%2x:%2x:%2x\r\n",mymac[0],mymac[1],mymac[2],mymac[3],mymac[4],mymac[5]);
    74ac:	ad b7       	in	r26, 0x3d	; 61
    74ae:	be b7       	in	r27, 0x3e	; 62
    74b0:	1e 97       	sbiw	r26, 0x0e	; 14
    74b2:	0f b6       	in	r0, 0x3f	; 63
    74b4:	f8 94       	cli
    74b6:	be bf       	out	0x3e, r27	; 62
    74b8:	0f be       	out	0x3f, r0	; 63
    74ba:	ad bf       	out	0x3d, r26	; 61
    74bc:	ed b7       	in	r30, 0x3d	; 61
    74be:	fe b7       	in	r31, 0x3e	; 62
    74c0:	31 96       	adiw	r30, 0x01	; 1
    74c2:	85 e6       	ldi	r24, 0x65	; 101
    74c4:	91 e2       	ldi	r25, 0x21	; 33
    74c6:	12 96       	adiw	r26, 0x02	; 2
    74c8:	9c 93       	st	X, r25
    74ca:	8e 93       	st	-X, r24
    74cc:	11 97       	sbiw	r26, 0x01	; 1
    74ce:	80 91 7c 0c 	lds	r24, 0x0C7C
    74d2:	82 83       	std	Z+2, r24	; 0x02
    74d4:	13 82       	std	Z+3, r1	; 0x03
    74d6:	80 91 7d 0c 	lds	r24, 0x0C7D
    74da:	84 83       	std	Z+4, r24	; 0x04
    74dc:	15 82       	std	Z+5, r1	; 0x05
    74de:	80 91 7e 0c 	lds	r24, 0x0C7E
    74e2:	86 83       	std	Z+6, r24	; 0x06
    74e4:	17 82       	std	Z+7, r1	; 0x07
    74e6:	80 91 7f 0c 	lds	r24, 0x0C7F
    74ea:	80 87       	std	Z+8, r24	; 0x08
    74ec:	11 86       	std	Z+9, r1	; 0x09
    74ee:	80 91 80 0c 	lds	r24, 0x0C80
    74f2:	82 87       	std	Z+10, r24	; 0x0a
    74f4:	13 86       	std	Z+11, r1	; 0x0b
    74f6:	80 91 81 0c 	lds	r24, 0x0C81
    74fa:	84 87       	std	Z+12, r24	; 0x0c
    74fc:	15 86       	std	Z+13, r1	; 0x0d
    74fe:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    7502:	a0 e0       	ldi	r26, 0x00	; 0
    7504:	b0 e0       	ldi	r27, 0x00	; 0
    7506:	8d b7       	in	r24, 0x3d	; 61
    7508:	9e b7       	in	r25, 0x3e	; 62
    750a:	0e 96       	adiw	r24, 0x0e	; 14
    750c:	0f b6       	in	r0, 0x3f	; 63
    750e:	f8 94       	cli
    7510:	9e bf       	out	0x3e, r25	; 62
    7512:	0f be       	out	0x3f, r0	; 63
    7514:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
}
    7516:	cd 01       	movw	r24, r26
    7518:	df 91       	pop	r29
    751a:	cf 91       	pop	r28
    751c:	08 95       	ret

0000751e <cmd_550>:
		return 0;
	}
}

int16_t cmd_550(char *outbuffer)
{
    751e:	cf 93       	push	r28
    7520:	df 93       	push	r29
    7522:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7524:	00 97       	sbiw	r24, 0x00	; 0
    7526:	19 f4       	brne	.+6      	; 0x752e <cmd_550+0x10>
    7528:	a0 e0       	ldi	r26, 0x00	; 0
    752a:	b0 e0       	ldi	r27, 0x00	; 0
    752c:	0b c0       	rjmp	.+22     	; 0x7544 <cmd_550+0x26>
		strcpy_P(outbuffer,PSTR("550 Requested action not taken.\r\n"));
    752e:	65 e4       	ldi	r22, 0x45	; 69
    7530:	7e e1       	ldi	r23, 0x1E	; 30
    7532:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7536:	de 01       	movw	r26, r28
    7538:	0d 90       	ld	r0, X+
    753a:	00 20       	and	r0, r0
    753c:	e9 f7       	brne	.-6      	; 0x7538 <cmd_550+0x1a>
    753e:	11 97       	sbiw	r26, 0x01	; 1
    7540:	ac 1b       	sub	r26, r28
    7542:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    7544:	cd 01       	movw	r24, r26
    7546:	df 91       	pop	r29
    7548:	cf 91       	pop	r28
    754a:	08 95       	ret

0000754c <cmd_530>:
		return 0;
	}
}

int16_t cmd_530(char *outbuffer)
{
    754c:	cf 93       	push	r28
    754e:	df 93       	push	r29
    7550:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7552:	00 97       	sbiw	r24, 0x00	; 0
    7554:	19 f4       	brne	.+6      	; 0x755c <cmd_530+0x10>
    7556:	a0 e0       	ldi	r26, 0x00	; 0
    7558:	b0 e0       	ldi	r27, 0x00	; 0
    755a:	0b c0       	rjmp	.+22     	; 0x7572 <cmd_530+0x26>
		strcpy_P(outbuffer,PSTR("530 Not logged in.\r\n"));
    755c:	67 e6       	ldi	r22, 0x67	; 103
    755e:	7e e1       	ldi	r23, 0x1E	; 30
    7560:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7564:	de 01       	movw	r26, r28
    7566:	0d 90       	ld	r0, X+
    7568:	00 20       	and	r0, r0
    756a:	e9 f7       	brne	.-6      	; 0x7566 <cmd_530+0x1a>
    756c:	11 97       	sbiw	r26, 0x01	; 1
    756e:	ac 1b       	sub	r26, r28
    7570:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    7572:	cd 01       	movw	r24, r26
    7574:	df 91       	pop	r29
    7576:	cf 91       	pop	r28
    7578:	08 95       	ret

0000757a <cmd_502>:
		return 0;
	}
}

int16_t cmd_502(char *outbuffer)
{
    757a:	cf 93       	push	r28
    757c:	df 93       	push	r29
    757e:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7580:	00 97       	sbiw	r24, 0x00	; 0
    7582:	19 f4       	brne	.+6      	; 0x758a <cmd_502+0x10>
    7584:	a0 e0       	ldi	r26, 0x00	; 0
    7586:	b0 e0       	ldi	r27, 0x00	; 0
    7588:	0b c0       	rjmp	.+22     	; 0x75a0 <cmd_502+0x26>
		strcpy_P(outbuffer,PSTR("502 not implemented.\r\n"));
    758a:	6c e7       	ldi	r22, 0x7C	; 124
    758c:	7e e1       	ldi	r23, 0x1E	; 30
    758e:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7592:	de 01       	movw	r26, r28
    7594:	0d 90       	ld	r0, X+
    7596:	00 20       	and	r0, r0
    7598:	e9 f7       	brne	.-6      	; 0x7594 <cmd_502+0x1a>
    759a:	11 97       	sbiw	r26, 0x01	; 1
    759c:	ac 1b       	sub	r26, r28
    759e:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    75a0:	cd 01       	movw	r24, r26
    75a2:	df 91       	pop	r29
    75a4:	cf 91       	pop	r28
    75a6:	08 95       	ret

000075a8 <print_disk_info>:
/**
 * \ingroup usartcmdline
 * \b DISK-Befehl Informationen zur SD-Karte ausgeben
 */
int16_t print_disk_info(char *outbuffer)	//const struct fat16_fs_struct* fs)
{
    75a8:	df 93       	push	r29
    75aa:	cf 93       	push	r28
    75ac:	cd b7       	in	r28, 0x3d	; 61
    75ae:	de b7       	in	r29, 0x3e	; 62
    75b0:	69 97       	sbiw	r28, 0x19	; 25
    75b2:	0f b6       	in	r0, 0x3f	; 63
    75b4:	f8 94       	cli
    75b6:	de bf       	out	0x3e, r29	; 62
    75b8:	0f be       	out	0x3f, r0	; 63
    75ba:	cd bf       	out	0x3d, r28	; 61
    75bc:	9c 01       	movw	r18, r24
#if !USE_MMC
	return cmd_502(outbuffer);
#else
	if (!cwdir_ptr)
    75be:	80 91 cb 0d 	lds	r24, 0x0DCB
    75c2:	90 91 cc 0d 	lds	r25, 0x0DCC
    75c6:	89 2b       	or	r24, r25
    75c8:	19 f4       	brne	.+6      	; 0x75d0 <print_disk_info+0x28>
    75ca:	20 e0       	ldi	r18, 0x00	; 0
    75cc:	30 e0       	ldi	r19, 0x00	; 0
    75ce:	ce c0       	rjmp	.+412    	; 0x776c <print_disk_info+0x1c4>
        return 0;

	if (outbuffer)					// nur bei USART
    75d0:	21 15       	cp	r18, r1
    75d2:	31 05       	cpc	r19, r1
    75d4:	29 f0       	breq	.+10     	; 0x75e0 <print_disk_info+0x38>
		return cmd_502(outbuffer);
    75d6:	c9 01       	movw	r24, r18
    75d8:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    75dc:	9c 01       	movw	r18, r24
    75de:	c6 c0       	rjmp	.+396    	; 0x776c <print_disk_info+0x1c4>

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info)) {
    75e0:	ce 01       	movw	r24, r28
    75e2:	01 96       	adiw	r24, 0x01	; 1
    75e4:	0e 94 c7 5f 	call	0xbf8e	; 0xbf8e <sd_raw_get_info>
    75e8:	88 23       	and	r24, r24
    75ea:	81 f4       	brne	.+32     	; 0x760c <print_disk_info+0x64>
	    usart_write("\r\nDisk kann nicht gelesen werden.");
    75ec:	00 d0       	rcall	.+0      	; 0x75ee <print_disk_info+0x46>
    75ee:	81 ef       	ldi	r24, 0xF1	; 241
    75f0:	9d e1       	ldi	r25, 0x1D	; 29
    75f2:	ad b7       	in	r26, 0x3d	; 61
    75f4:	be b7       	in	r27, 0x3e	; 62
    75f6:	12 96       	adiw	r26, 0x02	; 2
    75f8:	9c 93       	st	X, r25
    75fa:	8e 93       	st	-X, r24
    75fc:	11 97       	sbiw	r26, 0x01	; 1
    75fe:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    7602:	20 e0       	ldi	r18, 0x00	; 0
    7604:	30 e0       	ldi	r19, 0x00	; 0
    7606:	0f 90       	pop	r0
    7608:	0f 90       	pop	r0
    760a:	b0 c0       	rjmp	.+352    	; 0x776c <print_disk_info+0x1c4>
        return 0;
	}

    usart_write("\r\nmanuf: 0x%x",disk_info.manufacturer);
    760c:	00 d0       	rcall	.+0      	; 0x760e <print_disk_info+0x66>
    760e:	00 d0       	rcall	.+0      	; 0x7610 <print_disk_info+0x68>
    7610:	ed b7       	in	r30, 0x3d	; 61
    7612:	fe b7       	in	r31, 0x3e	; 62
    7614:	31 96       	adiw	r30, 0x01	; 1
    7616:	83 ee       	ldi	r24, 0xE3	; 227
    7618:	9d e1       	ldi	r25, 0x1D	; 29
    761a:	ad b7       	in	r26, 0x3d	; 61
    761c:	be b7       	in	r27, 0x3e	; 62
    761e:	12 96       	adiw	r26, 0x02	; 2
    7620:	9c 93       	st	X, r25
    7622:	8e 93       	st	-X, r24
    7624:	11 97       	sbiw	r26, 0x01	; 1
    7626:	89 81       	ldd	r24, Y+1	; 0x01
    7628:	82 83       	std	Z+2, r24	; 0x02
    762a:	13 82       	std	Z+3, r1	; 0x03
    762c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\noem:     %s",disk_info.oem);
    7630:	85 ed       	ldi	r24, 0xD5	; 213
    7632:	9d e1       	ldi	r25, 0x1D	; 29
    7634:	ed b7       	in	r30, 0x3d	; 61
    7636:	fe b7       	in	r31, 0x3e	; 62
    7638:	92 83       	std	Z+2, r25	; 0x02
    763a:	81 83       	std	Z+1, r24	; 0x01
    763c:	ce 01       	movw	r24, r28
    763e:	02 96       	adiw	r24, 0x02	; 2
    7640:	94 83       	std	Z+4, r25	; 0x04
    7642:	83 83       	std	Z+3, r24	; 0x03
    7644:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nprod:    %s",disk_info.product);
    7648:	87 ec       	ldi	r24, 0xC7	; 199
    764a:	9d e1       	ldi	r25, 0x1D	; 29
    764c:	ad b7       	in	r26, 0x3d	; 61
    764e:	be b7       	in	r27, 0x3e	; 62
    7650:	12 96       	adiw	r26, 0x02	; 2
    7652:	9c 93       	st	X, r25
    7654:	8e 93       	st	-X, r24
    7656:	11 97       	sbiw	r26, 0x01	; 1
    7658:	ce 01       	movw	r24, r28
    765a:	05 96       	adiw	r24, 0x05	; 5
    765c:	14 96       	adiw	r26, 0x04	; 4
    765e:	9c 93       	st	X, r25
    7660:	8e 93       	st	-X, r24
    7662:	13 97       	sbiw	r26, 0x03	; 3
    7664:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nrev:     %i",disk_info.revision);
    7668:	ed b7       	in	r30, 0x3d	; 61
    766a:	fe b7       	in	r31, 0x3e	; 62
    766c:	31 96       	adiw	r30, 0x01	; 1
    766e:	89 eb       	ldi	r24, 0xB9	; 185
    7670:	9d e1       	ldi	r25, 0x1D	; 29
    7672:	ad b7       	in	r26, 0x3d	; 61
    7674:	be b7       	in	r27, 0x3e	; 62
    7676:	12 96       	adiw	r26, 0x02	; 2
    7678:	9c 93       	st	X, r25
    767a:	8e 93       	st	-X, r24
    767c:	11 97       	sbiw	r26, 0x01	; 1
    767e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7680:	82 83       	std	Z+2, r24	; 0x02
    7682:	13 82       	std	Z+3, r1	; 0x03
    7684:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nserial:  %l",disk_info.serial);
    7688:	00 d0       	rcall	.+0      	; 0x768a <print_disk_info+0xe2>
    768a:	8b ea       	ldi	r24, 0xAB	; 171
    768c:	9d e1       	ldi	r25, 0x1D	; 29
    768e:	ed b7       	in	r30, 0x3d	; 61
    7690:	fe b7       	in	r31, 0x3e	; 62
    7692:	92 83       	std	Z+2, r25	; 0x02
    7694:	81 83       	std	Z+1, r24	; 0x01
    7696:	8c 85       	ldd	r24, Y+12	; 0x0c
    7698:	9d 85       	ldd	r25, Y+13	; 0x0d
    769a:	ae 85       	ldd	r26, Y+14	; 0x0e
    769c:	bf 85       	ldd	r27, Y+15	; 0x0f
    769e:	83 83       	std	Z+3, r24	; 0x03
    76a0:	94 83       	std	Z+4, r25	; 0x04
    76a2:	a5 83       	std	Z+5, r26	; 0x05
    76a4:	b6 83       	std	Z+6, r27	; 0x06
    76a6:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\ndate:    %i/%i",disk_info.manufacturing_month,disk_info.manufacturing_year);
    76aa:	ed b7       	in	r30, 0x3d	; 61
    76ac:	fe b7       	in	r31, 0x3e	; 62
    76ae:	31 96       	adiw	r30, 0x01	; 1
    76b0:	8a e9       	ldi	r24, 0x9A	; 154
    76b2:	9d e1       	ldi	r25, 0x1D	; 29
    76b4:	ad b7       	in	r26, 0x3d	; 61
    76b6:	be b7       	in	r27, 0x3e	; 62
    76b8:	12 96       	adiw	r26, 0x02	; 2
    76ba:	9c 93       	st	X, r25
    76bc:	8e 93       	st	-X, r24
    76be:	11 97       	sbiw	r26, 0x01	; 1
    76c0:	89 89       	ldd	r24, Y+17	; 0x11
    76c2:	82 83       	std	Z+2, r24	; 0x02
    76c4:	13 82       	std	Z+3, r1	; 0x03
    76c6:	88 89       	ldd	r24, Y+16	; 0x10
    76c8:	84 83       	std	Z+4, r24	; 0x04
    76ca:	15 82       	std	Z+5, r1	; 0x05
    76cc:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nsize:    %l",disk_info.capacity);
    76d0:	8c e8       	ldi	r24, 0x8C	; 140
    76d2:	9d e1       	ldi	r25, 0x1D	; 29
    76d4:	ed b7       	in	r30, 0x3d	; 61
    76d6:	fe b7       	in	r31, 0x3e	; 62
    76d8:	92 83       	std	Z+2, r25	; 0x02
    76da:	81 83       	std	Z+1, r24	; 0x01
    76dc:	8a 89       	ldd	r24, Y+18	; 0x12
    76de:	9b 89       	ldd	r25, Y+19	; 0x13
    76e0:	ac 89       	ldd	r26, Y+20	; 0x14
    76e2:	bd 89       	ldd	r27, Y+21	; 0x15
    76e4:	83 83       	std	Z+3, r24	; 0x03
    76e6:	94 83       	std	Z+4, r25	; 0x04
    76e8:	a5 83       	std	Z+5, r26	; 0x05
    76ea:	b6 83       	std	Z+6, r27	; 0x06
    76ec:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\ncopy:    %i",disk_info.flag_copy);
    76f0:	0f 90       	pop	r0
    76f2:	0f 90       	pop	r0
    76f4:	ed b7       	in	r30, 0x3d	; 61
    76f6:	fe b7       	in	r31, 0x3e	; 62
    76f8:	31 96       	adiw	r30, 0x01	; 1
    76fa:	8e e7       	ldi	r24, 0x7E	; 126
    76fc:	9d e1       	ldi	r25, 0x1D	; 29
    76fe:	ad b7       	in	r26, 0x3d	; 61
    7700:	be b7       	in	r27, 0x3e	; 62
    7702:	12 96       	adiw	r26, 0x02	; 2
    7704:	9c 93       	st	X, r25
    7706:	8e 93       	st	-X, r24
    7708:	11 97       	sbiw	r26, 0x01	; 1
    770a:	8e 89       	ldd	r24, Y+22	; 0x16
    770c:	82 83       	std	Z+2, r24	; 0x02
    770e:	13 82       	std	Z+3, r1	; 0x03
    7710:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nwr.pr.:  %i/%i",disk_info.flag_write_protect_temp,disk_info.flag_write_protect);
    7714:	00 d0       	rcall	.+0      	; 0x7716 <print_disk_info+0x16e>
    7716:	ed b7       	in	r30, 0x3d	; 61
    7718:	fe b7       	in	r31, 0x3e	; 62
    771a:	31 96       	adiw	r30, 0x01	; 1
    771c:	8d e6       	ldi	r24, 0x6D	; 109
    771e:	9d e1       	ldi	r25, 0x1D	; 29
    7720:	ad b7       	in	r26, 0x3d	; 61
    7722:	be b7       	in	r27, 0x3e	; 62
    7724:	12 96       	adiw	r26, 0x02	; 2
    7726:	9c 93       	st	X, r25
    7728:	8e 93       	st	-X, r24
    772a:	11 97       	sbiw	r26, 0x01	; 1
    772c:	88 8d       	ldd	r24, Y+24	; 0x18
    772e:	82 83       	std	Z+2, r24	; 0x02
    7730:	13 82       	std	Z+3, r1	; 0x03
    7732:	8f 89       	ldd	r24, Y+23	; 0x17
    7734:	84 83       	std	Z+4, r24	; 0x04
    7736:	15 82       	std	Z+5, r1	; 0x05
    7738:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    usart_write("\r\nformat:  %i",disk_info.format);
    773c:	0f 90       	pop	r0
    773e:	0f 90       	pop	r0
    7740:	ed b7       	in	r30, 0x3d	; 61
    7742:	fe b7       	in	r31, 0x3e	; 62
    7744:	31 96       	adiw	r30, 0x01	; 1
    7746:	8f e5       	ldi	r24, 0x5F	; 95
    7748:	9d e1       	ldi	r25, 0x1D	; 29
    774a:	ad b7       	in	r26, 0x3d	; 61
    774c:	be b7       	in	r27, 0x3e	; 62
    774e:	12 96       	adiw	r26, 0x02	; 2
    7750:	9c 93       	st	X, r25
    7752:	8e 93       	st	-X, r24
    7754:	11 97       	sbiw	r26, 0x01	; 1
    7756:	89 8d       	ldd	r24, Y+25	; 0x19
    7758:	82 83       	std	Z+2, r24	; 0x02
    775a:	13 82       	std	Z+3, r1	; 0x03
    775c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    7760:	20 e0       	ldi	r18, 0x00	; 0
    7762:	30 e0       	ldi	r19, 0x00	; 0
    7764:	0f 90       	pop	r0
    7766:	0f 90       	pop	r0
    7768:	0f 90       	pop	r0
    776a:	0f 90       	pop	r0
//    uart_puts_p(PSTR("free:   ")); uart_putdw_dec(fat16_get_fs_free(fs)); uart_putc('/');
//                                   uart_putdw_dec(fat16_get_fs_size(fs)); uart_putc('\n');
	return 0;
#endif
}
    776c:	c9 01       	movw	r24, r18
    776e:	69 96       	adiw	r28, 0x19	; 25
    7770:	0f b6       	in	r0, 0x3f	; 63
    7772:	f8 94       	cli
    7774:	de bf       	out	0x3e, r29	; 62
    7776:	0f be       	out	0x3f, r0	; 63
    7778:	cd bf       	out	0x3d, r28	; 61
    777a:	cf 91       	pop	r28
    777c:	df 91       	pop	r29
    777e:	08 95       	ret

00007780 <command_help>:
/**
 * \ingroup usartcmdline
 * \b HELP-Befehl Hilfstext ausgeben
 */
int16_t command_help (char *outbuffer)
{
    7780:	ef 92       	push	r14
    7782:	ff 92       	push	r15
    7784:	1f 93       	push	r17
    7786:	cf 93       	push	r28
    7788:	df 93       	push	r29
	if (outbuffer)					// nur bei USART
    778a:	00 97       	sbiw	r24, 0x00	; 0
    778c:	21 f0       	breq	.+8      	; 0x7796 <command_help+0x16>
		return cmd_502(outbuffer);
    778e:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    7792:	9c 01       	movw	r18, r24
    7794:	20 c0       	rjmp	.+64     	; 0x77d6 <command_help+0x56>
    7796:	c1 e3       	ldi	r28, 0x31	; 49
    7798:	db e1       	ldi	r29, 0x1B	; 27
	PGM_P helptest_pointer = helptext;
	
	do
	{
		data = pgm_read_byte(helptest_pointer++);
		usart_write("%c",data);
    779a:	83 e1       	ldi	r24, 0x13	; 19
    779c:	e8 2e       	mov	r14, r24
    779e:	8e e1       	ldi	r24, 0x1E	; 30
    77a0:	f8 2e       	mov	r15, r24
 * \b HELP-Befehl Hilfstext ausgeben
 */
int16_t command_help (char *outbuffer)
{
	if (outbuffer)					// nur bei USART
		return cmd_502(outbuffer);
    77a2:	fe 01       	movw	r30, r28
	unsigned char data;
	PGM_P helptest_pointer = helptext;
	
	do
	{
		data = pgm_read_byte(helptest_pointer++);
    77a4:	21 96       	adiw	r28, 0x01	; 1
    77a6:	14 91       	lpm	r17, Z+
		usart_write("%c",data);
    77a8:	00 d0       	rcall	.+0      	; 0x77aa <command_help+0x2a>
    77aa:	00 d0       	rcall	.+0      	; 0x77ac <command_help+0x2c>
    77ac:	ed b7       	in	r30, 0x3d	; 61
    77ae:	fe b7       	in	r31, 0x3e	; 62
    77b0:	31 96       	adiw	r30, 0x01	; 1
    77b2:	ad b7       	in	r26, 0x3d	; 61
    77b4:	be b7       	in	r27, 0x3e	; 62
    77b6:	12 96       	adiw	r26, 0x02	; 2
    77b8:	fc 92       	st	X, r15
    77ba:	ee 92       	st	-X, r14
    77bc:	11 97       	sbiw	r26, 0x01	; 1
    77be:	12 83       	std	Z+2, r17	; 0x02
    77c0:	13 82       	std	Z+3, r1	; 0x03
    77c2:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
	}while(data != 0);
    77c6:	0f 90       	pop	r0
    77c8:	0f 90       	pop	r0
    77ca:	0f 90       	pop	r0
    77cc:	0f 90       	pop	r0
    77ce:	11 23       	and	r17, r17
    77d0:	41 f7       	brne	.-48     	; 0x77a2 <command_help+0x22>
    77d2:	20 e0       	ldi	r18, 0x00	; 0
    77d4:	30 e0       	ldi	r19, 0x00	; 0
	return 0;
#endif
}
    77d6:	c9 01       	movw	r24, r18
    77d8:	df 91       	pop	r29
    77da:	cf 91       	pop	r28
    77dc:	1f 91       	pop	r17
    77de:	ff 90       	pop	r15
    77e0:	ef 90       	pop	r14
    77e2:	08 95       	ret

000077e4 <command_OWlookup>:
 * \ingroup usartcmdline
 * \b OWREAD-Befehl DS18x20 auf Bus suchen und anzeigen
 */
int16_t command_OWlookup(char *outbuffer)
{
	if (outbuffer)					// nur bei USART
    77e4:	00 97       	sbiw	r24, 0x00	; 0
    77e6:	19 f4       	brne	.+6      	; 0x77ee <command_OWlookup+0xa>
    77e8:	20 e0       	ldi	r18, 0x00	; 0
    77ea:	30 e0       	ldi	r19, 0x00	; 0
    77ec:	03 c0       	rjmp	.+6      	; 0x77f4 <command_OWlookup+0x10>
		return cmd_502(outbuffer);
    77ee:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    77f2:	9c 01       	movw	r18, r24
			else usart_write(" *** Messung fehlgeschlagen. (Kurzschluss?) ***");
	}
	
	#endif
	return 0;
}
    77f4:	c9 01       	movw	r24, r18
    77f6:	08 95       	ret

000077f8 <command_OWread>:
 * \ingroup usartcmdline
 * \b OW-Befehl T-Werte der fixen DS18x20 anzeigen
 */
int16_t command_OWread(char *outbuffer)
{
	if (outbuffer)					// nur bei USART
    77f8:	00 97       	sbiw	r24, 0x00	; 0
    77fa:	19 f4       	brne	.+6      	; 0x7802 <command_OWread+0xa>
    77fc:	20 e0       	ldi	r18, 0x00	; 0
    77fe:	30 e0       	ldi	r19, 0x00	; 0
    7800:	03 c0       	rjmp	.+6      	; 0x7808 <command_OWread+0x10>
		return cmd_502(outbuffer);
    7802:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    7806:	9c 01       	movw	r18, r24
	}

	usart_write("\r\n");
	#endif
	return 0;
}
    7808:	c9 01       	movw	r24, r18
    780a:	08 95       	ret

0000780c <command_ADC>:
 * \ingroup usartcmdline
 * \b ADC-Befehl analoge Werte der AD-Wandler anzeigen
 */
int16_t command_ADC(char *outbuffer)
{
	if (outbuffer)					// nur bei USART
    780c:	00 97       	sbiw	r24, 0x00	; 0
    780e:	19 f4       	brne	.+6      	; 0x7816 <command_ADC+0xa>
    7810:	20 e0       	ldi	r18, 0x00	; 0
    7812:	30 e0       	ldi	r19, 0x00	; 0
    7814:	03 c0       	rjmp	.+6      	; 0x781c <command_ADC+0x10>
		return cmd_502(outbuffer);
    7816:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    781a:	9c 01       	movw	r18, r24
		usart_write("\r\nADC-Kanal(%i) = %i",i,var_array[i]);
	}
	usart_write("\r\n");
	#endif
	return 0;
}
    781c:	c9 01       	movw	r24, r18
    781e:	08 95       	ret

00007820 <command_wol>:
 * \ingroup usartcmdline
 * \b WOL-Befehl Wake-On-Lan Paket versenden
 */
int16_t command_wol (char *outbuffer)
{
	if (outbuffer)					// nur bei USART
    7820:	00 97       	sbiw	r24, 0x00	; 0
    7822:	19 f4       	brne	.+6      	; 0x782a <command_wol+0xa>
    7824:	20 e0       	ldi	r18, 0x00	; 0
    7826:	30 e0       	ldi	r19, 0x00	; 0
    7828:	03 c0       	rjmp	.+6      	; 0x7830 <command_wol+0x10>
		return cmd_502(outbuffer);
    782a:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    782e:	9c 01       	movw	r18, r24
		//MagicPacket senden
		wol_request();
	}
	#endif //USE_WOL	
	return 0;
}
    7830:	c9 01       	movw	r24, r18
    7832:	08 95       	ret

00007834 <command_tcp>:
/**
 * \ingroup usartcmdline
 * \b TCP-Befehl zeige TCP-Tabelle
 */
int16_t command_tcp (char *outbuffer)
{
    7834:	2f 92       	push	r2
    7836:	3f 92       	push	r3
    7838:	4f 92       	push	r4
    783a:	5f 92       	push	r5
    783c:	6f 92       	push	r6
    783e:	7f 92       	push	r7
    7840:	8f 92       	push	r8
    7842:	9f 92       	push	r9
    7844:	af 92       	push	r10
    7846:	bf 92       	push	r11
    7848:	cf 92       	push	r12
    784a:	df 92       	push	r13
    784c:	ef 92       	push	r14
    784e:	ff 92       	push	r15
    7850:	0f 93       	push	r16
    7852:	1f 93       	push	r17
    7854:	cf 93       	push	r28
    7856:	df 93       	push	r29
	if (outbuffer)					// momentan nur bei USART
    7858:	00 97       	sbiw	r24, 0x00	; 0
    785a:	21 f0       	breq	.+8      	; 0x7864 <command_tcp+0x30>
		return cmd_502(outbuffer);
    785c:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    7860:	9c 01       	movw	r18, r24
    7862:	d0 c0       	rjmp	.+416    	; 0x7a04 <command_tcp+0x1d0>
    7864:	c0 e0       	ldi	r28, 0x00	; 0
    7866:	d0 e0       	ldi	r29, 0x00	; 0

	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		usart_write("%2i",index);
		usart_write("  IP:%3i",(tcp_entry[index].ip&0x000000FF));
    7868:	f5 ed       	ldi	r31, 0xD5	; 213
    786a:	2f 2e       	mov	r2, r31
    786c:	f0 e2       	ldi	r31, 0x20	; 32
    786e:	3f 2e       	mov	r3, r31
		usart_write(".%3i",((tcp_entry[index].ip&0x0000FF00)>>8));
    7870:	e0 ed       	ldi	r30, 0xD0	; 208
    7872:	4e 2e       	mov	r4, r30
    7874:	e0 e2       	ldi	r30, 0x20	; 32
    7876:	5e 2e       	mov	r5, r30
		usart_write(".%3i",((tcp_entry[index].ip&0x00FF0000)>>16));
    7878:	7b ec       	ldi	r23, 0xCB	; 203
    787a:	67 2e       	mov	r6, r23
    787c:	70 e2       	ldi	r23, 0x20	; 32
    787e:	77 2e       	mov	r7, r23
		usart_write(".%3i",((tcp_entry[index].ip&0xFF000000)>>24));
    7880:	66 ec       	ldi	r22, 0xC6	; 198
    7882:	86 2e       	mov	r8, r22
    7884:	60 e2       	ldi	r22, 0x20	; 32
    7886:	96 2e       	mov	r9, r22
		usart_write(" SRC_PORT:%4i",HTONS(tcp_entry[index].src_port));
    7888:	58 eb       	ldi	r21, 0xB8	; 184
    788a:	a5 2e       	mov	r10, r21
    788c:	50 e2       	ldi	r21, 0x20	; 32
    788e:	b5 2e       	mov	r11, r21
		usart_write(" DEST_PORT:%4i",HTONS(tcp_entry[index].dest_port));
    7890:	49 ea       	ldi	r20, 0xA9	; 169
    7892:	c4 2e       	mov	r12, r20
    7894:	40 e2       	ldi	r20, 0x20	; 32
    7896:	d4 2e       	mov	r13, r20
		usart_write(" Time:%4i\r\n",tcp_entry[index].time);
    7898:	3d e9       	ldi	r19, 0x9D	; 157
    789a:	e3 2e       	mov	r14, r19
    789c:	30 e2       	ldi	r19, 0x20	; 32
    789e:	f3 2e       	mov	r15, r19
	if (outbuffer)					// momentan nur bei USART
		return cmd_502(outbuffer);

	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
	{
		usart_write("%2i",index);
    78a0:	00 d0       	rcall	.+0      	; 0x78a2 <command_tcp+0x6e>
    78a2:	00 d0       	rcall	.+0      	; 0x78a4 <command_tcp+0x70>
    78a4:	ee ed       	ldi	r30, 0xDE	; 222
    78a6:	f0 e2       	ldi	r31, 0x20	; 32
    78a8:	ad b7       	in	r26, 0x3d	; 61
    78aa:	be b7       	in	r27, 0x3e	; 62
    78ac:	12 96       	adiw	r26, 0x02	; 2
    78ae:	fc 93       	st	X, r31
    78b0:	ee 93       	st	-X, r30
    78b2:	11 97       	sbiw	r26, 0x01	; 1
    78b4:	14 96       	adiw	r26, 0x04	; 4
    78b6:	dc 93       	st	X, r29
    78b8:	ce 93       	st	-X, r28
    78ba:	13 97       	sbiw	r26, 0x03	; 3
    78bc:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write("  IP:%3i",(tcp_entry[index].ip&0x000000FF));
    78c0:	86 e1       	ldi	r24, 0x16	; 22
    78c2:	90 e0       	ldi	r25, 0x00	; 0
    78c4:	c8 9f       	mul	r28, r24
    78c6:	80 01       	movw	r16, r0
    78c8:	c9 9f       	mul	r28, r25
    78ca:	10 0d       	add	r17, r0
    78cc:	d8 9f       	mul	r29, r24
    78ce:	10 0d       	add	r17, r0
    78d0:	11 24       	eor	r1, r1
    78d2:	0c 5a       	subi	r16, 0xAC	; 172
    78d4:	14 4f       	sbci	r17, 0xF4	; 244
    78d6:	f8 01       	movw	r30, r16
    78d8:	80 81       	ld	r24, Z
    78da:	91 81       	ldd	r25, Z+1	; 0x01
    78dc:	a2 81       	ldd	r26, Z+2	; 0x02
    78de:	b3 81       	ldd	r27, Z+3	; 0x03
    78e0:	00 d0       	rcall	.+0      	; 0x78e2 <command_tcp+0xae>
    78e2:	ed b7       	in	r30, 0x3d	; 61
    78e4:	fe b7       	in	r31, 0x3e	; 62
    78e6:	32 82       	std	Z+2, r3	; 0x02
    78e8:	21 82       	std	Z+1, r2	; 0x01
    78ea:	90 70       	andi	r25, 0x00	; 0
    78ec:	a0 70       	andi	r26, 0x00	; 0
    78ee:	b0 70       	andi	r27, 0x00	; 0
    78f0:	83 83       	std	Z+3, r24	; 0x03
    78f2:	94 83       	std	Z+4, r25	; 0x04
    78f4:	a5 83       	std	Z+5, r26	; 0x05
    78f6:	b6 83       	std	Z+6, r27	; 0x06
    78f8:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((tcp_entry[index].ip&0x0000FF00)>>8));
    78fc:	f8 01       	movw	r30, r16
    78fe:	80 81       	ld	r24, Z
    7900:	91 81       	ldd	r25, Z+1	; 0x01
    7902:	a2 81       	ldd	r26, Z+2	; 0x02
    7904:	b3 81       	ldd	r27, Z+3	; 0x03
    7906:	ed b7       	in	r30, 0x3d	; 61
    7908:	fe b7       	in	r31, 0x3e	; 62
    790a:	52 82       	std	Z+2, r5	; 0x02
    790c:	41 82       	std	Z+1, r4	; 0x01
    790e:	89 2f       	mov	r24, r25
    7910:	90 e0       	ldi	r25, 0x00	; 0
    7912:	a0 e0       	ldi	r26, 0x00	; 0
    7914:	b0 e0       	ldi	r27, 0x00	; 0
    7916:	83 83       	std	Z+3, r24	; 0x03
    7918:	94 83       	std	Z+4, r25	; 0x04
    791a:	a5 83       	std	Z+5, r26	; 0x05
    791c:	b6 83       	std	Z+6, r27	; 0x06
    791e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((tcp_entry[index].ip&0x00FF0000)>>16));
    7922:	f8 01       	movw	r30, r16
    7924:	80 81       	ld	r24, Z
    7926:	91 81       	ldd	r25, Z+1	; 0x01
    7928:	a2 81       	ldd	r26, Z+2	; 0x02
    792a:	b3 81       	ldd	r27, Z+3	; 0x03
    792c:	ed b7       	in	r30, 0x3d	; 61
    792e:	fe b7       	in	r31, 0x3e	; 62
    7930:	72 82       	std	Z+2, r7	; 0x02
    7932:	61 82       	std	Z+1, r6	; 0x01
    7934:	8a 2f       	mov	r24, r26
    7936:	90 e0       	ldi	r25, 0x00	; 0
    7938:	a0 e0       	ldi	r26, 0x00	; 0
    793a:	b0 e0       	ldi	r27, 0x00	; 0
    793c:	83 83       	std	Z+3, r24	; 0x03
    793e:	94 83       	std	Z+4, r25	; 0x04
    7940:	a5 83       	std	Z+5, r26	; 0x05
    7942:	b6 83       	std	Z+6, r27	; 0x06
    7944:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((tcp_entry[index].ip&0xFF000000)>>24));
    7948:	f8 01       	movw	r30, r16
    794a:	80 81       	ld	r24, Z
    794c:	91 81       	ldd	r25, Z+1	; 0x01
    794e:	a2 81       	ldd	r26, Z+2	; 0x02
    7950:	b3 81       	ldd	r27, Z+3	; 0x03
    7952:	ed b7       	in	r30, 0x3d	; 61
    7954:	fe b7       	in	r31, 0x3e	; 62
    7956:	92 82       	std	Z+2, r9	; 0x02
    7958:	81 82       	std	Z+1, r8	; 0x01
    795a:	8b 2f       	mov	r24, r27
    795c:	99 27       	eor	r25, r25
    795e:	aa 27       	eor	r26, r26
    7960:	bb 27       	eor	r27, r27
    7962:	83 83       	std	Z+3, r24	; 0x03
    7964:	94 83       	std	Z+4, r25	; 0x04
    7966:	a5 83       	std	Z+5, r26	; 0x05
    7968:	b6 83       	std	Z+6, r27	; 0x06
    796a:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(" SRC_PORT:%4i",HTONS(tcp_entry[index].src_port));
    796e:	d8 01       	movw	r26, r16
    7970:	14 96       	adiw	r26, 0x04	; 4
    7972:	2d 91       	ld	r18, X+
    7974:	3c 91       	ld	r19, X
    7976:	15 97       	sbiw	r26, 0x05	; 5
    7978:	14 96       	adiw	r26, 0x04	; 4
    797a:	8d 91       	ld	r24, X+
    797c:	9c 91       	ld	r25, X
    797e:	15 97       	sbiw	r26, 0x05	; 5
    7980:	0f 90       	pop	r0
    7982:	0f 90       	pop	r0
    7984:	ed b7       	in	r30, 0x3d	; 61
    7986:	fe b7       	in	r31, 0x3e	; 62
    7988:	b2 82       	std	Z+2, r11	; 0x02
    798a:	a1 82       	std	Z+1, r10	; 0x01
    798c:	89 2f       	mov	r24, r25
    798e:	99 27       	eor	r25, r25
    7990:	32 2f       	mov	r19, r18
    7992:	22 27       	eor	r18, r18
    7994:	82 2b       	or	r24, r18
    7996:	93 2b       	or	r25, r19
    7998:	94 83       	std	Z+4, r25	; 0x04
    799a:	83 83       	std	Z+3, r24	; 0x03
    799c:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(" DEST_PORT:%4i",HTONS(tcp_entry[index].dest_port));
    79a0:	d8 01       	movw	r26, r16
    79a2:	16 96       	adiw	r26, 0x06	; 6
    79a4:	2d 91       	ld	r18, X+
    79a6:	3c 91       	ld	r19, X
    79a8:	17 97       	sbiw	r26, 0x07	; 7
    79aa:	16 96       	adiw	r26, 0x06	; 6
    79ac:	8d 91       	ld	r24, X+
    79ae:	9c 91       	ld	r25, X
    79b0:	17 97       	sbiw	r26, 0x07	; 7
    79b2:	ed b7       	in	r30, 0x3d	; 61
    79b4:	fe b7       	in	r31, 0x3e	; 62
    79b6:	d2 82       	std	Z+2, r13	; 0x02
    79b8:	c1 82       	std	Z+1, r12	; 0x01
    79ba:	89 2f       	mov	r24, r25
    79bc:	99 27       	eor	r25, r25
    79be:	32 2f       	mov	r19, r18
    79c0:	22 27       	eor	r18, r18
    79c2:	82 2b       	or	r24, r18
    79c4:	93 2b       	or	r25, r19
    79c6:	94 83       	std	Z+4, r25	; 0x04
    79c8:	83 83       	std	Z+3, r24	; 0x03
    79ca:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(" Time:%4i\r\n",tcp_entry[index].time);
    79ce:	d8 01       	movw	r26, r16
    79d0:	53 96       	adiw	r26, 0x13	; 19
    79d2:	8c 91       	ld	r24, X
    79d4:	ed b7       	in	r30, 0x3d	; 61
    79d6:	fe b7       	in	r31, 0x3e	; 62
    79d8:	31 96       	adiw	r30, 0x01	; 1
    79da:	ad b7       	in	r26, 0x3d	; 61
    79dc:	be b7       	in	r27, 0x3e	; 62
    79de:	12 96       	adiw	r26, 0x02	; 2
    79e0:	fc 92       	st	X, r15
    79e2:	ee 92       	st	-X, r14
    79e4:	11 97       	sbiw	r26, 0x01	; 1
    79e6:	82 83       	std	Z+2, r24	; 0x02
    79e8:	13 82       	std	Z+3, r1	; 0x03
    79ea:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    79ee:	21 96       	adiw	r28, 0x01	; 1
int16_t command_tcp (char *outbuffer)
{
	if (outbuffer)					// momentan nur bei USART
		return cmd_502(outbuffer);

	for (unsigned char index = 0;index<MAX_TCP_ENTRY;index++)
    79f0:	0f 90       	pop	r0
    79f2:	0f 90       	pop	r0
    79f4:	0f 90       	pop	r0
    79f6:	0f 90       	pop	r0
    79f8:	c5 30       	cpi	r28, 0x05	; 5
    79fa:	d1 05       	cpc	r29, r1
    79fc:	09 f0       	breq	.+2      	; 0x7a00 <command_tcp+0x1cc>
    79fe:	50 cf       	rjmp	.-352    	; 0x78a0 <command_tcp+0x6c>
    7a00:	20 e0       	ldi	r18, 0x00	; 0
    7a02:	30 e0       	ldi	r19, 0x00	; 0
		usart_write(" SRC_PORT:%4i",HTONS(tcp_entry[index].src_port));
		usart_write(" DEST_PORT:%4i",HTONS(tcp_entry[index].dest_port));
		usart_write(" Time:%4i\r\n",tcp_entry[index].time);
	}
	return 0;
}
    7a04:	c9 01       	movw	r24, r18
    7a06:	df 91       	pop	r29
    7a08:	cf 91       	pop	r28
    7a0a:	1f 91       	pop	r17
    7a0c:	0f 91       	pop	r16
    7a0e:	ff 90       	pop	r15
    7a10:	ef 90       	pop	r14
    7a12:	df 90       	pop	r13
    7a14:	cf 90       	pop	r12
    7a16:	bf 90       	pop	r11
    7a18:	af 90       	pop	r10
    7a1a:	9f 90       	pop	r9
    7a1c:	8f 90       	pop	r8
    7a1e:	7f 90       	pop	r7
    7a20:	6f 90       	pop	r6
    7a22:	5f 90       	pop	r5
    7a24:	4f 90       	pop	r4
    7a26:	3f 90       	pop	r3
    7a28:	2f 90       	pop	r2
    7a2a:	08 95       	ret

00007a2c <command_arp>:
/**
 * \ingroup usartcmdline
 * \b arp-Befehl zeige ARP-Tabelle
 */
int16_t command_arp (char *outbuffer)
{
    7a2c:	2f 92       	push	r2
    7a2e:	3f 92       	push	r3
    7a30:	4f 92       	push	r4
    7a32:	5f 92       	push	r5
    7a34:	6f 92       	push	r6
    7a36:	7f 92       	push	r7
    7a38:	8f 92       	push	r8
    7a3a:	9f 92       	push	r9
    7a3c:	af 92       	push	r10
    7a3e:	bf 92       	push	r11
    7a40:	cf 92       	push	r12
    7a42:	df 92       	push	r13
    7a44:	ef 92       	push	r14
    7a46:	ff 92       	push	r15
    7a48:	0f 93       	push	r16
    7a4a:	1f 93       	push	r17
    7a4c:	cf 93       	push	r28
    7a4e:	df 93       	push	r29
	if (outbuffer)					// momentan nur bei USART
    7a50:	00 97       	sbiw	r24, 0x00	; 0
    7a52:	21 f0       	breq	.+8      	; 0x7a5c <command_arp+0x30>
		return cmd_502(outbuffer);
    7a54:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    7a58:	9c 01       	movw	r18, r24
    7a5a:	01 c1       	rjmp	.+514    	; 0x7c5e <command_arp+0x232>
    7a5c:	c0 e0       	ldi	r28, 0x00	; 0
    7a5e:	d0 e0       	ldi	r29, 0x00	; 0
		usart_write("%2i  MAC:%2x",index,arp_entry[index].arp_t_mac[0]);
		usart_write(".%2x",arp_entry[index].arp_t_mac[1]);
		usart_write(".%2x",arp_entry[index].arp_t_mac[2]);
		usart_write(".%2x",arp_entry[index].arp_t_mac[3]);
		usart_write(".%2x",arp_entry[index].arp_t_mac[4]);
		usart_write(".%2x",arp_entry[index].arp_t_mac[5]);
    7a60:	a7 e0       	ldi	r26, 0x07	; 7
    7a62:	2a 2e       	mov	r2, r26
    7a64:	a1 e2       	ldi	r26, 0x21	; 33
    7a66:	3a 2e       	mov	r3, r26
		
		usart_write("  IP:%3i",(arp_entry[index].arp_t_ip&0x000000FF));
    7a68:	fe ef       	ldi	r31, 0xFE	; 254
    7a6a:	4f 2e       	mov	r4, r31
    7a6c:	f0 e2       	ldi	r31, 0x20	; 32
    7a6e:	5f 2e       	mov	r5, r31
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0x0000FF00)>>8));
    7a70:	e9 ef       	ldi	r30, 0xF9	; 249
    7a72:	6e 2e       	mov	r6, r30
    7a74:	e0 e2       	ldi	r30, 0x20	; 32
    7a76:	7e 2e       	mov	r7, r30
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0x00FF0000)>>16));
    7a78:	74 ef       	ldi	r23, 0xF4	; 244
    7a7a:	87 2e       	mov	r8, r23
    7a7c:	70 e2       	ldi	r23, 0x20	; 32
    7a7e:	97 2e       	mov	r9, r23
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0xFF000000)>>24));
    7a80:	6f ee       	ldi	r22, 0xEF	; 239
    7a82:	a6 2e       	mov	r10, r22
    7a84:	60 e2       	ldi	r22, 0x20	; 32
    7a86:	b6 2e       	mov	r11, r22
			
		usart_write("  Time:%4i\r\n",arp_entry[index].arp_t_time);
    7a88:	52 ee       	ldi	r21, 0xE2	; 226
    7a8a:	c5 2e       	mov	r12, r21
    7a8c:	50 e2       	ldi	r21, 0x20	; 32
    7a8e:	d5 2e       	mov	r13, r21
	if (outbuffer)					// momentan nur bei USART
		return cmd_502(outbuffer);

	for (unsigned char index = 0;index<MAX_ARP_ENTRY;index++)
	{
		usart_write("%2i  MAC:%2x",index,arp_entry[index].arp_t_mac[0]);
    7a90:	8e 01       	movw	r16, r28
    7a92:	00 0f       	add	r16, r16
    7a94:	11 1f       	adc	r17, r17
    7a96:	0c 0f       	add	r16, r28
    7a98:	1d 1f       	adc	r17, r29
    7a9a:	00 0f       	add	r16, r16
    7a9c:	11 1f       	adc	r17, r17
    7a9e:	00 0f       	add	r16, r16
    7aa0:	11 1f       	adc	r17, r17
    7aa2:	27 e0       	ldi	r18, 0x07	; 7
    7aa4:	e2 2e       	mov	r14, r18
    7aa6:	2b e0       	ldi	r18, 0x0B	; 11
    7aa8:	f2 2e       	mov	r15, r18
    7aaa:	e0 0e       	add	r14, r16
    7aac:	f1 1e       	adc	r15, r17
    7aae:	d7 01       	movw	r26, r14
    7ab0:	8c 91       	ld	r24, X
    7ab2:	00 d0       	rcall	.+0      	; 0x7ab4 <command_arp+0x88>
    7ab4:	00 d0       	rcall	.+0      	; 0x7ab6 <command_arp+0x8a>
    7ab6:	00 d0       	rcall	.+0      	; 0x7ab8 <command_arp+0x8c>
    7ab8:	ed b7       	in	r30, 0x3d	; 61
    7aba:	fe b7       	in	r31, 0x3e	; 62
    7abc:	31 96       	adiw	r30, 0x01	; 1
    7abe:	20 e2       	ldi	r18, 0x20	; 32
    7ac0:	31 e2       	ldi	r19, 0x21	; 33
    7ac2:	ad b7       	in	r26, 0x3d	; 61
    7ac4:	be b7       	in	r27, 0x3e	; 62
    7ac6:	12 96       	adiw	r26, 0x02	; 2
    7ac8:	3c 93       	st	X, r19
    7aca:	2e 93       	st	-X, r18
    7acc:	11 97       	sbiw	r26, 0x01	; 1
    7ace:	d3 83       	std	Z+3, r29	; 0x03
    7ad0:	c2 83       	std	Z+2, r28	; 0x02
    7ad2:	84 83       	std	Z+4, r24	; 0x04
    7ad4:	15 82       	std	Z+5, r1	; 0x05
    7ad6:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%2x",arp_entry[index].arp_t_mac[1]);
    7ada:	d7 01       	movw	r26, r14
    7adc:	11 96       	adiw	r26, 0x01	; 1
    7ade:	8c 91       	ld	r24, X
    7ae0:	0f 90       	pop	r0
    7ae2:	0f 90       	pop	r0
    7ae4:	ed b7       	in	r30, 0x3d	; 61
    7ae6:	fe b7       	in	r31, 0x3e	; 62
    7ae8:	31 96       	adiw	r30, 0x01	; 1
    7aea:	2b e1       	ldi	r18, 0x1B	; 27
    7aec:	31 e2       	ldi	r19, 0x21	; 33
    7aee:	ad b7       	in	r26, 0x3d	; 61
    7af0:	be b7       	in	r27, 0x3e	; 62
    7af2:	12 96       	adiw	r26, 0x02	; 2
    7af4:	3c 93       	st	X, r19
    7af6:	2e 93       	st	-X, r18
    7af8:	11 97       	sbiw	r26, 0x01	; 1
    7afa:	82 83       	std	Z+2, r24	; 0x02
    7afc:	13 82       	std	Z+3, r1	; 0x03
    7afe:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%2x",arp_entry[index].arp_t_mac[2]);
    7b02:	f8 01       	movw	r30, r16
    7b04:	e7 5f       	subi	r30, 0xF7	; 247
    7b06:	f4 4f       	sbci	r31, 0xF4	; 244
    7b08:	80 81       	ld	r24, Z
    7b0a:	ed b7       	in	r30, 0x3d	; 61
    7b0c:	fe b7       	in	r31, 0x3e	; 62
    7b0e:	31 96       	adiw	r30, 0x01	; 1
    7b10:	26 e1       	ldi	r18, 0x16	; 22
    7b12:	31 e2       	ldi	r19, 0x21	; 33
    7b14:	ad b7       	in	r26, 0x3d	; 61
    7b16:	be b7       	in	r27, 0x3e	; 62
    7b18:	12 96       	adiw	r26, 0x02	; 2
    7b1a:	3c 93       	st	X, r19
    7b1c:	2e 93       	st	-X, r18
    7b1e:	11 97       	sbiw	r26, 0x01	; 1
    7b20:	82 83       	std	Z+2, r24	; 0x02
    7b22:	13 82       	std	Z+3, r1	; 0x03
    7b24:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%2x",arp_entry[index].arp_t_mac[3]);
    7b28:	d7 01       	movw	r26, r14
    7b2a:	13 96       	adiw	r26, 0x03	; 3
    7b2c:	8c 91       	ld	r24, X
    7b2e:	ed b7       	in	r30, 0x3d	; 61
    7b30:	fe b7       	in	r31, 0x3e	; 62
    7b32:	31 96       	adiw	r30, 0x01	; 1
    7b34:	21 e1       	ldi	r18, 0x11	; 17
    7b36:	31 e2       	ldi	r19, 0x21	; 33
    7b38:	ad b7       	in	r26, 0x3d	; 61
    7b3a:	be b7       	in	r27, 0x3e	; 62
    7b3c:	12 96       	adiw	r26, 0x02	; 2
    7b3e:	3c 93       	st	X, r19
    7b40:	2e 93       	st	-X, r18
    7b42:	11 97       	sbiw	r26, 0x01	; 1
    7b44:	82 83       	std	Z+2, r24	; 0x02
    7b46:	13 82       	std	Z+3, r1	; 0x03
    7b48:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%2x",arp_entry[index].arp_t_mac[4]);
    7b4c:	05 5f       	subi	r16, 0xF5	; 245
    7b4e:	14 4f       	sbci	r17, 0xF4	; 244
    7b50:	d8 01       	movw	r26, r16
    7b52:	8c 91       	ld	r24, X
    7b54:	ed b7       	in	r30, 0x3d	; 61
    7b56:	fe b7       	in	r31, 0x3e	; 62
    7b58:	31 96       	adiw	r30, 0x01	; 1
    7b5a:	2c e0       	ldi	r18, 0x0C	; 12
    7b5c:	31 e2       	ldi	r19, 0x21	; 33
    7b5e:	ad b7       	in	r26, 0x3d	; 61
    7b60:	be b7       	in	r27, 0x3e	; 62
    7b62:	12 96       	adiw	r26, 0x02	; 2
    7b64:	3c 93       	st	X, r19
    7b66:	2e 93       	st	-X, r18
    7b68:	11 97       	sbiw	r26, 0x01	; 1
    7b6a:	82 83       	std	Z+2, r24	; 0x02
    7b6c:	13 82       	std	Z+3, r1	; 0x03
    7b6e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%2x",arp_entry[index].arp_t_mac[5]);
    7b72:	d7 01       	movw	r26, r14
    7b74:	15 96       	adiw	r26, 0x05	; 5
    7b76:	8c 91       	ld	r24, X
    7b78:	ed b7       	in	r30, 0x3d	; 61
    7b7a:	fe b7       	in	r31, 0x3e	; 62
    7b7c:	31 96       	adiw	r30, 0x01	; 1
    7b7e:	ad b7       	in	r26, 0x3d	; 61
    7b80:	be b7       	in	r27, 0x3e	; 62
    7b82:	12 96       	adiw	r26, 0x02	; 2
    7b84:	3c 92       	st	X, r3
    7b86:	2e 92       	st	-X, r2
    7b88:	11 97       	sbiw	r26, 0x01	; 1
    7b8a:	82 83       	std	Z+2, r24	; 0x02
    7b8c:	13 82       	std	Z+3, r1	; 0x03
    7b8e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		
		usart_write("  IP:%3i",(arp_entry[index].arp_t_ip&0x000000FF));
    7b92:	f7 01       	movw	r30, r14
    7b94:	86 81       	ldd	r24, Z+6	; 0x06
    7b96:	97 81       	ldd	r25, Z+7	; 0x07
    7b98:	a0 85       	ldd	r26, Z+8	; 0x08
    7b9a:	b1 85       	ldd	r27, Z+9	; 0x09
    7b9c:	00 d0       	rcall	.+0      	; 0x7b9e <command_arp+0x172>
    7b9e:	ed b7       	in	r30, 0x3d	; 61
    7ba0:	fe b7       	in	r31, 0x3e	; 62
    7ba2:	52 82       	std	Z+2, r5	; 0x02
    7ba4:	41 82       	std	Z+1, r4	; 0x01
    7ba6:	90 70       	andi	r25, 0x00	; 0
    7ba8:	a0 70       	andi	r26, 0x00	; 0
    7baa:	b0 70       	andi	r27, 0x00	; 0
    7bac:	83 83       	std	Z+3, r24	; 0x03
    7bae:	94 83       	std	Z+4, r25	; 0x04
    7bb0:	a5 83       	std	Z+5, r26	; 0x05
    7bb2:	b6 83       	std	Z+6, r27	; 0x06
    7bb4:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0x0000FF00)>>8));
    7bb8:	f7 01       	movw	r30, r14
    7bba:	86 81       	ldd	r24, Z+6	; 0x06
    7bbc:	97 81       	ldd	r25, Z+7	; 0x07
    7bbe:	a0 85       	ldd	r26, Z+8	; 0x08
    7bc0:	b1 85       	ldd	r27, Z+9	; 0x09
    7bc2:	ed b7       	in	r30, 0x3d	; 61
    7bc4:	fe b7       	in	r31, 0x3e	; 62
    7bc6:	72 82       	std	Z+2, r7	; 0x02
    7bc8:	61 82       	std	Z+1, r6	; 0x01
    7bca:	89 2f       	mov	r24, r25
    7bcc:	90 e0       	ldi	r25, 0x00	; 0
    7bce:	a0 e0       	ldi	r26, 0x00	; 0
    7bd0:	b0 e0       	ldi	r27, 0x00	; 0
    7bd2:	83 83       	std	Z+3, r24	; 0x03
    7bd4:	94 83       	std	Z+4, r25	; 0x04
    7bd6:	a5 83       	std	Z+5, r26	; 0x05
    7bd8:	b6 83       	std	Z+6, r27	; 0x06
    7bda:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0x00FF0000)>>16));
    7bde:	f7 01       	movw	r30, r14
    7be0:	86 81       	ldd	r24, Z+6	; 0x06
    7be2:	97 81       	ldd	r25, Z+7	; 0x07
    7be4:	a0 85       	ldd	r26, Z+8	; 0x08
    7be6:	b1 85       	ldd	r27, Z+9	; 0x09
    7be8:	ed b7       	in	r30, 0x3d	; 61
    7bea:	fe b7       	in	r31, 0x3e	; 62
    7bec:	92 82       	std	Z+2, r9	; 0x02
    7bee:	81 82       	std	Z+1, r8	; 0x01
    7bf0:	8a 2f       	mov	r24, r26
    7bf2:	90 e0       	ldi	r25, 0x00	; 0
    7bf4:	a0 e0       	ldi	r26, 0x00	; 0
    7bf6:	b0 e0       	ldi	r27, 0x00	; 0
    7bf8:	83 83       	std	Z+3, r24	; 0x03
    7bfa:	94 83       	std	Z+4, r25	; 0x04
    7bfc:	a5 83       	std	Z+5, r26	; 0x05
    7bfe:	b6 83       	std	Z+6, r27	; 0x06
    7c00:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0xFF000000)>>24));
    7c04:	f7 01       	movw	r30, r14
    7c06:	86 81       	ldd	r24, Z+6	; 0x06
    7c08:	97 81       	ldd	r25, Z+7	; 0x07
    7c0a:	a0 85       	ldd	r26, Z+8	; 0x08
    7c0c:	b1 85       	ldd	r27, Z+9	; 0x09
    7c0e:	ed b7       	in	r30, 0x3d	; 61
    7c10:	fe b7       	in	r31, 0x3e	; 62
    7c12:	b2 82       	std	Z+2, r11	; 0x02
    7c14:	a1 82       	std	Z+1, r10	; 0x01
    7c16:	8b 2f       	mov	r24, r27
    7c18:	99 27       	eor	r25, r25
    7c1a:	aa 27       	eor	r26, r26
    7c1c:	bb 27       	eor	r27, r27
    7c1e:	83 83       	std	Z+3, r24	; 0x03
    7c20:	94 83       	std	Z+4, r25	; 0x04
    7c22:	a5 83       	std	Z+5, r26	; 0x05
    7c24:	b6 83       	std	Z+6, r27	; 0x06
    7c26:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
			
		usart_write("  Time:%4i\r\n",arp_entry[index].arp_t_time);
    7c2a:	d7 01       	movw	r26, r14
    7c2c:	1a 96       	adiw	r26, 0x0a	; 10
    7c2e:	8d 91       	ld	r24, X+
    7c30:	9c 91       	ld	r25, X
    7c32:	1b 97       	sbiw	r26, 0x0b	; 11
    7c34:	0f 90       	pop	r0
    7c36:	0f 90       	pop	r0
    7c38:	ed b7       	in	r30, 0x3d	; 61
    7c3a:	fe b7       	in	r31, 0x3e	; 62
    7c3c:	d2 82       	std	Z+2, r13	; 0x02
    7c3e:	c1 82       	std	Z+1, r12	; 0x01
    7c40:	94 83       	std	Z+4, r25	; 0x04
    7c42:	83 83       	std	Z+3, r24	; 0x03
    7c44:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    7c48:	21 96       	adiw	r28, 0x01	; 1
int16_t command_arp (char *outbuffer)
{
	if (outbuffer)					// momentan nur bei USART
		return cmd_502(outbuffer);

	for (unsigned char index = 0;index<MAX_ARP_ENTRY;index++)
    7c4a:	0f 90       	pop	r0
    7c4c:	0f 90       	pop	r0
    7c4e:	0f 90       	pop	r0
    7c50:	0f 90       	pop	r0
    7c52:	c5 30       	cpi	r28, 0x05	; 5
    7c54:	d1 05       	cpc	r29, r1
    7c56:	09 f0       	breq	.+2      	; 0x7c5a <command_arp+0x22e>
    7c58:	1b cf       	rjmp	.-458    	; 0x7a90 <command_arp+0x64>
    7c5a:	20 e0       	ldi	r18, 0x00	; 0
    7c5c:	30 e0       	ldi	r19, 0x00	; 0
		usart_write(".%3i",((arp_entry[index].arp_t_ip&0xFF000000)>>24));
			
		usart_write("  Time:%4i\r\n",arp_entry[index].arp_t_time);
	}
	return 0;
}
    7c5e:	c9 01       	movw	r24, r18
    7c60:	df 91       	pop	r29
    7c62:	cf 91       	pop	r28
    7c64:	1f 91       	pop	r17
    7c66:	0f 91       	pop	r16
    7c68:	ff 90       	pop	r15
    7c6a:	ef 90       	pop	r14
    7c6c:	df 90       	pop	r13
    7c6e:	cf 90       	pop	r12
    7c70:	bf 90       	pop	r11
    7c72:	af 90       	pop	r10
    7c74:	9f 90       	pop	r9
    7c76:	8f 90       	pop	r8
    7c78:	7f 90       	pop	r7
    7c7a:	6f 90       	pop	r6
    7c7c:	5f 90       	pop	r5
    7c7e:	4f 90       	pop	r4
    7c80:	3f 90       	pop	r3
    7c82:	2f 90       	pop	r2
    7c84:	08 95       	ret

00007c86 <cmd_250>:
		return 0;
	}
}

int16_t cmd_250(char *outbuffer)
{
    7c86:	cf 93       	push	r28
    7c88:	df 93       	push	r29
    7c8a:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7c8c:	00 97       	sbiw	r24, 0x00	; 0
    7c8e:	19 f4       	brne	.+6      	; 0x7c96 <cmd_250+0x10>
    7c90:	a0 e0       	ldi	r26, 0x00	; 0
    7c92:	b0 e0       	ldi	r27, 0x00	; 0
    7c94:	0b c0       	rjmp	.+22     	; 0x7cac <cmd_250+0x26>
		strcpy_P(outbuffer,PSTR("250 ok.\r\n"));
    7c96:	63 e9       	ldi	r22, 0x93	; 147
    7c98:	7e e1       	ldi	r23, 0x1E	; 30
    7c9a:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7c9e:	de 01       	movw	r26, r28
    7ca0:	0d 90       	ld	r0, X+
    7ca2:	00 20       	and	r0, r0
    7ca4:	e9 f7       	brne	.-6      	; 0x7ca0 <cmd_250+0x1a>
    7ca6:	11 97       	sbiw	r26, 0x01	; 1
    7ca8:	ac 1b       	sub	r26, r28
    7caa:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    7cac:	cd 01       	movw	r24, r26
    7cae:	df 91       	pop	r29
    7cb0:	cf 91       	pop	r28
    7cb2:	08 95       	ret

00007cb4 <cmd_200>:
		return 0;
	}
}

int16_t cmd_200(char *outbuffer)
{
    7cb4:	cf 93       	push	r28
    7cb6:	df 93       	push	r29
    7cb8:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7cba:	00 97       	sbiw	r24, 0x00	; 0
    7cbc:	19 f4       	brne	.+6      	; 0x7cc4 <cmd_200+0x10>
    7cbe:	a0 e0       	ldi	r26, 0x00	; 0
    7cc0:	b0 e0       	ldi	r27, 0x00	; 0
    7cc2:	0b c0       	rjmp	.+22     	; 0x7cda <cmd_200+0x26>
		strcpy_P(outbuffer,PSTR("200 Command ok.\r\n"));
    7cc4:	6d e9       	ldi	r22, 0x9D	; 157
    7cc6:	7e e1       	ldi	r23, 0x1E	; 30
    7cc8:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7ccc:	de 01       	movw	r26, r28
    7cce:	0d 90       	ld	r0, X+
    7cd0:	00 20       	and	r0, r0
    7cd2:	e9 f7       	brne	.-6      	; 0x7cce <cmd_200+0x1a>
    7cd4:	11 97       	sbiw	r26, 0x01	; 1
    7cd6:	ac 1b       	sub	r26, r28
    7cd8:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    7cda:	cd 01       	movw	r24, r26
    7cdc:	df 91       	pop	r29
    7cde:	cf 91       	pop	r28
    7ce0:	08 95       	ret

00007ce2 <cmd_PASS>:
 * ber Statusflags frei/gesperrt geschaltet.
 * - bei USART passiert nichts.
 */
int16_t cmd_PASS(char *outbuffer)
{
	if (outbuffer) {
    7ce2:	00 97       	sbiw	r24, 0x00	; 0
    7ce4:	19 f4       	brne	.+6      	; 0x7cec <cmd_PASS+0xa>
    7ce6:	20 e0       	ldi	r18, 0x00	; 0
    7ce8:	30 e0       	ldi	r19, 0x00	; 0
    7cea:	03 c0       	rjmp	.+6      	; 0x7cf2 <cmd_PASS+0x10>
		#if FTP_ANONYMOUS
		return cmd_200(outbuffer);
    7cec:	0e 94 5a 3e 	call	0x7cb4	; 0x7cb4 <cmd_200>
    7cf0:	9c 01       	movw	r18, r24
		return strlen(outbuffer);
		#endif
	}

	return 0;	// bei USART
}
    7cf2:	c9 01       	movw	r24, r18
    7cf4:	08 95       	ret

00007cf6 <cmd_USER>:
 * - bei nicht anonymem Zugang wird mit "331 ..." Kennwort angefordert.
 * - bei USART passiert nichts.
 */
int16_t cmd_USER(char *outbuffer)
{
	if (outbuffer) {
    7cf6:	00 97       	sbiw	r24, 0x00	; 0
    7cf8:	19 f4       	brne	.+6      	; 0x7d00 <cmd_USER+0xa>
    7cfa:	20 e0       	ldi	r18, 0x00	; 0
    7cfc:	30 e0       	ldi	r19, 0x00	; 0
    7cfe:	03 c0       	rjmp	.+6      	; 0x7d06 <cmd_USER+0x10>
		#if FTP_ANONYMOUS
		return cmd_200(outbuffer);
    7d00:	0e 94 5a 3e 	call	0x7cb4	; 0x7cb4 <cmd_200>
    7d04:	9c 01       	movw	r18, r24
		return strlen(outbuffer);
		#endif
	}

	return 0;	// bei USART
}
    7d06:	c9 01       	movw	r24, r18
    7d08:	08 95       	ret

00007d0a <cmd_150>:
	return 0;	// bei USART
}

//------------------------------------------------------------------------------
int16_t cmd_150(char *outbuffer)
{
    7d0a:	cf 93       	push	r28
    7d0c:	df 93       	push	r29
    7d0e:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7d10:	00 97       	sbiw	r24, 0x00	; 0
    7d12:	19 f4       	brne	.+6      	; 0x7d1a <cmd_150+0x10>
    7d14:	a0 e0       	ldi	r26, 0x00	; 0
    7d16:	b0 e0       	ldi	r27, 0x00	; 0
    7d18:	14 c0       	rjmp	.+40     	; 0x7d42 <cmd_150+0x38>
	  #if !TCP_SERVICE
		return cmd_502(outbuffer);
	  #else
		if (tcpsrv_status.transfermode)
    7d1a:	80 91 70 0d 	lds	r24, 0x0D70
    7d1e:	86 ff       	sbrs	r24, 6
    7d20:	04 c0       	rjmp	.+8      	; 0x7d2a <cmd_150+0x20>
			strcpy_P(outbuffer,PSTR("150 Opening BINARY mode data connection.\r\n"));
    7d22:	ce 01       	movw	r24, r28
    7d24:	69 ed       	ldi	r22, 0xD9	; 217
    7d26:	7e e1       	ldi	r23, 0x1E	; 30
    7d28:	03 c0       	rjmp	.+6      	; 0x7d30 <cmd_150+0x26>
		else
			strcpy_P(outbuffer,PSTR("150 Opening ASCII mode data connection.\r\n"));
    7d2a:	ce 01       	movw	r24, r28
    7d2c:	6f ea       	ldi	r22, 0xAF	; 175
    7d2e:	7e e1       	ldi	r23, 0x1E	; 30
    7d30:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen(outbuffer);
    7d34:	de 01       	movw	r26, r28
    7d36:	0d 90       	ld	r0, X+
    7d38:	00 20       	and	r0, r0
    7d3a:	e9 f7       	brne	.-6      	; 0x7d36 <cmd_150+0x2c>
    7d3c:	11 97       	sbiw	r26, 0x01	; 1
    7d3e:	ac 1b       	sub	r26, r28
    7d40:	bd 0b       	sbc	r27, r29
	  #endif
	}
	else {
		return 0;
	}
}
    7d42:	cd 01       	movw	r24, r26
    7d44:	df 91       	pop	r29
    7d46:	cf 91       	pop	r28
    7d48:	08 95       	ret

00007d4a <cmd_LIST>:
 * \b LIST-Befehl Verzeichnisanzeige bei FTP
 *
 * initialisiert die Verzeichnisanzeige im FTP-Datenkanal
 */
int16_t cmd_LIST(char *outbuffer)
{
    7d4a:	9c 01       	movw	r18, r24
	if (outbuffer) {
    7d4c:	00 97       	sbiw	r24, 0x00	; 0
    7d4e:	19 f4       	brne	.+6      	; 0x7d56 <cmd_LIST+0xc>
    7d50:	20 e0       	ldi	r18, 0x00	; 0
    7d52:	30 e0       	ldi	r19, 0x00	; 0
    7d54:	0f c0       	rjmp	.+30     	; 0x7d74 <cmd_LIST+0x2a>
		#if !FTP_ANONYMOUS
		if (!tcpsrv_status.loginOK)
			return cmd_530(outbuffer);
		#endif

		tcpsrv_status.data_state = 1;
    7d56:	80 91 70 0d 	lds	r24, 0x0D70
    7d5a:	8f 7c       	andi	r24, 0xCF	; 207
    7d5c:	80 61       	ori	r24, 0x10	; 16
    7d5e:	80 93 70 0d 	sts	0x0D70, r24
		tcpsrv_status.LISTcontinue = 0; 	// reset Listing
    7d62:	80 91 71 0d 	lds	r24, 0x0D71
    7d66:	8d 7f       	andi	r24, 0xFD	; 253
    7d68:	80 93 71 0d 	sts	0x0D71, r24
		// Anfang der bertragung
		return cmd_150(outbuffer);
    7d6c:	c9 01       	movw	r24, r18
    7d6e:	0e 94 85 3e 	call	0x7d0a	; 0x7d0a <cmd_150>
    7d72:	9c 01       	movw	r18, r24
	  #else
		return cmd_502(outbuffer);
	  #endif
	}
	return 0;
}
    7d74:	c9 01       	movw	r24, r18
    7d76:	08 95       	ret

00007d78 <cmd_TYPE>:
 * intern gibt es keinen Unterschied ob biner oder als ASCII bertragen
 * wird, da wir auf einer 8-bit Maschine arbeiten und die bertragung
 * auch 8-bitig abluft. Also kein Grund fr Konvertierungen.
 */
int16_t cmd_TYPE(char *outbuffer)
{
    7d78:	cf 93       	push	r28
    7d7a:	df 93       	push	r29
    7d7c:	ec 01       	movw	r28, r24
#if !TCP_SERVICE
	return cmd_502(outbuffer);
#else
	if (outbuffer) {
    7d7e:	00 97       	sbiw	r24, 0x00	; 0
    7d80:	19 f4       	brne	.+6      	; 0x7d88 <cmd_TYPE+0x10>
    7d82:	a0 e0       	ldi	r26, 0x00	; 0
    7d84:	b0 e0       	ldi	r27, 0x00	; 0
    7d86:	21 c0       	rjmp	.+66     	; 0x7dca <cmd_TYPE+0x52>
		if (*argv == 'I') {
    7d88:	e0 91 6e 0d 	lds	r30, 0x0D6E
    7d8c:	f0 91 6f 0d 	lds	r31, 0x0D6F
    7d90:	80 81       	ld	r24, Z
    7d92:	89 34       	cpi	r24, 0x49	; 73
    7d94:	49 f4       	brne	.+18     	; 0x7da8 <cmd_TYPE+0x30>
			strcpy_P(outbuffer,PSTR("200 Using BINARY mode to transfer data.\r\n"));
    7d96:	ce 01       	movw	r24, r28
    7d98:	6d e2       	ldi	r22, 0x2D	; 45
    7d9a:	7f e1       	ldi	r23, 0x1F	; 31
    7d9c:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
			tcpsrv_status.transfermode = 1;
    7da0:	80 91 70 0d 	lds	r24, 0x0D70
    7da4:	80 64       	ori	r24, 0x40	; 64
    7da6:	08 c0       	rjmp	.+16     	; 0x7db8 <cmd_TYPE+0x40>
		}
		else {
			strcpy_P(outbuffer,PSTR("200 Using ASCII mode to transfer data.\r\n"));
    7da8:	ce 01       	movw	r24, r28
    7daa:	64 e0       	ldi	r22, 0x04	; 4
    7dac:	7f e1       	ldi	r23, 0x1F	; 31
    7dae:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
			tcpsrv_status.transfermode = 0;
    7db2:	80 91 70 0d 	lds	r24, 0x0D70
    7db6:	8f 7b       	andi	r24, 0xBF	; 191
    7db8:	80 93 70 0d 	sts	0x0D70, r24
		}
		return strlen(outbuffer);
    7dbc:	de 01       	movw	r26, r28
    7dbe:	0d 90       	ld	r0, X+
    7dc0:	00 20       	and	r0, r0
    7dc2:	e9 f7       	brne	.-6      	; 0x7dbe <cmd_TYPE+0x46>
    7dc4:	11 97       	sbiw	r26, 0x01	; 1
    7dc6:	ac 1b       	sub	r26, r28
    7dc8:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
#endif
}
    7dca:	cd 01       	movw	r24, r26
    7dcc:	df 91       	pop	r29
    7dce:	cf 91       	pop	r28
    7dd0:	08 95       	ret

00007dd2 <cmd_SYST>:
 * \b Ausgabe:
 * - Falls UNIX_LIST definiert ist "215 UNIX"
 * - Falls DOS_LIST definiert ist  "215 DOS"
 */
int16_t cmd_SYST(char *outbuffer)
{
    7dd2:	cf 93       	push	r28
    7dd4:	df 93       	push	r29
    7dd6:	ec 01       	movw	r28, r24
	if (outbuffer) {
    7dd8:	00 97       	sbiw	r24, 0x00	; 0
    7dda:	19 f4       	brne	.+6      	; 0x7de2 <cmd_SYST+0x10>
    7ddc:	a0 e0       	ldi	r26, 0x00	; 0
    7dde:	b0 e0       	ldi	r27, 0x00	; 0
    7de0:	0b c0       	rjmp	.+22     	; 0x7df8 <cmd_SYST+0x26>
#ifdef UNIX_LIST
		strcpy_P(outbuffer,PSTR("215 UNIX\r\n"));
#endif
#ifdef DOS_LIST
		strcpy_P(outbuffer,PSTR("215 DOS\r\n"));	//215 Windows_NT
    7de2:	69 e2       	ldi	r22, 0x29	; 41
    7de4:	70 e2       	ldi	r23, 0x20	; 32
    7de6:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
#endif
		return strlen(outbuffer);
    7dea:	de 01       	movw	r26, r28
    7dec:	0d 90       	ld	r0, X+
    7dee:	00 20       	and	r0, r0
    7df0:	e9 f7       	brne	.-6      	; 0x7dec <cmd_SYST+0x1a>
    7df2:	11 97       	sbiw	r26, 0x01	; 1
    7df4:	ac 1b       	sub	r26, r28
    7df6:	bd 0b       	sbc	r27, r29
	}
	else {
		return 0;
	}
}
    7df8:	cd 01       	movw	r24, r26
    7dfa:	df 91       	pop	r29
    7dfc:	cf 91       	pop	r28
    7dfe:	08 95       	ret

00007e00 <cmd_CDUP>:
 *	\b CDUP-Befehl
 *
 *	ein Verzeichnis in der Hierarchie nach oben wechseln
*/
int16_t cmd_CDUP(char *outbuffer)
{
    7e00:	cf 92       	push	r12
    7e02:	df 92       	push	r13
    7e04:	ef 92       	push	r14
    7e06:	ff 92       	push	r15
    7e08:	0f 93       	push	r16
    7e0a:	1f 93       	push	r17
    7e0c:	df 93       	push	r29
    7e0e:	cf 93       	push	r28
    7e10:	cd b7       	in	r28, 0x3d	; 61
    7e12:	de b7       	in	r29, 0x3e	; 62
    7e14:	af 97       	sbiw	r28, 0x2f	; 47
    7e16:	0f b6       	in	r0, 0x3f	; 63
    7e18:	f8 94       	cli
    7e1a:	de bf       	out	0x3e, r29	; 62
    7e1c:	0f be       	out	0x3f, r0	; 63
    7e1e:	cd bf       	out	0x3d, r28	; 61
    7e20:	6c 01       	movw	r12, r24
	if (outbuffer && !tcpsrv_status.loginOK)
		return cmd_530(outbuffer);
	#endif

	// ein Verzeichnis nach oben
	int8_t i = strlen(cwdirectory) - 1;
    7e22:	e8 e7       	ldi	r30, 0x78	; 120
    7e24:	f1 e0       	ldi	r31, 0x01	; 1
    7e26:	01 90       	ld	r0, Z+
    7e28:	00 20       	and	r0, r0
    7e2a:	e9 f7       	brne	.-6      	; 0x7e26 <cmd_CDUP+0x26>
    7e2c:	31 97       	sbiw	r30, 0x01	; 1
    7e2e:	e8 57       	subi	r30, 0x78	; 120
    7e30:	f1 40       	sbci	r31, 0x01	; 1
    7e32:	4e 2f       	mov	r20, r30
    7e34:	41 50       	subi	r20, 0x01	; 1
    7e36:	a4 2f       	mov	r26, r20
    7e38:	bb 27       	eor	r27, r27
    7e3a:	a7 fd       	sbrc	r26, 7
    7e3c:	b0 95       	com	r27
    7e3e:	a8 58       	subi	r26, 0x88	; 136
    7e40:	be 4f       	sbci	r27, 0xFE	; 254
    7e42:	20 e0       	ldi	r18, 0x00	; 0
    7e44:	30 e0       	ldi	r19, 0x00	; 0
    7e46:	0b c0       	rjmp	.+22     	; 0x7e5e <cmd_CDUP+0x5e>
	char *pdir = (char *)cwdirectory;

	for (;i>=0;--i) {
    7e48:	fd 01       	movw	r30, r26
		if (*(pdir+i) == '/') {
    7e4a:	8c 91       	ld	r24, X
    7e4c:	2f 5f       	subi	r18, 0xFF	; 255
    7e4e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e50:	11 97       	sbiw	r26, 0x01	; 1
    7e52:	8f 32       	cpi	r24, 0x2F	; 47
    7e54:	21 f4       	brne	.+8      	; 0x7e5e <cmd_CDUP+0x5e>
			*(pdir+i) = '\0';
    7e56:	10 82       	st	Z, r1
			break;
		}
	}

	if (i <= 0) {
    7e58:	19 16       	cp	r1, r25
    7e5a:	5c f0       	brlt	.+22     	; 0x7e72 <cmd_CDUP+0x72>
    7e5c:	04 c0       	rjmp	.+8      	; 0x7e66 <cmd_CDUP+0x66>
    7e5e:	94 2f       	mov	r25, r20
    7e60:	92 1b       	sub	r25, r18

	// ein Verzeichnis nach oben
	int8_t i = strlen(cwdirectory) - 1;
	char *pdir = (char *)cwdirectory;

	for (;i>=0;--i) {
    7e62:	97 ff       	sbrs	r25, 7
    7e64:	f1 cf       	rjmp	.-30     	; 0x7e48 <cmd_CDUP+0x48>
			break;
		}
	}

	if (i <= 0) {
		strcpy_P((char *)cwdirectory,PSTR("/"));	// oben angekommen
    7e66:	88 e7       	ldi	r24, 0x78	; 120
    7e68:	91 e0       	ldi	r25, 0x01	; 1
    7e6a:	65 e7       	ldi	r22, 0x75	; 117
    7e6c:	7f e1       	ldi	r23, 0x1F	; 31
    7e6e:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
	}

	// Zeiger aktualisieren
    struct fat16_dir_entry_struct directory;
	if (fat16_get_dir_entry_of_path(sd_get_fs(), cwdirectory, &directory)) {
    7e72:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    7e76:	68 e7       	ldi	r22, 0x78	; 120
    7e78:	71 e0       	ldi	r23, 0x01	; 1
    7e7a:	7e 01       	movw	r14, r28
    7e7c:	08 94       	sec
    7e7e:	e1 1c       	adc	r14, r1
    7e80:	f1 1c       	adc	r15, r1
    7e82:	a7 01       	movw	r20, r14
    7e84:	0e 94 12 5e 	call	0xbc24	; 0xbc24 <fat16_get_dir_entry_of_path>
    7e88:	88 23       	and	r24, r24
    7e8a:	d9 f0       	breq	.+54     	; 0x7ec2 <cmd_CDUP+0xc2>
		struct fat16_dir_struct* dir_new = fat16_open_dir(sd_get_fs(), &directory);
    7e8c:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    7e90:	b7 01       	movw	r22, r14
    7e92:	0e 94 91 5d 	call	0xbb22	; 0xbb22 <fat16_open_dir>
    7e96:	7c 01       	movw	r14, r24
		if(dir_new) {
    7e98:	00 97       	sbiw	r24, 0x00	; 0
    7e9a:	99 f0       	breq	.+38     	; 0x7ec2 <cmd_CDUP+0xc2>
			if(cwdir_ptr != sd_get_root_dir())
    7e9c:	00 91 cb 0d 	lds	r16, 0x0DCB
    7ea0:	10 91 cc 0d 	lds	r17, 0x0DCC
    7ea4:	0e 94 a8 5e 	call	0xbd50	; 0xbd50 <sd_get_root_dir>
    7ea8:	08 17       	cp	r16, r24
    7eaa:	19 07       	cpc	r17, r25
    7eac:	31 f0       	breq	.+12     	; 0x7eba <cmd_CDUP+0xba>
				fat16_close_dir(cwdir_ptr);
    7eae:	80 91 cb 0d 	lds	r24, 0x0DCB
    7eb2:	90 91 cc 0d 	lds	r25, 0x0DCC
    7eb6:	0e 94 ec 50 	call	0xa1d8	; 0xa1d8 <fat16_close_dir>
			cwdir_ptr = dir_new;
    7eba:	f0 92 cc 0d 	sts	0x0DCC, r15
    7ebe:	e0 92 cb 0d 	sts	0x0DCB, r14
		}
	}

	if (outbuffer) {
    7ec2:	c1 14       	cp	r12, r1
    7ec4:	d1 04       	cpc	r13, r1
    7ec6:	19 f4       	brne	.+6      	; 0x7ece <cmd_CDUP+0xce>
    7ec8:	a0 e0       	ldi	r26, 0x00	; 0
    7eca:	b0 e0       	ldi	r27, 0x00	; 0
    7ecc:	25 c0       	rjmp	.+74     	; 0x7f18 <cmd_CDUP+0x118>
		sprintf_P(outbuffer,PSTR("250 Directory changed to %s\r\n"),cwdirectory);
    7ece:	00 d0       	rcall	.+0      	; 0x7ed0 <cmd_CDUP+0xd0>
    7ed0:	00 d0       	rcall	.+0      	; 0x7ed2 <cmd_CDUP+0xd2>
    7ed2:	00 d0       	rcall	.+0      	; 0x7ed4 <cmd_CDUP+0xd4>
    7ed4:	ed b7       	in	r30, 0x3d	; 61
    7ed6:	fe b7       	in	r31, 0x3e	; 62
    7ed8:	31 96       	adiw	r30, 0x01	; 1
    7eda:	ad b7       	in	r26, 0x3d	; 61
    7edc:	be b7       	in	r27, 0x3e	; 62
    7ede:	12 96       	adiw	r26, 0x02	; 2
    7ee0:	dc 92       	st	X, r13
    7ee2:	ce 92       	st	-X, r12
    7ee4:	11 97       	sbiw	r26, 0x01	; 1
    7ee6:	87 e5       	ldi	r24, 0x57	; 87
    7ee8:	9f e1       	ldi	r25, 0x1F	; 31
    7eea:	93 83       	std	Z+3, r25	; 0x03
    7eec:	82 83       	std	Z+2, r24	; 0x02
    7eee:	88 e7       	ldi	r24, 0x78	; 120
    7ef0:	91 e0       	ldi	r25, 0x01	; 1
    7ef2:	95 83       	std	Z+5, r25	; 0x05
    7ef4:	84 83       	std	Z+4, r24	; 0x04
    7ef6:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    7efa:	d6 01       	movw	r26, r12
    7efc:	0d 90       	ld	r0, X+
    7efe:	00 20       	and	r0, r0
    7f00:	e9 f7       	brne	.-6      	; 0x7efc <cmd_CDUP+0xfc>
    7f02:	11 97       	sbiw	r26, 0x01	; 1
    7f04:	ac 19       	sub	r26, r12
    7f06:	bd 09       	sbc	r27, r13
    7f08:	8d b7       	in	r24, 0x3d	; 61
    7f0a:	9e b7       	in	r25, 0x3e	; 62
    7f0c:	06 96       	adiw	r24, 0x06	; 6
    7f0e:	0f b6       	in	r0, 0x3f	; 63
    7f10:	f8 94       	cli
    7f12:	9e bf       	out	0x3e, r25	; 62
    7f14:	0f be       	out	0x3f, r0	; 63
    7f16:	8d bf       	out	0x3d, r24	; 61
	}
	else {
		return 0;
	}
#endif
}
    7f18:	cd 01       	movw	r24, r26
    7f1a:	af 96       	adiw	r28, 0x2f	; 47
    7f1c:	0f b6       	in	r0, 0x3f	; 63
    7f1e:	f8 94       	cli
    7f20:	de bf       	out	0x3e, r29	; 62
    7f22:	0f be       	out	0x3f, r0	; 63
    7f24:	cd bf       	out	0x3d, r28	; 61
    7f26:	cf 91       	pop	r28
    7f28:	df 91       	pop	r29
    7f2a:	1f 91       	pop	r17
    7f2c:	0f 91       	pop	r16
    7f2e:	ff 90       	pop	r15
    7f30:	ef 90       	pop	r14
    7f32:	df 90       	pop	r13
    7f34:	cf 90       	pop	r12
    7f36:	08 95       	ret

00007f38 <cmd_CWD>:
 *  \remarks
 *	cwdirectory enthlt den aktuellen Pfad ohne trailing "/"
 *	nur das Rootverzeichnis enthlt "/"
*/
int16_t cmd_CWD(char *outbuffer)
{
    7f38:	cf 92       	push	r12
    7f3a:	df 92       	push	r13
    7f3c:	ef 92       	push	r14
    7f3e:	ff 92       	push	r15
    7f40:	0f 93       	push	r16
    7f42:	1f 93       	push	r17
    7f44:	df 93       	push	r29
    7f46:	cf 93       	push	r28
    7f48:	cd b7       	in	r28, 0x3d	; 61
    7f4a:	de b7       	in	r29, 0x3e	; 62
    7f4c:	cf 56       	subi	r28, 0x6F	; 111
    7f4e:	d0 40       	sbci	r29, 0x00	; 0
    7f50:	0f b6       	in	r0, 0x3f	; 63
    7f52:	f8 94       	cli
    7f54:	de bf       	out	0x3e, r29	; 62
    7f56:	0f be       	out	0x3f, r0	; 63
    7f58:	cd bf       	out	0x3d, r28	; 61
    7f5a:	6c 01       	movw	r12, r24
		return cmd_530(outbuffer);
	#endif

	char tmpdir[MAX_PATH+1];

	if (*argv != '/') {								// bei aktuellem directory beginnen
    7f5c:	20 91 6e 0d 	lds	r18, 0x0D6E
    7f60:	30 91 6f 0d 	lds	r19, 0x0D6F
    7f64:	d9 01       	movw	r26, r18
    7f66:	8c 91       	ld	r24, X
    7f68:	8f 32       	cpi	r24, 0x2F	; 47
    7f6a:	09 f4       	brne	.+2      	; 0x7f6e <cmd_CWD+0x36>
    7f6c:	b1 c0       	rjmp	.+354    	; 0x80d0 <cmd_CWD+0x198>

		strcpy(tmpdir,cwdirectory);
    7f6e:	ce 01       	movw	r24, r28
    7f70:	c0 96       	adiw	r24, 0x30	; 48
    7f72:	68 e7       	ldi	r22, 0x78	; 120
    7f74:	71 e0       	ldi	r23, 0x01	; 1
    7f76:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <strcpy>

		if ((strlen(argv) == 2) && *argv == '.' && *(argv+1) == '.') {
    7f7a:	20 91 6e 0d 	lds	r18, 0x0D6E
    7f7e:	30 91 6f 0d 	lds	r19, 0x0D6F
    7f82:	f9 01       	movw	r30, r18
    7f84:	01 90       	ld	r0, Z+
    7f86:	00 20       	and	r0, r0
    7f88:	e9 f7       	brne	.-6      	; 0x7f84 <cmd_CWD+0x4c>
    7f8a:	33 97       	sbiw	r30, 0x03	; 3
    7f8c:	e2 17       	cp	r30, r18
    7f8e:	f3 07       	cpc	r31, r19
    7f90:	d9 f5       	brne	.+118    	; 0x8008 <cmd_CWD+0xd0>
    7f92:	f9 01       	movw	r30, r18
    7f94:	80 81       	ld	r24, Z
    7f96:	8e 32       	cpi	r24, 0x2E	; 46
    7f98:	b9 f5       	brne	.+110    	; 0x8008 <cmd_CWD+0xd0>
    7f9a:	81 81       	ldd	r24, Z+1	; 0x01
    7f9c:	8e 32       	cpi	r24, 0x2E	; 46
    7f9e:	a1 f5       	brne	.+104    	; 0x8008 <cmd_CWD+0xd0>
			strcat_P(argv,PSTR("/"));
    7fa0:	c9 01       	movw	r24, r18
    7fa2:	67 e9       	ldi	r22, 0x97	; 151
    7fa4:	7f e1       	ldi	r23, 0x1F	; 31
    7fa6:	0e 94 d4 6d 	call	0xdba8	; 0xdba8 <strcat_P>
    7faa:	2e c0       	rjmp	.+92     	; 0x8008 <cmd_CWD+0xd0>
		}

		while ((strlen(argv) > 2) && *argv == '.' && *(argv+1) == '.' && *(argv+2) == '/') {
			// ein Verzeichnis nach oben
			int8_t i = strlen(tmpdir) - 1;
    7fac:	f8 01       	movw	r30, r16
    7fae:	01 90       	ld	r0, Z+
    7fb0:	00 20       	and	r0, r0
    7fb2:	e9 f7       	brne	.-6      	; 0x7fae <cmd_CWD+0x76>
    7fb4:	6e 2f       	mov	r22, r30
    7fb6:	60 1b       	sub	r22, r16
    7fb8:	62 50       	subi	r22, 0x02	; 2
    7fba:	86 2f       	mov	r24, r22
    7fbc:	99 27       	eor	r25, r25
    7fbe:	87 fd       	sbrc	r24, 7
    7fc0:	90 95       	com	r25
    7fc2:	f8 01       	movw	r30, r16
    7fc4:	e8 0f       	add	r30, r24
    7fc6:	f9 1f       	adc	r31, r25
    7fc8:	40 e0       	ldi	r20, 0x00	; 0
    7fca:	50 e0       	ldi	r21, 0x00	; 0

			for (;i>=0;--i) {
    7fcc:	7c 01       	movw	r14, r24
    7fce:	0f c0       	rjmp	.+30     	; 0x7fee <cmd_CWD+0xb6>
    7fd0:	d7 01       	movw	r26, r14
    7fd2:	a4 1b       	sub	r26, r20
    7fd4:	b5 0b       	sbc	r27, r21
				if (tmpdir[i] == '/') {
    7fd6:	80 81       	ld	r24, Z
    7fd8:	4f 5f       	subi	r20, 0xFF	; 255
    7fda:	5f 4f       	sbci	r21, 0xFF	; 255
    7fdc:	31 97       	sbiw	r30, 0x01	; 1
    7fde:	8f 32       	cpi	r24, 0x2F	; 47
    7fe0:	31 f4       	brne	.+12     	; 0x7fee <cmd_CWD+0xb6>
					tmpdir[i] = '\0';
    7fe2:	a0 0f       	add	r26, r16
    7fe4:	b1 1f       	adc	r27, r17
    7fe6:	1c 92       	st	X, r1
					break;
				}
			}

			if (i <= 0) {
    7fe8:	19 16       	cp	r1, r25
    7fea:	3c f0       	brlt	.+14     	; 0x7ffa <cmd_CWD+0xc2>
    7fec:	04 c0       	rjmp	.+8      	; 0x7ff6 <cmd_CWD+0xbe>
    7fee:	96 2f       	mov	r25, r22
    7ff0:	94 1b       	sub	r25, r20

		while ((strlen(argv) > 2) && *argv == '.' && *(argv+1) == '.' && *(argv+2) == '/') {
			// ein Verzeichnis nach oben
			int8_t i = strlen(tmpdir) - 1;

			for (;i>=0;--i) {
    7ff2:	97 ff       	sbrs	r25, 7
    7ff4:	ed cf       	rjmp	.-38     	; 0x7fd0 <cmd_CWD+0x98>
					break;
				}
			}

			if (i <= 0) {
				tmpdir[0] = '/';	// oben angekommen
    7ff6:	78 ab       	std	Y+48, r23	; 0x30
				tmpdir[1] = '\0';
    7ff8:	19 aa       	std	Y+49, r1	; 0x31
			}

			argv += 3;
    7ffa:	2d 5f       	subi	r18, 0xFD	; 253
    7ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    7ffe:	30 93 6f 0d 	sts	0x0D6F, r19
    8002:	20 93 6e 0d 	sts	0x0D6E, r18
    8006:	04 c0       	rjmp	.+8      	; 0x8010 <cmd_CWD+0xd8>
			strcat_P(argv,PSTR("/"));
		}

		while ((strlen(argv) > 2) && *argv == '.' && *(argv+1) == '.' && *(argv+2) == '/') {
			// ein Verzeichnis nach oben
			int8_t i = strlen(tmpdir) - 1;
    8008:	8e 01       	movw	r16, r28
    800a:	00 5d       	subi	r16, 0xD0	; 208
    800c:	1f 4f       	sbci	r17, 0xFF	; 255
					break;
				}
			}

			if (i <= 0) {
				tmpdir[0] = '/';	// oben angekommen
    800e:	7f e2       	ldi	r23, 0x2F	; 47

		if ((strlen(argv) == 2) && *argv == '.' && *(argv+1) == '.') {
			strcat_P(argv,PSTR("/"));
		}

		while ((strlen(argv) > 2) && *argv == '.' && *(argv+1) == '.' && *(argv+2) == '/') {
    8010:	20 91 6e 0d 	lds	r18, 0x0D6E
    8014:	30 91 6f 0d 	lds	r19, 0x0D6F
    8018:	f9 01       	movw	r30, r18
    801a:	01 90       	ld	r0, Z+
    801c:	00 20       	and	r0, r0
    801e:	e9 f7       	brne	.-6      	; 0x801a <cmd_CWD+0xe2>
    8020:	31 97       	sbiw	r30, 0x01	; 1
    8022:	e2 1b       	sub	r30, r18
    8024:	f3 0b       	sbc	r31, r19
    8026:	33 97       	sbiw	r30, 0x03	; 3
    8028:	70 f0       	brcs	.+28     	; 0x8046 <cmd_CWD+0x10e>
    802a:	d9 01       	movw	r26, r18
    802c:	8c 91       	ld	r24, X
    802e:	8e 32       	cpi	r24, 0x2E	; 46
    8030:	51 f4       	brne	.+20     	; 0x8046 <cmd_CWD+0x10e>
    8032:	11 96       	adiw	r26, 0x01	; 1
    8034:	8c 91       	ld	r24, X
    8036:	11 97       	sbiw	r26, 0x01	; 1
    8038:	8e 32       	cpi	r24, 0x2E	; 46
    803a:	29 f4       	brne	.+10     	; 0x8046 <cmd_CWD+0x10e>
    803c:	12 96       	adiw	r26, 0x02	; 2
    803e:	8c 91       	ld	r24, X
    8040:	8f 32       	cpi	r24, 0x2F	; 47
    8042:	09 f4       	brne	.+2      	; 0x8046 <cmd_CWD+0x10e>
    8044:	b3 cf       	rjmp	.-154    	; 0x7fac <cmd_CWD+0x74>
			}

			argv += 3;
		}

		if (*argv == '.' && *(argv+1) == '/') argv += 2;	// zeigt auf aktuelles Verzeichnis
    8046:	f9 01       	movw	r30, r18
    8048:	80 81       	ld	r24, Z
    804a:	8e 32       	cpi	r24, 0x2E	; 46
    804c:	49 f4       	brne	.+18     	; 0x8060 <cmd_CWD+0x128>
    804e:	81 81       	ldd	r24, Z+1	; 0x01
    8050:	8f 32       	cpi	r24, 0x2F	; 47
    8052:	31 f4       	brne	.+12     	; 0x8060 <cmd_CWD+0x128>
    8054:	2e 5f       	subi	r18, 0xFE	; 254
    8056:	3f 4f       	sbci	r19, 0xFF	; 255
    8058:	30 93 6f 0d 	sts	0x0D6F, r19
    805c:	20 93 6e 0d 	sts	0x0D6E, r18

		register uint8_t len = strlen(tmpdir);
    8060:	ce 01       	movw	r24, r28
    8062:	c0 96       	adiw	r24, 0x30	; 48
    8064:	fc 01       	movw	r30, r24
    8066:	01 90       	ld	r0, Z+
    8068:	00 20       	and	r0, r0
    806a:	e9 f7       	brne	.-6      	; 0x8066 <cmd_CWD+0x12e>
    806c:	31 97       	sbiw	r30, 0x01	; 1
    806e:	0e 2f       	mov	r16, r30
    8070:	08 1b       	sub	r16, r24
		register uint8_t lennew = strlen(argv);
    8072:	e0 91 6e 0d 	lds	r30, 0x0D6E
    8076:	f0 91 6f 0d 	lds	r31, 0x0D6F
    807a:	df 01       	movw	r26, r30
    807c:	0d 90       	ld	r0, X+
    807e:	00 20       	and	r0, r0
    8080:	e9 f7       	brne	.-6      	; 0x807c <cmd_CWD+0x144>
    8082:	11 97       	sbiw	r26, 0x01	; 1
    8084:	ae 1b       	sub	r26, r30
    8086:	bf 0b       	sbc	r27, r31
    8088:	1a 2f       	mov	r17, r26

		if ( (len > 1) && lennew )			// falls nicht root und neues Unterverzeichnis bergeben wurde
    808a:	02 30       	cpi	r16, 0x02	; 2
    808c:	30 f0       	brcs	.+12     	; 0x809a <cmd_CWD+0x162>
    808e:	aa 23       	and	r26, r26
    8090:	21 f0       	breq	.+8      	; 0x809a <cmd_CWD+0x162>
			strcat_P(tmpdir,PSTR("/"));		// also nicht ".." eingegeben
    8092:	65 e9       	ldi	r22, 0x95	; 149
    8094:	7f e1       	ldi	r23, 0x1F	; 31
    8096:	0e 94 d4 6d 	call	0xdba8	; 0xdba8 <strcat_P>

		if ((len + lennew) < MAX_PATH) {	// falls der Pfad auch in den Speicherplatz passt
    809a:	80 2f       	mov	r24, r16
    809c:	90 e0       	ldi	r25, 0x00	; 0
    809e:	81 0f       	add	r24, r17
    80a0:	91 1d       	adc	r25, r1
    80a2:	cf 97       	sbiw	r24, 0x3f	; 63
    80a4:	64 f5       	brge	.+88     	; 0x80fe <cmd_CWD+0x1c6>

			register char *ptr = argv;		// letzen '/' bei Unterverzeichnis entfernen
    80a6:	e0 91 6e 0d 	lds	r30, 0x0D6E
    80aa:	f0 91 6f 0d 	lds	r31, 0x0D6F
			while (*ptr++);
    80ae:	81 91       	ld	r24, Z+
    80b0:	88 23       	and	r24, r24
    80b2:	e9 f7       	brne	.-6      	; 0x80ae <cmd_CWD+0x176>
			ptr -= 2;
    80b4:	32 97       	sbiw	r30, 0x02	; 2
			if (*ptr == '/') *ptr = '\0';
    80b6:	80 81       	ld	r24, Z
    80b8:	8f 32       	cpi	r24, 0x2F	; 47
    80ba:	09 f4       	brne	.+2      	; 0x80be <cmd_CWD+0x186>
    80bc:	10 82       	st	Z, r1

			strcat(tmpdir,argv);
    80be:	60 91 6e 0d 	lds	r22, 0x0D6E
    80c2:	70 91 6f 0d 	lds	r23, 0x0D6F
    80c6:	ce 01       	movw	r24, r28
    80c8:	c0 96       	adiw	r24, 0x30	; 48
    80ca:	0e 94 86 6e 	call	0xdd0c	; 0xdd0c <strcat>
    80ce:	17 c0       	rjmp	.+46     	; 0x80fe <cmd_CWD+0x1c6>
		}
	}
	else {
		register uint8_t lennew = strlen(argv) - 1;		// letzten '/' entfernen falls vorhanden
    80d0:	d9 01       	movw	r26, r18
    80d2:	0d 90       	ld	r0, X+
    80d4:	00 20       	and	r0, r0
    80d6:	e9 f7       	brne	.-6      	; 0x80d2 <cmd_CWD+0x19a>
    80d8:	8a 2f       	mov	r24, r26
    80da:	82 1b       	sub	r24, r18
    80dc:	82 50       	subi	r24, 0x02	; 2
		if ( lennew > 0 && *(argv + lennew) == '/' )
    80de:	39 f0       	breq	.+14     	; 0x80ee <cmd_CWD+0x1b6>
    80e0:	f9 01       	movw	r30, r18
    80e2:	e8 0f       	add	r30, r24
    80e4:	f1 1d       	adc	r31, r1
    80e6:	80 81       	ld	r24, Z
    80e8:	8f 32       	cpi	r24, 0x2F	; 47
    80ea:	09 f4       	brne	.+2      	; 0x80ee <cmd_CWD+0x1b6>
			*(argv + lennew) = '\0';
    80ec:	10 82       	st	Z, r1
		strcpy(tmpdir,argv);
    80ee:	60 91 6e 0d 	lds	r22, 0x0D6E
    80f2:	70 91 6f 0d 	lds	r23, 0x0D6F
    80f6:	ce 01       	movw	r24, r28
    80f8:	c0 96       	adiw	r24, 0x30	; 48
    80fa:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <strcpy>
	}

	// Verzeichnis berprfen und Zeiger neu setzen
    struct fat16_dir_entry_struct directory;
	if (fat16_get_dir_entry_of_path(sd_get_fs(), tmpdir, &directory)) {
    80fe:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    8102:	8e 01       	movw	r16, r28
    8104:	00 5d       	subi	r16, 0xD0	; 208
    8106:	1f 4f       	sbci	r17, 0xFF	; 255
    8108:	b8 01       	movw	r22, r16
    810a:	7e 01       	movw	r14, r28
    810c:	08 94       	sec
    810e:	e1 1c       	adc	r14, r1
    8110:	f1 1c       	adc	r15, r1
    8112:	a7 01       	movw	r20, r14
    8114:	0e 94 12 5e 	call	0xbc24	; 0xbc24 <fat16_get_dir_entry_of_path>
    8118:	88 23       	and	r24, r24
    811a:	01 f1       	breq	.+64     	; 0x815c <cmd_CWD+0x224>
		// neues Verzeichnis gefunden
		strcpy((char *)cwdirectory,tmpdir);
    811c:	88 e7       	ldi	r24, 0x78	; 120
    811e:	91 e0       	ldi	r25, 0x01	; 1
    8120:	b8 01       	movw	r22, r16
    8122:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <strcpy>
		struct fat16_dir_struct* dir_new = fat16_open_dir(sd_get_fs(), &directory);
    8126:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    812a:	b7 01       	movw	r22, r14
    812c:	0e 94 91 5d 	call	0xbb22	; 0xbb22 <fat16_open_dir>
    8130:	7c 01       	movw	r14, r24
		if(dir_new) {
    8132:	00 97       	sbiw	r24, 0x00	; 0
    8134:	99 f0       	breq	.+38     	; 0x815c <cmd_CWD+0x224>
			if(cwdir_ptr != sd_get_root_dir())
    8136:	00 91 cb 0d 	lds	r16, 0x0DCB
    813a:	10 91 cc 0d 	lds	r17, 0x0DCC
    813e:	0e 94 a8 5e 	call	0xbd50	; 0xbd50 <sd_get_root_dir>
    8142:	08 17       	cp	r16, r24
    8144:	19 07       	cpc	r17, r25
    8146:	31 f0       	breq	.+12     	; 0x8154 <cmd_CWD+0x21c>
				fat16_close_dir(cwdir_ptr);
    8148:	80 91 cb 0d 	lds	r24, 0x0DCB
    814c:	90 91 cc 0d 	lds	r25, 0x0DCC
    8150:	0e 94 ec 50 	call	0xa1d8	; 0xa1d8 <fat16_close_dir>
			cwdir_ptr = dir_new;
    8154:	f0 92 cc 0d 	sts	0x0DCC, r15
    8158:	e0 92 cb 0d 	sts	0x0DCB, r14
		}
	}

	if (outbuffer) {
    815c:	c1 14       	cp	r12, r1
    815e:	d1 04       	cpc	r13, r1
    8160:	19 f4       	brne	.+6      	; 0x8168 <cmd_CWD+0x230>
    8162:	a0 e0       	ldi	r26, 0x00	; 0
    8164:	b0 e0       	ldi	r27, 0x00	; 0
    8166:	25 c0       	rjmp	.+74     	; 0x81b2 <cmd_CWD+0x27a>
		sprintf_P(outbuffer,PSTR("250 Directory changed to %s\r\n"),cwdirectory);
    8168:	00 d0       	rcall	.+0      	; 0x816a <cmd_CWD+0x232>
    816a:	00 d0       	rcall	.+0      	; 0x816c <cmd_CWD+0x234>
    816c:	00 d0       	rcall	.+0      	; 0x816e <cmd_CWD+0x236>
    816e:	ed b7       	in	r30, 0x3d	; 61
    8170:	fe b7       	in	r31, 0x3e	; 62
    8172:	31 96       	adiw	r30, 0x01	; 1
    8174:	ad b7       	in	r26, 0x3d	; 61
    8176:	be b7       	in	r27, 0x3e	; 62
    8178:	12 96       	adiw	r26, 0x02	; 2
    817a:	dc 92       	st	X, r13
    817c:	ce 92       	st	-X, r12
    817e:	11 97       	sbiw	r26, 0x01	; 1
    8180:	87 e7       	ldi	r24, 0x77	; 119
    8182:	9f e1       	ldi	r25, 0x1F	; 31
    8184:	93 83       	std	Z+3, r25	; 0x03
    8186:	82 83       	std	Z+2, r24	; 0x02
    8188:	88 e7       	ldi	r24, 0x78	; 120
    818a:	91 e0       	ldi	r25, 0x01	; 1
    818c:	95 83       	std	Z+5, r25	; 0x05
    818e:	84 83       	std	Z+4, r24	; 0x04
    8190:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8194:	d6 01       	movw	r26, r12
    8196:	0d 90       	ld	r0, X+
    8198:	00 20       	and	r0, r0
    819a:	e9 f7       	brne	.-6      	; 0x8196 <cmd_CWD+0x25e>
    819c:	11 97       	sbiw	r26, 0x01	; 1
    819e:	ac 19       	sub	r26, r12
    81a0:	bd 09       	sbc	r27, r13
    81a2:	ed b7       	in	r30, 0x3d	; 61
    81a4:	fe b7       	in	r31, 0x3e	; 62
    81a6:	36 96       	adiw	r30, 0x06	; 6
    81a8:	0f b6       	in	r0, 0x3f	; 63
    81aa:	f8 94       	cli
    81ac:	fe bf       	out	0x3e, r31	; 62
    81ae:	0f be       	out	0x3f, r0	; 63
    81b0:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		return 0;
	}
#endif
}
    81b2:	cd 01       	movw	r24, r26
    81b4:	c1 59       	subi	r28, 0x91	; 145
    81b6:	df 4f       	sbci	r29, 0xFF	; 255
    81b8:	0f b6       	in	r0, 0x3f	; 63
    81ba:	f8 94       	cli
    81bc:	de bf       	out	0x3e, r29	; 62
    81be:	0f be       	out	0x3f, r0	; 63
    81c0:	cd bf       	out	0x3d, r28	; 61
    81c2:	cf 91       	pop	r28
    81c4:	df 91       	pop	r29
    81c6:	1f 91       	pop	r17
    81c8:	0f 91       	pop	r16
    81ca:	ff 90       	pop	r15
    81cc:	ef 90       	pop	r14
    81ce:	df 90       	pop	r13
    81d0:	cf 90       	pop	r12
    81d2:	08 95       	ret

000081d4 <cmd_MKD>:
/**
 * \ingroup tcpftp
 * \b MKD-Befehl Verzeichnis anlegen
 */
int16_t cmd_MKD(char *outbuffer)
{
    81d4:	cf 93       	push	r28
    81d6:	df 93       	push	r29
    81d8:	ec 01       	movw	r28, r24
	#if !FTP_ANONYMOUS
	if (outbuffer && !tcpsrv_status.loginOK)
		return cmd_530(outbuffer);
	#endif

	if( f16_mkdir(argv) && outbuffer) {
    81da:	80 91 6e 0d 	lds	r24, 0x0D6E
    81de:	90 91 6f 0d 	lds	r25, 0x0D6F
    81e2:	0e 94 58 4b 	call	0x96b0	; 0x96b0 <f16_mkdir>
    81e6:	88 23       	and	r24, r24
    81e8:	31 f0       	breq	.+12     	; 0x81f6 <cmd_MKD+0x22>
    81ea:	20 97       	sbiw	r28, 0x00	; 0
    81ec:	59 f0       	breq	.+22     	; 0x8204 <cmd_MKD+0x30>
		return cmd_200(outbuffer);	// success
    81ee:	ce 01       	movw	r24, r28
    81f0:	0e 94 5a 3e 	call	0x7cb4	; 0x7cb4 <cmd_200>
    81f4:	05 c0       	rjmp	.+10     	; 0x8200 <cmd_MKD+0x2c>
	}
#endif

	if (outbuffer)
    81f6:	20 97       	sbiw	r28, 0x00	; 0
    81f8:	29 f0       	breq	.+10     	; 0x8204 <cmd_MKD+0x30>
		return cmd_550(outbuffer);
    81fa:	ce 01       	movw	r24, r28
    81fc:	0e 94 8f 3a 	call	0x751e	; 0x751e <cmd_550>
    8200:	9c 01       	movw	r18, r24
    8202:	02 c0       	rjmp	.+4      	; 0x8208 <cmd_MKD+0x34>
    8204:	20 e0       	ldi	r18, 0x00	; 0
    8206:	30 e0       	ldi	r19, 0x00	; 0
	else
		return 0;
}
    8208:	c9 01       	movw	r24, r18
    820a:	df 91       	pop	r29
    820c:	cf 91       	pop	r28
    820e:	08 95       	ret

00008210 <cmd_RETR>:
 * \b RETR-Befehl Dateianforderung bei FTP
 *
 * initialisiert die Dateibertragung im FTP-Datenkanal
 */
int16_t cmd_RETR(char *outbuffer)
{
    8210:	cf 93       	push	r28
    8212:	df 93       	push	r29
    8214:	ec 01       	movw	r28, r24
	if (outbuffer) {
    8216:	00 97       	sbiw	r24, 0x00	; 0
    8218:	f1 f0       	breq	.+60     	; 0x8256 <cmd_RETR+0x46>
		#if !FTP_ANONYMOUS
		if (!tcpsrv_status.loginOK)
			return cmd_530(outbuffer);
		#endif

		if( f16_exist(argv) ) {
    821a:	80 91 6e 0d 	lds	r24, 0x0D6E
    821e:	90 91 6f 0d 	lds	r25, 0x0D6F
    8222:	0e 94 80 4b 	call	0x9700	; 0x9700 <f16_exist>
    8226:	88 23       	and	r24, r24
    8228:	99 f0       	breq	.+38     	; 0x8250 <cmd_RETR+0x40>
			strcpy((char *)tcpsrv_status.fname,argv);
    822a:	60 91 6e 0d 	lds	r22, 0x0D6E
    822e:	70 91 6f 0d 	lds	r23, 0x0D6F
    8232:	8d e9       	ldi	r24, 0x9D	; 157
    8234:	9d e0       	ldi	r25, 0x0D	; 13
    8236:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <strcpy>
			tcpsrv_status.data_state = 2;
    823a:	80 91 70 0d 	lds	r24, 0x0D70
    823e:	8f 7c       	andi	r24, 0xCF	; 207
    8240:	80 62       	ori	r24, 0x20	; 32
    8242:	80 93 70 0d 	sts	0x0D70, r24
			// Anfang der bertragung
			return cmd_150(outbuffer);
    8246:	ce 01       	movw	r24, r28
    8248:	0e 94 85 3e 	call	0x7d0a	; 0x7d0a <cmd_150>
    824c:	9c 01       	movw	r18, r24
    824e:	05 c0       	rjmp	.+10     	; 0x825a <cmd_RETR+0x4a>
		}
		else
		#endif
			cmd_502(outbuffer);	// TODO richtige Fehlermeldung einsetzen
    8250:	ce 01       	movw	r24, r28
    8252:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    8256:	20 e0       	ldi	r18, 0x00	; 0
    8258:	30 e0       	ldi	r19, 0x00	; 0
	}
	return 0;
}
    825a:	c9 01       	movw	r24, r18
    825c:	df 91       	pop	r29
    825e:	cf 91       	pop	r28
    8260:	08 95       	ret

00008262 <cmd_DELE>:
 * \b DELE-Befehl Datei-/Verzeichnis lschen
 *
 * Dateien und Verzeichniseintrge werden bei FAT16 identisch behandelt.
 */
int16_t cmd_DELE(char *outbuffer)
{
    8262:	cf 93       	push	r28
    8264:	df 93       	push	r29
    8266:	ec 01       	movw	r28, r24
	#if !FTP_ANONYMOUS
	if (outbuffer && !tcpsrv_status.loginOK)
		return cmd_530(outbuffer);
	#endif

	if( f16_exist(argv) ) {
    8268:	80 91 6e 0d 	lds	r24, 0x0D6E
    826c:	90 91 6f 0d 	lds	r25, 0x0D6F
    8270:	0e 94 80 4b 	call	0x9700	; 0x9700 <f16_exist>
    8274:	88 23       	and	r24, r24
    8276:	11 f1       	breq	.+68     	; 0x82bc <cmd_DELE+0x5a>
		usart_write("\r\nDELE: %s exist.",argv);
    8278:	00 d0       	rcall	.+0      	; 0x827a <cmd_DELE+0x18>
    827a:	00 d0       	rcall	.+0      	; 0x827c <cmd_DELE+0x1a>
    827c:	8d eb       	ldi	r24, 0xBD	; 189
    827e:	9f e1       	ldi	r25, 0x1F	; 31
    8280:	ed b7       	in	r30, 0x3d	; 61
    8282:	fe b7       	in	r31, 0x3e	; 62
    8284:	92 83       	std	Z+2, r25	; 0x02
    8286:	81 83       	std	Z+1, r24	; 0x01
    8288:	80 91 6e 0d 	lds	r24, 0x0D6E
    828c:	90 91 6f 0d 	lds	r25, 0x0D6F
    8290:	94 83       	std	Z+4, r25	; 0x04
    8292:	83 83       	std	Z+3, r24	; 0x03
    8294:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		if (f16_delete(argv) && outbuffer)
    8298:	0f 90       	pop	r0
    829a:	0f 90       	pop	r0
    829c:	0f 90       	pop	r0
    829e:	0f 90       	pop	r0
    82a0:	80 91 6e 0d 	lds	r24, 0x0D6E
    82a4:	90 91 6f 0d 	lds	r25, 0x0D6F
    82a8:	0e 94 aa 4b 	call	0x9754	; 0x9754 <f16_delete>
    82ac:	88 23       	and	r24, r24
    82ae:	31 f0       	breq	.+12     	; 0x82bc <cmd_DELE+0x5a>
    82b0:	20 97       	sbiw	r28, 0x00	; 0
    82b2:	59 f0       	breq	.+22     	; 0x82ca <cmd_DELE+0x68>
				return cmd_200(outbuffer);	// success
    82b4:	ce 01       	movw	r24, r28
    82b6:	0e 94 5a 3e 	call	0x7cb4	; 0x7cb4 <cmd_200>
    82ba:	05 c0       	rjmp	.+10     	; 0x82c6 <cmd_DELE+0x64>
	}
#endif

	if (outbuffer) {
    82bc:	20 97       	sbiw	r28, 0x00	; 0
    82be:	29 f0       	breq	.+10     	; 0x82ca <cmd_DELE+0x68>
		return cmd_550(outbuffer);
    82c0:	ce 01       	movw	r24, r28
    82c2:	0e 94 8f 3a 	call	0x751e	; 0x751e <cmd_550>
    82c6:	9c 01       	movw	r18, r24
    82c8:	02 c0       	rjmp	.+4      	; 0x82ce <cmd_DELE+0x6c>
    82ca:	20 e0       	ldi	r18, 0x00	; 0
    82cc:	30 e0       	ldi	r19, 0x00	; 0
	}
	return 0;
}
    82ce:	c9 01       	movw	r24, r18
    82d0:	df 91       	pop	r29
    82d2:	cf 91       	pop	r28
    82d4:	08 95       	ret

000082d6 <cmd_STOR>:
 * \b STOR-Befehl Datenempfang bei FTP
 *
 * initialisiert den Datenempfang im FTP-Datenkanal
 */
int16_t cmd_STOR(char *outbuffer)
{
    82d6:	cf 93       	push	r28
    82d8:	df 93       	push	r29
    82da:	ec 01       	movw	r28, r24
	if (outbuffer) {
    82dc:	00 97       	sbiw	r24, 0x00	; 0
    82de:	19 f4       	brne	.+6      	; 0x82e6 <cmd_STOR+0x10>
    82e0:	20 e0       	ldi	r18, 0x00	; 0
    82e2:	30 e0       	ldi	r19, 0x00	; 0
    82e4:	2b c0       	rjmp	.+86     	; 0x833c <cmd_STOR+0x66>
		#if !FTP_ANONYMOUS
		if (!tcpsrv_status.loginOK)
			return cmd_530(outbuffer);
		#endif

		if( f16_exist(argv) ) {
    82e6:	80 91 6e 0d 	lds	r24, 0x0D6E
    82ea:	90 91 6f 0d 	lds	r25, 0x0D6F
    82ee:	0e 94 80 4b 	call	0x9700	; 0x9700 <f16_exist>
    82f2:	88 23       	and	r24, r24
    82f4:	31 f0       	breq	.+12     	; 0x8302 <cmd_STOR+0x2c>
			// Datei lschen
			f16_delete(argv);
    82f6:	80 91 6e 0d 	lds	r24, 0x0D6E
    82fa:	90 91 6f 0d 	lds	r25, 0x0D6F
    82fe:	0e 94 aa 4b 	call	0x9754	; 0x9754 <f16_delete>
		}

		strcpy((char *)tcpsrv_status.fname,argv);
    8302:	60 91 6e 0d 	lds	r22, 0x0D6E
    8306:	70 91 6f 0d 	lds	r23, 0x0D6F
    830a:	8d e9       	ldi	r24, 0x9D	; 157
    830c:	9d e0       	ldi	r25, 0x0D	; 13
    830e:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <strcpy>
		tcpsrv_status.datafile = f16_open(argv,"a");	// Datendatei ffnen
    8312:	80 91 6e 0d 	lds	r24, 0x0D6E
    8316:	90 91 6f 0d 	lds	r25, 0x0D6F
    831a:	6a e6       	ldi	r22, 0x6A	; 106
    831c:	71 e0       	ldi	r23, 0x01	; 1
    831e:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    8322:	90 93 be 0d 	sts	0x0DBE, r25
    8326:	80 93 bd 0d 	sts	0x0DBD, r24
		tcpsrv_status.data_state = 3;
    832a:	80 91 70 0d 	lds	r24, 0x0D70
    832e:	80 63       	ori	r24, 0x30	; 48
    8330:	80 93 70 0d 	sts	0x0D70, r24
		// Anfang der bertragung
		return cmd_150(outbuffer);
    8334:	ce 01       	movw	r24, r28
    8336:	0e 94 85 3e 	call	0x7d0a	; 0x7d0a <cmd_150>
    833a:	9c 01       	movw	r18, r24
	  #else
		return cmd_502(outbuffer);
	  #endif
	}
	return 0;
}
    833c:	c9 01       	movw	r24, r18
    833e:	df 91       	pop	r29
    8340:	cf 91       	pop	r28
    8342:	08 95       	ret

00008344 <cat>:
/**
 * \ingroup usartcmdline
 * \b CAT-Befehl Anzeige eines Dateiinhalts auf der USART
 */
int16_t cat(char *outbuffer)
{
    8344:	cf 93       	push	r28
    8346:	df 93       	push	r29
	if (outbuffer)					// nur bei USART
    8348:	00 97       	sbiw	r24, 0x00	; 0
    834a:	21 f0       	breq	.+8      	; 0x8354 <cat+0x10>
		return cmd_502(outbuffer);
    834c:	0e 94 bd 3a 	call	0x757a	; 0x757a <cmd_502>
    8350:	9c 01       	movw	r18, r24
    8352:	1b c0       	rjmp	.+54     	; 0x838a <cat+0x46>

	#if USE_MMC
	int ch;

	File *ptrFile = f16_open(argv,"r");
    8354:	80 91 6e 0d 	lds	r24, 0x0D6E
    8358:	90 91 6f 0d 	lds	r25, 0x0D6F
    835c:	6c e6       	ldi	r22, 0x6C	; 108
    835e:	71 e0       	ldi	r23, 0x01	; 1
    8360:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    8364:	ec 01       	movw	r28, r24
	if (!ptrFile) return 0;
    8366:	00 97       	sbiw	r24, 0x00	; 0
    8368:	29 f4       	brne	.+10     	; 0x8374 <cat+0x30>
    836a:	0d c0       	rjmp	.+26     	; 0x8386 <cat+0x42>

	ch = f16_getc(ptrFile);
	while ( ch > 0 ) {
		usart_write_char((char)ch);
    836c:	60 e0       	ldi	r22, 0x00	; 0
    836e:	70 e0       	ldi	r23, 0x00	; 0
    8370:	0e 94 d5 13 	call	0x27aa	; 0x27aa <usart_putchar>
		ch = f16_getc(ptrFile);
    8374:	ce 01       	movw	r24, r28
    8376:	0e 94 32 4c 	call	0x9864	; 0x9864 <f16_getc>

	File *ptrFile = f16_open(argv,"r");
	if (!ptrFile) return 0;

	ch = f16_getc(ptrFile);
	while ( ch > 0 ) {
    837a:	18 16       	cp	r1, r24
    837c:	19 06       	cpc	r1, r25
    837e:	b4 f3       	brlt	.-20     	; 0x836c <cat+0x28>
		usart_write_char((char)ch);
		ch = f16_getc(ptrFile);
		}

	f16_close(ptrFile);
    8380:	ce 01       	movw	r24, r28
    8382:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
    8386:	20 e0       	ldi	r18, 0x00	; 0
    8388:	30 e0       	ldi	r19, 0x00	; 0
	#endif
	return 0;
}
    838a:	c9 01       	movw	r24, r18
    838c:	df 91       	pop	r29
    838e:	cf 91       	pop	r28
    8390:	08 95       	ret

00008392 <cmd_MMCdir>:
 *   vorhanden sind wird <tt>tcpsrv_status.LISTcontinue</tt> auf true gesetzt.
 * 	 Bei abgeschlossenem Listing wird <tt>tcpsrv_status.LISTcontinue</tt> auf
 *   false gesetzt.
 */
int16_t cmd_MMCdir(char *outbuffer)
{
    8392:	2f 92       	push	r2
    8394:	3f 92       	push	r3
    8396:	4f 92       	push	r4
    8398:	5f 92       	push	r5
    839a:	6f 92       	push	r6
    839c:	7f 92       	push	r7
    839e:	8f 92       	push	r8
    83a0:	9f 92       	push	r9
    83a2:	af 92       	push	r10
    83a4:	bf 92       	push	r11
    83a6:	cf 92       	push	r12
    83a8:	df 92       	push	r13
    83aa:	ef 92       	push	r14
    83ac:	ff 92       	push	r15
    83ae:	0f 93       	push	r16
    83b0:	1f 93       	push	r17
    83b2:	df 93       	push	r29
    83b4:	cf 93       	push	r28
    83b6:	cd b7       	in	r28, 0x3d	; 61
    83b8:	de b7       	in	r29, 0x3e	; 62
    83ba:	c2 54       	subi	r28, 0x42	; 66
    83bc:	d0 40       	sbci	r29, 0x00	; 0
    83be:	0f b6       	in	r0, 0x3f	; 63
    83c0:	f8 94       	cli
    83c2:	de bf       	out	0x3e, r29	; 62
    83c4:	0f be       	out	0x3f, r0	; 63
    83c6:	cd bf       	out	0x3d, r28	; 61
    83c8:	8c 01       	movw	r16, r24
#if USE_MMC
	if (!cwdir_ptr)
    83ca:	80 91 cb 0d 	lds	r24, 0x0DCB
    83ce:	90 91 cc 0d 	lds	r25, 0x0DCC
    83d2:	89 2b       	or	r24, r25
    83d4:	09 f4       	brne	.+2      	; 0x83d8 <cmd_MMCdir+0x46>
    83d6:	52 c1       	rjmp	.+676    	; 0x867c <cmd_MMCdir+0x2ea>
	if (outbuffer && !tcpsrv_status.loginOK)
		return cmd_530(outbuffer);
	#endif

	#if TCP_SERVICE
	tcpsrv_status.LISTcontinue = 0;	// continue Flag zurcksetzen
    83d8:	80 91 71 0d 	lds	r24, 0x0D71
    83dc:	8d 7f       	andi	r24, 0xFD	; 253
    83de:	80 93 71 0d 	sts	0x0D71, r24
	#endif
	if (!outbuffer) {
    83e2:	01 15       	cp	r16, r1
    83e4:	11 05       	cpc	r17, r1
    83e6:	11 f0       	breq	.+4      	; 0x83ec <cmd_MMCdir+0x5a>
    83e8:	78 01       	movw	r14, r16
    83ea:	0d c1       	rjmp	.+538    	; 0x8606 <cmd_MMCdir+0x274>
		usart_write("\n\rSD-Karte:");
    83ec:	00 d0       	rcall	.+0      	; 0x83ee <cmd_MMCdir+0x5c>
    83ee:	8d e1       	ldi	r24, 0x1D	; 29
    83f0:	90 e2       	ldi	r25, 0x20	; 32
    83f2:	ad b7       	in	r26, 0x3d	; 61
    83f4:	be b7       	in	r27, 0x3e	; 62
    83f6:	12 96       	adiw	r26, 0x02	; 2
    83f8:	9c 93       	st	X, r25
    83fa:	8e 93       	st	-X, r24
    83fc:	11 97       	sbiw	r26, 0x01	; 1
    83fe:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8402:	ee 24       	eor	r14, r14
    8404:	ff 24       	eor	r15, r15
    8406:	0f 90       	pop	r0
    8408:	0f 90       	pop	r0
    840a:	fd c0       	rjmp	.+506    	; 0x8606 <cmd_MMCdir+0x274>
	uint8_t sec;

    /* Verzeichniseintrge lesen */
    while(fat16_read_dir(cwdir_ptr, &dir_entry))
    {
		fat16_get_file_modification_date(&dir_entry, &year, &month, &day);
    840c:	c6 01       	movw	r24, r12
    840e:	be 01       	movw	r22, r28
    8410:	6a 5f       	subi	r22, 0xFA	; 250
    8412:	7f 4f       	sbci	r23, 0xFF	; 255
    8414:	ae 01       	movw	r20, r28
    8416:	4f 5f       	subi	r20, 0xFF	; 255
    8418:	5f 4f       	sbci	r21, 0xFF	; 255
    841a:	9e 01       	movw	r18, r28
    841c:	2e 5f       	subi	r18, 0xFE	; 254
    841e:	3f 4f       	sbci	r19, 0xFF	; 255
    8420:	0e 94 9a 52 	call	0xa534	; 0xa534 <fat16_get_file_modification_date>
		fat16_get_file_modification_time(&dir_entry, &hour, &min, &sec);
    8424:	c6 01       	movw	r24, r12
    8426:	be 01       	movw	r22, r28
    8428:	6d 5f       	subi	r22, 0xFD	; 253
    842a:	7f 4f       	sbci	r23, 0xFF	; 255
    842c:	ae 01       	movw	r20, r28
    842e:	4c 5f       	subi	r20, 0xFC	; 252
    8430:	5f 4f       	sbci	r21, 0xFF	; 255
    8432:	9e 01       	movw	r18, r28
    8434:	2b 5f       	subi	r18, 0xFB	; 251
    8436:	3f 4f       	sbci	r19, 0xFF	; 255
    8438:	0e 94 ba 52 	call	0xa574	; 0xa574 <fat16_get_file_modification_time>

		if (outbuffer) {
    843c:	01 15       	cp	r16, r1
    843e:	11 05       	cpc	r17, r1
    8440:	09 f4       	brne	.+2      	; 0x8444 <cmd_MMCdir+0xb2>
    8442:	74 c0       	rjmp	.+232    	; 0x852c <cmd_MMCdir+0x19a>
			#ifdef DOS_LIST
			/*
			*  DOS style Dateiliste
			* (bei FileZilla nennt sich das DOS - woanders Windows_NT(?) ...)
			*/
			if (dir_entry.attributes & FAT16_ATTRIB_DIR) {
    8444:	8c a9       	ldd	r24, Y+52	; 0x34
    8446:	84 ff       	sbrs	r24, 4
    8448:	06 c0       	rjmp	.+12     	; 0x8456 <cmd_MMCdir+0xc4>
				strcpy_P((char *)tmpbuf,PSTR("<DIR>"));
    844a:	c5 01       	movw	r24, r10
    844c:	67 e1       	ldi	r22, 0x17	; 23
    844e:	70 e2       	ldi	r23, 0x20	; 32
    8450:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
    8454:	23 c0       	rjmp	.+70     	; 0x849c <cmd_MMCdir+0x10a>
			}
			else {
				sprintf_P(tmpbuf,PSTR("%ld"),dir_entry.file_size);
    8456:	ed b7       	in	r30, 0x3d	; 61
    8458:	fe b7       	in	r31, 0x3e	; 62
    845a:	38 97       	sbiw	r30, 0x08	; 8
    845c:	0f b6       	in	r0, 0x3f	; 63
    845e:	f8 94       	cli
    8460:	fe bf       	out	0x3e, r31	; 62
    8462:	0f be       	out	0x3f, r0	; 63
    8464:	ed bf       	out	0x3d, r30	; 61
    8466:	31 96       	adiw	r30, 0x01	; 1
    8468:	ad b7       	in	r26, 0x3d	; 61
    846a:	be b7       	in	r27, 0x3e	; 62
    846c:	12 96       	adiw	r26, 0x02	; 2
    846e:	bc 92       	st	X, r11
    8470:	ae 92       	st	-X, r10
    8472:	11 97       	sbiw	r26, 0x01	; 1
    8474:	73 82       	std	Z+3, r7	; 0x03
    8476:	62 82       	std	Z+2, r6	; 0x02
    8478:	8b ad       	ldd	r24, Y+59	; 0x3b
    847a:	9c ad       	ldd	r25, Y+60	; 0x3c
    847c:	ad ad       	ldd	r26, Y+61	; 0x3d
    847e:	be ad       	ldd	r27, Y+62	; 0x3e
    8480:	84 83       	std	Z+4, r24	; 0x04
    8482:	95 83       	std	Z+5, r25	; 0x05
    8484:	a6 83       	std	Z+6, r26	; 0x06
    8486:	b7 83       	std	Z+7, r27	; 0x07
    8488:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
    848c:	ed b7       	in	r30, 0x3d	; 61
    848e:	fe b7       	in	r31, 0x3e	; 62
    8490:	38 96       	adiw	r30, 0x08	; 8
    8492:	0f b6       	in	r0, 0x3f	; 63
    8494:	f8 94       	cli
    8496:	fe bf       	out	0x3e, r31	; 62
    8498:	0f be       	out	0x3f, r0	; 63
    849a:	ed bf       	out	0x3d, r30	; 61
			}

			sprintf_P((char *)pstr,PSTR("%i-%i-%i %i:%i:%i %8s %s\r\n"),month, day, year, hour, min, sec, tmpbuf,dir_entry.long_name);
    849c:	2d b7       	in	r18, 0x3d	; 61
    849e:	3e b7       	in	r19, 0x3e	; 62
    84a0:	24 51       	subi	r18, 0x14	; 20
    84a2:	30 40       	sbci	r19, 0x00	; 0
    84a4:	0f b6       	in	r0, 0x3f	; 63
    84a6:	f8 94       	cli
    84a8:	3e bf       	out	0x3e, r19	; 62
    84aa:	0f be       	out	0x3f, r0	; 63
    84ac:	2d bf       	out	0x3d, r18	; 61
    84ae:	ed b7       	in	r30, 0x3d	; 61
    84b0:	fe b7       	in	r31, 0x3e	; 62
    84b2:	31 96       	adiw	r30, 0x01	; 1
    84b4:	ad b7       	in	r26, 0x3d	; 61
    84b6:	be b7       	in	r27, 0x3e	; 62
    84b8:	12 96       	adiw	r26, 0x02	; 2
    84ba:	fc 92       	st	X, r15
    84bc:	ee 92       	st	-X, r14
    84be:	11 97       	sbiw	r26, 0x01	; 1
    84c0:	53 82       	std	Z+3, r5	; 0x03
    84c2:	42 82       	std	Z+2, r4	; 0x02
    84c4:	89 81       	ldd	r24, Y+1	; 0x01
    84c6:	84 83       	std	Z+4, r24	; 0x04
    84c8:	15 82       	std	Z+5, r1	; 0x05
    84ca:	8a 81       	ldd	r24, Y+2	; 0x02
    84cc:	86 83       	std	Z+6, r24	; 0x06
    84ce:	17 82       	std	Z+7, r1	; 0x07
    84d0:	8e 81       	ldd	r24, Y+6	; 0x06
    84d2:	9f 81       	ldd	r25, Y+7	; 0x07
    84d4:	91 87       	std	Z+9, r25	; 0x09
    84d6:	80 87       	std	Z+8, r24	; 0x08
    84d8:	8b 81       	ldd	r24, Y+3	; 0x03
    84da:	82 87       	std	Z+10, r24	; 0x0a
    84dc:	13 86       	std	Z+11, r1	; 0x0b
    84de:	8c 81       	ldd	r24, Y+4	; 0x04
    84e0:	84 87       	std	Z+12, r24	; 0x0c
    84e2:	15 86       	std	Z+13, r1	; 0x0d
    84e4:	8d 81       	ldd	r24, Y+5	; 0x05
    84e6:	86 87       	std	Z+14, r24	; 0x0e
    84e8:	17 86       	std	Z+15, r1	; 0x0f
    84ea:	b1 8a       	std	Z+17, r11	; 0x11
    84ec:	a0 8a       	std	Z+16, r10	; 0x10
    84ee:	d3 8a       	std	Z+19, r13	; 0x13
    84f0:	c2 8a       	std	Z+18, r12	; 0x12
    84f2:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
    84f6:	ed b7       	in	r30, 0x3d	; 61
    84f8:	fe b7       	in	r31, 0x3e	; 62
    84fa:	74 96       	adiw	r30, 0x14	; 20
    84fc:	0f b6       	in	r0, 0x3f	; 63
    84fe:	f8 94       	cli
    8500:	fe bf       	out	0x3e, r31	; 62
    8502:	0f be       	out	0x3f, r0	; 63
    8504:	ed bf       	out	0x3d, r30	; 61
			#endif

			while (*pstr++);	// bis auf '\0' vorzhlen
    8506:	97 01       	movw	r18, r14
    8508:	2f 5f       	subi	r18, 0xFF	; 255
    850a:	3f 4f       	sbci	r19, 0xFF	; 255
    850c:	d7 01       	movw	r26, r14
    850e:	8c 91       	ld	r24, X
    8510:	88 23       	and	r24, r24
    8512:	11 f0       	breq	.+4      	; 0x8518 <cmd_MMCdir+0x186>
    8514:	79 01       	movw	r14, r18
    8516:	f7 cf       	rjmp	.-18     	; 0x8506 <cmd_MMCdir+0x174>
			--pstr;

			if (pstr > (outbuffer + MAX_WINDOWS_SIZE - 64)) {	// mind. 64 Bytes fr nchsten Eintrag freilassen
    8518:	8e 14       	cp	r8, r14
    851a:	9f 04       	cpc	r9, r15
    851c:	08 f0       	brcs	.+2      	; 0x8520 <cmd_MMCdir+0x18e>
    851e:	8f c0       	rjmp	.+286    	; 0x863e <cmd_MMCdir+0x2ac>
				tcpsrv_status.LISTcontinue = 1;					// continue Flag setzen
    8520:	80 91 71 0d 	lds	r24, 0x0D71
    8524:	82 60       	ori	r24, 0x02	; 2
    8526:	80 93 71 0d 	sts	0x0D71, r24
    852a:	93 c0       	rjmp	.+294    	; 0x8652 <cmd_MMCdir+0x2c0>
				break;
			}
			#endif
		}
		else {
			usart_write("\r\n%2i.%2i.%i %2i:%2i ",day, month, year, hour, min);
    852c:	ed b7       	in	r30, 0x3d	; 61
    852e:	fe b7       	in	r31, 0x3e	; 62
    8530:	3c 97       	sbiw	r30, 0x0c	; 12
    8532:	0f b6       	in	r0, 0x3f	; 63
    8534:	f8 94       	cli
    8536:	fe bf       	out	0x3e, r31	; 62
    8538:	0f be       	out	0x3f, r0	; 63
    853a:	ed bf       	out	0x3d, r30	; 61
    853c:	31 96       	adiw	r30, 0x01	; 1
    853e:	22 ee       	ldi	r18, 0xE2	; 226
    8540:	3f e1       	ldi	r19, 0x1F	; 31
    8542:	ad b7       	in	r26, 0x3d	; 61
    8544:	be b7       	in	r27, 0x3e	; 62
    8546:	12 96       	adiw	r26, 0x02	; 2
    8548:	3c 93       	st	X, r19
    854a:	2e 93       	st	-X, r18
    854c:	11 97       	sbiw	r26, 0x01	; 1
    854e:	8a 81       	ldd	r24, Y+2	; 0x02
    8550:	82 83       	std	Z+2, r24	; 0x02
    8552:	13 82       	std	Z+3, r1	; 0x03
    8554:	89 81       	ldd	r24, Y+1	; 0x01
    8556:	84 83       	std	Z+4, r24	; 0x04
    8558:	15 82       	std	Z+5, r1	; 0x05
    855a:	8e 81       	ldd	r24, Y+6	; 0x06
    855c:	9f 81       	ldd	r25, Y+7	; 0x07
    855e:	97 83       	std	Z+7, r25	; 0x07
    8560:	86 83       	std	Z+6, r24	; 0x06
    8562:	8b 81       	ldd	r24, Y+3	; 0x03
    8564:	80 87       	std	Z+8, r24	; 0x08
    8566:	11 86       	std	Z+9, r1	; 0x09
    8568:	8c 81       	ldd	r24, Y+4	; 0x04
    856a:	82 87       	std	Z+10, r24	; 0x0a
    856c:	13 86       	std	Z+11, r1	; 0x0b
    856e:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
			if (dir_entry.attributes & FAT16_ATTRIB_DIR)
    8572:	8c a9       	ldd	r24, Y+52	; 0x34
    8574:	ad b7       	in	r26, 0x3d	; 61
    8576:	be b7       	in	r27, 0x3e	; 62
    8578:	1c 96       	adiw	r26, 0x0c	; 12
    857a:	0f b6       	in	r0, 0x3f	; 63
    857c:	f8 94       	cli
    857e:	be bf       	out	0x3e, r27	; 62
    8580:	0f be       	out	0x3f, r0	; 63
    8582:	ad bf       	out	0x3d, r26	; 61
    8584:	84 ff       	sbrs	r24, 4
    8586:	0a c0       	rjmp	.+20     	; 0x859c <cmd_MMCdir+0x20a>
				usart_write("    <DIR> ");
    8588:	00 d0       	rcall	.+0      	; 0x858a <cmd_MMCdir+0x1f8>
    858a:	ed b7       	in	r30, 0x3d	; 61
    858c:	fe b7       	in	r31, 0x3e	; 62
    858e:	32 82       	std	Z+2, r3	; 0x02
    8590:	21 82       	std	Z+1, r2	; 0x01
    8592:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8596:	0f 90       	pop	r0
    8598:	0f 90       	pop	r0
    859a:	20 c0       	rjmp	.+64     	; 0x85dc <cmd_MMCdir+0x24a>
			else
				usart_write("%9l ",dir_entry.file_size);
    859c:	00 d0       	rcall	.+0      	; 0x859e <cmd_MMCdir+0x20c>
    859e:	00 d0       	rcall	.+0      	; 0x85a0 <cmd_MMCdir+0x20e>
    85a0:	00 d0       	rcall	.+0      	; 0x85a2 <cmd_MMCdir+0x210>
    85a2:	e2 ed       	ldi	r30, 0xD2	; 210
    85a4:	ff e1       	ldi	r31, 0x1F	; 31
    85a6:	ad b7       	in	r26, 0x3d	; 61
    85a8:	be b7       	in	r27, 0x3e	; 62
    85aa:	12 96       	adiw	r26, 0x02	; 2
    85ac:	fc 93       	st	X, r31
    85ae:	ee 93       	st	-X, r30
    85b0:	11 97       	sbiw	r26, 0x01	; 1
    85b2:	8b ad       	ldd	r24, Y+59	; 0x3b
    85b4:	9c ad       	ldd	r25, Y+60	; 0x3c
    85b6:	ad ad       	ldd	r26, Y+61	; 0x3d
    85b8:	be ad       	ldd	r27, Y+62	; 0x3e
    85ba:	ed b7       	in	r30, 0x3d	; 61
    85bc:	fe b7       	in	r31, 0x3e	; 62
    85be:	83 83       	std	Z+3, r24	; 0x03
    85c0:	94 83       	std	Z+4, r25	; 0x04
    85c2:	a5 83       	std	Z+5, r26	; 0x05
    85c4:	b6 83       	std	Z+6, r27	; 0x06
    85c6:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    85ca:	2d b7       	in	r18, 0x3d	; 61
    85cc:	3e b7       	in	r19, 0x3e	; 62
    85ce:	2a 5f       	subi	r18, 0xFA	; 250
    85d0:	3f 4f       	sbci	r19, 0xFF	; 255
    85d2:	0f b6       	in	r0, 0x3f	; 63
    85d4:	f8 94       	cli
    85d6:	3e bf       	out	0x3e, r19	; 62
    85d8:	0f be       	out	0x3f, r0	; 63
    85da:	2d bf       	out	0x3d, r18	; 61

			usart_write("%s",dir_entry.long_name);
    85dc:	00 d0       	rcall	.+0      	; 0x85de <cmd_MMCdir+0x24c>
    85de:	00 d0       	rcall	.+0      	; 0x85e0 <cmd_MMCdir+0x24e>
    85e0:	ef ec       	ldi	r30, 0xCF	; 207
    85e2:	ff e1       	ldi	r31, 0x1F	; 31
    85e4:	ad b7       	in	r26, 0x3d	; 61
    85e6:	be b7       	in	r27, 0x3e	; 62
    85e8:	12 96       	adiw	r26, 0x02	; 2
    85ea:	fc 93       	st	X, r31
    85ec:	ee 93       	st	-X, r30
    85ee:	11 97       	sbiw	r26, 0x01	; 1
    85f0:	14 96       	adiw	r26, 0x04	; 4
    85f2:	dc 92       	st	X, r13
    85f4:	ce 92       	st	-X, r12
    85f6:	13 97       	sbiw	r26, 0x03	; 3
    85f8:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    85fc:	0f 90       	pop	r0
    85fe:	0f 90       	pop	r0
    8600:	0f 90       	pop	r0
    8602:	0f 90       	pop	r0
    8604:	1c c0       	rjmp	.+56     	; 0x863e <cmd_MMCdir+0x2ac>
	uint8_t hour;
	uint8_t min;
	uint8_t sec;

    /* Verzeichniseintrge lesen */
    while(fat16_read_dir(cwdir_ptr, &dir_entry))
    8606:	44 e1       	ldi	r20, 0x14	; 20
    8608:	c4 2e       	mov	r12, r20
    860a:	d1 2c       	mov	r13, r1
    860c:	cc 0e       	add	r12, r28
    860e:	dd 1e       	adc	r13, r29
			#endif
		}
		else {
			usart_write("\r\n%2i.%2i.%i %2i:%2i ",day, month, year, hour, min);
			if (dir_entry.attributes & FAT16_ATTRIB_DIR)
				usart_write("    <DIR> ");
    8610:	37 ed       	ldi	r19, 0xD7	; 215
    8612:	23 2e       	mov	r2, r19
    8614:	3f e1       	ldi	r19, 0x1F	; 31
    8616:	33 2e       	mov	r3, r19
    8618:	28 e0       	ldi	r18, 0x08	; 8
    861a:	a2 2e       	mov	r10, r18
    861c:	b1 2c       	mov	r11, r1
    861e:	ac 0e       	add	r10, r28
    8620:	bd 1e       	adc	r11, r29
			}
			else {
				sprintf_P(tmpbuf,PSTR("%ld"),dir_entry.file_size);
			}

			sprintf_P((char *)pstr,PSTR("%i-%i-%i %i:%i:%i %8s %s\r\n"),month, day, year, hour, min, sec, tmpbuf,dir_entry.long_name);
    8622:	98 ef       	ldi	r25, 0xF8	; 248
    8624:	49 2e       	mov	r4, r25
    8626:	9f e1       	ldi	r25, 0x1F	; 31
    8628:	59 2e       	mov	r5, r25
			#endif

			while (*pstr++);	// bis auf '\0' vorzhlen
			--pstr;

			if (pstr > (outbuffer + MAX_WINDOWS_SIZE - 64)) {	// mind. 64 Bytes fr nchsten Eintrag freilassen
    862a:	8c e0       	ldi	r24, 0x0C	; 12
    862c:	88 2e       	mov	r8, r24
    862e:	84 e0       	ldi	r24, 0x04	; 4
    8630:	98 2e       	mov	r9, r24
    8632:	80 0e       	add	r8, r16
    8634:	91 1e       	adc	r9, r17
			*/
			if (dir_entry.attributes & FAT16_ATTRIB_DIR) {
				strcpy_P((char *)tmpbuf,PSTR("<DIR>"));
			}
			else {
				sprintf_P(tmpbuf,PSTR("%ld"),dir_entry.file_size);
    8636:	b3 e1       	ldi	r27, 0x13	; 19
    8638:	6b 2e       	mov	r6, r27
    863a:	b0 e2       	ldi	r27, 0x20	; 32
    863c:	7b 2e       	mov	r7, r27
	uint8_t hour;
	uint8_t min;
	uint8_t sec;

    /* Verzeichniseintrge lesen */
    while(fat16_read_dir(cwdir_ptr, &dir_entry))
    863e:	80 91 cb 0d 	lds	r24, 0x0DCB
    8642:	90 91 cc 0d 	lds	r25, 0x0DCC
    8646:	b6 01       	movw	r22, r12
    8648:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    864c:	88 23       	and	r24, r24
    864e:	09 f0       	breq	.+2      	; 0x8652 <cmd_MMCdir+0x2c0>
    8650:	dd ce       	rjmp	.-582    	; 0x840c <cmd_MMCdir+0x7a>
			usart_write("%s",dir_entry.long_name);
		}
    }

	#if TCP_SERVICE
	if (!tcpsrv_status.LISTcontinue)
    8652:	80 91 71 0d 	lds	r24, 0x0D71
    8656:	81 fd       	sbrc	r24, 1
    8658:	06 c0       	rjmp	.+12     	; 0x8666 <cmd_MMCdir+0x2d4>
		fat16_reset_dir(cwdir_ptr);
    865a:	80 91 cb 0d 	lds	r24, 0x0DCB
    865e:	90 91 cc 0d 	lds	r25, 0x0DCC
    8662:	0e 94 f2 50 	call	0xa1e4	; 0xa1e4 <fat16_reset_dir>
	#endif

	if (outbuffer)
    8666:	01 15       	cp	r16, r1
    8668:	11 05       	cpc	r17, r1
    866a:	41 f0       	breq	.+16     	; 0x867c <cmd_MMCdir+0x2ea>
		return strlen(outbuffer);
    866c:	d8 01       	movw	r26, r16
    866e:	0d 90       	ld	r0, X+
    8670:	00 20       	and	r0, r0
    8672:	e9 f7       	brne	.-6      	; 0x866e <cmd_MMCdir+0x2dc>
    8674:	11 97       	sbiw	r26, 0x01	; 1
    8676:	a0 1b       	sub	r26, r16
    8678:	b1 0b       	sbc	r27, r17
    867a:	02 c0       	rjmp	.+4      	; 0x8680 <cmd_MMCdir+0x2ee>
    867c:	a0 e0       	ldi	r26, 0x00	; 0
    867e:	b0 e0       	ldi	r27, 0x00	; 0
	else
#endif
		return 0;
}
    8680:	cd 01       	movw	r24, r26
    8682:	ce 5b       	subi	r28, 0xBE	; 190
    8684:	df 4f       	sbci	r29, 0xFF	; 255
    8686:	0f b6       	in	r0, 0x3f	; 63
    8688:	f8 94       	cli
    868a:	de bf       	out	0x3e, r29	; 62
    868c:	0f be       	out	0x3f, r0	; 63
    868e:	cd bf       	out	0x3d, r28	; 61
    8690:	cf 91       	pop	r28
    8692:	df 91       	pop	r29
    8694:	1f 91       	pop	r17
    8696:	0f 91       	pop	r16
    8698:	ff 90       	pop	r15
    869a:	ef 90       	pop	r14
    869c:	df 90       	pop	r13
    869e:	cf 90       	pop	r12
    86a0:	bf 90       	pop	r11
    86a2:	af 90       	pop	r10
    86a4:	9f 90       	pop	r9
    86a6:	8f 90       	pop	r8
    86a8:	7f 90       	pop	r7
    86aa:	6f 90       	pop	r6
    86ac:	5f 90       	pop	r5
    86ae:	4f 90       	pop	r4
    86b0:	3f 90       	pop	r3
    86b2:	2f 90       	pop	r2
    86b4:	08 95       	ret

000086b6 <cmd_DNSQ>:
 *
 * \b Syntax: DNSQ \<hostname\>
 */
int16_t cmd_DNSQ(char *outbuffer)
{
	dns_request(argv,&dnsQueryIP);
    86b6:	80 91 6e 0d 	lds	r24, 0x0D6E
    86ba:	90 91 6f 0d 	lds	r25, 0x0D6F
    86be:	66 e6       	ldi	r22, 0x66	; 102
    86c0:	7d e0       	ldi	r23, 0x0D	; 13
    86c2:	0e 94 8c 36 	call	0x6d18	; 0x6d18 <dns_request>

	return 0;
}
    86c6:	80 e0       	ldi	r24, 0x00	; 0
    86c8:	90 e0       	ldi	r25, 0x00	; 0
    86ca:	08 95       	ret

000086cc <command_mail>:
 *
 *	\b Syntax: mail \<mailno\> <br>
 *	\<mailno\> ist dabei die Nummer einer vorhandenen Mail in mail.ini
 */
int16_t command_mail (char *outbuffer)
{
    86cc:	0f 93       	push	r16
    86ce:	1f 93       	push	r17
    86d0:	8c 01       	movw	r16, r24
	machineStatus.sendmail = atoi(argv);
    86d2:	80 91 6e 0d 	lds	r24, 0x0D6E
    86d6:	90 91 6f 0d 	lds	r25, 0x0D6F
    86da:	0e 94 87 6d 	call	0xdb0e	; 0xdb0e <atoi>
    86de:	80 93 43 06 	sts	0x0643, r24
	return cmd_250(outbuffer);
    86e2:	c8 01       	movw	r24, r16
    86e4:	0e 94 43 3e 	call	0x7c86	; 0x7c86 <cmd_250>
}
    86e8:	1f 91       	pop	r17
    86ea:	0f 91       	pop	r16
    86ec:	08 95       	ret

000086ee <command_ntp_refresh>:
/**
 * \ingroup tcpcmdcommon
 * \b NTPR-Befehl Time Refresh via NTP-Server
 */
int16_t command_ntp_refresh (char *outbuffer)
{
    86ee:	0f 93       	push	r16
    86f0:	1f 93       	push	r17
    86f2:	8c 01       	movw	r16, r24
	#if USE_NTP
	ntp_request();
    86f4:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <ntp_request>
	#endif //USE_NTP
	return cmd_250(outbuffer);
    86f8:	c8 01       	movw	r24, r16
    86fa:	0e 94 43 3e 	call	0x7c86	; 0x7c86 <cmd_250>
}
    86fe:	1f 91       	pop	r17
    8700:	0f 91       	pop	r16
    8702:	08 95       	ret

00008704 <getLong>:
 * \param[out] pstr uint32_t(long)-Pointer fr Ergebniswert
 * \returns 0 bei Fehler (kein(e) weiteren Werte vorhanden),<br>
 *  1 bei erfolgreicher Konversion
 */
uint8_t getLong(uint32_t *pstr)
{
    8704:	cf 93       	push	r28
    8706:	df 93       	push	r29
    8708:	ec 01       	movw	r28, r24
	char *ps = strsep(&argv,"., ");
    870a:	8e e6       	ldi	r24, 0x6E	; 110
    870c:	9d e0       	ldi	r25, 0x0D	; 13
    870e:	6e e6       	ldi	r22, 0x6E	; 110
    8710:	71 e0       	ldi	r23, 0x01	; 1
    8712:	0e 94 dc 6e 	call	0xddb8	; 0xddb8 <strsep>

	if (ps) {
    8716:	00 97       	sbiw	r24, 0x00	; 0
    8718:	11 f4       	brne	.+4      	; 0x871e <getLong+0x1a>
    871a:	80 e0       	ldi	r24, 0x00	; 0
    871c:	0b c0       	rjmp	.+22     	; 0x8734 <getLong+0x30>
		*pstr = strtoul(ps,NULL,0);
    871e:	60 e0       	ldi	r22, 0x00	; 0
    8720:	70 e0       	ldi	r23, 0x00	; 0
    8722:	40 e0       	ldi	r20, 0x00	; 0
    8724:	50 e0       	ldi	r21, 0x00	; 0
    8726:	0e 94 89 6c 	call	0xd912	; 0xd912 <strtoul>
    872a:	68 83       	st	Y, r22
    872c:	79 83       	std	Y+1, r23	; 0x01
    872e:	8a 83       	std	Y+2, r24	; 0x02
    8730:	9b 83       	std	Y+3, r25	; 0x03
    8732:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    8734:	df 91       	pop	r29
    8736:	cf 91       	pop	r28
    8738:	08 95       	ret

0000873a <command_ping>:
/**
 * \ingroup tcpcmd
 * \b PING-Befehl Sende "Ping" an angegebene Adresse
 */
int16_t command_ping (char *outbuffer)
{
    873a:	af 92       	push	r10
    873c:	bf 92       	push	r11
    873e:	cf 92       	push	r12
    8740:	df 92       	push	r13
    8742:	ef 92       	push	r14
    8744:	ff 92       	push	r15
    8746:	0f 93       	push	r16
    8748:	1f 93       	push	r17
    874a:	df 93       	push	r29
    874c:	cf 93       	push	r28
    874e:	00 d0       	rcall	.+0      	; 0x8750 <command_ping+0x16>
    8750:	00 d0       	rcall	.+0      	; 0x8752 <command_ping+0x18>
    8752:	cd b7       	in	r28, 0x3d	; 61
    8754:	de b7       	in	r29, 0x3e	; 62
	uint32_t var = 0;
    8756:	19 82       	std	Y+1, r1	; 0x01
    8758:	1a 82       	std	Y+2, r1	; 0x02
    875a:	1b 82       	std	Y+3, r1	; 0x03
    875c:	1c 82       	std	Y+4, r1	; 0x04

	if (getLong(&var))
    875e:	5e 01       	movw	r10, r28
    8760:	08 94       	sec
    8762:	a1 1c       	adc	r10, r1
    8764:	b1 1c       	adc	r11, r1
    8766:	c5 01       	movw	r24, r10
    8768:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    876c:	88 23       	and	r24, r24
    876e:	89 f1       	breq	.+98     	; 0x87d2 <command_ping+0x98>
    8770:	ee 24       	eor	r14, r14
    8772:	ff 24       	eor	r15, r15
    8774:	87 01       	movw	r16, r14
    8776:	cc 24       	eor	r12, r12
    8778:	dd 24       	eor	r13, r13
	{
		unsigned long dest_ip=0;

		for (uint8_t i=0; i<4; ++i) {
			dest_ip += (var<<(8*i));
    877a:	89 81       	ldd	r24, Y+1	; 0x01
    877c:	9a 81       	ldd	r25, Y+2	; 0x02
    877e:	ab 81       	ldd	r26, Y+3	; 0x03
    8780:	bc 81       	ldd	r27, Y+4	; 0x04
    8782:	0c 2c       	mov	r0, r12
    8784:	04 c0       	rjmp	.+8      	; 0x878e <command_ping+0x54>
    8786:	88 0f       	add	r24, r24
    8788:	99 1f       	adc	r25, r25
    878a:	aa 1f       	adc	r26, r26
    878c:	bb 1f       	adc	r27, r27
    878e:	0a 94       	dec	r0
    8790:	d2 f7       	brpl	.-12     	; 0x8786 <command_ping+0x4c>
    8792:	e8 0e       	add	r14, r24
    8794:	f9 1e       	adc	r15, r25
    8796:	0a 1f       	adc	r16, r26
    8798:	1b 1f       	adc	r17, r27
			if (!getLong(&var))
    879a:	c5 01       	movw	r24, r10
    879c:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    87a0:	88 23       	and	r24, r24
    87a2:	41 f0       	breq	.+16     	; 0x87b4 <command_ping+0x7a>
				break;
    87a4:	88 e0       	ldi	r24, 0x08	; 8
    87a6:	90 e0       	ldi	r25, 0x00	; 0
    87a8:	c8 0e       	add	r12, r24
    87aa:	d9 1e       	adc	r13, r25

	if (getLong(&var))
	{
		unsigned long dest_ip=0;

		for (uint8_t i=0; i<4; ++i) {
    87ac:	90 e2       	ldi	r25, 0x20	; 32
    87ae:	c9 16       	cp	r12, r25
    87b0:	d1 04       	cpc	r13, r1
    87b2:	19 f7       	brne	.-58     	; 0x877a <command_ping+0x40>
			if (!getLong(&var))
				break;
		}

		//ARP Request senden
		arp_request (dest_ip);
    87b4:	c8 01       	movw	r24, r16
    87b6:	b7 01       	movw	r22, r14
    87b8:	0e 94 9e 1e 	call	0x3d3c	; 0x3d3c <arp_request>
		
		//ICMP-Nachricht Type=8 Code=0: Echo-Anfrage
		//TODO: Sequenznummer, Identifier 
		icmp_send(dest_ip,0x08,0x00,1,1);
    87bc:	c8 01       	movw	r24, r16
    87be:	b7 01       	movw	r22, r14
    87c0:	48 e0       	ldi	r20, 0x08	; 8
    87c2:	20 e0       	ldi	r18, 0x00	; 0
    87c4:	01 e0       	ldi	r16, 0x01	; 1
    87c6:	10 e0       	ldi	r17, 0x00	; 0
    87c8:	51 e0       	ldi	r21, 0x01	; 1
    87ca:	e5 2e       	mov	r14, r21
    87cc:	f1 2c       	mov	r15, r1
    87ce:	0e 94 cf 1c 	call	0x399e	; 0x399e <icmp_send>
	}
	return 0;
}
    87d2:	80 e0       	ldi	r24, 0x00	; 0
    87d4:	90 e0       	ldi	r25, 0x00	; 0
    87d6:	0f 90       	pop	r0
    87d8:	0f 90       	pop	r0
    87da:	0f 90       	pop	r0
    87dc:	0f 90       	pop	r0
    87de:	cf 91       	pop	r28
    87e0:	df 91       	pop	r29
    87e2:	1f 91       	pop	r17
    87e4:	0f 91       	pop	r16
    87e6:	ff 90       	pop	r15
    87e8:	ef 90       	pop	r14
    87ea:	df 90       	pop	r13
    87ec:	cf 90       	pop	r12
    87ee:	bf 90       	pop	r11
    87f0:	af 90       	pop	r10
    87f2:	08 95       	ret

000087f4 <cmd_DNSR>:
 * \b DNS-Reverse-Lookup Befehl
 *
 * \b Syntax: DNSR \<ip\>
 */
int16_t cmd_DNSR(char *outbuffer)
{
    87f4:	af 92       	push	r10
    87f6:	bf 92       	push	r11
    87f8:	cf 92       	push	r12
    87fa:	df 92       	push	r13
    87fc:	ef 92       	push	r14
    87fe:	ff 92       	push	r15
    8800:	0f 93       	push	r16
    8802:	1f 93       	push	r17
    8804:	df 93       	push	r29
    8806:	cf 93       	push	r28
    8808:	00 d0       	rcall	.+0      	; 0x880a <cmd_DNSR+0x16>
    880a:	00 d0       	rcall	.+0      	; 0x880c <cmd_DNSR+0x18>
    880c:	cd b7       	in	r28, 0x3d	; 61
    880e:	de b7       	in	r29, 0x3e	; 62
	uint32_t ip = 0;
	uint32_t var;

	if (getLong(&var)) {
    8810:	5e 01       	movw	r10, r28
    8812:	08 94       	sec
    8814:	a1 1c       	adc	r10, r1
    8816:	b1 1c       	adc	r11, r1
    8818:	c5 01       	movw	r24, r10
    881a:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    881e:	88 23       	and	r24, r24
    8820:	21 f4       	brne	.+8      	; 0x882a <cmd_DNSR+0x36>
    8822:	ee 24       	eor	r14, r14
    8824:	ff 24       	eor	r15, r15
    8826:	87 01       	movw	r16, r14
    8828:	22 c0       	rjmp	.+68     	; 0x886e <cmd_DNSR+0x7a>
    882a:	ee 24       	eor	r14, r14
    882c:	ff 24       	eor	r15, r15
    882e:	87 01       	movw	r16, r14
    8830:	cc 24       	eor	r12, r12
    8832:	dd 24       	eor	r13, r13

		for (unsigned char count=0; count<4;++count) {
			ip += ( var<<(count*8) );
    8834:	89 81       	ldd	r24, Y+1	; 0x01
    8836:	9a 81       	ldd	r25, Y+2	; 0x02
    8838:	ab 81       	ldd	r26, Y+3	; 0x03
    883a:	bc 81       	ldd	r27, Y+4	; 0x04
    883c:	0c 2c       	mov	r0, r12
    883e:	04 c0       	rjmp	.+8      	; 0x8848 <cmd_DNSR+0x54>
    8840:	88 0f       	add	r24, r24
    8842:	99 1f       	adc	r25, r25
    8844:	aa 1f       	adc	r26, r26
    8846:	bb 1f       	adc	r27, r27
    8848:	0a 94       	dec	r0
    884a:	d2 f7       	brpl	.-12     	; 0x8840 <cmd_DNSR+0x4c>
    884c:	e8 0e       	add	r14, r24
    884e:	f9 1e       	adc	r15, r25
    8850:	0a 1f       	adc	r16, r26
    8852:	1b 1f       	adc	r17, r27
			if (!getLong(&var))
    8854:	c5 01       	movw	r24, r10
    8856:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    885a:	88 23       	and	r24, r24
    885c:	41 f0       	breq	.+16     	; 0x886e <cmd_DNSR+0x7a>
				break;
    885e:	88 e0       	ldi	r24, 0x08	; 8
    8860:	90 e0       	ldi	r25, 0x00	; 0
    8862:	c8 0e       	add	r12, r24
    8864:	d9 1e       	adc	r13, r25
	uint32_t ip = 0;
	uint32_t var;

	if (getLong(&var)) {

		for (unsigned char count=0; count<4;++count) {
    8866:	90 e2       	ldi	r25, 0x20	; 32
    8868:	c9 16       	cp	r12, r25
    886a:	d1 04       	cpc	r13, r1
    886c:	19 f7       	brne	.-58     	; 0x8834 <cmd_DNSR+0x40>
		}
	}

	// berschreibt den IP-String in der Kommandozeile (usart_rx_buffer)
	// mit dem gefundenen hostnamen
	dns_reverse_request(ip,usart_rx_buffer);
    886e:	c8 01       	movw	r24, r16
    8870:	b7 01       	movw	r22, r14
    8872:	46 ef       	ldi	r20, 0xF6	; 246
    8874:	5b e0       	ldi	r21, 0x0B	; 11
    8876:	0e 94 93 36 	call	0x6d26	; 0x6d26 <dns_reverse_request>

	return 0;
}
    887a:	80 e0       	ldi	r24, 0x00	; 0
    887c:	90 e0       	ldi	r25, 0x00	; 0
    887e:	0f 90       	pop	r0
    8880:	0f 90       	pop	r0
    8882:	0f 90       	pop	r0
    8884:	0f 90       	pop	r0
    8886:	cf 91       	pop	r28
    8888:	df 91       	pop	r29
    888a:	1f 91       	pop	r17
    888c:	0f 91       	pop	r16
    888e:	ff 90       	pop	r15
    8890:	ef 90       	pop	r14
    8892:	df 90       	pop	r13
    8894:	cf 90       	pop	r12
    8896:	bf 90       	pop	r11
    8898:	af 90       	pop	r10
    889a:	08 95       	ret

0000889c <write_eeprom_ip>:
 * IP aus CMD-Parameter im EEPROM speichern
 *
 * \param[in] eeprom_adresse Speicheradresse im EEPROM
 */
void write_eeprom_ip (unsigned int eeprom_adresse)
{
    889c:	cf 92       	push	r12
    889e:	df 92       	push	r13
    88a0:	ff 92       	push	r15
    88a2:	0f 93       	push	r16
    88a4:	1f 93       	push	r17
    88a6:	df 93       	push	r29
    88a8:	cf 93       	push	r28
    88aa:	00 d0       	rcall	.+0      	; 0x88ac <write_eeprom_ip+0x10>
    88ac:	00 d0       	rcall	.+0      	; 0x88ae <write_eeprom_ip+0x12>
    88ae:	cd b7       	in	r28, 0x3d	; 61
    88b0:	de b7       	in	r29, 0x3e	; 62
    88b2:	8c 01       	movw	r16, r24
	uint32_t var;

	if (getLong(&var))
    88b4:	6e 01       	movw	r12, r28
    88b6:	08 94       	sec
    88b8:	c1 1c       	adc	r12, r1
    88ba:	d1 1c       	adc	r13, r1
    88bc:	c6 01       	movw	r24, r12
    88be:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    88c2:	88 23       	and	r24, r24
    88c4:	91 f0       	breq	.+36     	; 0x88ea <write_eeprom_ip+0x4e>
    88c6:	ff 24       	eor	r15, r15
	{
		//value ins EEPROM schreiben
		for (unsigned char count = 0; count<4;count++)
		{
			eeprom_busy_wait ();
    88c8:	f9 99       	sbic	0x1f, 1	; 31
    88ca:	fe cf       	rjmp	.-4      	; 0x88c8 <write_eeprom_ip+0x2c>
			eeprom_write_byte((unsigned char *)(eeprom_adresse + count),(uint8_t)var);
    88cc:	c8 01       	movw	r24, r16
    88ce:	69 81       	ldd	r22, Y+1	; 0x01
    88d0:	0e 94 47 71 	call	0xe28e	; 0xe28e <__eewr_byte_m644p>
			if (!getLong(&var))
    88d4:	c6 01       	movw	r24, r12
    88d6:	0e 94 82 43 	call	0x8704	; 0x8704 <getLong>
    88da:	88 23       	and	r24, r24
    88dc:	31 f0       	breq	.+12     	; 0x88ea <write_eeprom_ip+0x4e>
	uint32_t var;

	if (getLong(&var))
	{
		//value ins EEPROM schreiben
		for (unsigned char count = 0; count<4;count++)
    88de:	f3 94       	inc	r15
    88e0:	0f 5f       	subi	r16, 0xFF	; 255
    88e2:	1f 4f       	sbci	r17, 0xFF	; 255
    88e4:	84 e0       	ldi	r24, 0x04	; 4
    88e6:	f8 16       	cp	r15, r24
    88e8:	79 f7       	brne	.-34     	; 0x88c8 <write_eeprom_ip+0x2c>
			eeprom_write_byte((unsigned char *)(eeprom_adresse + count),(uint8_t)var);
			if (!getLong(&var))
				break;
		}
	}
}
    88ea:	0f 90       	pop	r0
    88ec:	0f 90       	pop	r0
    88ee:	0f 90       	pop	r0
    88f0:	0f 90       	pop	r0
    88f2:	cf 91       	pop	r28
    88f4:	df 91       	pop	r29
    88f6:	1f 91       	pop	r17
    88f8:	0f 91       	pop	r16
    88fa:	ff 90       	pop	r15
    88fc:	df 90       	pop	r13
    88fe:	cf 90       	pop	r12
    8900:	08 95       	ret

00008902 <cmd_DNS>:
 * \b DNS-Befehl IP des DNS-Server anzeigen/setzen
 *
 * \b Syntax: DNS [a.b.c.d]
 */
int16_t cmd_DNS(char *outbuffer)
{
    8902:	cf 93       	push	r28
    8904:	df 93       	push	r29
    8906:	ec 01       	movw	r28, r24
	write_eeprom_ip(DNS_IP_EEPROM_STORE);
    8908:	8a e2       	ldi	r24, 0x2A	; 42
    890a:	90 e0       	ldi	r25, 0x00	; 0
    890c:	0e 94 4e 44 	call	0x889c	; 0x889c <write_eeprom_ip>
	(*((unsigned long*)&dns_server_ip[0])) = get_eeprom_value(DNS_IP_EEPROM_STORE,DNS_IP);
    8910:	8a e2       	ldi	r24, 0x2A	; 42
    8912:	90 e0       	ldi	r25, 0x00	; 0
    8914:	40 ec       	ldi	r20, 0xC0	; 192
    8916:	58 ea       	ldi	r21, 0xA8	; 168
    8918:	60 e0       	ldi	r22, 0x00	; 0
    891a:	71 e0       	ldi	r23, 0x01	; 1
    891c:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    8920:	60 93 6a 0d 	sts	0x0D6A, r22
    8924:	70 93 6b 0d 	sts	0x0D6B, r23
    8928:	80 93 6c 0d 	sts	0x0D6C, r24
    892c:	90 93 6d 0d 	sts	0x0D6D, r25
	if (outbuffer) {
    8930:	20 97       	sbiw	r28, 0x00	; 0
    8932:	b9 f1       	breq	.+110    	; 0x89a2 <cmd_DNS+0xa0>
		sprintf_P(outbuffer,PSTR("250 ok. DNS IP: %i.%i.%i.%i\r\n"),dns_server_ip[0],dns_server_ip[1],dns_server_ip[2],dns_server_ip[3]);
    8934:	8d b7       	in	r24, 0x3d	; 61
    8936:	9e b7       	in	r25, 0x3e	; 62
    8938:	0c 97       	sbiw	r24, 0x0c	; 12
    893a:	0f b6       	in	r0, 0x3f	; 63
    893c:	f8 94       	cli
    893e:	9e bf       	out	0x3e, r25	; 62
    8940:	0f be       	out	0x3f, r0	; 63
    8942:	8d bf       	out	0x3d, r24	; 61
    8944:	ed b7       	in	r30, 0x3d	; 61
    8946:	fe b7       	in	r31, 0x3e	; 62
    8948:	31 96       	adiw	r30, 0x01	; 1
    894a:	ad b7       	in	r26, 0x3d	; 61
    894c:	be b7       	in	r27, 0x3e	; 62
    894e:	12 96       	adiw	r26, 0x02	; 2
    8950:	dc 93       	st	X, r29
    8952:	ce 93       	st	-X, r28
    8954:	11 97       	sbiw	r26, 0x01	; 1
    8956:	8d e4       	ldi	r24, 0x4D	; 77
    8958:	90 e2       	ldi	r25, 0x20	; 32
    895a:	93 83       	std	Z+3, r25	; 0x03
    895c:	82 83       	std	Z+2, r24	; 0x02
    895e:	80 91 6a 0d 	lds	r24, 0x0D6A
    8962:	84 83       	std	Z+4, r24	; 0x04
    8964:	15 82       	std	Z+5, r1	; 0x05
    8966:	80 91 6b 0d 	lds	r24, 0x0D6B
    896a:	86 83       	std	Z+6, r24	; 0x06
    896c:	17 82       	std	Z+7, r1	; 0x07
    896e:	80 91 6c 0d 	lds	r24, 0x0D6C
    8972:	80 87       	std	Z+8, r24	; 0x08
    8974:	11 86       	std	Z+9, r1	; 0x09
    8976:	80 91 6d 0d 	lds	r24, 0x0D6D
    897a:	82 87       	std	Z+10, r24	; 0x0a
    897c:	13 86       	std	Z+11, r1	; 0x0b
    897e:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8982:	de 01       	movw	r26, r28
    8984:	0d 90       	ld	r0, X+
    8986:	00 20       	and	r0, r0
    8988:	e9 f7       	brne	.-6      	; 0x8984 <cmd_DNS+0x82>
    898a:	11 97       	sbiw	r26, 0x01	; 1
    898c:	ac 1b       	sub	r26, r28
    898e:	bd 0b       	sbc	r27, r29
    8990:	8d b7       	in	r24, 0x3d	; 61
    8992:	9e b7       	in	r25, 0x3e	; 62
    8994:	0c 96       	adiw	r24, 0x0c	; 12
    8996:	0f b6       	in	r0, 0x3f	; 63
    8998:	f8 94       	cli
    899a:	9e bf       	out	0x3e, r25	; 62
    899c:	0f be       	out	0x3f, r0	; 63
    899e:	8d bf       	out	0x3d, r24	; 61
    89a0:	35 c0       	rjmp	.+106    	; 0x8a0c <cmd_DNS+0x10a>
	}
	else {
		usart_write("DNS IP: %1i.%1i.%1i.%1i\r\n",dns_server_ip[0],dns_server_ip[1],dns_server_ip[2],dns_server_ip[3]);
    89a2:	ad b7       	in	r26, 0x3d	; 61
    89a4:	be b7       	in	r27, 0x3e	; 62
    89a6:	1a 97       	sbiw	r26, 0x0a	; 10
    89a8:	0f b6       	in	r0, 0x3f	; 63
    89aa:	f8 94       	cli
    89ac:	be bf       	out	0x3e, r27	; 62
    89ae:	0f be       	out	0x3f, r0	; 63
    89b0:	ad bf       	out	0x3d, r26	; 61
    89b2:	ed b7       	in	r30, 0x3d	; 61
    89b4:	fe b7       	in	r31, 0x3e	; 62
    89b6:	31 96       	adiw	r30, 0x01	; 1
    89b8:	83 e3       	ldi	r24, 0x33	; 51
    89ba:	90 e2       	ldi	r25, 0x20	; 32
    89bc:	12 96       	adiw	r26, 0x02	; 2
    89be:	9c 93       	st	X, r25
    89c0:	8e 93       	st	-X, r24
    89c2:	11 97       	sbiw	r26, 0x01	; 1
    89c4:	80 91 6a 0d 	lds	r24, 0x0D6A
    89c8:	82 83       	std	Z+2, r24	; 0x02
    89ca:	13 82       	std	Z+3, r1	; 0x03
    89cc:	80 91 6b 0d 	lds	r24, 0x0D6B
    89d0:	84 83       	std	Z+4, r24	; 0x04
    89d2:	15 82       	std	Z+5, r1	; 0x05
    89d4:	80 91 6c 0d 	lds	r24, 0x0D6C
    89d8:	86 83       	std	Z+6, r24	; 0x06
    89da:	17 82       	std	Z+7, r1	; 0x07
    89dc:	80 91 6d 0d 	lds	r24, 0x0D6D
    89e0:	80 87       	std	Z+8, r24	; 0x08
    89e2:	11 86       	std	Z+9, r1	; 0x09
    89e4:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		dns_reverse_request(IP(192,168,52,200),usart_rx_buffer);
    89e8:	8d b7       	in	r24, 0x3d	; 61
    89ea:	9e b7       	in	r25, 0x3e	; 62
    89ec:	0a 96       	adiw	r24, 0x0a	; 10
    89ee:	0f b6       	in	r0, 0x3f	; 63
    89f0:	f8 94       	cli
    89f2:	9e bf       	out	0x3e, r25	; 62
    89f4:	0f be       	out	0x3f, r0	; 63
    89f6:	8d bf       	out	0x3d, r24	; 61
    89f8:	60 ec       	ldi	r22, 0xC0	; 192
    89fa:	78 ea       	ldi	r23, 0xA8	; 168
    89fc:	84 e3       	ldi	r24, 0x34	; 52
    89fe:	98 ec       	ldi	r25, 0xC8	; 200
    8a00:	46 ef       	ldi	r20, 0xF6	; 246
    8a02:	5b e0       	ldi	r21, 0x0B	; 11
    8a04:	0e 94 93 36 	call	0x6d26	; 0x6d26 <dns_reverse_request>
    8a08:	a0 e0       	ldi	r26, 0x00	; 0
    8a0a:	b0 e0       	ldi	r27, 0x00	; 0
		return 0;
	}
}
    8a0c:	cd 01       	movw	r24, r26
    8a0e:	df 91       	pop	r29
    8a10:	cf 91       	pop	r28
    8a12:	08 95       	ret

00008a14 <command_router>:
/**
 * \ingroup tcpcmdcommon
 * \b Router-Befehl print/edit Router IP
 */
int16_t command_router (char *outbuffer)
{
    8a14:	cf 93       	push	r28
    8a16:	df 93       	push	r29
    8a18:	ec 01       	movw	r28, r24
	write_eeprom_ip(ROUTER_IP_EEPROM_STORE);
    8a1a:	86 e2       	ldi	r24, 0x26	; 38
    8a1c:	90 e0       	ldi	r25, 0x00	; 0
    8a1e:	0e 94 4e 44 	call	0x889c	; 0x889c <write_eeprom_ip>
	(*((unsigned long*)&router_ip[0])) = get_eeprom_value(ROUTER_IP_EEPROM_STORE,ROUTER_IP);
    8a22:	86 e2       	ldi	r24, 0x26	; 38
    8a24:	90 e0       	ldi	r25, 0x00	; 0
    8a26:	40 ec       	ldi	r20, 0xC0	; 192
    8a28:	58 ea       	ldi	r21, 0xA8	; 168
    8a2a:	60 e0       	ldi	r22, 0x00	; 0
    8a2c:	71 e0       	ldi	r23, 0x01	; 1
    8a2e:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    8a32:	60 93 4c 0b 	sts	0x0B4C, r22
    8a36:	70 93 4d 0b 	sts	0x0B4D, r23
    8a3a:	80 93 4e 0b 	sts	0x0B4E, r24
    8a3e:	90 93 4f 0b 	sts	0x0B4F, r25
	if (outbuffer) {
    8a42:	20 97       	sbiw	r28, 0x00	; 0
    8a44:	91 f1       	breq	.+100    	; 0x8aaa <command_router+0x96>
		sprintf_P(outbuffer,PSTR("250 ok. Router IP: %i.%i.%i.%i\r\n"),router_ip[0],router_ip[1],router_ip[2],router_ip[3]);
    8a46:	8d b7       	in	r24, 0x3d	; 61
    8a48:	9e b7       	in	r25, 0x3e	; 62
    8a4a:	0c 97       	sbiw	r24, 0x0c	; 12
    8a4c:	0f b6       	in	r0, 0x3f	; 63
    8a4e:	f8 94       	cli
    8a50:	9e bf       	out	0x3e, r25	; 62
    8a52:	0f be       	out	0x3f, r0	; 63
    8a54:	8d bf       	out	0x3d, r24	; 61
    8a56:	ed b7       	in	r30, 0x3d	; 61
    8a58:	fe b7       	in	r31, 0x3e	; 62
    8a5a:	31 96       	adiw	r30, 0x01	; 1
    8a5c:	ad b7       	in	r26, 0x3d	; 61
    8a5e:	be b7       	in	r27, 0x3e	; 62
    8a60:	12 96       	adiw	r26, 0x02	; 2
    8a62:	dc 93       	st	X, r29
    8a64:	ce 93       	st	-X, r28
    8a66:	11 97       	sbiw	r26, 0x01	; 1
    8a68:	8e ec       	ldi	r24, 0xCE	; 206
    8a6a:	91 e2       	ldi	r25, 0x21	; 33
    8a6c:	93 83       	std	Z+3, r25	; 0x03
    8a6e:	82 83       	std	Z+2, r24	; 0x02
    8a70:	80 91 4c 0b 	lds	r24, 0x0B4C
    8a74:	84 83       	std	Z+4, r24	; 0x04
    8a76:	15 82       	std	Z+5, r1	; 0x05
    8a78:	80 91 4d 0b 	lds	r24, 0x0B4D
    8a7c:	86 83       	std	Z+6, r24	; 0x06
    8a7e:	17 82       	std	Z+7, r1	; 0x07
    8a80:	80 91 4e 0b 	lds	r24, 0x0B4E
    8a84:	80 87       	std	Z+8, r24	; 0x08
    8a86:	11 86       	std	Z+9, r1	; 0x09
    8a88:	80 91 4f 0b 	lds	r24, 0x0B4F
    8a8c:	82 87       	std	Z+10, r24	; 0x0a
    8a8e:	13 86       	std	Z+11, r1	; 0x0b
    8a90:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8a94:	de 01       	movw	r26, r28
    8a96:	0d 90       	ld	r0, X+
    8a98:	00 20       	and	r0, r0
    8a9a:	e9 f7       	brne	.-6      	; 0x8a96 <command_router+0x82>
    8a9c:	11 97       	sbiw	r26, 0x01	; 1
    8a9e:	ac 1b       	sub	r26, r28
    8aa0:	bd 0b       	sbc	r27, r29
    8aa2:	8d b7       	in	r24, 0x3d	; 61
    8aa4:	9e b7       	in	r25, 0x3e	; 62
    8aa6:	0c 96       	adiw	r24, 0x0c	; 12
    8aa8:	28 c0       	rjmp	.+80     	; 0x8afa <command_router+0xe6>
	}
	else {
		usart_write("Router IP: %1i.%1i.%1i.%1i\r\n",router_ip[0],router_ip[1],router_ip[2],router_ip[3]);
    8aaa:	ad b7       	in	r26, 0x3d	; 61
    8aac:	be b7       	in	r27, 0x3e	; 62
    8aae:	1a 97       	sbiw	r26, 0x0a	; 10
    8ab0:	0f b6       	in	r0, 0x3f	; 63
    8ab2:	f8 94       	cli
    8ab4:	be bf       	out	0x3e, r27	; 62
    8ab6:	0f be       	out	0x3f, r0	; 63
    8ab8:	ad bf       	out	0x3d, r26	; 61
    8aba:	ed b7       	in	r30, 0x3d	; 61
    8abc:	fe b7       	in	r31, 0x3e	; 62
    8abe:	31 96       	adiw	r30, 0x01	; 1
    8ac0:	81 eb       	ldi	r24, 0xB1	; 177
    8ac2:	91 e2       	ldi	r25, 0x21	; 33
    8ac4:	12 96       	adiw	r26, 0x02	; 2
    8ac6:	9c 93       	st	X, r25
    8ac8:	8e 93       	st	-X, r24
    8aca:	11 97       	sbiw	r26, 0x01	; 1
    8acc:	80 91 4c 0b 	lds	r24, 0x0B4C
    8ad0:	82 83       	std	Z+2, r24	; 0x02
    8ad2:	13 82       	std	Z+3, r1	; 0x03
    8ad4:	80 91 4d 0b 	lds	r24, 0x0B4D
    8ad8:	84 83       	std	Z+4, r24	; 0x04
    8ada:	15 82       	std	Z+5, r1	; 0x05
    8adc:	80 91 4e 0b 	lds	r24, 0x0B4E
    8ae0:	86 83       	std	Z+6, r24	; 0x06
    8ae2:	17 82       	std	Z+7, r1	; 0x07
    8ae4:	80 91 4f 0b 	lds	r24, 0x0B4F
    8ae8:	80 87       	std	Z+8, r24	; 0x08
    8aea:	11 86       	std	Z+9, r1	; 0x09
    8aec:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8af0:	a0 e0       	ldi	r26, 0x00	; 0
    8af2:	b0 e0       	ldi	r27, 0x00	; 0
    8af4:	8d b7       	in	r24, 0x3d	; 61
    8af6:	9e b7       	in	r25, 0x3e	; 62
    8af8:	0a 96       	adiw	r24, 0x0a	; 10
    8afa:	0f b6       	in	r0, 0x3f	; 63
    8afc:	f8 94       	cli
    8afe:	9e bf       	out	0x3e, r25	; 62
    8b00:	0f be       	out	0x3f, r0	; 63
    8b02:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
}
    8b04:	cd 01       	movw	r24, r26
    8b06:	df 91       	pop	r29
    8b08:	cf 91       	pop	r28
    8b0a:	08 95       	ret

00008b0c <command_net>:
/**
 * \ingroup tcpcmdcommon
 * \b Net-Befehl print/edit Netmask
 */
int16_t command_net (char *outbuffer)
{
    8b0c:	cf 93       	push	r28
    8b0e:	df 93       	push	r29
    8b10:	ec 01       	movw	r28, r24
	write_eeprom_ip(NETMASK_EEPROM_STORE);
    8b12:	82 e2       	ldi	r24, 0x22	; 34
    8b14:	90 e0       	ldi	r25, 0x00	; 0
    8b16:	0e 94 4e 44 	call	0x889c	; 0x889c <write_eeprom_ip>
	(*((unsigned long*)&netmask[0])) = get_eeprom_value(NETMASK_EEPROM_STORE,NETMASK);
    8b1a:	82 e2       	ldi	r24, 0x22	; 34
    8b1c:	90 e0       	ldi	r25, 0x00	; 0
    8b1e:	4f ef       	ldi	r20, 0xFF	; 255
    8b20:	5f ef       	ldi	r21, 0xFF	; 255
    8b22:	6f ef       	ldi	r22, 0xFF	; 255
    8b24:	70 e0       	ldi	r23, 0x00	; 0
    8b26:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    8b2a:	60 93 50 0b 	sts	0x0B50, r22
    8b2e:	70 93 51 0b 	sts	0x0B51, r23
    8b32:	80 93 52 0b 	sts	0x0B52, r24
    8b36:	90 93 53 0b 	sts	0x0B53, r25
	if (outbuffer) {
    8b3a:	20 97       	sbiw	r28, 0x00	; 0
    8b3c:	91 f1       	breq	.+100    	; 0x8ba2 <command_net+0x96>
		sprintf_P(outbuffer,PSTR("NETMASK: %i.%i.%i.%i\r\n"),netmask[0],netmask[1],netmask[2],netmask[3]);
    8b3e:	8d b7       	in	r24, 0x3d	; 61
    8b40:	9e b7       	in	r25, 0x3e	; 62
    8b42:	0c 97       	sbiw	r24, 0x0c	; 12
    8b44:	0f b6       	in	r0, 0x3f	; 63
    8b46:	f8 94       	cli
    8b48:	9e bf       	out	0x3e, r25	; 62
    8b4a:	0f be       	out	0x3f, r0	; 63
    8b4c:	8d bf       	out	0x3d, r24	; 61
    8b4e:	ed b7       	in	r30, 0x3d	; 61
    8b50:	fe b7       	in	r31, 0x3e	; 62
    8b52:	31 96       	adiw	r30, 0x01	; 1
    8b54:	ad b7       	in	r26, 0x3d	; 61
    8b56:	be b7       	in	r27, 0x3e	; 62
    8b58:	12 96       	adiw	r26, 0x02	; 2
    8b5a:	dc 93       	st	X, r29
    8b5c:	ce 93       	st	-X, r28
    8b5e:	11 97       	sbiw	r26, 0x01	; 1
    8b60:	8a e0       	ldi	r24, 0x0A	; 10
    8b62:	92 e2       	ldi	r25, 0x22	; 34
    8b64:	93 83       	std	Z+3, r25	; 0x03
    8b66:	82 83       	std	Z+2, r24	; 0x02
    8b68:	80 91 50 0b 	lds	r24, 0x0B50
    8b6c:	84 83       	std	Z+4, r24	; 0x04
    8b6e:	15 82       	std	Z+5, r1	; 0x05
    8b70:	80 91 51 0b 	lds	r24, 0x0B51
    8b74:	86 83       	std	Z+6, r24	; 0x06
    8b76:	17 82       	std	Z+7, r1	; 0x07
    8b78:	80 91 52 0b 	lds	r24, 0x0B52
    8b7c:	80 87       	std	Z+8, r24	; 0x08
    8b7e:	11 86       	std	Z+9, r1	; 0x09
    8b80:	80 91 53 0b 	lds	r24, 0x0B53
    8b84:	82 87       	std	Z+10, r24	; 0x0a
    8b86:	13 86       	std	Z+11, r1	; 0x0b
    8b88:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8b8c:	de 01       	movw	r26, r28
    8b8e:	0d 90       	ld	r0, X+
    8b90:	00 20       	and	r0, r0
    8b92:	e9 f7       	brne	.-6      	; 0x8b8e <command_net+0x82>
    8b94:	11 97       	sbiw	r26, 0x01	; 1
    8b96:	ac 1b       	sub	r26, r28
    8b98:	bd 0b       	sbc	r27, r29
    8b9a:	8d b7       	in	r24, 0x3d	; 61
    8b9c:	9e b7       	in	r25, 0x3e	; 62
    8b9e:	0c 96       	adiw	r24, 0x0c	; 12
    8ba0:	28 c0       	rjmp	.+80     	; 0x8bf2 <command_net+0xe6>
	}
	else {
		usart_write("NETMASK: %1i.%1i.%1i.%1i\r\n",netmask[0],netmask[1],netmask[2],netmask[3]);
    8ba2:	ad b7       	in	r26, 0x3d	; 61
    8ba4:	be b7       	in	r27, 0x3e	; 62
    8ba6:	1a 97       	sbiw	r26, 0x0a	; 10
    8ba8:	0f b6       	in	r0, 0x3f	; 63
    8baa:	f8 94       	cli
    8bac:	be bf       	out	0x3e, r27	; 62
    8bae:	0f be       	out	0x3f, r0	; 63
    8bb0:	ad bf       	out	0x3d, r26	; 61
    8bb2:	ed b7       	in	r30, 0x3d	; 61
    8bb4:	fe b7       	in	r31, 0x3e	; 62
    8bb6:	31 96       	adiw	r30, 0x01	; 1
    8bb8:	8f ee       	ldi	r24, 0xEF	; 239
    8bba:	91 e2       	ldi	r25, 0x21	; 33
    8bbc:	12 96       	adiw	r26, 0x02	; 2
    8bbe:	9c 93       	st	X, r25
    8bc0:	8e 93       	st	-X, r24
    8bc2:	11 97       	sbiw	r26, 0x01	; 1
    8bc4:	80 91 50 0b 	lds	r24, 0x0B50
    8bc8:	82 83       	std	Z+2, r24	; 0x02
    8bca:	13 82       	std	Z+3, r1	; 0x03
    8bcc:	80 91 51 0b 	lds	r24, 0x0B51
    8bd0:	84 83       	std	Z+4, r24	; 0x04
    8bd2:	15 82       	std	Z+5, r1	; 0x05
    8bd4:	80 91 52 0b 	lds	r24, 0x0B52
    8bd8:	86 83       	std	Z+6, r24	; 0x06
    8bda:	17 82       	std	Z+7, r1	; 0x07
    8bdc:	80 91 53 0b 	lds	r24, 0x0B53
    8be0:	80 87       	std	Z+8, r24	; 0x08
    8be2:	11 86       	std	Z+9, r1	; 0x09
    8be4:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8be8:	a0 e0       	ldi	r26, 0x00	; 0
    8bea:	b0 e0       	ldi	r27, 0x00	; 0
    8bec:	8d b7       	in	r24, 0x3d	; 61
    8bee:	9e b7       	in	r25, 0x3e	; 62
    8bf0:	0a 96       	adiw	r24, 0x0a	; 10
    8bf2:	0f b6       	in	r0, 0x3f	; 63
    8bf4:	f8 94       	cli
    8bf6:	9e bf       	out	0x3e, r25	; 62
    8bf8:	0f be       	out	0x3f, r0	; 63
    8bfa:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
}
    8bfc:	cd 01       	movw	r24, r26
    8bfe:	df 91       	pop	r29
    8c00:	cf 91       	pop	r28
    8c02:	08 95       	ret

00008c04 <command_ntp>:
/**
 * \ingroup tcpcmdcommon
 * \b NTP-Befehl print/edit NTP Server IP
 */
int16_t command_ntp (char *outbuffer)
{
    8c04:	cf 93       	push	r28
    8c06:	df 93       	push	r29
    8c08:	ec 01       	movw	r28, r24
	#if USE_NTP
	write_eeprom_ip(NTP_IP_EEPROM_STORE);
    8c0a:	82 e3       	ldi	r24, 0x32	; 50
    8c0c:	90 e0       	ldi	r25, 0x00	; 0
    8c0e:	0e 94 4e 44 	call	0x889c	; 0x889c <write_eeprom_ip>
	(*((unsigned long*)&ntp_server_ip[0])) = get_eeprom_value(NTP_IP_EEPROM_STORE,NTP_IP);
    8c12:	82 e3       	ldi	r24, 0x32	; 50
    8c14:	90 e0       	ldi	r25, 0x00	; 0
    8c16:	45 e5       	ldi	r20, 0x55	; 85
    8c18:	5a e0       	ldi	r21, 0x0A	; 10
    8c1a:	64 ec       	ldi	r22, 0xC4	; 196
    8c1c:	78 eb       	ldi	r23, 0xB8	; 184
    8c1e:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    8c22:	60 93 50 06 	sts	0x0650, r22
    8c26:	70 93 51 06 	sts	0x0651, r23
    8c2a:	80 93 52 06 	sts	0x0652, r24
    8c2e:	90 93 53 06 	sts	0x0653, r25
	if (outbuffer) {
    8c32:	20 97       	sbiw	r28, 0x00	; 0
    8c34:	91 f1       	breq	.+100    	; 0x8c9a <command_ntp+0x96>
		sprintf_P(outbuffer,PSTR("NTP_Server: %i.%i.%i.%i\r\n"),ntp_server_ip[0],ntp_server_ip[1],ntp_server_ip[2],ntp_server_ip[3]);
    8c36:	8d b7       	in	r24, 0x3d	; 61
    8c38:	9e b7       	in	r25, 0x3e	; 62
    8c3a:	0c 97       	sbiw	r24, 0x0c	; 12
    8c3c:	0f b6       	in	r0, 0x3f	; 63
    8c3e:	f8 94       	cli
    8c40:	9e bf       	out	0x3e, r25	; 62
    8c42:	0f be       	out	0x3f, r0	; 63
    8c44:	8d bf       	out	0x3d, r24	; 61
    8c46:	ed b7       	in	r30, 0x3d	; 61
    8c48:	fe b7       	in	r31, 0x3e	; 62
    8c4a:	31 96       	adiw	r30, 0x01	; 1
    8c4c:	ad b7       	in	r26, 0x3d	; 61
    8c4e:	be b7       	in	r27, 0x3e	; 62
    8c50:	12 96       	adiw	r26, 0x02	; 2
    8c52:	dc 93       	st	X, r29
    8c54:	ce 93       	st	-X, r28
    8c56:	11 97       	sbiw	r26, 0x01	; 1
    8c58:	8f e3       	ldi	r24, 0x3F	; 63
    8c5a:	92 e2       	ldi	r25, 0x22	; 34
    8c5c:	93 83       	std	Z+3, r25	; 0x03
    8c5e:	82 83       	std	Z+2, r24	; 0x02
    8c60:	80 91 50 06 	lds	r24, 0x0650
    8c64:	84 83       	std	Z+4, r24	; 0x04
    8c66:	15 82       	std	Z+5, r1	; 0x05
    8c68:	80 91 51 06 	lds	r24, 0x0651
    8c6c:	86 83       	std	Z+6, r24	; 0x06
    8c6e:	17 82       	std	Z+7, r1	; 0x07
    8c70:	80 91 52 06 	lds	r24, 0x0652
    8c74:	80 87       	std	Z+8, r24	; 0x08
    8c76:	11 86       	std	Z+9, r1	; 0x09
    8c78:	80 91 53 06 	lds	r24, 0x0653
    8c7c:	82 87       	std	Z+10, r24	; 0x0a
    8c7e:	13 86       	std	Z+11, r1	; 0x0b
    8c80:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8c84:	de 01       	movw	r26, r28
    8c86:	0d 90       	ld	r0, X+
    8c88:	00 20       	and	r0, r0
    8c8a:	e9 f7       	brne	.-6      	; 0x8c86 <command_ntp+0x82>
    8c8c:	11 97       	sbiw	r26, 0x01	; 1
    8c8e:	ac 1b       	sub	r26, r28
    8c90:	bd 0b       	sbc	r27, r29
    8c92:	8d b7       	in	r24, 0x3d	; 61
    8c94:	9e b7       	in	r25, 0x3e	; 62
    8c96:	0c 96       	adiw	r24, 0x0c	; 12
    8c98:	28 c0       	rjmp	.+80     	; 0x8cea <command_ntp+0xe6>
	}
	else {
		usart_write("NTP_Server: %1i.%1i.%1i.%1i\r\n",ntp_server_ip[0],ntp_server_ip[1],ntp_server_ip[2],ntp_server_ip[3]);
    8c9a:	ad b7       	in	r26, 0x3d	; 61
    8c9c:	be b7       	in	r27, 0x3e	; 62
    8c9e:	1a 97       	sbiw	r26, 0x0a	; 10
    8ca0:	0f b6       	in	r0, 0x3f	; 63
    8ca2:	f8 94       	cli
    8ca4:	be bf       	out	0x3e, r27	; 62
    8ca6:	0f be       	out	0x3f, r0	; 63
    8ca8:	ad bf       	out	0x3d, r26	; 61
    8caa:	ed b7       	in	r30, 0x3d	; 61
    8cac:	fe b7       	in	r31, 0x3e	; 62
    8cae:	31 96       	adiw	r30, 0x01	; 1
    8cb0:	81 e2       	ldi	r24, 0x21	; 33
    8cb2:	92 e2       	ldi	r25, 0x22	; 34
    8cb4:	12 96       	adiw	r26, 0x02	; 2
    8cb6:	9c 93       	st	X, r25
    8cb8:	8e 93       	st	-X, r24
    8cba:	11 97       	sbiw	r26, 0x01	; 1
    8cbc:	80 91 50 06 	lds	r24, 0x0650
    8cc0:	82 83       	std	Z+2, r24	; 0x02
    8cc2:	13 82       	std	Z+3, r1	; 0x03
    8cc4:	80 91 51 06 	lds	r24, 0x0651
    8cc8:	84 83       	std	Z+4, r24	; 0x04
    8cca:	15 82       	std	Z+5, r1	; 0x05
    8ccc:	80 91 52 06 	lds	r24, 0x0652
    8cd0:	86 83       	std	Z+6, r24	; 0x06
    8cd2:	17 82       	std	Z+7, r1	; 0x07
    8cd4:	80 91 53 06 	lds	r24, 0x0653
    8cd8:	80 87       	std	Z+8, r24	; 0x08
    8cda:	11 86       	std	Z+9, r1	; 0x09
    8cdc:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8ce0:	a0 e0       	ldi	r26, 0x00	; 0
    8ce2:	b0 e0       	ldi	r27, 0x00	; 0
    8ce4:	8d b7       	in	r24, 0x3d	; 61
    8ce6:	9e b7       	in	r25, 0x3e	; 62
    8ce8:	0a 96       	adiw	r24, 0x0a	; 10
    8cea:	0f b6       	in	r0, 0x3f	; 63
    8cec:	f8 94       	cli
    8cee:	9e bf       	out	0x3e, r25	; 62
    8cf0:	0f be       	out	0x3f, r0	; 63
    8cf2:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
	#endif //USE_NTP
}
    8cf4:	cd 01       	movw	r24, r26
    8cf6:	df 91       	pop	r29
    8cf8:	cf 91       	pop	r28
    8cfa:	08 95       	ret

00008cfc <command_ip>:
/**
 * \ingroup tcpcmdcommon
 * \b IP-Befehl print/edit own IP
 */
int16_t command_ip (char *outbuffer)
{
    8cfc:	cf 93       	push	r28
    8cfe:	df 93       	push	r29
    8d00:	ec 01       	movw	r28, r24
	write_eeprom_ip(IP_EEPROM_STORE);
    8d02:	8e e1       	ldi	r24, 0x1E	; 30
    8d04:	90 e0       	ldi	r25, 0x00	; 0
    8d06:	0e 94 4e 44 	call	0x889c	; 0x889c <write_eeprom_ip>
	(*((unsigned long*)&myip[0])) = get_eeprom_value(IP_EEPROM_STORE,MYIP);
    8d0a:	8e e1       	ldi	r24, 0x1E	; 30
    8d0c:	90 e0       	ldi	r25, 0x00	; 0
    8d0e:	40 ec       	ldi	r20, 0xC0	; 192
    8d10:	58 ea       	ldi	r21, 0xA8	; 168
    8d12:	61 e0       	ldi	r22, 0x01	; 1
    8d14:	73 e6       	ldi	r23, 0x63	; 99
    8d16:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <get_eeprom_value>
    8d1a:	60 93 46 0b 	sts	0x0B46, r22
    8d1e:	70 93 47 0b 	sts	0x0B47, r23
    8d22:	80 93 48 0b 	sts	0x0B48, r24
    8d26:	90 93 49 0b 	sts	0x0B49, r25
	if (outbuffer) {
    8d2a:	20 97       	sbiw	r28, 0x00	; 0
    8d2c:	91 f1       	breq	.+100    	; 0x8d92 <command_ip+0x96>
		sprintf_P(outbuffer,PSTR("My IP: %i.%i.%i.%i\r\n"),myip[0],myip[1],myip[2],myip[3]);
    8d2e:	8d b7       	in	r24, 0x3d	; 61
    8d30:	9e b7       	in	r25, 0x3e	; 62
    8d32:	0c 97       	sbiw	r24, 0x0c	; 12
    8d34:	0f b6       	in	r0, 0x3f	; 63
    8d36:	f8 94       	cli
    8d38:	9e bf       	out	0x3e, r25	; 62
    8d3a:	0f be       	out	0x3f, r0	; 63
    8d3c:	8d bf       	out	0x3d, r24	; 61
    8d3e:	ed b7       	in	r30, 0x3d	; 61
    8d40:	fe b7       	in	r31, 0x3e	; 62
    8d42:	31 96       	adiw	r30, 0x01	; 1
    8d44:	ad b7       	in	r26, 0x3d	; 61
    8d46:	be b7       	in	r27, 0x3e	; 62
    8d48:	12 96       	adiw	r26, 0x02	; 2
    8d4a:	dc 93       	st	X, r29
    8d4c:	ce 93       	st	-X, r28
    8d4e:	11 97       	sbiw	r26, 0x01	; 1
    8d50:	82 e7       	ldi	r24, 0x72	; 114
    8d52:	92 e2       	ldi	r25, 0x22	; 34
    8d54:	93 83       	std	Z+3, r25	; 0x03
    8d56:	82 83       	std	Z+2, r24	; 0x02
    8d58:	80 91 46 0b 	lds	r24, 0x0B46
    8d5c:	84 83       	std	Z+4, r24	; 0x04
    8d5e:	15 82       	std	Z+5, r1	; 0x05
    8d60:	80 91 47 0b 	lds	r24, 0x0B47
    8d64:	86 83       	std	Z+6, r24	; 0x06
    8d66:	17 82       	std	Z+7, r1	; 0x07
    8d68:	80 91 48 0b 	lds	r24, 0x0B48
    8d6c:	80 87       	std	Z+8, r24	; 0x08
    8d6e:	11 86       	std	Z+9, r1	; 0x09
    8d70:	80 91 49 0b 	lds	r24, 0x0B49
    8d74:	82 87       	std	Z+10, r24	; 0x0a
    8d76:	13 86       	std	Z+11, r1	; 0x0b
    8d78:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
		return strlen(outbuffer);
    8d7c:	de 01       	movw	r26, r28
    8d7e:	0d 90       	ld	r0, X+
    8d80:	00 20       	and	r0, r0
    8d82:	e9 f7       	brne	.-6      	; 0x8d7e <command_ip+0x82>
    8d84:	11 97       	sbiw	r26, 0x01	; 1
    8d86:	ac 1b       	sub	r26, r28
    8d88:	bd 0b       	sbc	r27, r29
    8d8a:	8d b7       	in	r24, 0x3d	; 61
    8d8c:	9e b7       	in	r25, 0x3e	; 62
    8d8e:	0c 96       	adiw	r24, 0x0c	; 12
    8d90:	28 c0       	rjmp	.+80     	; 0x8de2 <command_ip+0xe6>
	}
	else {
		usart_write("My IP: %1i.%1i.%1i.%1i\r\n",myip[0],myip[1],myip[2],myip[3]);
    8d92:	ad b7       	in	r26, 0x3d	; 61
    8d94:	be b7       	in	r27, 0x3e	; 62
    8d96:	1a 97       	sbiw	r26, 0x0a	; 10
    8d98:	0f b6       	in	r0, 0x3f	; 63
    8d9a:	f8 94       	cli
    8d9c:	be bf       	out	0x3e, r27	; 62
    8d9e:	0f be       	out	0x3f, r0	; 63
    8da0:	ad bf       	out	0x3d, r26	; 61
    8da2:	ed b7       	in	r30, 0x3d	; 61
    8da4:	fe b7       	in	r31, 0x3e	; 62
    8da6:	31 96       	adiw	r30, 0x01	; 1
    8da8:	89 e5       	ldi	r24, 0x59	; 89
    8daa:	92 e2       	ldi	r25, 0x22	; 34
    8dac:	12 96       	adiw	r26, 0x02	; 2
    8dae:	9c 93       	st	X, r25
    8db0:	8e 93       	st	-X, r24
    8db2:	11 97       	sbiw	r26, 0x01	; 1
    8db4:	80 91 46 0b 	lds	r24, 0x0B46
    8db8:	82 83       	std	Z+2, r24	; 0x02
    8dba:	13 82       	std	Z+3, r1	; 0x03
    8dbc:	80 91 47 0b 	lds	r24, 0x0B47
    8dc0:	84 83       	std	Z+4, r24	; 0x04
    8dc2:	15 82       	std	Z+5, r1	; 0x05
    8dc4:	80 91 48 0b 	lds	r24, 0x0B48
    8dc8:	86 83       	std	Z+6, r24	; 0x06
    8dca:	17 82       	std	Z+7, r1	; 0x07
    8dcc:	80 91 49 0b 	lds	r24, 0x0B49
    8dd0:	80 87       	std	Z+8, r24	; 0x08
    8dd2:	11 86       	std	Z+9, r1	; 0x09
    8dd4:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    8dd8:	a0 e0       	ldi	r26, 0x00	; 0
    8dda:	b0 e0       	ldi	r27, 0x00	; 0
    8ddc:	8d b7       	in	r24, 0x3d	; 61
    8dde:	9e b7       	in	r25, 0x3e	; 62
    8de0:	0a 96       	adiw	r24, 0x0a	; 10
    8de2:	0f b6       	in	r0, 0x3f	; 63
    8de4:	f8 94       	cli
    8de6:	9e bf       	out	0x3e, r25	; 62
    8de8:	0f be       	out	0x3f, r0	; 63
    8dea:	8d bf       	out	0x3d, r24	; 61
		return 0;
	}
}
    8dec:	cd 01       	movw	r24, r26
    8dee:	df 91       	pop	r29
    8df0:	cf 91       	pop	r28
    8df2:	08 95       	ret

00008df4 <extract_cmd>:
 *
 * \param[in] pstr char-Pointer auf Eingabe-Puffer
 * \returns 0 bei Fehler, 1 bei ausgefuehrtem Befehl
 */
unsigned char extract_cmd(char *pstr)
{
    8df4:	cf 92       	push	r12
    8df6:	df 92       	push	r13
    8df8:	ef 92       	push	r14
    8dfa:	ff 92       	push	r15
    8dfc:	1f 93       	push	r17
    8dfe:	df 93       	push	r29
    8e00:	cf 93       	push	r28
    8e02:	00 d0       	rcall	.+0      	; 0x8e04 <extract_cmd+0x10>
    8e04:	cd b7       	in	r28, 0x3d	; 61
    8e06:	de b7       	in	r29, 0x3e	; 62
    8e08:	9a 83       	std	Y+2, r25	; 0x02
    8e0a:	89 83       	std	Y+1, r24	; 0x01
	char *string_pointer_tmp;
	unsigned char cmd_index = 0;
 
 	// erst mal Tastaturpuffer in Kommando und Parameter aufteilen
    string_pointer_tmp = strsep(&pstr," "); 
    8e0c:	ce 01       	movw	r24, r28
    8e0e:	01 96       	adiw	r24, 0x01	; 1
    8e10:	62 e7       	ldi	r22, 0x72	; 114
    8e12:	71 e0       	ldi	r23, 0x01	; 1
    8e14:	0e 94 dc 6e 	call	0xddb8	; 0xddb8 <strsep>
    8e18:	6c 01       	movw	r12, r24
	argv = pstr;	// Zeiger auf Cmd-Parameter setzen
    8e1a:	89 81       	ldd	r24, Y+1	; 0x01
    8e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    8e1e:	90 93 6f 0d 	sts	0x0D6F, r25
    8e22:	80 93 6e 0d 	sts	0x0D6E, r24
    8e26:	10 e0       	ldi	r17, 0x00	; 0
    8e28:	0f c0       	rjmp	.+30     	; 0x8e48 <extract_cmd+0x54>
	// Kommando in Tabelle CMD_TABLE suchen
	while(strcasecmp_P(string_pointer_tmp,(char *)pgm_read_word(&CMD_TABLE[cmd_index].cmd)))
    {
        // wenn letzter Eintrag ({NULL,NULL}) erreicht wurde,
		// Abruch der Whileschleife und Unterprogramm verlassen 
        if (pgm_read_word(&CMD_TABLE[++cmd_index].cmd) == 0) return(0);
    8e2a:	1f 5f       	subi	r17, 0xFF	; 255
    8e2c:	e1 2f       	mov	r30, r17
    8e2e:	f0 e0       	ldi	r31, 0x00	; 0
    8e30:	ee 0f       	add	r30, r30
    8e32:	ff 1f       	adc	r31, r31
    8e34:	ee 0f       	add	r30, r30
    8e36:	ff 1f       	adc	r31, r31
    8e38:	e3 57       	subi	r30, 0x73	; 115
    8e3a:	f5 4e       	sbci	r31, 0xE5	; 229
    8e3c:	85 91       	lpm	r24, Z+
    8e3e:	94 91       	lpm	r25, Z+
    8e40:	89 2b       	or	r24, r25
    8e42:	11 f4       	brne	.+4      	; 0x8e48 <extract_cmd+0x54>
    8e44:	80 e0       	ldi	r24, 0x00	; 0
    8e46:	2a c0       	rjmp	.+84     	; 0x8e9c <extract_cmd+0xa8>
 	// erst mal Tastaturpuffer in Kommando und Parameter aufteilen
    string_pointer_tmp = strsep(&pstr," "); 
	argv = pstr;	// Zeiger auf Cmd-Parameter setzen

	// Kommando in Tabelle CMD_TABLE suchen
	while(strcasecmp_P(string_pointer_tmp,(char *)pgm_read_word(&CMD_TABLE[cmd_index].cmd)))
    8e48:	e1 2e       	mov	r14, r17
    8e4a:	ff 24       	eor	r15, r15
    8e4c:	f7 01       	movw	r30, r14
    8e4e:	ee 0f       	add	r30, r30
    8e50:	ff 1f       	adc	r31, r31
    8e52:	ee 0f       	add	r30, r30
    8e54:	ff 1f       	adc	r31, r31
    8e56:	e3 57       	subi	r30, 0x73	; 115
    8e58:	f5 4e       	sbci	r31, 0xE5	; 229
    8e5a:	65 91       	lpm	r22, Z+
    8e5c:	74 91       	lpm	r23, Z+
    8e5e:	c6 01       	movw	r24, r12
    8e60:	0e 94 c1 6d 	call	0xdb82	; 0xdb82 <strcasecmp_P>
    8e64:	89 2b       	or	r24, r25
    8e66:	09 f7       	brne	.-62     	; 0x8e2a <extract_cmd+0x36>
        if (pgm_read_word(&CMD_TABLE[++cmd_index].cmd) == 0) return(0);
    }
    
	// der Befehl wurde in der Tabelle gefunden;
	// jetzt Befehl ausfhren und Ergebnis zurckgeben
	usart_write("\r\n");
    8e68:	00 d0       	rcall	.+0      	; 0x8e6a <extract_cmd+0x76>
    8e6a:	87 e8       	ldi	r24, 0x87	; 135
    8e6c:	92 e2       	ldi	r25, 0x22	; 34
    8e6e:	ed b7       	in	r30, 0x3d	; 61
    8e70:	fe b7       	in	r31, 0x3e	; 62
    8e72:	92 83       	std	Z+2, r25	; 0x02
    8e74:	81 83       	std	Z+1, r24	; 0x01
    8e76:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
	((cmd_fp)pgm_read_word(&CMD_TABLE[cmd_index].fp))(0);
    8e7a:	c7 01       	movw	r24, r14
    8e7c:	88 0f       	add	r24, r24
    8e7e:	99 1f       	adc	r25, r25
    8e80:	88 0f       	add	r24, r24
    8e82:	99 1f       	adc	r25, r25
    8e84:	81 57       	subi	r24, 0x71	; 113
    8e86:	95 4e       	sbci	r25, 0xE5	; 229
    8e88:	fc 01       	movw	r30, r24
    8e8a:	25 91       	lpm	r18, Z+
    8e8c:	34 91       	lpm	r19, Z+
    8e8e:	0f 90       	pop	r0
    8e90:	0f 90       	pop	r0
    8e92:	80 e0       	ldi	r24, 0x00	; 0
    8e94:	90 e0       	ldi	r25, 0x00	; 0
    8e96:	f9 01       	movw	r30, r18
    8e98:	09 95       	icall
    8e9a:	81 e0       	ldi	r24, 0x01	; 1
	return(1); 
}
    8e9c:	0f 90       	pop	r0
    8e9e:	0f 90       	pop	r0
    8ea0:	cf 91       	pop	r28
    8ea2:	df 91       	pop	r29
    8ea4:	1f 91       	pop	r17
    8ea6:	ff 90       	pop	r15
    8ea8:	ef 90       	pop	r14
    8eaa:	df 90       	pop	r13
    8eac:	cf 90       	pop	r12
    8eae:	08 95       	ret

00008eb0 <read_file_to_eth_buffer>:
*/
uint16_t read_file_to_eth_buffer(void)
{
	int16_t i=0;

	if (!tcpsrv_status.datafile)
    8eb0:	80 91 bd 0d 	lds	r24, 0x0DBD
    8eb4:	90 91 be 0d 	lds	r25, 0x0DBE
    8eb8:	89 2b       	or	r24, r25
    8eba:	51 f4       	brne	.+20     	; 0x8ed0 <read_file_to_eth_buffer+0x20>
		tcpsrv_status.datafile = f16_open((char *)tcpsrv_status.fname,"r");
    8ebc:	8d e9       	ldi	r24, 0x9D	; 157
    8ebe:	9d e0       	ldi	r25, 0x0D	; 13
    8ec0:	64 e7       	ldi	r22, 0x74	; 116
    8ec2:	71 e0       	ldi	r23, 0x01	; 1
    8ec4:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    8ec8:	90 93 be 0d 	sts	0x0DBE, r25
    8ecc:	80 93 bd 0d 	sts	0x0DBD, r24

	/*
	** alte Pointer auf Datenanfang in Datei nachziehen
	*/
	tcpsrv_status.old_charcount = tcpsrv_status.charcount;
    8ed0:	40 91 c3 0d 	lds	r20, 0x0DC3
    8ed4:	50 91 c4 0d 	lds	r21, 0x0DC4
    8ed8:	60 91 c5 0d 	lds	r22, 0x0DC5
    8edc:	70 91 c6 0d 	lds	r23, 0x0DC6
    8ee0:	40 93 c7 0d 	sts	0x0DC7, r20
    8ee4:	50 93 c8 0d 	sts	0x0DC8, r21
    8ee8:	60 93 c9 0d 	sts	0x0DC9, r22
    8eec:	70 93 ca 0d 	sts	0x0DCA, r23

	/*
	*  positionieren und lesen
	*/
	if (f16_fseek(tcpsrv_status.datafile, tcpsrv_status.old_charcount, FAT16_SEEK_SET)) {
    8ef0:	80 91 bd 0d 	lds	r24, 0x0DBD
    8ef4:	90 91 be 0d 	lds	r25, 0x0DBE
    8ef8:	20 e0       	ldi	r18, 0x00	; 0
    8efa:	0e 94 95 4c 	call	0x992a	; 0x992a <f16_fseek>
    8efe:	89 2b       	or	r24, r25
    8f00:	69 f0       	breq	.+26     	; 0x8f1c <read_file_to_eth_buffer+0x6c>
		i = fat16_read_file(tcpsrv_status.datafile, (unsigned char *)&eth_buffer[TCP_DATA_START], MTU_SIZE-(TCP_DATA_START+10));
    8f02:	80 91 bd 0d 	lds	r24, 0x0DBD
    8f06:	90 91 be 0d 	lds	r25, 0x0DBE
    8f0a:	6c e8       	ldi	r22, 0x8C	; 140
    8f0c:	76 e0       	ldi	r23, 0x06	; 6
    8f0e:	40 e7       	ldi	r20, 0x70	; 112
    8f10:	54 e0       	ldi	r21, 0x04	; 4
    8f12:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <fat16_read_file>
    8f16:	bc 01       	movw	r22, r24
		if (i<0)
    8f18:	97 ff       	sbrs	r25, 7
    8f1a:	02 c0       	rjmp	.+4      	; 0x8f20 <read_file_to_eth_buffer+0x70>
    8f1c:	60 e0       	ldi	r22, 0x00	; 0
    8f1e:	70 e0       	ldi	r23, 0x00	; 0
			i = 0;
	}
	tcpsrv_status.charcount += i;
    8f20:	cb 01       	movw	r24, r22
    8f22:	aa 27       	eor	r26, r26
    8f24:	97 fd       	sbrc	r25, 7
    8f26:	a0 95       	com	r26
    8f28:	ba 2f       	mov	r27, r26
    8f2a:	20 91 c3 0d 	lds	r18, 0x0DC3
    8f2e:	30 91 c4 0d 	lds	r19, 0x0DC4
    8f32:	40 91 c5 0d 	lds	r20, 0x0DC5
    8f36:	50 91 c6 0d 	lds	r21, 0x0DC6
    8f3a:	82 0f       	add	r24, r18
    8f3c:	93 1f       	adc	r25, r19
    8f3e:	a4 1f       	adc	r26, r20
    8f40:	b5 1f       	adc	r27, r21
    8f42:	80 93 c3 0d 	sts	0x0DC3, r24
    8f46:	90 93 c4 0d 	sts	0x0DC4, r25
    8f4a:	a0 93 c5 0d 	sts	0x0DC5, r26
    8f4e:	b0 93 c6 0d 	sts	0x0DC6, r27
	//f16_close(tcpsrv_status.datafile);
	return i; // Zahl der kopierten Zeichen
}
    8f52:	cb 01       	movw	r24, r22
    8f54:	08 95       	ret

00008f56 <_respond>:
	memcpy(&eth_buffer[TCP_DATA_START],pstr,len);
	_respond(channel, len,index);
}

void _respond(uint8_t channel, uint16_t len, unsigned char index)
{
    8f56:	ff 92       	push	r15
    8f58:	0f 93       	push	r16
    8f5a:	1f 93       	push	r17
    8f5c:	cf 93       	push	r28
    8f5e:	df 93       	push	r29
    8f60:	f8 2e       	mov	r15, r24
    8f62:	8b 01       	movw	r16, r22
	tcp_entry[index].status =  ACK_FLAG | PSH_FLAG;
    8f64:	24 2f       	mov	r18, r20
    8f66:	30 e0       	ldi	r19, 0x00	; 0
    8f68:	86 e1       	ldi	r24, 0x16	; 22
    8f6a:	90 e0       	ldi	r25, 0x00	; 0
    8f6c:	28 9f       	mul	r18, r24
    8f6e:	e0 01       	movw	r28, r0
    8f70:	29 9f       	mul	r18, r25
    8f72:	d0 0d       	add	r29, r0
    8f74:	38 9f       	mul	r19, r24
    8f76:	d0 0d       	add	r29, r0
    8f78:	11 24       	eor	r1, r1
    8f7a:	cc 5a       	subi	r28, 0xAC	; 172
    8f7c:	d4 4f       	sbci	r29, 0xF4	; 244
    8f7e:	88 e1       	ldi	r24, 0x18	; 24
    8f80:	88 8b       	std	Y+16, r24	; 0x10
	create_new_tcp_packet(len,index);
    8f82:	cb 01       	movw	r24, r22
    8f84:	64 2f       	mov	r22, r20
    8f86:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>

	eth_buffer[TCP_DATA_START+len] = 0;	// nur fr debug
    8f8a:	0a 5a       	subi	r16, 0xAA	; 170
    8f8c:	19 4f       	sbci	r17, 0xF9	; 249
    8f8e:	f8 01       	movw	r30, r16
    8f90:	16 aa       	std	Z+54, r1	; 0x36
	TCPSRV_DEBUG("\r\nTCPSRV_DEBUG respond %i (%i): %s",index, len, &eth_buffer[TCP_DATA_START]);

	if (channel == CTRL_CHANNEL) {
    8f92:	ff 20       	and	r15, r15
    8f94:	99 f4       	brne	.+38     	; 0x8fbc <_respond+0x66>
		tcpsrv_status.ctl_waitack = 1;		// dieses Paket sollte besttigt werden
    8f96:	80 91 70 0d 	lds	r24, 0x0D70
    8f9a:	81 60       	ori	r24, 0x01	; 1
    8f9c:	80 93 70 0d 	sts	0x0D70, r24
		tcp_entry[index].time = TCP_TIME_OFF;	// Timer ausschalten
    8fa0:	8f ef       	ldi	r24, 0xFF	; 255
    8fa2:	8b 8b       	std	Y+19, r24	; 0x13
		tcpsrv_status.cmdindex= 0;			// auf erstes Zeichen setzen
    8fa4:	10 92 73 0d 	sts	0x0D73, r1
		tcpsrv_status.cmdbuffer[0] = 0;		// und cmd-string terminieren
    8fa8:	10 92 75 0d 	sts	0x0D75, r1
		tcpsrv_status.argvindex= 0;			// cmd Puffer resetten
    8fac:	10 92 74 0d 	sts	0x0D74, r1
		tcpsrv_status.argvbuffer[0] = 0;
    8fb0:	10 92 7d 0d 	sts	0x0D7D, r1
		tcpsrv_status.read_argv = 0;
    8fb4:	80 91 70 0d 	lds	r24, 0x0D70
    8fb8:	87 7f       	andi	r24, 0xF7	; 247
    8fba:	03 c0       	rjmp	.+6      	; 0x8fc2 <_respond+0x6c>
	}
	else
		tcpsrv_status.data_waitack = 1;		// dieses Paket sollte besttigt werden
    8fbc:	80 91 70 0d 	lds	r24, 0x0D70
    8fc0:	82 60       	ori	r24, 0x02	; 2
    8fc2:	80 93 70 0d 	sts	0x0D70, r24
}
    8fc6:	df 91       	pop	r29
    8fc8:	cf 91       	pop	r28
    8fca:	1f 91       	pop	r17
    8fcc:	0f 91       	pop	r16
    8fce:	ff 90       	pop	r15
    8fd0:	08 95       	ret

00008fd2 <respond_P>:

/*
*	Antwortstring(s) senden
*/
void respond_P(uint8_t channel, const char *pstr, unsigned char index)
{
    8fd2:	cf 92       	push	r12
    8fd4:	df 92       	push	r13
    8fd6:	ef 92       	push	r14
    8fd8:	ff 92       	push	r15
    8fda:	0f 93       	push	r16
    8fdc:	1f 93       	push	r17
    8fde:	d8 2e       	mov	r13, r24
    8fe0:	8b 01       	movw	r16, r22
    8fe2:	c4 2e       	mov	r12, r20
	uint16_t len = strlen_P(pstr);
    8fe4:	cb 01       	movw	r24, r22
    8fe6:	0e 94 e6 6d 	call	0xdbcc	; 0xdbcc <strlen_P>
    8fea:	7c 01       	movw	r14, r24
	memcpy_P(&eth_buffer[TCP_DATA_START],pstr,len);
    8fec:	8c e8       	ldi	r24, 0x8C	; 140
    8fee:	96 e0       	ldi	r25, 0x06	; 6
    8ff0:	b8 01       	movw	r22, r16
    8ff2:	a7 01       	movw	r20, r14
    8ff4:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>

	_respond(channel, len,index);
    8ff8:	8d 2d       	mov	r24, r13
    8ffa:	b7 01       	movw	r22, r14
    8ffc:	4c 2d       	mov	r20, r12
    8ffe:	0e 94 ab 47 	call	0x8f56	; 0x8f56 <_respond>
}
    9002:	1f 91       	pop	r17
    9004:	0f 91       	pop	r16
    9006:	ff 90       	pop	r15
    9008:	ef 90       	pop	r14
    900a:	df 90       	pop	r13
    900c:	cf 90       	pop	r12
    900e:	08 95       	ret

00009010 <respond_226>:
* 	mit 226 antworten
*	setzt Flag falls ACK noch aussteht
*	oder sendet "226 Transfer complete"
*/
void respond_226(unsigned char index)
{
    9010:	48 2f       	mov	r20, r24
	TCPSRV_DEBUG("\r\nTCP Server %i respond 226 wait: %i",index, tcpsrv_status.ctl_waitack);
	if (index < MAX_TCP_ENTRY) {
    9012:	85 30       	cpi	r24, 0x05	; 5
    9014:	78 f4       	brcc	.+30     	; 0x9034 <respond_226+0x24>
		if (tcpsrv_status.ctl_waitack)
    9016:	80 91 70 0d 	lds	r24, 0x0D70
    901a:	80 ff       	sbrs	r24, 0
    901c:	06 c0       	rjmp	.+12     	; 0x902a <respond_226+0x1a>
			tcpsrv_status.send_226 = 1;			// nach nchstem ACK wird "226 Transfer Ende" gesendet
    901e:	80 91 70 0d 	lds	r24, 0x0D70
    9022:	84 60       	ori	r24, 0x04	; 4
    9024:	80 93 70 0d 	sts	0x0D70, r24
    9028:	08 95       	ret
		else
			respond_P(CTRL_CHANNEL, PSTR("226 Transfer complete. Closing data connection\r\n"),index);
    902a:	80 e0       	ldi	r24, 0x00	; 0
    902c:	6e e9       	ldi	r22, 0x9E	; 158
    902e:	72 e2       	ldi	r23, 0x22	; 34
    9030:	0e 94 e9 47 	call	0x8fd2	; 0x8fd2 <respond_P>
    9034:	08 95       	ret

00009036 <doSrvCmd>:
/**
 *	\ingroup tcpsrv
 *	Telnet/FTP Befehl ausfhren
 */
uint16_t doSrvCmd(uint8_t index, unsigned char *cmdstr)
{
    9036:	ef 92       	push	r14
    9038:	ff 92       	push	r15
    903a:	0f 93       	push	r16
    903c:	1f 93       	push	r17
    903e:	cf 93       	push	r28
    9040:	df 93       	push	r29
    9042:	18 2f       	mov	r17, r24
    9044:	7b 01       	movw	r14, r22
    9046:	00 e0       	ldi	r16, 0x00	; 0
    9048:	01 c0       	rjmp	.+2      	; 0x904c <doSrvCmd+0x16>
	int16_t len = 0;
	uint8_t i = 0;

	while (pgm_read_word(&CMD_TABLE[i].cmd) && strcasecmp_P((char *)cmdstr,(char *)pgm_read_word(&CMD_TABLE[i].cmd))) i++;
    904a:	0f 5f       	subi	r16, 0xFF	; 255
    904c:	c0 2f       	mov	r28, r16
    904e:	d0 e0       	ldi	r29, 0x00	; 0
    9050:	fe 01       	movw	r30, r28
    9052:	ee 0f       	add	r30, r30
    9054:	ff 1f       	adc	r31, r31
    9056:	ee 0f       	add	r30, r30
    9058:	ff 1f       	adc	r31, r31
    905a:	e3 57       	subi	r30, 0x73	; 115
    905c:	f5 4e       	sbci	r31, 0xE5	; 229
    905e:	65 91       	lpm	r22, Z+
    9060:	74 91       	lpm	r23, Z+
    9062:	61 15       	cp	r22, r1
    9064:	71 05       	cpc	r23, r1
    9066:	29 f0       	breq	.+10     	; 0x9072 <doSrvCmd+0x3c>
    9068:	c7 01       	movw	r24, r14
    906a:	0e 94 c1 6d 	call	0xdb82	; 0xdb82 <strcasecmp_P>
    906e:	89 2b       	or	r24, r25
    9070:	61 f7       	brne	.-40     	; 0x904a <doSrvCmd+0x14>
	// Wenn Befehlsindex zu gross, dann mit Fehler beenden
	if (!pgm_read_word(&CMD_TABLE[i].cmd)) {
    9072:	fe 01       	movw	r30, r28
    9074:	ee 0f       	add	r30, r30
    9076:	ff 1f       	adc	r31, r31
    9078:	ee 0f       	add	r30, r30
    907a:	ff 1f       	adc	r31, r31
    907c:	e3 57       	subi	r30, 0x73	; 115
    907e:	f5 4e       	sbci	r31, 0xE5	; 229
    9080:	85 91       	lpm	r24, Z+
    9082:	94 91       	lpm	r25, Z+
    9084:	89 2b       	or	r24, r25
    9086:	71 f4       	brne	.+28     	; 0x90a4 <doSrvCmd+0x6e>
		strcpy_P((char *)&eth_buffer[TCP_DATA_START],PSTR("502 not implemented.\r\n"));
    9088:	0c e8       	ldi	r16, 0x8C	; 140
    908a:	16 e0       	ldi	r17, 0x06	; 6
    908c:	c8 01       	movw	r24, r16
    908e:	6e ed       	ldi	r22, 0xDE	; 222
    9090:	72 e2       	ldi	r23, 0x22	; 34
    9092:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <strcpy_P>
		return strlen((char *)&eth_buffer[TCP_DATA_START]);
    9096:	f8 01       	movw	r30, r16
    9098:	01 90       	ld	r0, Z+
    909a:	00 20       	and	r0, r0
    909c:	e9 f7       	brne	.-6      	; 0x9098 <doSrvCmd+0x62>
    909e:	ed 58       	subi	r30, 0x8D	; 141
    90a0:	f6 40       	sbci	r31, 0x06	; 6
    90a2:	2d c0       	rjmp	.+90     	; 0x90fe <doSrvCmd+0xc8>
	}

	argv = (char *)tcpsrv_status.argvbuffer;	// Command-Parameter setzen
    90a4:	8d e7       	ldi	r24, 0x7D	; 125
    90a6:	9d e0       	ldi	r25, 0x0D	; 13
    90a8:	90 93 6f 0d 	sts	0x0D6F, r25
    90ac:	80 93 6e 0d 	sts	0x0D6E, r24
	len = ((cmd_fp)pgm_read_word(&CMD_TABLE[i].fp))((char *)&eth_buffer[TCP_DATA_START_VAR]); // Befehl ausfhren und Ergebnis zurckgeben
    90b0:	ce 01       	movw	r24, r28
    90b2:	88 0f       	add	r24, r24
    90b4:	99 1f       	adc	r25, r25
    90b6:	88 0f       	add	r24, r24
    90b8:	99 1f       	adc	r25, r25
    90ba:	81 57       	subi	r24, 0x71	; 113
    90bc:	95 4e       	sbci	r25, 0xE5	; 229
    90be:	fc 01       	movw	r30, r24
    90c0:	25 91       	lpm	r18, Z+
    90c2:	34 91       	lpm	r19, Z+
    90c4:	80 91 84 06 	lds	r24, 0x0684
    90c8:	90 e0       	ldi	r25, 0x00	; 0
    90ca:	80 7f       	andi	r24, 0xF0	; 240
    90cc:	90 70       	andi	r25, 0x00	; 0
    90ce:	95 95       	asr	r25
    90d0:	87 95       	ror	r24
    90d2:	95 95       	asr	r25
    90d4:	87 95       	ror	r24
    90d6:	88 58       	subi	r24, 0x88	; 136
    90d8:	99 4f       	sbci	r25, 0xF9	; 249
    90da:	f9 01       	movw	r30, r18
    90dc:	09 95       	icall

	if (len < 0) {	// negativer Wert beendet Verbindung
    90de:	97 ff       	sbrs	r25, 7
    90e0:	0d c0       	rjmp	.+26     	; 0x90fc <doSrvCmd+0xc6>
		//tcp_entry[index].app_status = 0xFFFD;	// 123456789.123456789.123456789.
		memcpy_P(&eth_buffer[TCP_DATA_START],PSTR("bye, bye ...\r\n"),14);
    90e2:	8c e8       	ldi	r24, 0x8C	; 140
    90e4:	96 e0       	ldi	r25, 0x06	; 6
    90e6:	6f ec       	ldi	r22, 0xCF	; 207
    90e8:	72 e2       	ldi	r23, 0x22	; 34
    90ea:	4e e0       	ldi	r20, 0x0E	; 14
    90ec:	50 e0       	ldi	r21, 0x00	; 0
    90ee:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>
		tcp_Port_close(index);
    90f2:	81 2f       	mov	r24, r17
    90f4:	0e 94 12 1a 	call	0x3424	; 0x3424 <tcp_Port_close>
    90f8:	8e e0       	ldi	r24, 0x0E	; 14
    90fa:	90 e0       	ldi	r25, 0x00	; 0
		len = 14;
	}
	return (len);
    90fc:	fc 01       	movw	r30, r24
}
    90fe:	cf 01       	movw	r24, r30
    9100:	df 91       	pop	r29
    9102:	cf 91       	pop	r28
    9104:	1f 91       	pop	r17
    9106:	0f 91       	pop	r16
    9108:	ff 90       	pop	r15
    910a:	ef 90       	pop	r14
    910c:	08 95       	ret

0000910e <tcpsrvd>:
/**
 *	\ingroup tcpsrv
 *	tcp Server (CTRL-Channel)
 */
void tcpsrvd(uint8_t index)
{
    910e:	ff 92       	push	r15
    9110:	0f 93       	push	r16
    9112:	1f 93       	push	r17
    9114:	cf 93       	push	r28
    9116:	df 93       	push	r29
    9118:	f8 2e       	mov	r15, r24
	TCPSRV_DEBUG("\r\n---- TCP SrvCTRL %i from: %i  Flags: 0x%x seq: %u ack:%u",
										index,LBBL_ENDIAN_INT(tcp_entry[index].src_port),tcp_entry[index].status,
										LBBL_ENDIAN_LONG(tcp_entry[index].seq_counter),
										LBBL_ENDIAN_LONG(tcp_entry[index].ack_counter) );

	if (tcp_entry[index].status & FIN_FLAG) {	// Wird Verbindungsabbau signalisiert?
    911a:	c8 2f       	mov	r28, r24
    911c:	d0 e0       	ldi	r29, 0x00	; 0
    911e:	86 e1       	ldi	r24, 0x16	; 22
    9120:	90 e0       	ldi	r25, 0x00	; 0
    9122:	c8 9f       	mul	r28, r24
    9124:	f0 01       	movw	r30, r0
    9126:	c9 9f       	mul	r28, r25
    9128:	f0 0d       	add	r31, r0
    912a:	d8 9f       	mul	r29, r24
    912c:	f0 0d       	add	r31, r0
    912e:	11 24       	eor	r1, r1
    9130:	ec 5a       	subi	r30, 0xAC	; 172
    9132:	f4 4f       	sbci	r31, 0xF4	; 244
    9134:	80 89       	ldd	r24, Z+16	; 0x10
    9136:	80 ff       	sbrs	r24, 0
    9138:	0e c0       	rjmp	.+28     	; 0x9156 <tcpsrvd+0x48>
		TCPSRV_DEBUG("\r\nCTRL-channel %i closed.",index);
		tcpsrv_status.tcpindex = 0xff;
    913a:	8f ef       	ldi	r24, 0xFF	; 255
    913c:	80 93 72 0d 	sts	0x0D72, r24
		#if FTP_ANONYMOUS
		tcpsrv_status.userOK = 0;
    9140:	80 91 71 0d 	lds	r24, 0x0D71
    9144:	8e 7f       	andi	r24, 0xFE	; 254
    9146:	80 93 71 0d 	sts	0x0D71, r24
		tcpsrv_status.loginOK = 0;
    914a:	80 91 70 0d 	lds	r24, 0x0D70
    914e:	8f 77       	andi	r24, 0x7F	; 127
    9150:	80 93 70 0d 	sts	0x0D70, r24
    9154:	d0 c0       	rjmp	.+416    	; 0x92f6 <tcpsrvd+0x1e8>
		#endif

		return;
	}

	if (tcp_entry[index].app_status <= 1) {	// erstmaliger Aufruf der Anwendung -> Begrung senden
    9156:	81 89       	ldd	r24, Z+17	; 0x11
    9158:	92 89       	ldd	r25, Z+18	; 0x12
    915a:	02 97       	sbiw	r24, 0x02	; 2
    915c:	90 f4       	brcc	.+36     	; 0x9182 <tcpsrvd+0x74>
		tcp_entry[index].app_status = 1;
    915e:	81 e0       	ldi	r24, 0x01	; 1
    9160:	90 e0       	ldi	r25, 0x00	; 0
    9162:	92 8b       	std	Z+18, r25	; 0x12
    9164:	81 8b       	std	Z+17, r24	; 0x11
		respond_P(CTRL_CHANNEL, PSTR("220 Server bereit\r\n"),index);
    9166:	80 e0       	ldi	r24, 0x00	; 0
    9168:	6a e8       	ldi	r22, 0x8A	; 138
    916a:	72 e2       	ldi	r23, 0x22	; 34
    916c:	4f 2d       	mov	r20, r15
    916e:	0e 94 e9 47 	call	0x8fd2	; 0x8fd2 <respond_P>
		tcpsrv_status.transfermode = 0;	// ASCII mode
    9172:	80 91 70 0d 	lds	r24, 0x0D70
    9176:	8f 7b       	andi	r24, 0xBF	; 191
    9178:	80 93 70 0d 	sts	0x0D70, r24
		tcpsrv_status.tcpindex = index;	// letzten socket merken
    917c:	f0 92 72 0d 	sts	0x0D72, r15
    9180:	ba c0       	rjmp	.+372    	; 0x92f6 <tcpsrvd+0x1e8>
		return;
	}
	// else if(tcp_entry[index].app_status > 1) ...

	if (tcp_entry[index].status&PSH_FLAG) {		// Ist das Paket fr die Anwendung bestimmt ?
    9182:	80 89       	ldd	r24, Z+16	; 0x10
    9184:	83 ff       	sbrs	r24, 3
    9186:	a1 c0       	rjmp	.+322    	; 0x92ca <tcpsrvd+0x1bc>
		tcp_entry[index].app_status = 2;		// nicht automatisch weiterzhlen
    9188:	82 e0       	ldi	r24, 0x02	; 2
    918a:	90 e0       	ldi	r25, 0x00	; 0
    918c:	92 8b       	std	Z+18, r25	; 0x12
    918e:	81 8b       	std	Z+17, r24	; 0x11
		/*
		* eingehende Zeichen (bei TELNET 1 char pro Paket !) sammeln
		* und Cmd-Zeile interpretieren.
		* Cmd und Parameter getrennt erfassen.
		*/
		for (int a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++) {	// Schleife ber alle Zeichen im Empfangspuffer
    9190:	20 91 84 06 	lds	r18, 0x0684
    9194:	30 e0       	ldi	r19, 0x00	; 0
    9196:	20 7f       	andi	r18, 0xF0	; 240
    9198:	30 70       	andi	r19, 0x00	; 0
    919a:	35 95       	asr	r19
    919c:	27 95       	ror	r18
    919e:	35 95       	asr	r19
    91a0:	27 95       	ror	r18
    91a2:	b9 01       	movw	r22, r18
    91a4:	6e 5d       	subi	r22, 0xDE	; 222
    91a6:	7f 4f       	sbci	r23, 0xFF	; 255
    91a8:	80 91 67 06 	lds	r24, 0x0667
    91ac:	48 2f       	mov	r20, r24
    91ae:	50 e0       	ldi	r21, 0x00	; 0
    91b0:	4e 5d       	subi	r20, 0xDE	; 222
    91b2:	5f 4f       	sbci	r21, 0xFF	; 255
    91b4:	90 91 66 06 	lds	r25, 0x0666
    91b8:	80 e0       	ldi	r24, 0x00	; 0
    91ba:	48 0f       	add	r20, r24
    91bc:	59 1f       	adc	r21, r25
    91be:	42 1b       	sub	r20, r18
    91c0:	53 0b       	sbc	r21, r19
    91c2:	db 01       	movw	r26, r22
    91c4:	aa 5a       	subi	r26, 0xAA	; 170
    91c6:	b9 4f       	sbci	r27, 0xF9	; 249
    91c8:	60 c0       	rjmp	.+192    	; 0x928a <tcpsrvd+0x17c>

			if (eth_buffer[a] == '\r') {			// Zeilenende erkannt ?
    91ca:	9c 91       	ld	r25, X
    91cc:	9d 30       	cpi	r25, 0x0D	; 13
    91ce:	69 f4       	brne	.+26     	; 0x91ea <tcpsrvd+0xdc>

				TCPSRV_DEBUG("\r\nTCP Server-CTRL cmd: %s argv: %s",tcpsrv_status.cmdbuffer,tcpsrv_status.argvbuffer);

				tcpsrv_status.tcpindex = index; 	// letzten socket merken
    91d0:	f0 92 72 0d 	sts	0x0D72, r15

				// ausfhren und Ergebnis im TCP-Paket zurckgeben
				_respond(CTRL_CHANNEL, doSrvCmd(index,(unsigned char *)tcpsrv_status.cmdbuffer),index);
    91d4:	8f 2d       	mov	r24, r15
    91d6:	65 e7       	ldi	r22, 0x75	; 117
    91d8:	7d e0       	ldi	r23, 0x0D	; 13
    91da:	0e 94 1b 48 	call	0x9036	; 0x9036 <doSrvCmd>
    91de:	bc 01       	movw	r22, r24
    91e0:	80 e0       	ldi	r24, 0x00	; 0
    91e2:	4f 2d       	mov	r20, r15
    91e4:	0e 94 ab 47 	call	0x8f56	; 0x8f56 <_respond>
    91e8:	86 c0       	rjmp	.+268    	; 0x92f6 <tcpsrvd+0x1e8>
				return;
			}

			else if ( tcpsrv_status.read_argv == 0 && eth_buffer[a] == ' ') {	// cmd Ende, Parameter folgt
    91ea:	80 91 70 0d 	lds	r24, 0x0D70
    91ee:	28 2f       	mov	r18, r24
    91f0:	28 70       	andi	r18, 0x08	; 8
    91f2:	83 fd       	sbrc	r24, 3
    91f4:	08 c0       	rjmp	.+16     	; 0x9206 <tcpsrvd+0xf8>
    91f6:	90 32       	cpi	r25, 0x20	; 32
    91f8:	31 f4       	brne	.+12     	; 0x9206 <tcpsrvd+0xf8>
				tcpsrv_status.read_argv = 1;
    91fa:	80 91 70 0d 	lds	r24, 0x0D70
    91fe:	88 60       	ori	r24, 0x08	; 8
    9200:	80 93 70 0d 	sts	0x0D70, r24
    9204:	3f c0       	rjmp	.+126    	; 0x9284 <tcpsrvd+0x176>
			}

			else if (eth_buffer[a] >= ' ') {		// CTRL-Zeichen ('\n', '\t' etc.) verwerfen
    9206:	90 32       	cpi	r25, 0x20	; 32
    9208:	e8 f1       	brcs	.+122    	; 0x9284 <tcpsrvd+0x176>

				// zum debuggen:
				//while(!(USR & (1<<UDRE)));		// Warten solange bis Zeichen gesendet wurde
				//UDR = eth_buffer[a];				// Ausgabe des Zeichens

				if (tcpsrv_status.read_argv) {
    920a:	22 23       	and	r18, r18
    920c:	f1 f0       	breq	.+60     	; 0x924a <tcpsrvd+0x13c>
					tcpsrv_status.argvbuffer[tcpsrv_status.argvindex++] = eth_buffer[a];
    920e:	80 91 74 0d 	lds	r24, 0x0D74
    9212:	e8 2f       	mov	r30, r24
    9214:	f0 e0       	ldi	r31, 0x00	; 0
    9216:	e0 59       	subi	r30, 0x90	; 144
    9218:	f2 4f       	sbci	r31, 0xF2	; 242
    921a:	95 87       	std	Z+13, r25	; 0x0d
    921c:	8f 5f       	subi	r24, 0xFF	; 255
    921e:	80 93 74 0d 	sts	0x0D74, r24
					tcpsrv_status.argvbuffer[tcpsrv_status.argvindex] = 0;	// und gleich wieder terminieren
    9222:	e0 91 74 0d 	lds	r30, 0x0D74
    9226:	f0 e0       	ldi	r31, 0x00	; 0
    9228:	e0 59       	subi	r30, 0x90	; 144
    922a:	f2 4f       	sbci	r31, 0xF2	; 242
    922c:	15 86       	std	Z+13, r1	; 0x0d
					if (tcpsrv_status.argvindex > MAXARGVBUFFER) {
    922e:	80 91 74 0d 	lds	r24, 0x0D74
    9232:	80 32       	cpi	r24, 0x20	; 32
    9234:	38 f1       	brcs	.+78     	; 0x9284 <tcpsrvd+0x176>
						tcpsrv_status.argvindex= 0;			// Pufferberlauf
    9236:	10 92 74 0d 	sts	0x0D74, r1
						tcpsrv_status.argvbuffer[0] = 0;
    923a:	10 92 7d 0d 	sts	0x0D7D, r1
						tcpsrv_status.read_argv = 0;
    923e:	80 91 70 0d 	lds	r24, 0x0D70
    9242:	87 7f       	andi	r24, 0xF7	; 247
    9244:	80 93 70 0d 	sts	0x0D70, r24
    9248:	24 c0       	rjmp	.+72     	; 0x9292 <tcpsrvd+0x184>
						break;
					}
				}

				else {
					tcpsrv_status.cmdbuffer[tcpsrv_status.cmdindex++] = eth_buffer[a];
    924a:	80 91 73 0d 	lds	r24, 0x0D73
    924e:	e8 2f       	mov	r30, r24
    9250:	f0 e0       	ldi	r31, 0x00	; 0
    9252:	e0 59       	subi	r30, 0x90	; 144
    9254:	f2 4f       	sbci	r31, 0xF2	; 242
    9256:	95 83       	std	Z+5, r25	; 0x05
    9258:	8f 5f       	subi	r24, 0xFF	; 255
    925a:	80 93 73 0d 	sts	0x0D73, r24
					tcpsrv_status.cmdbuffer[tcpsrv_status.cmdindex] = 0;	// und gleich wieder terminieren
    925e:	e0 91 73 0d 	lds	r30, 0x0D73
    9262:	f0 e0       	ldi	r31, 0x00	; 0
    9264:	e0 59       	subi	r30, 0x90	; 144
    9266:	f2 4f       	sbci	r31, 0xF2	; 242
    9268:	15 82       	std	Z+5, r1	; 0x05
					if (tcpsrv_status.cmdindex > MAXCMDBUFFER) {
    926a:	80 91 73 0d 	lds	r24, 0x0D73
    926e:	88 30       	cpi	r24, 0x08	; 8
    9270:	48 f0       	brcs	.+18     	; 0x9284 <tcpsrvd+0x176>
						// TODO: Fehler melden

						tcpsrv_status.cmdindex= 0;			// cmd Puffer resetten
    9272:	10 92 73 0d 	sts	0x0D73, r1
						tcpsrv_status.read_argv = 0;
    9276:	80 91 70 0d 	lds	r24, 0x0D70
    927a:	87 7f       	andi	r24, 0xF7	; 247
    927c:	80 93 70 0d 	sts	0x0D70, r24
						tcpsrv_status.cmdbuffer[0] = 0;
    9280:	10 92 75 0d 	sts	0x0D75, r1
		/*
		* eingehende Zeichen (bei TELNET 1 char pro Paket !) sammeln
		* und Cmd-Zeile interpretieren.
		* Cmd und Parameter getrennt erfassen.
		*/
		for (int a = TCP_DATA_START_VAR;a<(TCP_DATA_END_VAR);a++) {	// Schleife ber alle Zeichen im Empfangspuffer
    9284:	6f 5f       	subi	r22, 0xFF	; 255
    9286:	7f 4f       	sbci	r23, 0xFF	; 255
    9288:	11 96       	adiw	r26, 0x01	; 1
    928a:	64 17       	cp	r22, r20
    928c:	75 07       	cpc	r23, r21
    928e:	0c f4       	brge	.+2      	; 0x9292 <tcpsrvd+0x184>
    9290:	9c cf       	rjmp	.-200    	; 0x91ca <tcpsrvd+0xbc>
				}
			}
		}

		TCPSRV_DEBUG("\r\nTCP Server-CTRL sende ACK");
		tcp_entry[index].status =  ACK_FLAG;	// empfangenes Paket besttigen
    9292:	86 e1       	ldi	r24, 0x16	; 22
    9294:	90 e0       	ldi	r25, 0x00	; 0
    9296:	c8 9f       	mul	r28, r24
    9298:	80 01       	movw	r16, r0
    929a:	c9 9f       	mul	r28, r25
    929c:	10 0d       	add	r17, r0
    929e:	d8 9f       	mul	r29, r24
    92a0:	10 0d       	add	r17, r0
    92a2:	11 24       	eor	r1, r1
    92a4:	0c 5a       	subi	r16, 0xAC	; 172
    92a6:	14 4f       	sbci	r17, 0xF4	; 244
    92a8:	80 e1       	ldi	r24, 0x10	; 16
    92aa:	f8 01       	movw	r30, r16
    92ac:	80 8b       	std	Z+16, r24	; 0x10
		create_new_tcp_packet(0,index);			// lscht .status flags
    92ae:	80 e0       	ldi	r24, 0x00	; 0
    92b0:	90 e0       	ldi	r25, 0x00	; 0
    92b2:	6f 2d       	mov	r22, r15
    92b4:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
		tcpsrv_status.ctl_waitack = 0;
    92b8:	80 91 70 0d 	lds	r24, 0x0D70
    92bc:	8e 7f       	andi	r24, 0xFE	; 254
    92be:	80 93 70 0d 	sts	0x0D70, r24
		tcp_entry[index].time = TCP_TIME_OFF;	// Timer ausschalten
    92c2:	8f ef       	ldi	r24, 0xFF	; 255
    92c4:	f8 01       	movw	r30, r16
    92c6:	83 8b       	std	Z+19, r24	; 0x13
    92c8:	16 c0       	rjmp	.+44     	; 0x92f6 <tcpsrvd+0x1e8>
		//tcp_entry[index].time = MAX_TCP_PORT_OPEN_TIME;
		return;
	}

	// ist dies ein ACK von einem gesendeten Paket
	if ((tcp_entry[index].status&ACK_FLAG)) {	//&& (tcpsrv_status.ctl_waitack)
    92ca:	80 89       	ldd	r24, Z+16	; 0x10
    92cc:	84 ff       	sbrs	r24, 4
    92ce:	13 c0       	rjmp	.+38     	; 0x92f6 <tcpsrvd+0x1e8>
		tcpsrv_status.ctl_waitack = 0;
    92d0:	80 91 70 0d 	lds	r24, 0x0D70
    92d4:	8e 7f       	andi	r24, 0xFE	; 254
    92d6:	80 93 70 0d 	sts	0x0D70, r24
		tcp_entry[index].time = TCP_TIME_OFF;	// Timer ausschalten
    92da:	8f ef       	ldi	r24, 0xFF	; 255
    92dc:	83 8b       	std	Z+19, r24	; 0x13
		TCPSRV_DEBUG("\r\nACK: dest: %i src %i seq %l ack %l",tcp_entry[index].dest_port, tcp_entry[index].src_port,
													   LBBL_ENDIAN_LONG(tcp_entry[index].seq_counter),
													   tcp_entry[index].ack_counter);

		if (tcpsrv_status.send_226) {		// muss noch "226 Transfer Ende" gesendet werden?
    92de:	80 91 70 0d 	lds	r24, 0x0D70
    92e2:	82 ff       	sbrs	r24, 2
    92e4:	08 c0       	rjmp	.+16     	; 0x92f6 <tcpsrvd+0x1e8>
			TCPSRV_DEBUG("\r\nTCP Server-CTRL sende 226");
			tcpsrv_status.send_226 = 0;
    92e6:	80 91 70 0d 	lds	r24, 0x0D70
    92ea:	8b 7f       	andi	r24, 0xFB	; 251
    92ec:	80 93 70 0d 	sts	0x0D70, r24
			respond_226(index);
    92f0:	8f 2d       	mov	r24, r15
    92f2:	0e 94 08 48 	call	0x9010	; 0x9010 <respond_226>
		}
	}
	*/

	return;
}
    92f6:	df 91       	pop	r29
    92f8:	cf 91       	pop	r28
    92fa:	1f 91       	pop	r17
    92fc:	0f 91       	pop	r16
    92fe:	ff 90       	pop	r15
    9300:	08 95       	ret

00009302 <tcpsrvd_init>:
/**
 *	\ingroup tcpsrv
 *	Initialisierung des TCP-Servers
 */
void tcpsrvd_init(void)
{
    9302:	0f 93       	push	r16
    9304:	1f 93       	push	r17
	//Serverport und Anwendung in TCP Anwendungsliste eintragen
	add_tcp_app (21, (void(*)(unsigned char))tcpsrvd);
    9306:	07 e8       	ldi	r16, 0x87	; 135
    9308:	18 e4       	ldi	r17, 0x48	; 72
    930a:	85 e1       	ldi	r24, 0x15	; 21
    930c:	90 e0       	ldi	r25, 0x00	; 0
    930e:	b8 01       	movw	r22, r16
    9310:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
	add_tcp_app (2100, (void(*)(unsigned char))datachannel);
    9314:	84 e3       	ldi	r24, 0x34	; 52
    9316:	98 e0       	ldi	r25, 0x08	; 8
    9318:	69 ea       	ldi	r22, 0xA9	; 169
    931a:	79 e4       	ldi	r23, 0x49	; 73
    931c:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>
	add_tcp_app (MYTCP_PORT, (void(*)(unsigned char))tcpsrvd);
    9320:	82 e3       	ldi	r24, 0x32	; 50
    9322:	9f ee       	ldi	r25, 0xEF	; 239
    9324:	b8 01       	movw	r22, r16
    9326:	0e 94 df 14 	call	0x29be	; 0x29be <add_tcp_app>

	#if FTP_ANONYMOUS
	tcpsrv_status.userOK = 0;
    932a:	80 91 71 0d 	lds	r24, 0x0D71
    932e:	8e 7f       	andi	r24, 0xFE	; 254
    9330:	80 93 71 0d 	sts	0x0D71, r24
	tcpsrv_status.loginOK = 0;
    9334:	e1 e7       	ldi	r30, 0x71	; 113
    9336:	fd e0       	ldi	r31, 0x0D	; 13
    9338:	82 91       	ld	r24, -Z
    933a:	8f 77       	andi	r24, 0x7F	; 127
    933c:	80 83       	st	Z, r24
	#endif

	tcpsrv_status.tcpindex = 0xff;
    933e:	8f ef       	ldi	r24, 0xFF	; 255
    9340:	80 93 72 0d 	sts	0x0D72, r24
	tcpsrv_status.datafile = 0;
    9344:	10 92 be 0d 	sts	0x0DBE, r1
    9348:	10 92 bd 0d 	sts	0x0DBD, r1
}
    934c:	1f 91       	pop	r17
    934e:	0f 91       	pop	r16
    9350:	08 95       	ret

00009352 <datachannel>:
/**
 *	\ingroup tcpsrv
 * 	Datenkanal auf Port 2100
 */
void datachannel(unsigned char index)
{
    9352:	ff 92       	push	r15
    9354:	0f 93       	push	r16
    9356:	1f 93       	push	r17
    9358:	cf 93       	push	r28
    935a:	df 93       	push	r29
    935c:	f8 2e       	mov	r15, r24
	TCPSRV_DEBUG("\r\n---- Datachannel %i State: %i Flags: 0x%x seq: %u ack:%u",
										index,tcpsrv_status.data_state,tcp_entry[index].status,
										LBBL_ENDIAN_LONG(tcp_entry[index].seq_counter),
										LBBL_ENDIAN_LONG(tcp_entry[index].ack_counter) );

	switch(tcpsrv_status.data_state)
    935e:	80 91 70 0d 	lds	r24, 0x0D70
    9362:	82 95       	swap	r24
    9364:	83 70       	andi	r24, 0x03	; 3
    9366:	28 2f       	mov	r18, r24
    9368:	30 e0       	ldi	r19, 0x00	; 0
    936a:	22 30       	cpi	r18, 0x02	; 2
    936c:	31 05       	cpc	r19, r1
    936e:	09 f4       	brne	.+2      	; 0x9372 <datachannel+0x20>
    9370:	5d c0       	rjmp	.+186    	; 0x942c <datachannel+0xda>
    9372:	23 30       	cpi	r18, 0x03	; 3
    9374:	31 05       	cpc	r19, r1
    9376:	09 f4       	brne	.+2      	; 0x937a <datachannel+0x28>
    9378:	11 c1       	rjmp	.+546    	; 0x959c <datachannel+0x24a>
    937a:	cf 2d       	mov	r28, r15
    937c:	d0 e0       	ldi	r29, 0x00	; 0
    937e:	21 30       	cpi	r18, 0x01	; 1
    9380:	31 05       	cpc	r19, r1
    9382:	09 f0       	breq	.+2      	; 0x9386 <datachannel+0x34>
    9384:	68 c1       	rjmp	.+720    	; 0x9656 <datachannel+0x304>
	{
		case 1:		// LIST
			if (tcp_entry[index].app_status < 1) {
    9386:	86 e1       	ldi	r24, 0x16	; 22
    9388:	90 e0       	ldi	r25, 0x00	; 0
    938a:	c8 9f       	mul	r28, r24
    938c:	f0 01       	movw	r30, r0
    938e:	c9 9f       	mul	r28, r25
    9390:	f0 0d       	add	r31, r0
    9392:	d8 9f       	mul	r29, r24
    9394:	f0 0d       	add	r31, r0
    9396:	11 24       	eor	r1, r1
    9398:	ec 5a       	subi	r30, 0xAC	; 172
    939a:	f4 4f       	sbci	r31, 0xF4	; 244
    939c:	81 89       	ldd	r24, Z+17	; 0x11
    939e:	92 89       	ldd	r25, Z+18	; 0x12
    93a0:	89 2b       	or	r24, r25
    93a2:	49 f4       	brne	.+18     	; 0x93b6 <datachannel+0x64>
				// erster Aufruf - initialisieren
				tcp_entry[index].app_status = 1;
    93a4:	32 8b       	std	Z+18, r19	; 0x12
    93a6:	21 8b       	std	Z+17, r18	; 0x11
				tcpsrv_status.data_waitack = 0;
    93a8:	80 91 70 0d 	lds	r24, 0x0D70
    93ac:	8d 7f       	andi	r24, 0xFD	; 253
    93ae:	80 93 70 0d 	sts	0x0D70, r24
				tcp_entry[index].time = TCP_MAX_ENTRY_TIME * 2;
    93b2:	86 e0       	ldi	r24, 0x06	; 6
    93b4:	83 8b       	std	Z+19, r24	; 0x13
				}
				tcpsrv_status.data_waitack = 0;
			}
			*/

			int16_t bufferlen = cmd_MMCdir((char *)&eth_buffer[TCP_DATA_START]);
    93b6:	8c e8       	ldi	r24, 0x8C	; 140
    93b8:	96 e0       	ldi	r25, 0x06	; 6
    93ba:	0e 94 c9 41 	call	0x8392	; 0x8392 <cmd_MMCdir>
    93be:	9c 01       	movw	r18, r24

			if ( !tcpsrv_status.LISTcontinue ) {				// Ende der Dateiliste?
    93c0:	80 91 71 0d 	lds	r24, 0x0D71
    93c4:	81 fd       	sbrc	r24, 1
    93c6:	17 c0       	rjmp	.+46     	; 0x93f6 <datachannel+0xa4>
				tcpsrv_status.data_state = 0;					// nchster Status ist "idle"
    93c8:	80 91 70 0d 	lds	r24, 0x0D70
    93cc:	8f 7c       	andi	r24, 0xCF	; 207
    93ce:	80 93 70 0d 	sts	0x0D70, r24
				tcp_entry[index].status = ACK_FLAG | FIN_FLAG;	// Ende senden
    93d2:	86 e1       	ldi	r24, 0x16	; 22
    93d4:	90 e0       	ldi	r25, 0x00	; 0
    93d6:	c8 9f       	mul	r28, r24
    93d8:	f0 01       	movw	r30, r0
    93da:	c9 9f       	mul	r28, r25
    93dc:	f0 0d       	add	r31, r0
    93de:	d8 9f       	mul	r29, r24
    93e0:	f0 0d       	add	r31, r0
    93e2:	11 24       	eor	r1, r1
    93e4:	ec 5a       	subi	r30, 0xAC	; 172
    93e6:	f4 4f       	sbci	r31, 0xF4	; 244
    93e8:	81 e1       	ldi	r24, 0x11	; 17
    93ea:	80 8b       	std	Z+16, r24	; 0x10
				tcp_entry[index].app_status = 0xFFFF;			// Anwendung beendet.
    93ec:	8f ef       	ldi	r24, 0xFF	; 255
    93ee:	9f ef       	ldi	r25, 0xFF	; 255
    93f0:	92 8b       	std	Z+18, r25	; 0x12
    93f2:	81 8b       	std	Z+17, r24	; 0x11
    93f4:	12 c0       	rjmp	.+36     	; 0x941a <datachannel+0xc8>
			}
			else {
				tcp_entry[index].status = ACK_FLAG;
    93f6:	86 e1       	ldi	r24, 0x16	; 22
    93f8:	90 e0       	ldi	r25, 0x00	; 0
    93fa:	c8 9f       	mul	r28, r24
    93fc:	f0 01       	movw	r30, r0
    93fe:	c9 9f       	mul	r28, r25
    9400:	f0 0d       	add	r31, r0
    9402:	d8 9f       	mul	r29, r24
    9404:	f0 0d       	add	r31, r0
    9406:	11 24       	eor	r1, r1
    9408:	ec 5a       	subi	r30, 0xAC	; 172
    940a:	f4 4f       	sbci	r31, 0xF4	; 244
    940c:	80 e1       	ldi	r24, 0x10	; 16
    940e:	80 8b       	std	Z+16, r24	; 0x10
				tcpsrv_status.data_waitack = 1;					// flag setzen, dass wir auf ACK warten
    9410:	80 91 70 0d 	lds	r24, 0x0D70
    9414:	82 60       	ori	r24, 0x02	; 2
    9416:	80 93 70 0d 	sts	0x0D70, r24
			}

			//TCPSRV_DEBUG("\r\nFTP_LIST:(%i) #entry:%i\r\n%s",bufferlen,tcpsrv_status.direntry_num,&eth_buffer[TCP_DATA_START]);
			create_new_tcp_packet(bufferlen,index);				// Senden
    941a:	c9 01       	movw	r24, r18
    941c:	6f 2d       	mov	r22, r15
    941e:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>

			if ( !tcpsrv_status.LISTcontinue ) {				// Ende der Dateiliste?
    9422:	80 91 71 0d 	lds	r24, 0x0D71
    9426:	81 fd       	sbrc	r24, 1
    9428:	3d c1       	rjmp	.+634    	; 0x96a4 <datachannel+0x352>
    942a:	b3 c0       	rjmp	.+358    	; 0x9592 <datachannel+0x240>
			}
			break;

		case 2:		// RETR

			if (tcp_entry[index].app_status < 1) {
    942c:	cf 2d       	mov	r28, r15
    942e:	d0 e0       	ldi	r29, 0x00	; 0
    9430:	86 e1       	ldi	r24, 0x16	; 22
    9432:	90 e0       	ldi	r25, 0x00	; 0
    9434:	c8 9f       	mul	r28, r24
    9436:	f0 01       	movw	r30, r0
    9438:	c9 9f       	mul	r28, r25
    943a:	f0 0d       	add	r31, r0
    943c:	d8 9f       	mul	r29, r24
    943e:	f0 0d       	add	r31, r0
    9440:	11 24       	eor	r1, r1
    9442:	ec 5a       	subi	r30, 0xAC	; 172
    9444:	f4 4f       	sbci	r31, 0xF4	; 244
    9446:	81 89       	ldd	r24, Z+17	; 0x11
    9448:	92 89       	ldd	r25, Z+18	; 0x12
    944a:	89 2b       	or	r24, r25
    944c:	c9 f4       	brne	.+50     	; 0x9480 <datachannel+0x12e>

				// erster Aufruf - initialisieren
				tcp_entry[index].app_status = 1;
    944e:	81 e0       	ldi	r24, 0x01	; 1
    9450:	90 e0       	ldi	r25, 0x00	; 0
    9452:	92 8b       	std	Z+18, r25	; 0x12
    9454:	81 8b       	std	Z+17, r24	; 0x11
				tcpsrv_status.old_charcount = 0;
    9456:	10 92 c7 0d 	sts	0x0DC7, r1
    945a:	10 92 c8 0d 	sts	0x0DC8, r1
    945e:	10 92 c9 0d 	sts	0x0DC9, r1
    9462:	10 92 ca 0d 	sts	0x0DCA, r1
				tcpsrv_status.charcount = 0;
    9466:	10 92 c3 0d 	sts	0x0DC3, r1
    946a:	10 92 c4 0d 	sts	0x0DC4, r1
    946e:	10 92 c5 0d 	sts	0x0DC5, r1
    9472:	10 92 c6 0d 	sts	0x0DC6, r1
				tcpsrv_status.data_waitack = 0;
    9476:	80 91 70 0d 	lds	r24, 0x0D70
    947a:	8d 7f       	andi	r24, 0xFD	; 253
    947c:	80 93 70 0d 	sts	0x0D70, r24
			}
			
			if(tcpsrv_status.data_waitack != 0) {				// warten wir auf ACK vom letzten Paket ?
    9480:	80 91 70 0d 	lds	r24, 0x0D70
    9484:	81 ff       	sbrs	r24, 1
    9486:	41 c0       	rjmp	.+130    	; 0x950a <datachannel+0x1b8>
				if (tcp_entry[index].status&ACK_FLAG) {
    9488:	86 e1       	ldi	r24, 0x16	; 22
    948a:	90 e0       	ldi	r25, 0x00	; 0
    948c:	c8 9f       	mul	r28, r24
    948e:	f0 01       	movw	r30, r0
    9490:	c9 9f       	mul	r28, r25
    9492:	f0 0d       	add	r31, r0
    9494:	d8 9f       	mul	r29, r24
    9496:	f0 0d       	add	r31, r0
    9498:	11 24       	eor	r1, r1
    949a:	ec 5a       	subi	r30, 0xAC	; 172
    949c:	f4 4f       	sbci	r31, 0xF4	; 244
    949e:	80 89       	ldd	r24, Z+16	; 0x10
    94a0:	84 ff       	sbrs	r24, 4
    94a2:	10 c0       	rjmp	.+32     	; 0x94c4 <datachannel+0x172>
					// letztes Paket besttigt.
					// Zeiger nachziehen
					tcpsrv_status.old_charcount = tcpsrv_status.charcount;
    94a4:	80 91 c3 0d 	lds	r24, 0x0DC3
    94a8:	90 91 c4 0d 	lds	r25, 0x0DC4
    94ac:	a0 91 c5 0d 	lds	r26, 0x0DC5
    94b0:	b0 91 c6 0d 	lds	r27, 0x0DC6
    94b4:	80 93 c7 0d 	sts	0x0DC7, r24
    94b8:	90 93 c8 0d 	sts	0x0DC8, r25
    94bc:	a0 93 c9 0d 	sts	0x0DC9, r26
    94c0:	b0 93 ca 0d 	sts	0x0DCA, r27
				}

				if(tcp_entry[index].status==0) {
    94c4:	86 e1       	ldi	r24, 0x16	; 22
    94c6:	90 e0       	ldi	r25, 0x00	; 0
    94c8:	c8 9f       	mul	r28, r24
    94ca:	f0 01       	movw	r30, r0
    94cc:	c9 9f       	mul	r28, r25
    94ce:	f0 0d       	add	r31, r0
    94d0:	d8 9f       	mul	r29, r24
    94d2:	f0 0d       	add	r31, r0
    94d4:	11 24       	eor	r1, r1
    94d6:	ec 5a       	subi	r30, 0xAC	; 172
    94d8:	f4 4f       	sbci	r31, 0xF4	; 244
    94da:	80 89       	ldd	r24, Z+16	; 0x10
    94dc:	88 23       	and	r24, r24
    94de:	81 f4       	brne	.+32     	; 0x9500 <datachannel+0x1ae>
					// keine Besttigung fr Paket. (TIMEOUT ?)
					// Zeiger auf letztes Paket zurcksetzen
					tcpsrv_status.charcount = tcpsrv_status.old_charcount;
    94e0:	80 91 c7 0d 	lds	r24, 0x0DC7
    94e4:	90 91 c8 0d 	lds	r25, 0x0DC8
    94e8:	a0 91 c9 0d 	lds	r26, 0x0DC9
    94ec:	b0 91 ca 0d 	lds	r27, 0x0DCA
    94f0:	80 93 c3 0d 	sts	0x0DC3, r24
    94f4:	90 93 c4 0d 	sts	0x0DC4, r25
    94f8:	a0 93 c5 0d 	sts	0x0DC5, r26
    94fc:	b0 93 c6 0d 	sts	0x0DC6, r27
				}
				tcpsrv_status.data_waitack = 0;
    9500:	80 91 70 0d 	lds	r24, 0x0D70
    9504:	8d 7f       	andi	r24, 0xFD	; 253
    9506:	80 93 70 0d 	sts	0x0D70, r24
			}

			// Datendatei in eth-Puffer einlesen
			unsigned int count = read_file_to_eth_buffer();
    950a:	0e 94 58 47 	call	0x8eb0	; 0x8eb0 <read_file_to_eth_buffer>
    950e:	8c 01       	movw	r16, r24

			if(count < MTU_SIZE-(TCP_DATA_START+10)) {			// ist das das letzte Paket
    9510:	84 e0       	ldi	r24, 0x04	; 4
    9512:	00 37       	cpi	r16, 0x70	; 112
    9514:	18 07       	cpc	r17, r24
    9516:	18 f5       	brcc	.+70     	; 0x955e <datachannel+0x20c>
				// Ende der Datenbertragung
				tcpsrv_status.data_state = 0;					// nchster Status ist "idle"
    9518:	80 91 70 0d 	lds	r24, 0x0D70
    951c:	8f 7c       	andi	r24, 0xCF	; 207
    951e:	80 93 70 0d 	sts	0x0D70, r24
				tcp_entry[index].status = ACK_FLAG | FIN_FLAG;	// Ende senden
    9522:	86 e1       	ldi	r24, 0x16	; 22
    9524:	90 e0       	ldi	r25, 0x00	; 0
    9526:	c8 9f       	mul	r28, r24
    9528:	f0 01       	movw	r30, r0
    952a:	c9 9f       	mul	r28, r25
    952c:	f0 0d       	add	r31, r0
    952e:	d8 9f       	mul	r29, r24
    9530:	f0 0d       	add	r31, r0
    9532:	11 24       	eor	r1, r1
    9534:	ec 5a       	subi	r30, 0xAC	; 172
    9536:	f4 4f       	sbci	r31, 0xF4	; 244
    9538:	81 e1       	ldi	r24, 0x11	; 17
    953a:	80 8b       	std	Z+16, r24	; 0x10
				tcp_entry[index].app_status = 0xFFFF;			// Anwendung beendet.
    953c:	8f ef       	ldi	r24, 0xFF	; 255
    953e:	9f ef       	ldi	r25, 0xFF	; 255
    9540:	92 8b       	std	Z+18, r25	; 0x12
    9542:	81 8b       	std	Z+17, r24	; 0x11
				if (tcpsrv_status.datafile) {					// Filepointer freigeben
    9544:	80 91 bd 0d 	lds	r24, 0x0DBD
    9548:	90 91 be 0d 	lds	r25, 0x0DBE
    954c:	00 97       	sbiw	r24, 0x00	; 0
    954e:	c9 f0       	breq	.+50     	; 0x9582 <datachannel+0x230>
					f16_close(tcpsrv_status.datafile);
    9550:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
					tcpsrv_status.datafile = 0;
    9554:	10 92 be 0d 	sts	0x0DBE, r1
    9558:	10 92 bd 0d 	sts	0x0DBD, r1
    955c:	12 c0       	rjmp	.+36     	; 0x9582 <datachannel+0x230>
				}
			}
			else {
				tcp_entry[index].status = ACK_FLAG;
    955e:	86 e1       	ldi	r24, 0x16	; 22
    9560:	90 e0       	ldi	r25, 0x00	; 0
    9562:	c8 9f       	mul	r28, r24
    9564:	f0 01       	movw	r30, r0
    9566:	c9 9f       	mul	r28, r25
    9568:	f0 0d       	add	r31, r0
    956a:	d8 9f       	mul	r29, r24
    956c:	f0 0d       	add	r31, r0
    956e:	11 24       	eor	r1, r1
    9570:	ec 5a       	subi	r30, 0xAC	; 172
    9572:	f4 4f       	sbci	r31, 0xF4	; 244
    9574:	80 e1       	ldi	r24, 0x10	; 16
    9576:	80 8b       	std	Z+16, r24	; 0x10
				tcpsrv_status.data_waitack = 1;					// flag setzen, dass wir auf ACK warten
    9578:	80 91 70 0d 	lds	r24, 0x0D70
    957c:	82 60       	ori	r24, 0x02	; 2
    957e:	80 93 70 0d 	sts	0x0D70, r24
			}

			create_new_tcp_packet(count,index);					// Senden
    9582:	c8 01       	movw	r24, r16
    9584:	6f 2d       	mov	r22, r15
    9586:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>
			if(count < MTU_SIZE-(TCP_DATA_START+10)) {			// ist das das letzte Paket
    958a:	00 57       	subi	r16, 0x70	; 112
    958c:	14 40       	sbci	r17, 0x04	; 4
    958e:	08 f0       	brcs	.+2      	; 0x9592 <datachannel+0x240>
    9590:	89 c0       	rjmp	.+274    	; 0x96a4 <datachannel+0x352>
				respond_226(tcpsrv_status.tcpindex);			// Ende der bertragung auf control socket melden
    9592:	80 91 72 0d 	lds	r24, 0x0D72
    9596:	0e 94 08 48 	call	0x9010	; 0x9010 <respond_226>
    959a:	84 c0       	rjmp	.+264    	; 0x96a4 <datachannel+0x352>
			}
			break;

		case 3:		// STOR
			if (!tcpsrv_status.datafile)
    959c:	80 91 bd 0d 	lds	r24, 0x0DBD
    95a0:	90 91 be 0d 	lds	r25, 0x0DBE
    95a4:	89 2b       	or	r24, r25
    95a6:	51 f4       	brne	.+20     	; 0x95bc <datachannel+0x26a>
				tcpsrv_status.datafile = f16_open((char *)tcpsrv_status.fname,"a");
    95a8:	8d e9       	ldi	r24, 0x9D	; 157
    95aa:	9d e0       	ldi	r25, 0x0D	; 13
    95ac:	66 e7       	ldi	r22, 0x76	; 118
    95ae:	71 e0       	ldi	r23, 0x01	; 1
    95b0:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    95b4:	90 93 be 0d 	sts	0x0DBE, r25
    95b8:	80 93 bd 0d 	sts	0x0DBD, r24

			TCPSRV_DEBUG("\r\nTCPSRV_DEBUG STOR %s %i Bytes",tcpsrv_status.fname,(TCP_DATA_END_VAR)-(TCP_DATA_START_VAR));
			if (tcpsrv_status.datafile) {
    95bc:	20 91 bd 0d 	lds	r18, 0x0DBD
    95c0:	30 91 be 0d 	lds	r19, 0x0DBE
    95c4:	21 15       	cp	r18, r1
    95c6:	31 05       	cpc	r19, r1
    95c8:	c9 f0       	breq	.+50     	; 0x95fc <datachannel+0x2aa>
				TCPSRV_DEBUG("\r\nTCPSRV_DEBUG STOR %i bis %i",TCP_DATA_START_VAR,TCP_DATA_END_VAR);
				fat16_write_file(tcpsrv_status.datafile, (unsigned char *)&eth_buffer[TCP_DATA_START_VAR],(TCP_DATA_END_VAR)-(TCP_DATA_START_VAR));
    95ca:	60 91 84 06 	lds	r22, 0x0684
    95ce:	70 e0       	ldi	r23, 0x00	; 0
    95d0:	60 7f       	andi	r22, 0xF0	; 240
    95d2:	70 70       	andi	r23, 0x00	; 0
    95d4:	75 95       	asr	r23
    95d6:	67 95       	ror	r22
    95d8:	75 95       	asr	r23
    95da:	67 95       	ror	r22
    95dc:	50 91 66 06 	lds	r21, 0x0666
    95e0:	40 e0       	ldi	r20, 0x00	; 0
    95e2:	80 91 67 06 	lds	r24, 0x0667
    95e6:	48 0f       	add	r20, r24
    95e8:	51 1d       	adc	r21, r1
    95ea:	46 1b       	sub	r20, r22
    95ec:	57 0b       	sbc	r21, r23
    95ee:	46 1b       	sub	r20, r22
    95f0:	57 0b       	sbc	r21, r23
    95f2:	c9 01       	movw	r24, r18
    95f4:	68 58       	subi	r22, 0x88	; 136
    95f6:	79 4f       	sbci	r23, 0xF9	; 249
    95f8:	0e 94 0e 5c 	call	0xb81c	; 0xb81c <fat16_write_file>
				//sd_raw_sync();	// flush databuffers
			}

			uint8_t fin_test = tcp_entry[index].status & FIN_FLAG;
    95fc:	2f 2d       	mov	r18, r15
    95fe:	30 e0       	ldi	r19, 0x00	; 0
    9600:	86 e1       	ldi	r24, 0x16	; 22
    9602:	90 e0       	ldi	r25, 0x00	; 0
    9604:	28 9f       	mul	r18, r24
    9606:	f0 01       	movw	r30, r0
    9608:	29 9f       	mul	r18, r25
    960a:	f0 0d       	add	r31, r0
    960c:	38 9f       	mul	r19, r24
    960e:	f0 0d       	add	r31, r0
    9610:	11 24       	eor	r1, r1
    9612:	ec 5a       	subi	r30, 0xAC	; 172
    9614:	f4 4f       	sbci	r31, 0xF4	; 244
    9616:	10 89       	ldd	r17, Z+16	; 0x10

			tcp_entry[index].status =  ACK_FLAG;
    9618:	80 e1       	ldi	r24, 0x10	; 16
    961a:	80 8b       	std	Z+16, r24	; 0x10
			create_new_tcp_packet(0,index);
    961c:	80 e0       	ldi	r24, 0x00	; 0
    961e:	90 e0       	ldi	r25, 0x00	; 0
    9620:	6f 2d       	mov	r22, r15
    9622:	0e 94 e7 18 	call	0x31ce	; 0x31ce <create_new_tcp_packet>

			/*
			** je nach Dateigre sendet FileZilla das FIN_FLAG mit dem letzten Datenpaket
			** oder auch getrennt als eigenstndiges Paket
			*/
			if (fin_test) {									// Wird Verbindungsabbau signalisiert?
    9626:	10 ff       	sbrs	r17, 0
    9628:	3d c0       	rjmp	.+122    	; 0x96a4 <datachannel+0x352>
				TCPSRV_DEBUG("\r\ndata-channel %i closed Port: %i",index,tcp_entry[index].src_port);
				respond_226(tcpsrv_status.tcpindex);		// im Ctrl-Kanal noch mitteilen
    962a:	80 91 72 0d 	lds	r24, 0x0D72
    962e:	0e 94 08 48 	call	0x9010	; 0x9010 <respond_226>
				tcpsrv_status.data_state = 0;				// idle setzen
    9632:	80 91 70 0d 	lds	r24, 0x0D70
    9636:	8f 7c       	andi	r24, 0xCF	; 207
    9638:	80 93 70 0d 	sts	0x0D70, r24
				if (tcpsrv_status.datafile) {
    963c:	80 91 bd 0d 	lds	r24, 0x0DBD
    9640:	90 91 be 0d 	lds	r25, 0x0DBE
    9644:	00 97       	sbiw	r24, 0x00	; 0
    9646:	71 f1       	breq	.+92     	; 0x96a4 <datachannel+0x352>
					f16_close(tcpsrv_status.datafile);
    9648:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
					tcpsrv_status.datafile = 0;
    964c:	10 92 be 0d 	sts	0x0DBE, r1
    9650:	10 92 bd 0d 	sts	0x0DBD, r1
    9654:	27 c0       	rjmp	.+78     	; 0x96a4 <datachannel+0x352>
			}
		break;

		case 0:
		default:
			if (!(tcp_entry[index].status & FIN_FLAG)) {	// Wird Verbindungsabbau signalisiert?
    9656:	86 e1       	ldi	r24, 0x16	; 22
    9658:	90 e0       	ldi	r25, 0x00	; 0
    965a:	c8 9f       	mul	r28, r24
    965c:	f0 01       	movw	r30, r0
    965e:	c9 9f       	mul	r28, r25
    9660:	f0 0d       	add	r31, r0
    9662:	d8 9f       	mul	r29, r24
    9664:	f0 0d       	add	r31, r0
    9666:	11 24       	eor	r1, r1
    9668:	ec 5a       	subi	r30, 0xAC	; 172
    966a:	f4 4f       	sbci	r31, 0xF4	; 244
    966c:	80 89       	ldd	r24, Z+16	; 0x10
    966e:	80 ff       	sbrs	r24, 0
    9670:	19 c0       	rjmp	.+50     	; 0x96a4 <datachannel+0x352>
				// ACK wird automatisch in stack.c gesendet
				return;
			}

			// ACK vom FIN_FLAG ? -> Port wird vom client noch geschlossen; oder Timeout
			if ((tcp_entry[index].status&ACK_FLAG)) {
    9672:	80 89       	ldd	r24, Z+16	; 0x10
    9674:	84 ff       	sbrs	r24, 4
    9676:	02 c0       	rjmp	.+4      	; 0x967c <datachannel+0x32a>
				tcp_entry[index].time = MAX_TCP_PORT_OPEN_TIME;
    9678:	8e e1       	ldi	r24, 0x1E	; 30
    967a:	83 8b       	std	Z+19, r24	; 0x13
			}

			TCPSRV_DEBUG("\r\nDatenkanal %i closed. App: %x",index,tcp_entry[index].app_status);
			tcp_entry[index].app_status = 0xFFFF;			// Anwendung beendet.
    967c:	86 e1       	ldi	r24, 0x16	; 22
    967e:	90 e0       	ldi	r25, 0x00	; 0
    9680:	c8 9f       	mul	r28, r24
    9682:	f0 01       	movw	r30, r0
    9684:	c9 9f       	mul	r28, r25
    9686:	f0 0d       	add	r31, r0
    9688:	d8 9f       	mul	r29, r24
    968a:	f0 0d       	add	r31, r0
    968c:	11 24       	eor	r1, r1
    968e:	ec 5a       	subi	r30, 0xAC	; 172
    9690:	f4 4f       	sbci	r31, 0xF4	; 244
    9692:	8f ef       	ldi	r24, 0xFF	; 255
    9694:	9f ef       	ldi	r25, 0xFF	; 255
    9696:	92 8b       	std	Z+18, r25	; 0x12
    9698:	81 8b       	std	Z+17, r24	; 0x11
			tcpsrv_status.data_waitack = 0;
    969a:	80 91 70 0d 	lds	r24, 0x0D70
    969e:	8d 7f       	andi	r24, 0xFD	; 253
    96a0:	80 93 70 0d 	sts	0x0D70, r24
			break;
	}
}
    96a4:	df 91       	pop	r29
    96a6:	cf 91       	pop	r28
    96a8:	1f 91       	pop	r17
    96aa:	0f 91       	pop	r16
    96ac:	ff 90       	pop	r15
    96ae:	08 95       	ret

000096b0 <f16_mkdir>:
/**
 *	\ingroup sdcard
 *  neues Verzeichnis anlegen
 */
uint8_t f16_mkdir(const char *dirname)
{
    96b0:	0f 93       	push	r16
    96b2:	1f 93       	push	r17
    96b4:	df 93       	push	r29
    96b6:	cf 93       	push	r28
    96b8:	cd b7       	in	r28, 0x3d	; 61
    96ba:	de b7       	in	r29, 0x3e	; 62
    96bc:	af 97       	sbiw	r28, 0x2f	; 47
    96be:	0f b6       	in	r0, 0x3f	; 63
    96c0:	f8 94       	cli
    96c2:	de bf       	out	0x3e, r29	; 62
    96c4:	0f be       	out	0x3f, r0	; 63
    96c6:	cd bf       	out	0x3d, r28	; 61
    96c8:	8c 01       	movw	r16, r24
	uint8_t iret = 0;

	if (!sd_get_fs())
    96ca:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    96ce:	89 2b       	or	r24, r25
    96d0:	11 f4       	brne	.+4      	; 0x96d6 <f16_mkdir+0x26>
    96d2:	80 e0       	ldi	r24, 0x00	; 0
    96d4:	0a c0       	rjmp	.+20     	; 0x96ea <f16_mkdir+0x3a>
		return iret;

	struct fat16_dir_entry_struct dir_entry;

	iret = fat16_create_dir(cwdir_ptr, dirname, &dir_entry);
    96d6:	80 91 cb 0d 	lds	r24, 0x0DCB
    96da:	90 91 cc 0d 	lds	r25, 0x0DCC
    96de:	b8 01       	movw	r22, r16
    96e0:	ae 01       	movw	r20, r28
    96e2:	4f 5f       	subi	r20, 0xFF	; 255
    96e4:	5f 4f       	sbci	r21, 0xFF	; 255
    96e6:	0e 94 53 59 	call	0xb2a6	; 0xb2a6 <fat16_create_dir>

	return iret;
}
    96ea:	af 96       	adiw	r28, 0x2f	; 47
    96ec:	0f b6       	in	r0, 0x3f	; 63
    96ee:	f8 94       	cli
    96f0:	de bf       	out	0x3e, r29	; 62
    96f2:	0f be       	out	0x3f, r0	; 63
    96f4:	cd bf       	out	0x3d, r28	; 61
    96f6:	cf 91       	pop	r28
    96f8:	df 91       	pop	r29
    96fa:	1f 91       	pop	r17
    96fc:	0f 91       	pop	r16
    96fe:	08 95       	ret

00009700 <f16_exist>:
/**
 *	\ingroup sdcard
 *  Datei auf Existenz prfen
 */
uint8_t f16_exist(const char *filename)
{
    9700:	0f 93       	push	r16
    9702:	1f 93       	push	r17
    9704:	df 93       	push	r29
    9706:	cf 93       	push	r28
    9708:	cd b7       	in	r28, 0x3d	; 61
    970a:	de b7       	in	r29, 0x3e	; 62
    970c:	af 97       	sbiw	r28, 0x2f	; 47
    970e:	0f b6       	in	r0, 0x3f	; 63
    9710:	f8 94       	cli
    9712:	de bf       	out	0x3e, r29	; 62
    9714:	0f be       	out	0x3f, r0	; 63
    9716:	cd bf       	out	0x3d, r28	; 61
    9718:	8c 01       	movw	r16, r24
	uint8_t iret = 0;

	if (!sd_get_fs())
    971a:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    971e:	89 2b       	or	r24, r25
    9720:	11 f4       	brne	.+4      	; 0x9726 <f16_exist+0x26>
    9722:	80 e0       	ldi	r24, 0x00	; 0
    9724:	0c c0       	rjmp	.+24     	; 0x973e <f16_exist+0x3e>
		return 0;

    struct fat16_dir_entry_struct file_entry;

	SD_DEBUG("\r\nsdcard exist: file %s ", filename);
    if(sd_find_file_in_dir(cwdir_ptr, filename, &file_entry)) {
    9726:	80 91 cb 0d 	lds	r24, 0x0DCB
    972a:	90 91 cc 0d 	lds	r25, 0x0DCC
    972e:	b8 01       	movw	r22, r16
    9730:	ae 01       	movw	r20, r28
    9732:	4f 5f       	subi	r20, 0xFF	; 255
    9734:	5f 4f       	sbci	r21, 0xFF	; 255
    9736:	0e 94 ad 5e 	call	0xbd5a	; 0xbd5a <sd_find_file_in_dir>
    973a:	81 11       	cpse	r24, r1
    973c:	81 e0       	ldi	r24, 0x01	; 1
		SD_DEBUG("NOT ");

	SD_DEBUG("found.");

	return iret;
}
    973e:	af 96       	adiw	r28, 0x2f	; 47
    9740:	0f b6       	in	r0, 0x3f	; 63
    9742:	f8 94       	cli
    9744:	de bf       	out	0x3e, r29	; 62
    9746:	0f be       	out	0x3f, r0	; 63
    9748:	cd bf       	out	0x3d, r28	; 61
    974a:	cf 91       	pop	r28
    974c:	df 91       	pop	r29
    974e:	1f 91       	pop	r17
    9750:	0f 91       	pop	r16
    9752:	08 95       	ret

00009754 <f16_delete>:
/**
 *	\ingroup sdcard
 *  Datei oder Verzeichniseintrag lschen
 */
uint8_t f16_delete(const char *filename)
{
    9754:	0f 93       	push	r16
    9756:	1f 93       	push	r17
    9758:	df 93       	push	r29
    975a:	cf 93       	push	r28
    975c:	cd b7       	in	r28, 0x3d	; 61
    975e:	de b7       	in	r29, 0x3e	; 62
    9760:	af 97       	sbiw	r28, 0x2f	; 47
    9762:	0f b6       	in	r0, 0x3f	; 63
    9764:	f8 94       	cli
    9766:	de bf       	out	0x3e, r29	; 62
    9768:	0f be       	out	0x3f, r0	; 63
    976a:	cd bf       	out	0x3d, r28	; 61
    976c:	8c 01       	movw	r16, r24
	uint8_t iret = 0;
	if (!sd_get_fs())
    976e:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    9772:	89 2b       	or	r24, r25
    9774:	b1 f0       	breq	.+44     	; 0x97a2 <f16_delete+0x4e>
		return iret;

    struct fat16_dir_entry_struct file_entry;

    if(sd_find_file_in_dir(cwdir_ptr, filename, &file_entry)) {
    9776:	80 91 cb 0d 	lds	r24, 0x0DCB
    977a:	90 91 cc 0d 	lds	r25, 0x0DCC
    977e:	b8 01       	movw	r22, r16
    9780:	8e 01       	movw	r16, r28
    9782:	0f 5f       	subi	r16, 0xFF	; 255
    9784:	1f 4f       	sbci	r17, 0xFF	; 255
    9786:	a8 01       	movw	r20, r16
    9788:	0e 94 ad 5e 	call	0xbd5a	; 0xbd5a <sd_find_file_in_dir>
    978c:	88 23       	and	r24, r24
    978e:	49 f0       	breq	.+18     	; 0x97a2 <f16_delete+0x4e>
        if(fat16_delete_file(sd_get_fs(), &file_entry))
    9790:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    9794:	b8 01       	movw	r22, r16
    9796:	0e 94 18 52 	call	0xa430	; 0xa430 <fat16_delete_file>
    979a:	88 23       	and	r24, r24
    979c:	19 f0       	breq	.+6      	; 0x97a4 <f16_delete+0x50>
    979e:	81 e0       	ldi	r24, 0x01	; 1
    97a0:	01 c0       	rjmp	.+2      	; 0x97a4 <f16_delete+0x50>
    97a2:	80 e0       	ldi	r24, 0x00	; 0
			iret = 1;
    }
	return iret;
}
    97a4:	af 96       	adiw	r28, 0x2f	; 47
    97a6:	0f b6       	in	r0, 0x3f	; 63
    97a8:	f8 94       	cli
    97aa:	de bf       	out	0x3e, r29	; 62
    97ac:	0f be       	out	0x3f, r0	; 63
    97ae:	cd bf       	out	0x3d, r28	; 61
    97b0:	cf 91       	pop	r28
    97b2:	df 91       	pop	r29
    97b4:	1f 91       	pop	r17
    97b6:	0f 91       	pop	r16
    97b8:	08 95       	ret

000097ba <f16_fputs>:
 *  string in Datei schreiben
 *
 * \see f16_puts_P
 */
int f16_fputs(char *s, File *stream)
{
    97ba:	fc 01       	movw	r30, r24
    97bc:	40 e0       	ldi	r20, 0x00	; 0
    97be:	50 e0       	ldi	r21, 0x00	; 0
	int i;

	for (i=0;;++i) {
		if (*s++ == 0)
    97c0:	81 91       	ld	r24, Z+
    97c2:	88 23       	and	r24, r24
    97c4:	19 f0       	breq	.+6      	; 0x97cc <f16_fputs+0x12>
 */
int f16_fputs(char *s, File *stream)
{
	int i;

	for (i=0;;++i) {
    97c6:	4f 5f       	subi	r20, 0xFF	; 255
    97c8:	5f 4f       	sbci	r21, 0xFF	; 255
    97ca:	fa cf       	rjmp	.-12     	; 0x97c0 <f16_fputs+0x6>
		if (*s++ == 0)
			break;
	}

	return fat16_write_file(stream, (uint8_t *)s, i);
    97cc:	cb 01       	movw	r24, r22
    97ce:	bf 01       	movw	r22, r30
    97d0:	0e 94 0e 5c 	call	0xb81c	; 0xb81c <fat16_write_file>
}
    97d4:	08 95       	ret

000097d6 <f16_fputc>:
 *
 * \see f16_puts
 * \see f16_puts_P
 */
int f16_fputc(char c, File *stream)
{
    97d6:	df 93       	push	r29
    97d8:	cf 93       	push	r28
    97da:	0f 92       	push	r0
    97dc:	cd b7       	in	r28, 0x3d	; 61
    97de:	de b7       	in	r29, 0x3e	; 62
    97e0:	89 83       	std	Y+1, r24	; 0x01
    97e2:	cb 01       	movw	r24, r22
	return fat16_write_file(stream, (uint8_t *)&c, 1);
    97e4:	be 01       	movw	r22, r28
    97e6:	6f 5f       	subi	r22, 0xFF	; 255
    97e8:	7f 4f       	sbci	r23, 0xFF	; 255
    97ea:	41 e0       	ldi	r20, 0x01	; 1
    97ec:	50 e0       	ldi	r21, 0x00	; 0
    97ee:	0e 94 0e 5c 	call	0xb81c	; 0xb81c <fat16_write_file>
}
    97f2:	0f 90       	pop	r0
    97f4:	cf 91       	pop	r28
    97f6:	df 91       	pop	r29
    97f8:	08 95       	ret

000097fa <f16_printf_P>:
 *	\attention der Puffer fr den formatierten String hat nur 64 char
 *
 * \sa Anwendungsbeispiel ::log_status
 */
int f16_printf_P(File *stream,const char *format,...)
{
    97fa:	ff 92       	push	r15
    97fc:	0f 93       	push	r16
    97fe:	1f 93       	push	r17
    9800:	df 93       	push	r29
    9802:	cf 93       	push	r28
    9804:	cd b7       	in	r28, 0x3d	; 61
    9806:	de b7       	in	r29, 0x3e	; 62
    9808:	c0 54       	subi	r28, 0x40	; 64
    980a:	d0 40       	sbci	r29, 0x00	; 0
    980c:	0f b6       	in	r0, 0x3f	; 63
    980e:	f8 94       	cli
    9810:	de bf       	out	0x3e, r29	; 62
    9812:	0f be       	out	0x3f, r0	; 63
    9814:	cd bf       	out	0x3d, r28	; 61
    9816:	9e 01       	movw	r18, r28
    9818:	24 5b       	subi	r18, 0xB4	; 180
    981a:	3f 4f       	sbci	r19, 0xFF	; 255
		
	char outbuffer[64];
	uint8_t nchar = 0;

	va_start (ap, format);
	nchar = vsprintf_P(outbuffer, format, ap);
    981c:	8e 01       	movw	r16, r28
    981e:	0f 5f       	subi	r16, 0xFF	; 255
    9820:	1f 4f       	sbci	r17, 0xFF	; 255
    9822:	c8 01       	movw	r24, r16
    9824:	2c 96       	adiw	r28, 0x0c	; 12
    9826:	6e ad       	ldd	r22, Y+62	; 0x3e
    9828:	7f ad       	ldd	r23, Y+63	; 0x3f
    982a:	2c 97       	sbiw	r28, 0x0c	; 12
    982c:	a9 01       	movw	r20, r18
    982e:	0e 94 46 6f 	call	0xde8c	; 0xde8c <vsprintf_P>
    9832:	f8 2e       	mov	r15, r24
	fat16_write_file(stream, (unsigned char *)outbuffer, nchar);
    9834:	2a 96       	adiw	r28, 0x0a	; 10
    9836:	8e ad       	ldd	r24, Y+62	; 0x3e
    9838:	9f ad       	ldd	r25, Y+63	; 0x3f
    983a:	2a 97       	sbiw	r28, 0x0a	; 10
    983c:	b8 01       	movw	r22, r16
    983e:	4f 2d       	mov	r20, r15
    9840:	50 e0       	ldi	r21, 0x00	; 0
    9842:	0e 94 0e 5c 	call	0xb81c	; 0xb81c <fat16_write_file>
	va_end(ap);
	return nchar;
}
    9846:	8f 2d       	mov	r24, r15
    9848:	90 e0       	ldi	r25, 0x00	; 0
    984a:	c0 5c       	subi	r28, 0xC0	; 192
    984c:	df 4f       	sbci	r29, 0xFF	; 255
    984e:	0f b6       	in	r0, 0x3f	; 63
    9850:	f8 94       	cli
    9852:	de bf       	out	0x3e, r29	; 62
    9854:	0f be       	out	0x3f, r0	; 63
    9856:	cd bf       	out	0x3d, r28	; 61
    9858:	cf 91       	pop	r28
    985a:	df 91       	pop	r29
    985c:	1f 91       	pop	r17
    985e:	0f 91       	pop	r16
    9860:	ff 90       	pop	r15
    9862:	08 95       	ret

00009864 <f16_getc>:
 *	\ingroup sdcard
 *  einzelnes Zeichen aus Datei lesen
 *
 */
int f16_getc(File *stream)
{
    9864:	df 93       	push	r29
    9866:	cf 93       	push	r28
    9868:	0f 92       	push	r0
    986a:	cd b7       	in	r28, 0x3d	; 61
    986c:	de b7       	in	r29, 0x3e	; 62
	unsigned char c;
	int i;

	i = fat16_read_file(stream, &c, 1);	// gibt Anzahl gelesener Zeichen zurck oder 0/-1 bei EOF/Fehler
    986e:	be 01       	movw	r22, r28
    9870:	6f 5f       	subi	r22, 0xFF	; 255
    9872:	7f 4f       	sbci	r23, 0xFF	; 255
    9874:	41 e0       	ldi	r20, 0x01	; 1
    9876:	50 e0       	ldi	r21, 0x00	; 0
    9878:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <fat16_read_file>
	if (i <= 0) {
    987c:	18 16       	cp	r1, r24
    987e:	19 06       	cpc	r1, r25
    9880:	1c f0       	brlt	.+6      	; 0x9888 <f16_getc+0x24>
    9882:	2f ef       	ldi	r18, 0xFF	; 255
    9884:	3f ef       	ldi	r19, 0xFF	; 255
    9886:	03 c0       	rjmp	.+6      	; 0x988e <f16_getc+0x2a>
		return -1;		// EOF
	}
	else {
		return (int)c;
    9888:	89 81       	ldd	r24, Y+1	; 0x01
    988a:	28 2f       	mov	r18, r24
    988c:	30 e0       	ldi	r19, 0x00	; 0
	}
}
    988e:	c9 01       	movw	r24, r18
    9890:	0f 90       	pop	r0
    9892:	cf 91       	pop	r28
    9894:	df 91       	pop	r29
    9896:	08 95       	ret

00009898 <f16_gets>:
 *	\ingroup sdcard
 *  eine Zeile aus Datei lesen
 *
 */
char *f16_gets(char *string, int size, File *stream)
{
    9898:	ef 92       	push	r14
    989a:	ff 92       	push	r15
    989c:	0f 93       	push	r16
    989e:	1f 93       	push	r17
    98a0:	df 93       	push	r29
    98a2:	cf 93       	push	r28
    98a4:	00 d0       	rcall	.+0      	; 0x98a6 <f16_gets+0xe>
    98a6:	00 d0       	rcall	.+0      	; 0x98a8 <f16_gets+0x10>
    98a8:	cd b7       	in	r28, 0x3d	; 61
    98aa:	de b7       	in	r29, 0x3e	; 62
    98ac:	8c 01       	movw	r16, r24
    98ae:	9b 01       	movw	r18, r22
    98b0:	7a 01       	movw	r14, r20
	int i;

	i = fat16_read_file(stream, (uint8_t*)string, size-1);	// gibt Anzahl gelesener Zeichen zurck oder 0/-1 bei EOF/Fehler
    98b2:	21 50       	subi	r18, 0x01	; 1
    98b4:	30 40       	sbci	r19, 0x00	; 0
    98b6:	ca 01       	movw	r24, r20
    98b8:	b8 01       	movw	r22, r16
    98ba:	a9 01       	movw	r20, r18
    98bc:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <fat16_read_file>
    98c0:	9c 01       	movw	r18, r24
	if (i <= 0) {
    98c2:	18 16       	cp	r1, r24
    98c4:	19 06       	cpc	r1, r25
    98c6:	1c f0       	brlt	.+6      	; 0x98ce <f16_gets+0x36>
    98c8:	00 e0       	ldi	r16, 0x00	; 0
    98ca:	10 e0       	ldi	r17, 0x00	; 0
    98cc:	22 c0       	rjmp	.+68     	; 0x9912 <f16_gets+0x7a>
    98ce:	f8 01       	movw	r30, r16
    98d0:	01 c0       	rjmp	.+2      	; 0x98d4 <f16_gets+0x3c>
		return (char *)(0);		// EOF
	}
	else {
		char *ptr = string;
		while (*ptr != '\n' && --i) {
			++ptr;
    98d2:	31 96       	adiw	r30, 0x01	; 1
	if (i <= 0) {
		return (char *)(0);		// EOF
	}
	else {
		char *ptr = string;
		while (*ptr != '\n' && --i) {
    98d4:	80 81       	ld	r24, Z
    98d6:	8a 30       	cpi	r24, 0x0A	; 10
    98d8:	19 f0       	breq	.+6      	; 0x98e0 <f16_gets+0x48>
    98da:	21 50       	subi	r18, 0x01	; 1
    98dc:	30 40       	sbci	r19, 0x00	; 0
    98de:	c9 f7       	brne	.-14     	; 0x98d2 <f16_gets+0x3a>
			++ptr;
		}
		--i;
    98e0:	21 50       	subi	r18, 0x01	; 1
    98e2:	30 40       	sbci	r19, 0x00	; 0
		++ptr;
		*ptr = 0;	// terminieren
    98e4:	11 82       	std	Z+1, r1	; 0x01


		if (i>0) {	// Datei wieder hinter CRLF positionieren
    98e6:	12 16       	cp	r1, r18
    98e8:	13 06       	cpc	r1, r19
    98ea:	9c f4       	brge	.+38     	; 0x9912 <f16_gets+0x7a>
			int32_t off = -i;
    98ec:	88 27       	eor	r24, r24
    98ee:	99 27       	eor	r25, r25
    98f0:	82 1b       	sub	r24, r18
    98f2:	93 0b       	sbc	r25, r19
    98f4:	aa 27       	eor	r26, r26
    98f6:	97 fd       	sbrc	r25, 7
    98f8:	a0 95       	com	r26
    98fa:	ba 2f       	mov	r27, r26
    98fc:	89 83       	std	Y+1, r24	; 0x01
    98fe:	9a 83       	std	Y+2, r25	; 0x02
    9900:	ab 83       	std	Y+3, r26	; 0x03
    9902:	bc 83       	std	Y+4, r27	; 0x04
			fat16_seek_file(stream, &off, FAT16_SEEK_CUR);
    9904:	c7 01       	movw	r24, r14
    9906:	be 01       	movw	r22, r28
    9908:	6f 5f       	subi	r22, 0xFF	; 255
    990a:	7f 4f       	sbci	r23, 0xFF	; 255
    990c:	41 e0       	ldi	r20, 0x01	; 1
    990e:	0e 94 b2 5b 	call	0xb764	; 0xb764 <fat16_seek_file>
		}
		return string;
	}
}
    9912:	c8 01       	movw	r24, r16
    9914:	0f 90       	pop	r0
    9916:	0f 90       	pop	r0
    9918:	0f 90       	pop	r0
    991a:	0f 90       	pop	r0
    991c:	cf 91       	pop	r28
    991e:	df 91       	pop	r29
    9920:	1f 91       	pop	r17
    9922:	0f 91       	pop	r16
    9924:	ff 90       	pop	r15
    9926:	ef 90       	pop	r14
    9928:	08 95       	ret

0000992a <f16_fseek>:
/**
 *	\ingroup sdcard
 *  Datenzeiger in geffneter Datei positionieren
 */
int f16_fseek(File *stream, int32_t offset, uint8_t origin)
{
    992a:	df 93       	push	r29
    992c:	cf 93       	push	r28
    992e:	00 d0       	rcall	.+0      	; 0x9930 <f16_fseek+0x6>
    9930:	00 d0       	rcall	.+0      	; 0x9932 <f16_fseek+0x8>
    9932:	cd b7       	in	r28, 0x3d	; 61
    9934:	de b7       	in	r29, 0x3e	; 62
	int32_t off = offset;
    9936:	49 83       	std	Y+1, r20	; 0x01
    9938:	5a 83       	std	Y+2, r21	; 0x02
    993a:	6b 83       	std	Y+3, r22	; 0x03
    993c:	7c 83       	std	Y+4, r23	; 0x04
	return (int)fat16_seek_file(stream, &off, origin);
    993e:	be 01       	movw	r22, r28
    9940:	6f 5f       	subi	r22, 0xFF	; 255
    9942:	7f 4f       	sbci	r23, 0xFF	; 255
    9944:	42 2f       	mov	r20, r18
    9946:	0e 94 b2 5b 	call	0xb764	; 0xb764 <fat16_seek_file>
}
    994a:	90 e0       	ldi	r25, 0x00	; 0
    994c:	0f 90       	pop	r0
    994e:	0f 90       	pop	r0
    9950:	0f 90       	pop	r0
    9952:	0f 90       	pop	r0
    9954:	cf 91       	pop	r28
    9956:	df 91       	pop	r29
    9958:	08 95       	ret

0000995a <f16_fputs_P>:
 *
 * \see f16_puts
 * \sa Anwendungsbeispiel log_status
  */
int f16_fputs_P(const char *s, File *stream)
{
    995a:	cf 92       	push	r12
    995c:	df 92       	push	r13
    995e:	ef 92       	push	r14
    9960:	ff 92       	push	r15
    9962:	0f 93       	push	r16
    9964:	1f 93       	push	r17
    9966:	cf 93       	push	r28
    9968:	df 93       	push	r29
    996a:	7c 01       	movw	r14, r24
    996c:	6b 01       	movw	r12, r22
    996e:	c0 e0       	ldi	r28, 0x00	; 0
    9970:	d0 e0       	ldi	r29, 0x00	; 0
	int i;
	char c;
	uint8_t *ptr = (uint8_t *)s;

	for (i=0;;++i) {		// Stringlnge ermitteln
		c = pgm_read_byte(ptr++);
    9972:	f7 01       	movw	r30, r14
    9974:	ec 0f       	add	r30, r28
    9976:	fd 1f       	adc	r31, r29
    9978:	e4 91       	lpm	r30, Z+
		if (c == 0)
    997a:	ee 23       	and	r30, r30
    997c:	11 f0       	breq	.+4      	; 0x9982 <f16_fputs_P+0x28>
{
	int i;
	char c;
	uint8_t *ptr = (uint8_t *)s;

	for (i=0;;++i) {		// Stringlnge ermitteln
    997e:	21 96       	adiw	r28, 0x01	; 1
    9980:	f8 cf       	rjmp	.-16     	; 0x9972 <f16_fputs_P+0x18>
		c = pgm_read_byte(ptr++);
		if (c == 0)
			break;
	}

	ptr = malloc(i);
    9982:	ce 01       	movw	r24, r28
    9984:	0e 94 84 6b 	call	0xd708	; 0xd708 <malloc>
    9988:	18 2f       	mov	r17, r24
    998a:	09 2f       	mov	r16, r25
	memcpy_P(ptr,s,i);
    998c:	b7 01       	movw	r22, r14
    998e:	ae 01       	movw	r20, r28
    9990:	0e 94 b8 6d 	call	0xdb70	; 0xdb70 <memcpy_P>

	i = fat16_write_file(stream, ptr, i);
    9994:	c6 01       	movw	r24, r12
    9996:	61 2f       	mov	r22, r17
    9998:	70 2f       	mov	r23, r16
    999a:	ae 01       	movw	r20, r28
    999c:	0e 94 0e 5c 	call	0xb81c	; 0xb81c <fat16_write_file>
    99a0:	f8 2e       	mov	r15, r24
    99a2:	e9 2e       	mov	r14, r25

	free(ptr);
    99a4:	81 2f       	mov	r24, r17
    99a6:	90 2f       	mov	r25, r16
    99a8:	0e 94 31 6c 	call	0xd862	; 0xd862 <free>
	return i;
}
    99ac:	8f 2d       	mov	r24, r15
    99ae:	9e 2d       	mov	r25, r14
    99b0:	df 91       	pop	r29
    99b2:	cf 91       	pop	r28
    99b4:	1f 91       	pop	r17
    99b6:	0f 91       	pop	r16
    99b8:	ff 90       	pop	r15
    99ba:	ef 90       	pop	r14
    99bc:	df 90       	pop	r13
    99be:	cf 90       	pop	r12
    99c0:	08 95       	ret

000099c2 <f16_flush>:
 *	\ingroup sdcard
 *  Datenpuffer auf Karte schreiben
 */
void f16_flush()
{
	sd_raw_sync();
    99c2:	0e 94 45 62 	call	0xc48a	; 0xc48a <sd_raw_sync>
}
    99c6:	08 95       	ret

000099c8 <f16_close>:
 *
 * \see f16_open
 * \sa Anwendungsbeispiel log_status
 */
void f16_close(File *stream)
{
    99c8:	0f 93       	push	r16
    99ca:	1f 93       	push	r17
    99cc:	8c 01       	movw	r16, r24
	sd_raw_sync();
    99ce:	0e 94 45 62 	call	0xc48a	; 0xc48a <sd_raw_sync>
	fat16_close_file(stream);
    99d2:	c8 01       	movw	r24, r16
    99d4:	0e 94 a0 4f 	call	0x9f40	; 0x9f40 <fat16_close_file>
}
    99d8:	1f 91       	pop	r17
    99da:	0f 91       	pop	r16
    99dc:	08 95       	ret

000099de <f16_open>:
 *
 * \see f16_close
 * \sa Anwendungsbeispiel log_status
 */
File* f16_open(const char *filename, const char *mode)
{
    99de:	cf 92       	push	r12
    99e0:	df 92       	push	r13
    99e2:	ef 92       	push	r14
    99e4:	ff 92       	push	r15
    99e6:	0f 93       	push	r16
    99e8:	1f 93       	push	r17
    99ea:	df 93       	push	r29
    99ec:	cf 93       	push	r28
    99ee:	cd b7       	in	r28, 0x3d	; 61
    99f0:	de b7       	in	r29, 0x3e	; 62
    99f2:	e3 97       	sbiw	r28, 0x33	; 51
    99f4:	0f b6       	in	r0, 0x3f	; 63
    99f6:	f8 94       	cli
    99f8:	de bf       	out	0x3e, r29	; 62
    99fa:	0f be       	out	0x3f, r0	; 63
    99fc:	cd bf       	out	0x3d, r28	; 61
    99fe:	6c 01       	movw	r12, r24
    9a00:	7b 01       	movw	r14, r22
	if (!sd_get_fs())
    9a02:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    9a06:	89 2b       	or	r24, r25
    9a08:	31 f5       	brne	.+76     	; 0x9a56 <f16_open+0x78>
    9a0a:	55 c0       	rjmp	.+170    	; 0x9ab6 <f16_open+0xd8>

    struct fat16_dir_entry_struct file_entry;

    while(fat16_read_dir(cwdir_ptr, &file_entry))
    {
        if(strcasecmp(file_entry.long_name, filename) == 0)
    9a0c:	c8 01       	movw	r24, r16
    9a0e:	b6 01       	movw	r22, r12
    9a10:	0e 94 4e 6e 	call	0xdc9c	; 0xdc9c <strcasecmp>
    9a14:	89 2b       	or	r24, r25
    9a16:	11 f5       	brne	.+68     	; 0x9a5c <f16_open+0x7e>
        {
            fat16_reset_dir(cwdir_ptr);
    9a18:	80 91 cb 0d 	lds	r24, 0x0DCB
    9a1c:	90 91 cc 0d 	lds	r25, 0x0DCC
    9a20:	0e 94 f2 50 	call	0xa1e4	; 0xa1e4 <fat16_reset_dir>

			File *newfile = fat16_open_file(sd_get_fs(), &file_entry);
    9a24:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    9a28:	b8 01       	movw	r22, r16
    9a2a:	0e 94 dd 5d 	call	0xbbba	; 0xbbba <fat16_open_file>
    9a2e:	8c 01       	movw	r16, r24
			newfile->mode = *mode;
    9a30:	d7 01       	movw	r26, r14
    9a32:	8c 91       	ld	r24, X
    9a34:	f8 01       	movw	r30, r16
    9a36:	87 ab       	std	Z+55, r24	; 0x37
			if (*mode == 'a') {
    9a38:	8c 91       	ld	r24, X
    9a3a:	81 36       	cpi	r24, 0x61	; 97
    9a3c:	f1 f5       	brne	.+124    	; 0x9aba <f16_open+0xdc>
				int32_t offset = 0;
    9a3e:	19 82       	std	Y+1, r1	; 0x01
    9a40:	1a 82       	std	Y+2, r1	; 0x02
    9a42:	1b 82       	std	Y+3, r1	; 0x03
    9a44:	1c 82       	std	Y+4, r1	; 0x04
				fat16_seek_file(newfile, &offset, FAT16_SEEK_END);
    9a46:	c8 01       	movw	r24, r16
    9a48:	be 01       	movw	r22, r28
    9a4a:	6f 5f       	subi	r22, 0xFF	; 255
    9a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    9a4e:	42 e0       	ldi	r20, 0x02	; 2
    9a50:	0e 94 b2 5b 	call	0xb764	; 0xb764 <fat16_seek_file>
    9a54:	32 c0       	rjmp	.+100    	; 0x9aba <f16_open+0xdc>
	if (!sd_get_fs())
		return 0;

    struct fat16_dir_entry_struct file_entry;

    while(fat16_read_dir(cwdir_ptr, &file_entry))
    9a56:	8e 01       	movw	r16, r28
    9a58:	0b 5f       	subi	r16, 0xFB	; 251
    9a5a:	1f 4f       	sbci	r17, 0xFF	; 255
    9a5c:	80 91 cb 0d 	lds	r24, 0x0DCB
    9a60:	90 91 cc 0d 	lds	r25, 0x0DCC
    9a64:	b8 01       	movw	r22, r16
    9a66:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    9a6a:	88 23       	and	r24, r24
    9a6c:	79 f6       	brne	.-98     	; 0x9a0c <f16_open+0x2e>
			}
			return newfile;
        }
    }

	fat16_reset_dir(cwdir_ptr);
    9a6e:	80 91 cb 0d 	lds	r24, 0x0DCB
    9a72:	90 91 cc 0d 	lds	r25, 0x0DCC
    9a76:	0e 94 f2 50 	call	0xa1e4	; 0xa1e4 <fat16_reset_dir>

	// kein Dateieintrag gefunden -> bei mode == "a" oder "w" neuen erstellen
	if (*mode == 'a' || *mode == 'w') {
    9a7a:	d7 01       	movw	r26, r14
    9a7c:	8c 91       	ld	r24, X
    9a7e:	81 36       	cpi	r24, 0x61	; 97
    9a80:	11 f0       	breq	.+4      	; 0x9a86 <f16_open+0xa8>
    9a82:	87 37       	cpi	r24, 0x77	; 119
    9a84:	c1 f4       	brne	.+48     	; 0x9ab6 <f16_open+0xd8>
    	if(fat16_create_file(cwdir_ptr, filename, &file_entry)) {
    9a86:	8e 01       	movw	r16, r28
    9a88:	0b 5f       	subi	r16, 0xFB	; 251
    9a8a:	1f 4f       	sbci	r17, 0xFF	; 255
    9a8c:	80 91 cb 0d 	lds	r24, 0x0DCB
    9a90:	90 91 cc 0d 	lds	r25, 0x0DCC
    9a94:	b6 01       	movw	r22, r12
    9a96:	a8 01       	movw	r20, r16
    9a98:	0e 94 12 5a 	call	0xb424	; 0xb424 <fat16_create_file>
    9a9c:	88 23       	and	r24, r24
    9a9e:	59 f0       	breq	.+22     	; 0x9ab6 <f16_open+0xd8>
			File *newfile = fat16_open_file(sd_get_fs(), &file_entry);
    9aa0:	0e 94 a3 5e 	call	0xbd46	; 0xbd46 <sd_get_fs>
    9aa4:	b8 01       	movw	r22, r16
    9aa6:	0e 94 dd 5d 	call	0xbbba	; 0xbbba <fat16_open_file>
    9aaa:	fc 01       	movw	r30, r24
			newfile->mode = *mode;
    9aac:	d7 01       	movw	r26, r14
    9aae:	8c 91       	ld	r24, X
    9ab0:	87 ab       	std	Z+55, r24	; 0x37
    9ab2:	8f 01       	movw	r16, r30
    9ab4:	02 c0       	rjmp	.+4      	; 0x9aba <f16_open+0xdc>
			return newfile;
    9ab6:	00 e0       	ldi	r16, 0x00	; 0
    9ab8:	10 e0       	ldi	r17, 0x00	; 0
		}
	}

    return 0;
}
    9aba:	c8 01       	movw	r24, r16
    9abc:	e3 96       	adiw	r28, 0x33	; 51
    9abe:	0f b6       	in	r0, 0x3f	; 63
    9ac0:	f8 94       	cli
    9ac2:	de bf       	out	0x3e, r29	; 62
    9ac4:	0f be       	out	0x3f, r0	; 63
    9ac6:	cd bf       	out	0x3d, r28	; 61
    9ac8:	cf 91       	pop	r28
    9aca:	df 91       	pop	r29
    9acc:	1f 91       	pop	r17
    9ace:	0f 91       	pop	r16
    9ad0:	ff 90       	pop	r15
    9ad2:	ef 90       	pop	r14
    9ad4:	df 90       	pop	r13
    9ad6:	cf 90       	pop	r12
    9ad8:	08 95       	ret

00009ada <f16_check>:
 *	\ingroup sdcard
 *  Ein-/Ausstecken der Karte abhandeln
 */
void f16_check(void)
{
    if(sd_get_root_dir() && !sd_raw_available())
    9ada:	0e 94 a8 5e 	call	0xbd50	; 0xbd50 <sd_get_root_dir>
    9ade:	89 2b       	or	r24, r25
    9ae0:	e9 f0       	breq	.+58     	; 0x9b1c <f16_check+0x42>
    9ae2:	0e 94 86 5f 	call	0xbf0c	; 0xbf0c <sd_raw_available>
    9ae6:	88 23       	and	r24, r24
    9ae8:	c9 f4       	brne	.+50     	; 0x9b1c <f16_check+0x42>
    {
        fat16_close_dir(cwdir_ptr);
    9aea:	80 91 cb 0d 	lds	r24, 0x0DCB
    9aee:	90 91 cc 0d 	lds	r25, 0x0DCC
    9af2:	0e 94 ec 50 	call	0xa1d8	; 0xa1d8 <fat16_close_dir>
        sd_close();
    9af6:	0e 94 fa 5e 	call	0xbdf4	; 0xbdf4 <sd_close>
        cwdir_ptr = 0;
    9afa:	10 92 cc 0d 	sts	0x0DCC, r1
    9afe:	10 92 cb 0d 	sts	0x0DCB, r1
		#if USE_LOGDATEI
		if (logStatus.logfile) {
    9b02:	80 91 e6 0b 	lds	r24, 0x0BE6
    9b06:	90 91 e7 0b 	lds	r25, 0x0BE7
    9b0a:	00 97       	sbiw	r24, 0x00	; 0
    9b0c:	09 f1       	breq	.+66     	; 0x9b50 <f16_check+0x76>
			f16_close(logStatus.logfile);
    9b0e:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
			logStatus.logfile = 0;
    9b12:	10 92 e7 0b 	sts	0x0BE7, r1
    9b16:	10 92 e6 0b 	sts	0x0BE6, r1
    9b1a:	08 95       	ret
		}
		#endif

        SD_DEBUG("\r\nSD-Karte unplugged");
    }
    else if(!sd_get_root_dir() && sd_raw_available())
    9b1c:	0e 94 a8 5e 	call	0xbd50	; 0xbd50 <sd_get_root_dir>
    9b20:	89 2b       	or	r24, r25
    9b22:	b1 f4       	brne	.+44     	; 0x9b50 <f16_check+0x76>
    9b24:	0e 94 86 5f 	call	0xbf0c	; 0xbf0c <sd_raw_available>
    9b28:	88 23       	and	r24, r24
    9b2a:	91 f0       	breq	.+36     	; 0x9b50 <f16_check+0x76>
    {
        switch(sd_open())						// SD-Karte initialisieren
    9b2c:	0e 94 19 5f 	call	0xbe32	; 0xbe32 <sd_open>
    9b30:	88 23       	and	r24, r24
    9b32:	71 f4       	brne	.+28     	; 0x9b50 <f16_check+0x76>
        {
            case SD_ERROR_NONE:
                cwdir_ptr = sd_get_root_dir();	// dir-Pointer setzen
    9b34:	0e 94 a8 5e 	call	0xbd50	; 0xbd50 <sd_get_root_dir>
    9b38:	90 93 cc 0d 	sts	0x0DCC, r25
    9b3c:	80 93 cb 0d 	sts	0x0DCB, r24
				cwdirectory[0] = '/';			// start ist root
    9b40:	8f e2       	ldi	r24, 0x2F	; 47
    9b42:	80 93 78 01 	sts	0x0178, r24
				cwdirectory[1] = 0;
    9b46:	10 92 79 01 	sts	0x0179, r1

				#if USE_LOGDATEI
				machineStatus.LogInit = 1;		// Logdatei in Mainloop initialisieren
    9b4a:	81 e0       	ldi	r24, 0x01	; 1
    9b4c:	80 93 40 06 	sts	0x0640, r24
    9b50:	08 95       	ret

00009b52 <f16_init>:
 *	\ingroup sdcard
 *	Hardware fr SD-Karte initialisieren
 */
void f16_init()
{
	spi_init();				// TWI-Bus
    9b52:	0e 94 81 64 	call	0xc902	; 0xc902 <spi_init>
	configure_pin_cs();		// CS des Kartenslots
    9b56:	21 9a       	sbi	0x04, 1	; 4
    sd_raw_init();			// Karte in SPI-Modus setzen
    9b58:	0e 94 2a 63 	call	0xc654	; 0xc654 <sd_raw_init>
	cwdir_ptr = 0;			// noch kein directory gelesen
    9b5c:	10 92 cc 0d 	sts	0x0DCC, r1
    9b60:	10 92 cb 0d 	sts	0x0DCB, r1
}
    9b64:	08 95       	ret

00009b66 <fat16_close>:
 *
 * \param[in] fs The filesystem to close.
 * \see fat16_open
 */
void fat16_close(struct fat16_fs_struct* fs)
{
    9b66:	fc 01       	movw	r30, r24
    if(!fs)
    9b68:	00 97       	sbiw	r24, 0x00	; 0
    9b6a:	11 f0       	breq	.+4      	; 0x9b70 <fat16_close+0xa>
        return;

#if USE_DYNAMIC_MEMORY
    free(fs);
#else
    fs->partition = 0;
    9b6c:	11 82       	std	Z+1, r1	; 0x01
    9b6e:	10 82       	st	Z, r1
    9b70:	08 95       	ret

00009b72 <fat16_get_next_cluster>:
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    9b72:	df 93       	push	r29
    9b74:	cf 93       	push	r28
    9b76:	00 d0       	rcall	.+0      	; 0x9b78 <fat16_get_next_cluster+0x6>
    9b78:	cd b7       	in	r28, 0x3d	; 61
    9b7a:	de b7       	in	r29, 0x3e	; 62
    9b7c:	dc 01       	movw	r26, r24
    if(!fs || cluster_num < 2)
    9b7e:	00 97       	sbiw	r24, 0x00	; 0
    9b80:	a1 f1       	breq	.+104    	; 0x9bea <fat16_get_next_cluster+0x78>
    9b82:	62 30       	cpi	r22, 0x02	; 2
    9b84:	71 05       	cpc	r23, r1
    9b86:	88 f1       	brcs	.+98     	; 0x9bea <fat16_get_next_cluster+0x78>
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
    9b88:	ed 91       	ld	r30, X+
    9b8a:	fc 91       	ld	r31, X
    9b8c:	11 97       	sbiw	r26, 0x01	; 1
    9b8e:	66 0f       	add	r22, r22
    9b90:	77 1f       	adc	r23, r23
    9b92:	80 e0       	ldi	r24, 0x00	; 0
    9b94:	90 e0       	ldi	r25, 0x00	; 0
    9b96:	16 96       	adiw	r26, 0x06	; 6
    9b98:	2d 91       	ld	r18, X+
    9b9a:	3d 91       	ld	r19, X+
    9b9c:	4d 91       	ld	r20, X+
    9b9e:	5c 91       	ld	r21, X
    9ba0:	19 97       	sbiw	r26, 0x09	; 9
    9ba2:	62 0f       	add	r22, r18
    9ba4:	73 1f       	adc	r23, r19
    9ba6:	84 1f       	adc	r24, r20
    9ba8:	95 1f       	adc	r25, r21
    9baa:	01 90       	ld	r0, Z+
    9bac:	f0 81       	ld	r31, Z
    9bae:	e0 2d       	mov	r30, r0
    9bb0:	ae 01       	movw	r20, r28
    9bb2:	4f 5f       	subi	r20, 0xFF	; 255
    9bb4:	5f 4f       	sbci	r21, 0xFF	; 255
    9bb6:	22 e0       	ldi	r18, 0x02	; 2
    9bb8:	30 e0       	ldi	r19, 0x00	; 0
    9bba:	09 95       	icall
    9bbc:	88 23       	and	r24, r24
    9bbe:	a9 f0       	breq	.+42     	; 0x9bea <fat16_get_next_cluster+0x78>
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    9bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    9bc2:	80 e0       	ldi	r24, 0x00	; 0
    9bc4:	29 81       	ldd	r18, Y+1	; 0x01
    9bc6:	30 e0       	ldi	r19, 0x00	; 0
    9bc8:	28 2b       	or	r18, r24
    9bca:	39 2b       	or	r19, r25
                  ((uint16_t) fat_entry[1] << 8);
    
    if(cluster_num == FAT16_CLUSTER_FREE ||
    9bcc:	21 15       	cp	r18, r1
    9bce:	31 05       	cpc	r19, r1
    9bd0:	71 f0       	breq	.+28     	; 0x9bee <fat16_get_next_cluster+0x7c>
    9bd2:	8f ef       	ldi	r24, 0xFF	; 255
    9bd4:	27 3f       	cpi	r18, 0xF7	; 247
    9bd6:	38 07       	cpc	r19, r24
    9bd8:	41 f0       	breq	.+16     	; 0x9bea <fat16_get_next_cluster+0x78>
    9bda:	c9 01       	movw	r24, r18
    9bdc:	40 96       	adiw	r24, 0x10	; 16
    9bde:	07 97       	sbiw	r24, 0x07	; 7
    9be0:	20 f0       	brcs	.+8      	; 0x9bea <fat16_get_next_cluster+0x78>
    9be2:	8f ef       	ldi	r24, 0xFF	; 255
    9be4:	28 3f       	cpi	r18, 0xF8	; 248
    9be6:	38 07       	cpc	r19, r24
    9be8:	10 f0       	brcs	.+4      	; 0x9bee <fat16_get_next_cluster+0x7c>
    9bea:	20 e0       	ldi	r18, 0x00	; 0
    9bec:	30 e0       	ldi	r19, 0x00	; 0
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
       (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
        return 0;
    
    return cluster_num;
}
    9bee:	c9 01       	movw	r24, r18
    9bf0:	0f 90       	pop	r0
    9bf2:	0f 90       	pop	r0
    9bf4:	cf 91       	pop	r28
    9bf6:	df 91       	pop	r29
    9bf8:	08 95       	ret

00009bfa <fat16_free_clusters>:
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    9bfa:	2f 92       	push	r2
    9bfc:	3f 92       	push	r3
    9bfe:	4f 92       	push	r4
    9c00:	5f 92       	push	r5
    9c02:	6f 92       	push	r6
    9c04:	7f 92       	push	r7
    9c06:	8f 92       	push	r8
    9c08:	9f 92       	push	r9
    9c0a:	af 92       	push	r10
    9c0c:	bf 92       	push	r11
    9c0e:	cf 92       	push	r12
    9c10:	df 92       	push	r13
    9c12:	ef 92       	push	r14
    9c14:	ff 92       	push	r15
    9c16:	0f 93       	push	r16
    9c18:	1f 93       	push	r17
    9c1a:	df 93       	push	r29
    9c1c:	cf 93       	push	r28
    9c1e:	00 d0       	rcall	.+0      	; 0x9c20 <fat16_free_clusters+0x26>
    9c20:	cd b7       	in	r28, 0x3d	; 61
    9c22:	de b7       	in	r29, 0x3e	; 62
    9c24:	4c 01       	movw	r8, r24
#if FAT16_WRITE_SUPPORT
    if(!fs || cluster_num < 2)
    9c26:	00 97       	sbiw	r24, 0x00	; 0
    9c28:	09 f4       	brne	.+2      	; 0x9c2c <fat16_free_clusters+0x32>
    9c2a:	4d c0       	rjmp	.+154    	; 0x9cc6 <fat16_free_clusters+0xcc>
    9c2c:	62 30       	cpi	r22, 0x02	; 2
    9c2e:	71 05       	cpc	r23, r1
    9c30:	08 f4       	brcc	.+2      	; 0x9c34 <fat16_free_clusters+0x3a>
    9c32:	49 c0       	rjmp	.+146    	; 0x9cc6 <fat16_free_clusters+0xcc>
        return 0;

    uint32_t fat_offset = fs->header.fat_offset;
    9c34:	dc 01       	movw	r26, r24
    9c36:	16 96       	adiw	r26, 0x06	; 6
    9c38:	4d 90       	ld	r4, X+
    9c3a:	5d 90       	ld	r5, X+
    9c3c:	6d 90       	ld	r6, X+
    9c3e:	7c 90       	ld	r7, X
    9c40:	19 97       	sbiw	r26, 0x09	; 9
    uint8_t buffer[2];
    while(cluster_num)
    {
        if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
    9c42:	1e 01       	movw	r2, r28
    9c44:	08 94       	sec
    9c46:	21 1c       	adc	r2, r1
    9c48:	31 1c       	adc	r3, r1
    9c4a:	66 0f       	add	r22, r22
    9c4c:	77 1f       	adc	r23, r23
    9c4e:	6b 01       	movw	r12, r22
    9c50:	ee 24       	eor	r14, r14
    9c52:	ff 24       	eor	r15, r15
    9c54:	c4 0c       	add	r12, r4
    9c56:	d5 1c       	adc	r13, r5
    9c58:	e6 1c       	adc	r14, r6
    9c5a:	f7 1c       	adc	r15, r7
    9c5c:	d4 01       	movw	r26, r8
    9c5e:	ed 91       	ld	r30, X+
    9c60:	fc 91       	ld	r31, X
    9c62:	01 90       	ld	r0, Z+
    9c64:	f0 81       	ld	r31, Z
    9c66:	e0 2d       	mov	r30, r0
    9c68:	c7 01       	movw	r24, r14
    9c6a:	b6 01       	movw	r22, r12
    9c6c:	a1 01       	movw	r20, r2
    9c6e:	22 e0       	ldi	r18, 0x02	; 2
    9c70:	30 e0       	ldi	r19, 0x00	; 0
    9c72:	09 95       	icall
    9c74:	88 23       	and	r24, r24
    9c76:	39 f1       	breq	.+78     	; 0x9cc6 <fat16_free_clusters+0xcc>
            return 0;

        /* get next cluster of current cluster before freeing current cluster */
        uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
                                    ((uint16_t) buffer[1] << 8);
    9c78:	ba 80       	ldd	r11, Y+2	; 0x02
    9c7a:	aa 24       	eor	r10, r10
    9c7c:	89 81       	ldd	r24, Y+1	; 0x01
    9c7e:	08 2f       	mov	r16, r24
    9c80:	10 e0       	ldi	r17, 0x00	; 0
    9c82:	0a 29       	or	r16, r10
    9c84:	1b 29       	or	r17, r11

        if(cluster_num_next == FAT16_CLUSTER_FREE)
    9c86:	01 15       	cp	r16, r1
    9c88:	11 05       	cpc	r17, r1
    9c8a:	f9 f0       	breq	.+62     	; 0x9cca <fat16_free_clusters+0xd0>
            return 1;
        if(cluster_num_next == FAT16_CLUSTER_BAD ||
    9c8c:	c8 01       	movw	r24, r16
    9c8e:	40 96       	adiw	r24, 0x10	; 16
    9c90:	08 97       	sbiw	r24, 0x08	; 8
    9c92:	c8 f0       	brcs	.+50     	; 0x9cc6 <fat16_free_clusters+0xcc>
           (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
            cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
           )
          )
            return 0;
        if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN && cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
    9c94:	bf ef       	ldi	r27, 0xFF	; 255
    9c96:	08 3f       	cpi	r16, 0xF8	; 248
    9c98:	1b 07       	cpc	r17, r27
    9c9a:	10 f0       	brcs	.+4      	; 0x9ca0 <fat16_free_clusters+0xa6>
    9c9c:	00 e0       	ldi	r16, 0x00	; 0
    9c9e:	10 e0       	ldi	r17, 0x00	; 0
            cluster_num_next = 0;

        /* free cluster */
        buffer[0] = FAT16_CLUSTER_FREE & 0xff;
    9ca0:	19 82       	std	Y+1, r1	; 0x01
        buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
    9ca2:	1a 82       	std	Y+2, r1	; 0x02
        fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
    9ca4:	d4 01       	movw	r26, r8
    9ca6:	ed 91       	ld	r30, X+
    9ca8:	fc 91       	ld	r31, X
    9caa:	04 80       	ldd	r0, Z+4	; 0x04
    9cac:	f5 81       	ldd	r31, Z+5	; 0x05
    9cae:	e0 2d       	mov	r30, r0
    9cb0:	c7 01       	movw	r24, r14
    9cb2:	b6 01       	movw	r22, r12
    9cb4:	a1 01       	movw	r20, r2
    9cb6:	22 e0       	ldi	r18, 0x02	; 2
    9cb8:	30 e0       	ldi	r19, 0x00	; 0
    9cba:	09 95       	icall
    9cbc:	b8 01       	movw	r22, r16
    if(!fs || cluster_num < 2)
        return 0;

    uint32_t fat_offset = fs->header.fat_offset;
    uint8_t buffer[2];
    while(cluster_num)
    9cbe:	01 15       	cp	r16, r1
    9cc0:	11 05       	cpc	r17, r1
    9cc2:	19 f6       	brne	.-122    	; 0x9c4a <fat16_free_clusters+0x50>
    9cc4:	02 c0       	rjmp	.+4      	; 0x9cca <fat16_free_clusters+0xd0>
    9cc6:	80 e0       	ldi	r24, 0x00	; 0
    9cc8:	01 c0       	rjmp	.+2      	; 0x9ccc <fat16_free_clusters+0xd2>
    9cca:	81 e0       	ldi	r24, 0x01	; 1

    return 1;
#else
    return 0;
#endif
}
    9ccc:	0f 90       	pop	r0
    9cce:	0f 90       	pop	r0
    9cd0:	cf 91       	pop	r28
    9cd2:	df 91       	pop	r29
    9cd4:	1f 91       	pop	r17
    9cd6:	0f 91       	pop	r16
    9cd8:	ff 90       	pop	r15
    9cda:	ef 90       	pop	r14
    9cdc:	df 90       	pop	r13
    9cde:	cf 90       	pop	r12
    9ce0:	bf 90       	pop	r11
    9ce2:	af 90       	pop	r10
    9ce4:	9f 90       	pop	r9
    9ce6:	8f 90       	pop	r8
    9ce8:	7f 90       	pop	r7
    9cea:	6f 90       	pop	r6
    9cec:	5f 90       	pop	r5
    9cee:	4f 90       	pop	r4
    9cf0:	3f 90       	pop	r3
    9cf2:	2f 90       	pop	r2
    9cf4:	08 95       	ret

00009cf6 <fat16_append_clusters>:
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    9cf6:	2f 92       	push	r2
    9cf8:	3f 92       	push	r3
    9cfa:	4f 92       	push	r4
    9cfc:	5f 92       	push	r5
    9cfe:	6f 92       	push	r6
    9d00:	7f 92       	push	r7
    9d02:	8f 92       	push	r8
    9d04:	9f 92       	push	r9
    9d06:	af 92       	push	r10
    9d08:	bf 92       	push	r11
    9d0a:	cf 92       	push	r12
    9d0c:	df 92       	push	r13
    9d0e:	ef 92       	push	r14
    9d10:	ff 92       	push	r15
    9d12:	0f 93       	push	r16
    9d14:	1f 93       	push	r17
    9d16:	df 93       	push	r29
    9d18:	cf 93       	push	r28
    9d1a:	cd b7       	in	r28, 0x3d	; 61
    9d1c:	de b7       	in	r29, 0x3e	; 62
    9d1e:	2c 97       	sbiw	r28, 0x0c	; 12
    9d20:	0f b6       	in	r0, 0x3f	; 63
    9d22:	f8 94       	cli
    9d24:	de bf       	out	0x3e, r29	; 62
    9d26:	0f be       	out	0x3f, r0	; 63
    9d28:	cd bf       	out	0x3d, r28	; 61
    9d2a:	3c 01       	movw	r6, r24
    9d2c:	2b 01       	movw	r4, r22
    9d2e:	1a 01       	movw	r2, r20
#if FAT16_WRITE_SUPPORT
    if(!fs)
    9d30:	00 97       	sbiw	r24, 0x00	; 0
    9d32:	09 f4       	brne	.+2      	; 0x9d36 <fat16_append_clusters+0x40>
    9d34:	94 c0       	rjmp	.+296    	; 0x9e5e <fat16_append_clusters+0x168>
        return 0;

    device_read_t device_read = fs->partition->device_read;
    9d36:	dc 01       	movw	r26, r24
    9d38:	ed 91       	ld	r30, X+
    9d3a:	fc 91       	ld	r31, X
    9d3c:	11 97       	sbiw	r26, 0x01	; 1
    9d3e:	20 81       	ld	r18, Z
    9d40:	31 81       	ldd	r19, Z+1	; 0x01
    9d42:	3c 87       	std	Y+12, r19	; 0x0c
    9d44:	2b 87       	std	Y+11, r18	; 0x0b
    device_write_t device_write = fs->partition->device_write;
    9d46:	44 81       	ldd	r20, Z+4	; 0x04
    9d48:	55 81       	ldd	r21, Z+5	; 0x05
    9d4a:	5a 87       	std	Y+10, r21	; 0x0a
    9d4c:	49 87       	std	Y+9, r20	; 0x09
    uint32_t fat_offset = fs->header.fat_offset;
    9d4e:	16 96       	adiw	r26, 0x06	; 6
    9d50:	8d 91       	ld	r24, X+
    9d52:	9d 91       	ld	r25, X+
    9d54:	0d 90       	ld	r0, X+
    9d56:	bc 91       	ld	r27, X
    9d58:	a0 2d       	mov	r26, r0
    9d5a:	8d 83       	std	Y+5, r24	; 0x05
    9d5c:	9e 83       	std	Y+6, r25	; 0x06
    9d5e:	af 83       	std	Y+7, r26	; 0x07
    9d60:	b8 87       	std	Y+8, r27	; 0x08
    uint16_t cluster_max = fs->header.fat_size / 2;
    9d62:	f3 01       	movw	r30, r6
    9d64:	82 85       	ldd	r24, Z+10	; 0x0a
    9d66:	93 85       	ldd	r25, Z+11	; 0x0b
    9d68:	a4 85       	ldd	r26, Z+12	; 0x0c
    9d6a:	b5 85       	ldd	r27, Z+13	; 0x0d
    9d6c:	b6 95       	lsr	r27
    9d6e:	a7 95       	ror	r26
    9d70:	97 95       	ror	r25
    9d72:	87 95       	ror	r24
    9d74:	9c 83       	std	Y+4, r25	; 0x04
    9d76:	8b 83       	std	Y+3, r24	; 0x03
    9d78:	41 01       	movw	r8, r2
    9d7a:	cc 24       	eor	r12, r12
    9d7c:	dd 24       	eor	r13, r13
    9d7e:	aa 24       	eor	r10, r10
    9d80:	bb 24       	eor	r11, r11
    9d82:	43 c0       	rjmp	.+134    	; 0x9e0a <fat16_append_clusters+0x114>
    uint16_t count_left = count;
    uint8_t buffer[2];

    for(uint16_t cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
    {
        if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
    9d84:	c5 01       	movw	r24, r10
    9d86:	88 0f       	add	r24, r24
    9d88:	99 1f       	adc	r25, r25
    9d8a:	7c 01       	movw	r14, r24
    9d8c:	00 e0       	ldi	r16, 0x00	; 0
    9d8e:	10 e0       	ldi	r17, 0x00	; 0
    9d90:	2d 81       	ldd	r18, Y+5	; 0x05
    9d92:	3e 81       	ldd	r19, Y+6	; 0x06
    9d94:	4f 81       	ldd	r20, Y+7	; 0x07
    9d96:	58 85       	ldd	r21, Y+8	; 0x08
    9d98:	e2 0e       	add	r14, r18
    9d9a:	f3 1e       	adc	r15, r19
    9d9c:	04 1f       	adc	r16, r20
    9d9e:	15 1f       	adc	r17, r21
    9da0:	c8 01       	movw	r24, r16
    9da2:	b7 01       	movw	r22, r14
    9da4:	ae 01       	movw	r20, r28
    9da6:	4f 5f       	subi	r20, 0xFF	; 255
    9da8:	5f 4f       	sbci	r21, 0xFF	; 255
    9daa:	22 e0       	ldi	r18, 0x02	; 2
    9dac:	30 e0       	ldi	r19, 0x00	; 0
    9dae:	ab 85       	ldd	r26, Y+11	; 0x0b
    9db0:	bc 85       	ldd	r27, Y+12	; 0x0c
    9db2:	fd 01       	movw	r30, r26
    9db4:	09 95       	icall
    9db6:	88 23       	and	r24, r24
    9db8:	09 f4       	brne	.+2      	; 0x9dbc <fat16_append_clusters+0xc6>
    9dba:	51 c0       	rjmp	.+162    	; 0x9e5e <fat16_append_clusters+0x168>
            return 0;

        /* check if this is a free cluster */
        if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
    9dbc:	89 81       	ldd	r24, Y+1	; 0x01
    9dbe:	88 23       	and	r24, r24
    9dc0:	09 f5       	brne	.+66     	; 0x9e04 <fat16_append_clusters+0x10e>
    9dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    9dc4:	88 23       	and	r24, r24
    9dc6:	f1 f4       	brne	.+60     	; 0x9e04 <fat16_append_clusters+0x10e>
           buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
        {
            /* allocate cluster */
            if(count_left == count)
    9dc8:	82 14       	cp	r8, r2
    9dca:	93 04       	cpc	r9, r3
    9dcc:	21 f4       	brne	.+8      	; 0x9dd6 <fat16_append_clusters+0xe0>
            {
                buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
    9dce:	bf ef       	ldi	r27, 0xFF	; 255
    9dd0:	b9 83       	std	Y+1, r27	; 0x01
                buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
    9dd2:	ba 83       	std	Y+2, r27	; 0x02
    9dd4:	02 c0       	rjmp	.+4      	; 0x9dda <fat16_append_clusters+0xe4>
            }
            else
            {
                buffer[0] = cluster_next & 0xff;
    9dd6:	c9 82       	std	Y+1, r12	; 0x01
                buffer[1] = (cluster_next >> 8) & 0xff;
    9dd8:	da 82       	std	Y+2, r13	; 0x02
            }

            if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
    9dda:	c8 01       	movw	r24, r16
    9ddc:	b7 01       	movw	r22, r14
    9dde:	ae 01       	movw	r20, r28
    9de0:	4f 5f       	subi	r20, 0xFF	; 255
    9de2:	5f 4f       	sbci	r21, 0xFF	; 255
    9de4:	22 e0       	ldi	r18, 0x02	; 2
    9de6:	30 e0       	ldi	r19, 0x00	; 0
    9de8:	e9 85       	ldd	r30, Y+9	; 0x09
    9dea:	fa 85       	ldd	r31, Y+10	; 0x0a
    9dec:	09 95       	icall
    9dee:	88 23       	and	r24, r24
    9df0:	91 f0       	breq	.+36     	; 0x9e16 <fat16_append_clusters+0x120>
                break;

            cluster_next = cluster_new;
            if(--count_left == 0)
    9df2:	08 94       	sec
    9df4:	81 08       	sbc	r8, r1
    9df6:	91 08       	sbc	r9, r1
    9df8:	81 14       	cp	r8, r1
    9dfa:	91 04       	cpc	r9, r1
    9dfc:	11 f4       	brne	.+4      	; 0x9e02 <fat16_append_clusters+0x10c>
    9dfe:	65 01       	movw	r12, r10
    9e00:	0c c0       	rjmp	.+24     	; 0x9e1a <fat16_append_clusters+0x124>
    9e02:	65 01       	movw	r12, r10
    uint16_t cluster_max = fs->header.fat_size / 2;
    uint16_t cluster_next = 0;
    uint16_t count_left = count;
    uint8_t buffer[2];

    for(uint16_t cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
    9e04:	08 94       	sec
    9e06:	a1 1c       	adc	r10, r1
    9e08:	b1 1c       	adc	r11, r1
    9e0a:	2b 81       	ldd	r18, Y+3	; 0x03
    9e0c:	3c 81       	ldd	r19, Y+4	; 0x04
    9e0e:	a2 16       	cp	r10, r18
    9e10:	b3 06       	cpc	r11, r19
    9e12:	08 f4       	brcc	.+2      	; 0x9e16 <fat16_append_clusters+0x120>
    9e14:	b7 cf       	rjmp	.-146    	; 0x9d84 <fat16_append_clusters+0x8e>
        }
    }

    do
    {
        if(count_left > 0)
    9e16:	89 28       	or	r8, r9
    9e18:	f1 f4       	brne	.+60     	; 0x9e56 <fat16_append_clusters+0x160>
            break;

        /* We allocated a new cluster chain. Now join
         * it with the existing one.
         */
        if(cluster_num >= 2)
    9e1a:	32 e0       	ldi	r19, 0x02	; 2
    9e1c:	43 16       	cp	r4, r19
    9e1e:	51 04       	cpc	r5, r1
    9e20:	00 f1       	brcs	.+64     	; 0x9e62 <fat16_append_clusters+0x16c>
        {
            buffer[0] = cluster_next & 0xff;
    9e22:	c9 82       	std	Y+1, r12	; 0x01
            buffer[1] = (cluster_next >> 8) & 0xff;
    9e24:	da 82       	std	Y+2, r13	; 0x02
            if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
    9e26:	44 0c       	add	r4, r4
    9e28:	55 1c       	adc	r5, r5
    9e2a:	b2 01       	movw	r22, r4
    9e2c:	80 e0       	ldi	r24, 0x00	; 0
    9e2e:	90 e0       	ldi	r25, 0x00	; 0
    9e30:	2d 81       	ldd	r18, Y+5	; 0x05
    9e32:	3e 81       	ldd	r19, Y+6	; 0x06
    9e34:	4f 81       	ldd	r20, Y+7	; 0x07
    9e36:	58 85       	ldd	r21, Y+8	; 0x08
    9e38:	62 0f       	add	r22, r18
    9e3a:	73 1f       	adc	r23, r19
    9e3c:	84 1f       	adc	r24, r20
    9e3e:	95 1f       	adc	r25, r21
    9e40:	ae 01       	movw	r20, r28
    9e42:	4f 5f       	subi	r20, 0xFF	; 255
    9e44:	5f 4f       	sbci	r21, 0xFF	; 255
    9e46:	22 e0       	ldi	r18, 0x02	; 2
    9e48:	30 e0       	ldi	r19, 0x00	; 0
    9e4a:	a9 85       	ldd	r26, Y+9	; 0x09
    9e4c:	ba 85       	ldd	r27, Y+10	; 0x0a
    9e4e:	fd 01       	movw	r30, r26
    9e50:	09 95       	icall
    9e52:	88 23       	and	r24, r24
    9e54:	31 f4       	brne	.+12     	; 0x9e62 <fat16_append_clusters+0x16c>
    } while(0);

    /* No space left on device or writing error.
     * Free up all clusters already allocated.
     */
    fat16_free_clusters(fs, cluster_next);
    9e56:	c3 01       	movw	r24, r6
    9e58:	b6 01       	movw	r22, r12
    9e5a:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <fat16_free_clusters>

    return 0;
    9e5e:	cc 24       	eor	r12, r12
    9e60:	dd 24       	eor	r13, r13
#else
    return 0;
#endif
}
    9e62:	c6 01       	movw	r24, r12
    9e64:	2c 96       	adiw	r28, 0x0c	; 12
    9e66:	0f b6       	in	r0, 0x3f	; 63
    9e68:	f8 94       	cli
    9e6a:	de bf       	out	0x3e, r29	; 62
    9e6c:	0f be       	out	0x3f, r0	; 63
    9e6e:	cd bf       	out	0x3d, r28	; 61
    9e70:	cf 91       	pop	r28
    9e72:	df 91       	pop	r29
    9e74:	1f 91       	pop	r17
    9e76:	0f 91       	pop	r16
    9e78:	ff 90       	pop	r15
    9e7a:	ef 90       	pop	r14
    9e7c:	df 90       	pop	r13
    9e7e:	cf 90       	pop	r12
    9e80:	bf 90       	pop	r11
    9e82:	af 90       	pop	r10
    9e84:	9f 90       	pop	r9
    9e86:	8f 90       	pop	r8
    9e88:	7f 90       	pop	r7
    9e8a:	6f 90       	pop	r6
    9e8c:	5f 90       	pop	r5
    9e8e:	4f 90       	pop	r4
    9e90:	3f 90       	pop	r3
    9e92:	2f 90       	pop	r2
    9e94:	08 95       	ret

00009e96 <fat16_clear_cluster>:
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The cluster to clear.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_clear_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    9e96:	ef 92       	push	r14
    9e98:	ff 92       	push	r15
    9e9a:	0f 93       	push	r16
    9e9c:	1f 93       	push	r17
    9e9e:	df 93       	push	r29
    9ea0:	cf 93       	push	r28
    9ea2:	cd b7       	in	r28, 0x3d	; 61
    9ea4:	de b7       	in	r29, 0x3e	; 62
    9ea6:	60 97       	sbiw	r28, 0x10	; 16
    9ea8:	0f b6       	in	r0, 0x3f	; 63
    9eaa:	f8 94       	cli
    9eac:	de bf       	out	0x3e, r29	; 62
    9eae:	0f be       	out	0x3f, r0	; 63
    9eb0:	cd bf       	out	0x3d, r28	; 61
    9eb2:	8c 01       	movw	r16, r24
#if FAT16_WRITE_SUPPORT
    if(cluster_num < 2)
    9eb4:	62 30       	cpi	r22, 0x02	; 2
    9eb6:	71 05       	cpc	r23, r1
    9eb8:	10 f4       	brcc	.+4      	; 0x9ebe <fat16_clear_cluster+0x28>
    9eba:	80 e0       	ldi	r24, 0x00	; 0
    9ebc:	34 c0       	rjmp	.+104    	; 0x9f26 <fat16_clear_cluster+0x90>
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
uint32_t fat16_cluster_offset(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    if(!fs || cluster_num < 2)
    9ebe:	00 97       	sbiw	r24, 0x00	; 0
    9ec0:	29 f4       	brne	.+10     	; 0x9ecc <fat16_clear_cluster+0x36>
    9ec2:	40 e0       	ldi	r20, 0x00	; 0
    9ec4:	50 e0       	ldi	r21, 0x00	; 0
    9ec6:	60 e0       	ldi	r22, 0x00	; 0
    9ec8:	70 e0       	ldi	r23, 0x00	; 0
    9eca:	18 c0       	rjmp	.+48     	; 0x9efc <fat16_clear_cluster+0x66>
        return 0;

    return fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
    9ecc:	62 50       	subi	r22, 0x02	; 2
    9ece:	70 40       	sbci	r23, 0x00	; 0
    9ed0:	80 e0       	ldi	r24, 0x00	; 0
    9ed2:	90 e0       	ldi	r25, 0x00	; 0
    9ed4:	d8 01       	movw	r26, r16
    9ed6:	50 96       	adiw	r26, 0x10	; 16
    9ed8:	2d 91       	ld	r18, X+
    9eda:	3c 91       	ld	r19, X
    9edc:	51 97       	sbiw	r26, 0x11	; 17
    9ede:	40 e0       	ldi	r20, 0x00	; 0
    9ee0:	50 e0       	ldi	r21, 0x00	; 0
    9ee2:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    9ee6:	ab 01       	movw	r20, r22
    9ee8:	bc 01       	movw	r22, r24
    9eea:	f8 01       	movw	r30, r16
    9eec:	86 89       	ldd	r24, Z+22	; 0x16
    9eee:	97 89       	ldd	r25, Z+23	; 0x17
    9ef0:	a0 8d       	ldd	r26, Z+24	; 0x18
    9ef2:	b1 8d       	ldd	r27, Z+25	; 0x19
    9ef4:	48 0f       	add	r20, r24
    9ef6:	59 1f       	adc	r21, r25
    9ef8:	6a 1f       	adc	r22, r26
    9efa:	7b 1f       	adc	r23, r27
    if(cluster_num < 2)
        return 0;

    uint32_t cluster_offset = fat16_cluster_offset(fs, cluster_num);
    uint8_t zero[16];
    return fs->partition->device_write_interval(cluster_offset,
    9efc:	d8 01       	movw	r26, r16
    9efe:	ed 91       	ld	r30, X+
    9f00:	fc 91       	ld	r31, X
    9f02:	11 97       	sbiw	r26, 0x01	; 1
    9f04:	50 96       	adiw	r26, 0x10	; 16
    9f06:	2d 91       	ld	r18, X+
    9f08:	3c 91       	ld	r19, X
    9f0a:	51 97       	sbiw	r26, 0x11	; 17
    9f0c:	06 80       	ldd	r0, Z+6	; 0x06
    9f0e:	f7 81       	ldd	r31, Z+7	; 0x07
    9f10:	e0 2d       	mov	r30, r0
    9f12:	cb 01       	movw	r24, r22
    9f14:	ba 01       	movw	r22, r20
    9f16:	ae 01       	movw	r20, r28
    9f18:	4f 5f       	subi	r20, 0xFF	; 255
    9f1a:	5f 4f       	sbci	r21, 0xFF	; 255
    9f1c:	00 eb       	ldi	r16, 0xB0	; 176
    9f1e:	13 e5       	ldi	r17, 0x53	; 83
    9f20:	ee 24       	eor	r14, r14
    9f22:	ff 24       	eor	r15, r15
    9f24:	09 95       	icall
                                                0
                                               );
#else
    return 0;
#endif
}
    9f26:	60 96       	adiw	r28, 0x10	; 16
    9f28:	0f b6       	in	r0, 0x3f	; 63
    9f2a:	f8 94       	cli
    9f2c:	de bf       	out	0x3e, r29	; 62
    9f2e:	0f be       	out	0x3f, r0	; 63
    9f30:	cd bf       	out	0x3d, r28	; 61
    9f32:	cf 91       	pop	r28
    9f34:	df 91       	pop	r29
    9f36:	1f 91       	pop	r17
    9f38:	0f 91       	pop	r16
    9f3a:	ff 90       	pop	r15
    9f3c:	ef 90       	pop	r14
    9f3e:	08 95       	ret

00009f40 <fat16_close_file>:
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    9f40:	fc 01       	movw	r30, r24
    if(fd)
    9f42:	00 97       	sbiw	r24, 0x00	; 0
    9f44:	11 f0       	breq	.+4      	; 0x9f4a <fat16_close_file+0xa>
#if USE_DYNAMIC_MEMORY
        free(fd);
#else
        fd->fs = 0;
    9f46:	11 82       	std	Z+1, r1	; 0x01
    9f48:	10 82       	st	Z, r1
    9f4a:	08 95       	ret

00009f4c <fat16_read_file>:
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
    9f4c:	2f 92       	push	r2
    9f4e:	3f 92       	push	r3
    9f50:	4f 92       	push	r4
    9f52:	5f 92       	push	r5
    9f54:	6f 92       	push	r6
    9f56:	7f 92       	push	r7
    9f58:	8f 92       	push	r8
    9f5a:	9f 92       	push	r9
    9f5c:	af 92       	push	r10
    9f5e:	bf 92       	push	r11
    9f60:	cf 92       	push	r12
    9f62:	df 92       	push	r13
    9f64:	ef 92       	push	r14
    9f66:	ff 92       	push	r15
    9f68:	0f 93       	push	r16
    9f6a:	1f 93       	push	r17
    9f6c:	df 93       	push	r29
    9f6e:	cf 93       	push	r28
    9f70:	cd b7       	in	r28, 0x3d	; 61
    9f72:	de b7       	in	r29, 0x3e	; 62
    9f74:	2a 97       	sbiw	r28, 0x0a	; 10
    9f76:	0f b6       	in	r0, 0x3f	; 63
    9f78:	f8 94       	cli
    9f7a:	de bf       	out	0x3e, r29	; 62
    9f7c:	0f be       	out	0x3f, r0	; 63
    9f7e:	cd bf       	out	0x3d, r28	; 61
    9f80:	2c 01       	movw	r4, r24
    9f82:	7c 83       	std	Y+4, r23	; 0x04
    9f84:	6b 83       	std	Y+3, r22	; 0x03
    9f86:	1a 01       	movw	r2, r20
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    9f88:	00 97       	sbiw	r24, 0x00	; 0
    9f8a:	09 f4       	brne	.+2      	; 0x9f8e <fat16_read_file+0x42>
    9f8c:	06 c1       	rjmp	.+524    	; 0xa19a <fat16_read_file+0x24e>
    9f8e:	67 2b       	or	r22, r23
    9f90:	09 f4       	brne	.+2      	; 0x9f94 <fat16_read_file+0x48>
    9f92:	03 c1       	rjmp	.+518    	; 0xa19a <fat16_read_file+0x24e>
    9f94:	41 15       	cp	r20, r1
    9f96:	51 05       	cpc	r21, r1
    9f98:	09 f4       	brne	.+2      	; 0x9f9c <fat16_read_file+0x50>
    9f9a:	ff c0       	rjmp	.+510    	; 0xa19a <fat16_read_file+0x24e>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
    9f9c:	dc 01       	movw	r26, r24
    9f9e:	d1 96       	adiw	r26, 0x31	; 49
    9fa0:	ad 90       	ld	r10, X+
    9fa2:	bd 90       	ld	r11, X+
    9fa4:	cd 90       	ld	r12, X+
    9fa6:	dc 90       	ld	r13, X
    9fa8:	d4 97       	sbiw	r26, 0x34	; 52
    9faa:	99 96       	adiw	r26, 0x29	; 41
    9fac:	2d 91       	ld	r18, X+
    9fae:	3d 91       	ld	r19, X+
    9fb0:	4d 91       	ld	r20, X+
    9fb2:	5c 91       	ld	r21, X
    9fb4:	9c 97       	sbiw	r26, 0x2c	; 44
    9fb6:	c1 01       	movw	r24, r2
    9fb8:	a0 e0       	ldi	r26, 0x00	; 0
    9fba:	b0 e0       	ldi	r27, 0x00	; 0
    9fbc:	8a 0d       	add	r24, r10
    9fbe:	9b 1d       	adc	r25, r11
    9fc0:	ac 1d       	adc	r26, r12
    9fc2:	bd 1d       	adc	r27, r13
    9fc4:	28 17       	cp	r18, r24
    9fc6:	39 07       	cpc	r19, r25
    9fc8:	4a 07       	cpc	r20, r26
    9fca:	5b 07       	cpc	r21, r27
    9fcc:	28 f4       	brcc	.+10     	; 0x9fd8 <fat16_read_file+0x8c>
        buffer_len = fd->dir_entry.file_size - fd->pos;
    9fce:	19 01       	movw	r2, r18
    9fd0:	2a 18       	sub	r2, r10
    9fd2:	3b 08       	sbc	r3, r11
    if(buffer_len == 0)
    9fd4:	09 f4       	brne	.+2      	; 0x9fd8 <fat16_read_file+0x8c>
    9fd6:	e4 c0       	rjmp	.+456    	; 0xa1a0 <fat16_read_file+0x254>
        return 0;
    
    uint16_t cluster_size = fd->fs->header.cluster_size;
    9fd8:	d2 01       	movw	r26, r4
    9fda:	ed 91       	ld	r30, X+
    9fdc:	fc 91       	ld	r31, X
    9fde:	11 97       	sbiw	r26, 0x01	; 1
    9fe0:	20 89       	ldd	r18, Z+16	; 0x10
    9fe2:	31 89       	ldd	r19, Z+17	; 0x11
    9fe4:	3a 83       	std	Y+2, r19	; 0x02
    9fe6:	29 83       	std	Y+1, r18	; 0x01
    uint16_t cluster_num = fd->pos_cluster;
    9fe8:	d5 96       	adiw	r26, 0x35	; 53
    9fea:	8d 91       	ld	r24, X+
    9fec:	9c 91       	ld	r25, X
    9fee:	d6 97       	sbiw	r26, 0x36	; 54
    9ff0:	9a 87       	std	Y+10, r25	; 0x0a
    9ff2:	89 87       	std	Y+9, r24	; 0x09
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;
    9ff4:	39 01       	movw	r6, r18
    9ff6:	88 24       	eor	r8, r8
    9ff8:	99 24       	eor	r9, r9

    /* find cluster in which to start reading */
    if(!cluster_num)
    9ffa:	89 2b       	or	r24, r25
    9ffc:	d9 f5       	brne	.+118    	; 0xa074 <fat16_read_file+0x128>
    {
        cluster_num = fd->dir_entry.cluster;
    9ffe:	97 96       	adiw	r26, 0x27	; 39
    a000:	0d 90       	ld	r0, X+
    a002:	bc 91       	ld	r27, X
    a004:	a0 2d       	mov	r26, r0
    a006:	ba 87       	std	Y+10, r27	; 0x0a
    a008:	a9 87       	std	Y+9, r26	; 0x09
        
        if(!cluster_num)
    a00a:	ab 2b       	or	r26, r27
    a00c:	39 f4       	brne	.+14     	; 0xa01c <fat16_read_file+0xd0>
        {
            if(!fd->pos)
    a00e:	a1 14       	cp	r10, r1
    a010:	b1 04       	cpc	r11, r1
    a012:	c1 04       	cpc	r12, r1
    a014:	d1 04       	cpc	r13, r1
    a016:	09 f4       	brne	.+2      	; 0xa01a <fat16_read_file+0xce>
    a018:	c3 c0       	rjmp	.+390    	; 0xa1a0 <fat16_read_file+0x254>
    a01a:	bf c0       	rjmp	.+382    	; 0xa19a <fat16_read_file+0x24e>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
    a01c:	a1 14       	cp	r10, r1
    a01e:	b1 04       	cpc	r11, r1
    a020:	c1 04       	cpc	r12, r1
    a022:	d1 04       	cpc	r13, r1
    a024:	39 f1       	breq	.+78     	; 0xa074 <fat16_read_file+0x128>
    a026:	86 01       	movw	r16, r12
    a028:	75 01       	movw	r14, r10
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num)
    a02a:	88 27       	eor	r24, r24
    a02c:	99 27       	eor	r25, r25
    a02e:	dc 01       	movw	r26, r24
    a030:	86 19       	sub	r24, r6
    a032:	97 09       	sbc	r25, r7
    a034:	a8 09       	sbc	r26, r8
    a036:	b9 09       	sbc	r27, r9
    a038:	8d 83       	std	Y+5, r24	; 0x05
    a03a:	9e 83       	std	Y+6, r25	; 0x06
    a03c:	af 83       	std	Y+7, r26	; 0x07
    a03e:	b8 87       	std	Y+8, r27	; 0x08
    a040:	14 c0       	rjmp	.+40     	; 0xa06a <fat16_read_file+0x11e>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
    a042:	d2 01       	movw	r26, r4
    a044:	8d 91       	ld	r24, X+
    a046:	9c 91       	ld	r25, X
    a048:	69 85       	ldd	r22, Y+9	; 0x09
    a04a:	7a 85       	ldd	r23, Y+10	; 0x0a
    a04c:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
    a050:	9a 87       	std	Y+10, r25	; 0x0a
    a052:	89 87       	std	Y+9, r24	; 0x09
                if(!cluster_num)
    a054:	89 2b       	or	r24, r25
    a056:	09 f4       	brne	.+2      	; 0xa05a <fat16_read_file+0x10e>
    a058:	a0 c0       	rjmp	.+320    	; 0xa19a <fat16_read_file+0x24e>
    a05a:	8d 81       	ldd	r24, Y+5	; 0x05
    a05c:	9e 81       	ldd	r25, Y+6	; 0x06
    a05e:	af 81       	ldd	r26, Y+7	; 0x07
    a060:	b8 85       	ldd	r27, Y+8	; 0x08
    a062:	e8 0e       	add	r14, r24
    a064:	f9 1e       	adc	r15, r25
    a066:	0a 1f       	adc	r16, r26
    a068:	1b 1f       	adc	r17, r27
        }

        if(fd->pos)
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
    a06a:	e6 14       	cp	r14, r6
    a06c:	f7 04       	cpc	r15, r7
    a06e:	08 05       	cpc	r16, r8
    a070:	19 05       	cpc	r17, r9
    a072:	38 f7       	brcc	.-50     	; 0xa042 <fat16_read_file+0xf6>
        return 0;
    
    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;
    a074:	c6 01       	movw	r24, r12
    a076:	b5 01       	movw	r22, r10
    a078:	a4 01       	movw	r20, r8
    a07a:	93 01       	movw	r18, r6
    a07c:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    a080:	5b 01       	movw	r10, r22
    a082:	61 01       	movw	r12, r2
    
    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fat16_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
    a084:	d2 01       	movw	r26, r4
    a086:	ed 90       	ld	r14, X+
    a088:	fc 90       	ld	r15, X
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
uint32_t fat16_cluster_offset(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    if(!fs || cluster_num < 2)
    a08a:	e1 14       	cp	r14, r1
    a08c:	f1 04       	cpc	r15, r1
    a08e:	09 f1       	breq	.+66     	; 0xa0d2 <fat16_read_file+0x186>
    a090:	e9 85       	ldd	r30, Y+9	; 0x09
    a092:	fa 85       	ldd	r31, Y+10	; 0x0a
    a094:	e2 30       	cpi	r30, 0x02	; 2
    a096:	f1 05       	cpc	r31, r1
    a098:	e0 f0       	brcs	.+56     	; 0xa0d2 <fat16_read_file+0x186>
        return 0;

    return fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
    a09a:	32 97       	sbiw	r30, 0x02	; 2
    a09c:	bf 01       	movw	r22, r30
    a09e:	80 e0       	ldi	r24, 0x00	; 0
    a0a0:	90 e0       	ldi	r25, 0x00	; 0
    a0a2:	32 96       	adiw	r30, 0x02	; 2
    a0a4:	fa 87       	std	Y+10, r31	; 0x0a
    a0a6:	e9 87       	std	Y+9, r30	; 0x09
    a0a8:	d7 01       	movw	r26, r14
    a0aa:	50 96       	adiw	r26, 0x10	; 16
    a0ac:	2d 91       	ld	r18, X+
    a0ae:	3c 91       	ld	r19, X
    a0b0:	51 97       	sbiw	r26, 0x11	; 17
    a0b2:	40 e0       	ldi	r20, 0x00	; 0
    a0b4:	50 e0       	ldi	r21, 0x00	; 0
    a0b6:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    a0ba:	9b 01       	movw	r18, r22
    a0bc:	ac 01       	movw	r20, r24
    a0be:	f7 01       	movw	r30, r14
    a0c0:	86 89       	ldd	r24, Z+22	; 0x16
    a0c2:	97 89       	ldd	r25, Z+23	; 0x17
    a0c4:	a0 8d       	ldd	r26, Z+24	; 0x18
    a0c6:	b1 8d       	ldd	r27, Z+25	; 0x19
    a0c8:	28 0f       	add	r18, r24
    a0ca:	39 1f       	adc	r19, r25
    a0cc:	4a 1f       	adc	r20, r26
    a0ce:	5b 1f       	adc	r21, r27
    a0d0:	04 c0       	rjmp	.+8      	; 0xa0da <fat16_read_file+0x18e>
    a0d2:	20 e0       	ldi	r18, 0x00	; 0
    a0d4:	30 e0       	ldi	r19, 0x00	; 0
    a0d6:	40 e0       	ldi	r20, 0x00	; 0
    a0d8:	50 e0       	ldi	r21, 0x00	; 0
    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fat16_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
    a0da:	09 81       	ldd	r16, Y+1	; 0x01
    a0dc:	1a 81       	ldd	r17, Y+2	; 0x02
    a0de:	0a 19       	sub	r16, r10
    a0e0:	1b 09       	sbc	r17, r11
    a0e2:	c0 16       	cp	r12, r16
    a0e4:	d1 06       	cpc	r13, r17
    a0e6:	08 f4       	brcc	.+2      	; 0xa0ea <fat16_read_file+0x19e>
    a0e8:	86 01       	movw	r16, r12
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
    a0ea:	d7 01       	movw	r26, r14
    a0ec:	ed 91       	ld	r30, X+
    a0ee:	fc 91       	ld	r31, X
    a0f0:	c5 01       	movw	r24, r10
    a0f2:	a0 e0       	ldi	r26, 0x00	; 0
    a0f4:	b0 e0       	ldi	r27, 0x00	; 0
    a0f6:	28 0f       	add	r18, r24
    a0f8:	39 1f       	adc	r19, r25
    a0fa:	4a 1f       	adc	r20, r26
    a0fc:	5b 1f       	adc	r21, r27
    a0fe:	01 90       	ld	r0, Z+
    a100:	f0 81       	ld	r31, Z
    a102:	e0 2d       	mov	r30, r0
    a104:	ca 01       	movw	r24, r20
    a106:	b9 01       	movw	r22, r18
    a108:	4b 81       	ldd	r20, Y+3	; 0x03
    a10a:	5c 81       	ldd	r21, Y+4	; 0x04
    a10c:	98 01       	movw	r18, r16
    a10e:	09 95       	icall
    a110:	88 23       	and	r24, r24
    a112:	61 f1       	breq	.+88     	; 0xa16c <fat16_read_file+0x220>
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
    a114:	c0 1a       	sub	r12, r16
    a116:	d1 0a       	sbc	r13, r17
        fd->pos += copy_length;
    a118:	c8 01       	movw	r24, r16
    a11a:	a0 e0       	ldi	r26, 0x00	; 0
    a11c:	b0 e0       	ldi	r27, 0x00	; 0
    a11e:	f2 01       	movw	r30, r4
    a120:	21 a9       	ldd	r18, Z+49	; 0x31
    a122:	32 a9       	ldd	r19, Z+50	; 0x32
    a124:	43 a9       	ldd	r20, Z+51	; 0x33
    a126:	54 a9       	ldd	r21, Z+52	; 0x34
    a128:	28 0f       	add	r18, r24
    a12a:	39 1f       	adc	r19, r25
    a12c:	4a 1f       	adc	r20, r26
    a12e:	5b 1f       	adc	r21, r27
    a130:	d2 01       	movw	r26, r4
    a132:	d1 96       	adiw	r26, 0x31	; 49
    a134:	2d 93       	st	X+, r18
    a136:	3d 93       	st	X+, r19
    a138:	4d 93       	st	X+, r20
    a13a:	5c 93       	st	X, r21
    a13c:	d4 97       	sbiw	r26, 0x34	; 52

        if(first_cluster_offset + copy_length >= cluster_size)
    a13e:	c8 01       	movw	r24, r16
    a140:	8a 0d       	add	r24, r10
    a142:	9b 1d       	adc	r25, r11
    a144:	e9 81       	ldd	r30, Y+1	; 0x01
    a146:	fa 81       	ldd	r31, Y+2	; 0x02
    a148:	8e 17       	cp	r24, r30
    a14a:	9f 07       	cpc	r25, r31
    a14c:	a8 f0       	brcs	.+42     	; 0xa178 <fat16_read_file+0x22c>
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
    a14e:	8d 91       	ld	r24, X+
    a150:	9c 91       	ld	r25, X
    a152:	69 85       	ldd	r22, Y+9	; 0x09
    a154:	7a 85       	ldd	r23, Y+10	; 0x0a
    a156:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
    a15a:	9a 87       	std	Y+10, r25	; 0x0a
    a15c:	89 87       	std	Y+9, r24	; 0x09
    a15e:	89 2b       	or	r24, r25
    a160:	49 f4       	brne	.+18     	; 0xa174 <fat16_read_file+0x228>
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
    a162:	d2 01       	movw	r26, r4
    a164:	d6 96       	adiw	r26, 0x36	; 54
    a166:	1c 92       	st	X, r1
    a168:	1e 92       	st	-X, r1
    a16a:	d5 97       	sbiw	r26, 0x35	; 53
                return buffer_len - buffer_left;
    a16c:	a1 01       	movw	r20, r2
    a16e:	4c 19       	sub	r20, r12
    a170:	5d 09       	sbc	r21, r13
    a172:	18 c0       	rjmp	.+48     	; 0xa1a4 <fat16_read_file+0x258>
    a174:	aa 24       	eor	r10, r10
    a176:	bb 24       	eor	r11, r11
            }
        }

        fd->pos_cluster = cluster_num;
    a178:	29 85       	ldd	r18, Y+9	; 0x09
    a17a:	3a 85       	ldd	r19, Y+10	; 0x0a
    a17c:	f2 01       	movw	r30, r4
    a17e:	36 ab       	std	Z+54, r19	; 0x36
    a180:	25 ab       	std	Z+53, r18	; 0x35

    } while(buffer_left > 0); /* check if we are done */
    a182:	c1 14       	cp	r12, r1
    a184:	d1 04       	cpc	r13, r1
    a186:	39 f0       	breq	.+14     	; 0xa196 <fat16_read_file+0x24a>
        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
    a188:	8b 81       	ldd	r24, Y+3	; 0x03
    a18a:	9c 81       	ldd	r25, Y+4	; 0x04
    a18c:	80 0f       	add	r24, r16
    a18e:	91 1f       	adc	r25, r17
    a190:	9c 83       	std	Y+4, r25	; 0x04
    a192:	8b 83       	std	Y+3, r24	; 0x03
    a194:	77 cf       	rjmp	.-274    	; 0xa084 <fat16_read_file+0x138>

        fd->pos_cluster = cluster_num;

    } while(buffer_left > 0); /* check if we are done */

    return buffer_len;
    a196:	a1 01       	movw	r20, r2
    a198:	05 c0       	rjmp	.+10     	; 0xa1a4 <fat16_read_file+0x258>
    a19a:	4f ef       	ldi	r20, 0xFF	; 255
    a19c:	5f ef       	ldi	r21, 0xFF	; 255
    a19e:	02 c0       	rjmp	.+4      	; 0xa1a4 <fat16_read_file+0x258>
    a1a0:	40 e0       	ldi	r20, 0x00	; 0
    a1a2:	50 e0       	ldi	r21, 0x00	; 0
}
    a1a4:	ca 01       	movw	r24, r20
    a1a6:	2a 96       	adiw	r28, 0x0a	; 10
    a1a8:	0f b6       	in	r0, 0x3f	; 63
    a1aa:	f8 94       	cli
    a1ac:	de bf       	out	0x3e, r29	; 62
    a1ae:	0f be       	out	0x3f, r0	; 63
    a1b0:	cd bf       	out	0x3d, r28	; 61
    a1b2:	cf 91       	pop	r28
    a1b4:	df 91       	pop	r29
    a1b6:	1f 91       	pop	r17
    a1b8:	0f 91       	pop	r16
    a1ba:	ff 90       	pop	r15
    a1bc:	ef 90       	pop	r14
    a1be:	df 90       	pop	r13
    a1c0:	cf 90       	pop	r12
    a1c2:	bf 90       	pop	r11
    a1c4:	af 90       	pop	r10
    a1c6:	9f 90       	pop	r9
    a1c8:	8f 90       	pop	r8
    a1ca:	7f 90       	pop	r7
    a1cc:	6f 90       	pop	r6
    a1ce:	5f 90       	pop	r5
    a1d0:	4f 90       	pop	r4
    a1d2:	3f 90       	pop	r3
    a1d4:	2f 90       	pop	r2
    a1d6:	08 95       	ret

0000a1d8 <fat16_close_dir>:
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    a1d8:	fc 01       	movw	r30, r24
    if(dd)
    a1da:	00 97       	sbiw	r24, 0x00	; 0
    a1dc:	11 f0       	breq	.+4      	; 0xa1e2 <fat16_close_dir+0xa>
#if USE_DYNAMIC_MEMORY
        free(dd);
#else
        dd->fs = 0;
    a1de:	11 82       	std	Z+1, r1	; 0x01
    a1e0:	10 82       	st	Z, r1
    a1e2:	08 95       	ret

0000a1e4 <fat16_reset_dir>:
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    a1e4:	fc 01       	movw	r30, r24
    if(!dd)
    a1e6:	00 97       	sbiw	r24, 0x00	; 0
    a1e8:	11 f4       	brne	.+4      	; 0xa1ee <fat16_reset_dir+0xa>
    a1ea:	80 e0       	ldi	r24, 0x00	; 0
    a1ec:	08 95       	ret
        return 0;

    dd->entry_cluster = dd->dir_entry.cluster;
    a1ee:	87 a1       	ldd	r24, Z+39	; 0x27
    a1f0:	90 a5       	ldd	r25, Z+40	; 0x28
    a1f2:	92 ab       	std	Z+50, r25	; 0x32
    a1f4:	81 ab       	std	Z+49, r24	; 0x31
    dd->entry_offset = 0;
    a1f6:	14 aa       	std	Z+52, r1	; 0x34
    a1f8:	13 aa       	std	Z+51, r1	; 0x33
    a1fa:	81 e0       	ldi	r24, 0x01	; 1
    return 1;
}
    a1fc:	08 95       	ret

0000a1fe <fat16_dir_entry_read_callback>:
/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    a1fe:	af 92       	push	r10
    a200:	bf 92       	push	r11
    a202:	cf 92       	push	r12
    a204:	df 92       	push	r13
    a206:	ef 92       	push	r14
    a208:	ff 92       	push	r15
    a20a:	0f 93       	push	r16
    a20c:	1f 93       	push	r17
    a20e:	df 93       	push	r29
    a210:	cf 93       	push	r28
    a212:	cd b7       	in	r28, 0x3d	; 61
    a214:	de b7       	in	r29, 0x3e	; 62
    a216:	2d 97       	sbiw	r28, 0x0d	; 13
    a218:	0f b6       	in	r0, 0x3f	; 63
    a21a:	f8 94       	cli
    a21c:	de bf       	out	0x3e, r29	; 62
    a21e:	0f be       	out	0x3f, r0	; 63
    a220:	cd bf       	out	0x3d, r28	; 61
    a222:	8c 01       	movw	r16, r24
    a224:	5a 01       	movw	r10, r20
    a226:	6b 01       	movw	r12, r22
    struct fat16_read_dir_callback_arg* arg = p;
    a228:	79 01       	movw	r14, r18
    struct fat16_dir_entry_struct* dir_entry = arg->dir_entry;
    a22a:	f9 01       	movw	r30, r18
    a22c:	60 81       	ld	r22, Z
    a22e:	71 81       	ldd	r23, Z+1	; 0x01

    arg->bytes_read += 32;
    a230:	82 81       	ldd	r24, Z+2	; 0x02
    a232:	93 81       	ldd	r25, Z+3	; 0x03
    a234:	80 96       	adiw	r24, 0x20	; 32
    a236:	93 83       	std	Z+3, r25	; 0x03
    a238:	82 83       	std	Z+2, r24	; 0x02

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
    a23a:	f8 01       	movw	r30, r16
    a23c:	80 81       	ld	r24, Z
    a23e:	85 3e       	cpi	r24, 0xE5	; 229
    a240:	09 f4       	brne	.+2      	; 0xa244 <fat16_dir_entry_read_callback+0x46>
    a242:	e2 c0       	rjmp	.+452    	; 0xa408 <fat16_dir_entry_read_callback+0x20a>
    a244:	88 23       	and	r24, r24
    a246:	09 f4       	brne	.+2      	; 0xa24a <fat16_dir_entry_read_callback+0x4c>
    a248:	df c0       	rjmp	.+446    	; 0xa408 <fat16_dir_entry_read_callback+0x20a>
        return 1;

    if(!dir_entry->entry_offset)
    a24a:	fb 01       	movw	r30, r22
    a24c:	83 a5       	ldd	r24, Z+43	; 0x2b
    a24e:	94 a5       	ldd	r25, Z+44	; 0x2c
    a250:	a5 a5       	ldd	r26, Z+45	; 0x2d
    a252:	b6 a5       	ldd	r27, Z+46	; 0x2e
    a254:	00 97       	sbiw	r24, 0x00	; 0
    a256:	a1 05       	cpc	r26, r1
    a258:	b1 05       	cpc	r27, r1
    a25a:	21 f4       	brne	.+8      	; 0xa264 <fat16_dir_entry_read_callback+0x66>
        dir_entry->entry_offset = offset;
    a25c:	a3 a6       	std	Z+43, r10	; 0x2b
    a25e:	b4 a6       	std	Z+44, r11	; 0x2c
    a260:	c5 a6       	std	Z+45, r12	; 0x2d
    a262:	d6 a6       	std	Z+46, r13	; 0x2e
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
    a264:	61 15       	cp	r22, r1
    a266:	71 05       	cpc	r23, r1
    a268:	09 f4       	brne	.+2      	; 0xa26c <fat16_dir_entry_read_callback+0x6e>
    a26a:	d0 c0       	rjmp	.+416    	; 0xa40c <fat16_dir_entry_read_callback+0x20e>
    a26c:	01 15       	cp	r16, r1
    a26e:	11 05       	cpc	r17, r1
    a270:	09 f4       	brne	.+2      	; 0xa274 <fat16_dir_entry_read_callback+0x76>
    a272:	cc c0       	rjmp	.+408    	; 0xa40c <fat16_dir_entry_read_callback+0x20e>
    a274:	f8 01       	movw	r30, r16
    a276:	90 81       	ld	r25, Z
    a278:	99 23       	and	r25, r25
    a27a:	09 f4       	brne	.+2      	; 0xa27e <fat16_dir_entry_read_callback+0x80>
    a27c:	c7 c0       	rjmp	.+398    	; 0xa40c <fat16_dir_entry_read_callback+0x20e>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
    a27e:	83 85       	ldd	r24, Z+11	; 0x0b
    a280:	8f 30       	cpi	r24, 0x0F	; 15
    a282:	a9 f5       	brne	.+106    	; 0xa2ee <fat16_dir_entry_read_callback+0xf0>
    {
        /* Lfn supports unicode, but we do not, for now.
         * So we assume pure ascii and read only every
         * second byte.
         */
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
    a284:	89 2f       	mov	r24, r25
    a286:	90 e0       	ldi	r25, 0x00	; 0
    a288:	8f 73       	andi	r24, 0x3F	; 63
    a28a:	90 70       	andi	r25, 0x00	; 0
    a28c:	01 97       	sbiw	r24, 0x01	; 1
    a28e:	2d e0       	ldi	r18, 0x0D	; 13
    a290:	30 e0       	ldi	r19, 0x00	; 0
    a292:	82 9f       	mul	r24, r18
    a294:	a0 01       	movw	r20, r0
    a296:	83 9f       	mul	r24, r19
    a298:	50 0d       	add	r21, r0
    a29a:	92 9f       	mul	r25, r18
    a29c:	50 0d       	add	r21, r0
    a29e:	11 24       	eor	r1, r1
        const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
    a2a0:	de 01       	movw	r26, r28
    a2a2:	11 96       	adiw	r26, 0x01	; 1
    a2a4:	e8 eb       	ldi	r30, 0xB8	; 184
    a2a6:	f1 e0       	ldi	r31, 0x01	; 1
    a2a8:	8d e0       	ldi	r24, 0x0D	; 13
    a2aa:	01 90       	ld	r0, Z+
    a2ac:	0d 92       	st	X+, r0
    a2ae:	81 50       	subi	r24, 0x01	; 1
    a2b0:	e1 f7       	brne	.-8      	; 0xa2aa <fat16_dir_entry_read_callback+0xac>
    a2b2:	db 01       	movw	r26, r22
    a2b4:	a4 0f       	add	r26, r20
    a2b6:	b5 1f       	adc	r27, r21
    a2b8:	20 e0       	ldi	r18, 0x00	; 0
    a2ba:	30 e0       	ldi	r19, 0x00	; 0
        for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
            long_name[char_offset + i] = raw_entry[char_mapping[i]];
    a2bc:	be 01       	movw	r22, r28
    a2be:	6f 5f       	subi	r22, 0xFF	; 255
    a2c0:	7f 4f       	sbci	r23, 0xFF	; 255
    a2c2:	0f c0       	rjmp	.+30     	; 0xa2e2 <fat16_dir_entry_read_callback+0xe4>
    a2c4:	fb 01       	movw	r30, r22
    a2c6:	e2 0f       	add	r30, r18
    a2c8:	f3 1f       	adc	r31, r19
    a2ca:	80 81       	ld	r24, Z
    a2cc:	f8 01       	movw	r30, r16
    a2ce:	e8 0f       	add	r30, r24
    a2d0:	f1 1d       	adc	r31, r1
    a2d2:	80 81       	ld	r24, Z
    a2d4:	8d 93       	st	X+, r24
    a2d6:	2f 5f       	subi	r18, 0xFF	; 255
    a2d8:	3f 4f       	sbci	r19, 0xFF	; 255
         * So we assume pure ascii and read only every
         * second byte.
         */
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
        const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
        for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
    a2da:	2d 30       	cpi	r18, 0x0D	; 13
    a2dc:	31 05       	cpc	r19, r1
    a2de:	09 f4       	brne	.+2      	; 0xa2e2 <fat16_dir_entry_read_callback+0xe4>
    a2e0:	93 c0       	rjmp	.+294    	; 0xa408 <fat16_dir_entry_read_callback+0x20a>
    a2e2:	c9 01       	movw	r24, r18
    a2e4:	84 0f       	add	r24, r20
    a2e6:	95 1f       	adc	r25, r21
    a2e8:	4f 97       	sbiw	r24, 0x1f	; 31
    a2ea:	60 f3       	brcs	.-40     	; 0xa2c4 <fat16_dir_entry_read_callback+0xc6>
    a2ec:	8d c0       	rjmp	.+282    	; 0xa408 <fat16_dir_entry_read_callback+0x20a>
        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
    a2ee:	fb 01       	movw	r30, r22
    a2f0:	80 81       	ld	r24, Z
    a2f2:	88 23       	and	r24, r24
    a2f4:	b1 f5       	brne	.+108    	; 0xa362 <fat16_dir_entry_read_callback+0x164>
    a2f6:	a8 01       	movw	r20, r16
    a2f8:	d8 01       	movw	r26, r16
    a2fa:	80 e0       	ldi	r24, 0x00	; 0
    a2fc:	90 e0       	ldi	r25, 0x00	; 0
    a2fe:	28 2f       	mov	r18, r24
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
    a300:	3c 91       	ld	r19, X
    a302:	30 32       	cpi	r19, 0x20	; 32
    a304:	51 f0       	breq	.+20     	; 0xa31a <fat16_dir_entry_read_callback+0x11c>
                    break;
                long_name[i] = raw_entry[i];
    a306:	fb 01       	movw	r30, r22
    a308:	e8 0f       	add	r30, r24
    a30a:	f9 1f       	adc	r31, r25
    a30c:	30 83       	st	Z, r19
    a30e:	2f 5f       	subi	r18, 0xFF	; 255
    a310:	01 96       	adiw	r24, 0x01	; 1
    a312:	11 96       	adiw	r26, 0x01	; 1
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
    a314:	88 30       	cpi	r24, 0x08	; 8
    a316:	91 05       	cpc	r25, r1
    a318:	91 f7       	brne	.-28     	; 0xa2fe <fat16_dir_entry_read_callback+0x100>
            {
                if(raw_entry[i] == ' ')
                    break;
                long_name[i] = raw_entry[i];
            }
            if(long_name[0] == 0x05)
    a31a:	fb 01       	movw	r30, r22
    a31c:	80 81       	ld	r24, Z
    a31e:	85 30       	cpi	r24, 0x05	; 5
    a320:	11 f4       	brne	.+4      	; 0xa326 <fat16_dir_entry_read_callback+0x128>
                long_name[0] = (char) FAT16_DIRENTRY_DELETED;
    a322:	85 ee       	ldi	r24, 0xE5	; 229
    a324:	80 83       	st	Z, r24

            if(raw_entry[8] != ' ')
    a326:	f8 01       	movw	r30, r16
    a328:	80 85       	ldd	r24, Z+8	; 0x08
    a32a:	80 32       	cpi	r24, 0x20	; 32
    a32c:	b1 f0       	breq	.+44     	; 0xa35a <fat16_dir_entry_read_callback+0x15c>
            {
                long_name[i++] = '.';
    a32e:	fb 01       	movw	r30, r22
    a330:	e2 0f       	add	r30, r18
    a332:	f1 1d       	adc	r31, r1
    a334:	8e e2       	ldi	r24, 0x2E	; 46
    a336:	80 83       	st	Z, r24
    a338:	82 2f       	mov	r24, r18
    a33a:	8f 5f       	subi	r24, 0xFF	; 255

                uint8_t j = 8;
                for(; j < 11; ++j)
    a33c:	2c 5f       	subi	r18, 0xFC	; 252
                {
                    if(raw_entry[j] != ' ')
    a33e:	fa 01       	movw	r30, r20
    a340:	90 85       	ldd	r25, Z+8	; 0x08
    a342:	90 32       	cpi	r25, 0x20	; 32
    a344:	49 f0       	breq	.+18     	; 0xa358 <fat16_dir_entry_read_callback+0x15a>
                    {
                        long_name[i++] = raw_entry[j];
    a346:	fb 01       	movw	r30, r22
    a348:	e8 0f       	add	r30, r24
    a34a:	f1 1d       	adc	r31, r1
    a34c:	90 83       	st	Z, r25
    a34e:	8f 5f       	subi	r24, 0xFF	; 255
    a350:	4f 5f       	subi	r20, 0xFF	; 255
    a352:	5f 4f       	sbci	r21, 0xFF	; 255
            if(raw_entry[8] != ' ')
            {
                long_name[i++] = '.';

                uint8_t j = 8;
                for(; j < 11; ++j)
    a354:	82 17       	cp	r24, r18
    a356:	99 f7       	brne	.-26     	; 0xa33e <fat16_dir_entry_read_callback+0x140>
    a358:	28 2f       	mov	r18, r24
                        break;
                    }
                }
            } 

            long_name[i] = '\0';
    a35a:	fb 01       	movw	r30, r22
    a35c:	e2 0f       	add	r30, r18
    a35e:	f1 1d       	adc	r31, r1
    a360:	10 82       	st	Z, r1
        }
        
        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
    a362:	f8 01       	movw	r30, r16
    a364:	83 85       	ldd	r24, Z+11	; 0x0b
    a366:	fb 01       	movw	r30, r22
    a368:	80 a3       	std	Z+32, r24	; 0x20
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
    a36a:	f8 01       	movw	r30, r16
    a36c:	93 8d       	ldd	r25, Z+27	; 0x1b
    a36e:	80 e0       	ldi	r24, 0x00	; 0
    a370:	22 8d       	ldd	r18, Z+26	; 0x1a
    a372:	30 e0       	ldi	r19, 0x00	; 0
    a374:	82 2b       	or	r24, r18
    a376:	93 2b       	or	r25, r19
    a378:	fb 01       	movw	r30, r22
    a37a:	96 a3       	std	Z+38, r25	; 0x26
    a37c:	85 a3       	std	Z+37, r24	; 0x25
                             ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
    a37e:	f8 01       	movw	r30, r16
    a380:	25 8d       	ldd	r18, Z+29	; 0x1d
    a382:	30 e0       	ldi	r19, 0x00	; 0
    a384:	40 e0       	ldi	r20, 0x00	; 0
    a386:	50 e0       	ldi	r21, 0x00	; 0
    a388:	54 2f       	mov	r21, r20
    a38a:	43 2f       	mov	r20, r19
    a38c:	32 2f       	mov	r19, r18
    a38e:	22 27       	eor	r18, r18
    a390:	86 8d       	ldd	r24, Z+30	; 0x1e
    a392:	90 e0       	ldi	r25, 0x00	; 0
    a394:	a0 e0       	ldi	r26, 0x00	; 0
    a396:	b0 e0       	ldi	r27, 0x00	; 0
    a398:	dc 01       	movw	r26, r24
    a39a:	99 27       	eor	r25, r25
    a39c:	88 27       	eor	r24, r24
    a39e:	28 2b       	or	r18, r24
    a3a0:	39 2b       	or	r19, r25
    a3a2:	4a 2b       	or	r20, r26
    a3a4:	5b 2b       	or	r21, r27
    a3a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    a3a8:	90 e0       	ldi	r25, 0x00	; 0
    a3aa:	a0 e0       	ldi	r26, 0x00	; 0
    a3ac:	b0 e0       	ldi	r27, 0x00	; 0
    a3ae:	28 2b       	or	r18, r24
    a3b0:	39 2b       	or	r19, r25
    a3b2:	4a 2b       	or	r20, r26
    a3b4:	5b 2b       	or	r21, r27
    a3b6:	87 8d       	ldd	r24, Z+31	; 0x1f
    a3b8:	90 e0       	ldi	r25, 0x00	; 0
    a3ba:	a0 e0       	ldi	r26, 0x00	; 0
    a3bc:	b0 e0       	ldi	r27, 0x00	; 0
    a3be:	b8 2f       	mov	r27, r24
    a3c0:	aa 27       	eor	r26, r26
    a3c2:	99 27       	eor	r25, r25
    a3c4:	88 27       	eor	r24, r24
    a3c6:	28 2b       	or	r18, r24
    a3c8:	39 2b       	or	r19, r25
    a3ca:	4a 2b       	or	r20, r26
    a3cc:	5b 2b       	or	r21, r27
    a3ce:	fb 01       	movw	r30, r22
    a3d0:	27 a3       	std	Z+39, r18	; 0x27
    a3d2:	30 a7       	std	Z+40, r19	; 0x28
    a3d4:	41 a7       	std	Z+41, r20	; 0x29
    a3d6:	52 a7       	std	Z+42, r21	; 0x2a
                               ((uint32_t) raw_entry[29] << 8) |
                               ((uint32_t) raw_entry[30] << 16) |
                               ((uint32_t) raw_entry[31] << 24);

#if FAT16_DATETIME_SUPPORT
        dir_entry->modification_time = ((uint16_t) raw_entry[22]) |
    a3d8:	f8 01       	movw	r30, r16
    a3da:	97 89       	ldd	r25, Z+23	; 0x17
    a3dc:	80 e0       	ldi	r24, 0x00	; 0
    a3de:	26 89       	ldd	r18, Z+22	; 0x16
    a3e0:	30 e0       	ldi	r19, 0x00	; 0
    a3e2:	82 2b       	or	r24, r18
    a3e4:	93 2b       	or	r25, r19
    a3e6:	fb 01       	movw	r30, r22
    a3e8:	92 a3       	std	Z+34, r25	; 0x22
    a3ea:	81 a3       	std	Z+33, r24	; 0x21
                                       ((uint16_t) raw_entry[23] << 8);
        dir_entry->modification_date = ((uint16_t) raw_entry[24]) |
    a3ec:	f8 01       	movw	r30, r16
    a3ee:	91 8d       	ldd	r25, Z+25	; 0x19
    a3f0:	80 e0       	ldi	r24, 0x00	; 0
    a3f2:	20 8d       	ldd	r18, Z+24	; 0x18
    a3f4:	30 e0       	ldi	r19, 0x00	; 0
    a3f6:	82 2b       	or	r24, r18
    a3f8:	93 2b       	or	r25, r19
    a3fa:	fb 01       	movw	r30, r22
    a3fc:	94 a3       	std	Z+36, r25	; 0x24
    a3fe:	83 a3       	std	Z+35, r24	; 0x23
        {
            return 1;
        }
        case 2: /* directory entry complete, finish */
        {
            arg->finished = 1;
    a400:	81 e0       	ldi	r24, 0x01	; 1
    a402:	f7 01       	movw	r30, r14
    a404:	84 83       	std	Z+4, r24	; 0x04
    a406:	02 c0       	rjmp	.+4      	; 0xa40c <fat16_dir_entry_read_callback+0x20e>
            return 0;
    a408:	81 e0       	ldi	r24, 0x01	; 1
    a40a:	01 c0       	rjmp	.+2      	; 0xa40e <fat16_dir_entry_read_callback+0x210>
    a40c:	80 e0       	ldi	r24, 0x00	; 0
        }
    }

    return 0;
}
    a40e:	2d 96       	adiw	r28, 0x0d	; 13
    a410:	0f b6       	in	r0, 0x3f	; 63
    a412:	f8 94       	cli
    a414:	de bf       	out	0x3e, r29	; 62
    a416:	0f be       	out	0x3f, r0	; 63
    a418:	cd bf       	out	0x3d, r28	; 61
    a41a:	cf 91       	pop	r28
    a41c:	df 91       	pop	r29
    a41e:	1f 91       	pop	r17
    a420:	0f 91       	pop	r16
    a422:	ff 90       	pop	r15
    a424:	ef 90       	pop	r14
    a426:	df 90       	pop	r13
    a428:	cf 90       	pop	r12
    a42a:	bf 90       	pop	r11
    a42c:	af 90       	pop	r10
    a42e:	08 95       	ret

0000a430 <fat16_delete_file>:
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
    a430:	7f 92       	push	r7
    a432:	8f 92       	push	r8
    a434:	9f 92       	push	r9
    a436:	af 92       	push	r10
    a438:	bf 92       	push	r11
    a43a:	cf 92       	push	r12
    a43c:	df 92       	push	r13
    a43e:	ef 92       	push	r14
    a440:	ff 92       	push	r15
    a442:	0f 93       	push	r16
    a444:	1f 93       	push	r17
    a446:	df 93       	push	r29
    a448:	cf 93       	push	r28
    a44a:	cd b7       	in	r28, 0x3d	; 61
    a44c:	de b7       	in	r29, 0x3e	; 62
    a44e:	2c 97       	sbiw	r28, 0x0c	; 12
    a450:	0f b6       	in	r0, 0x3f	; 63
    a452:	f8 94       	cli
    a454:	de bf       	out	0x3e, r29	; 62
    a456:	0f be       	out	0x3f, r0	; 63
    a458:	cd bf       	out	0x3d, r28	; 61
    a45a:	6c 01       	movw	r12, r24
    a45c:	5b 01       	movw	r10, r22
#if FAT16_WRITE_SUPPORT
    if(!fs || !dir_entry)
    a45e:	00 97       	sbiw	r24, 0x00	; 0
    a460:	09 f4       	brne	.+2      	; 0xa464 <fat16_delete_file+0x34>
    a462:	53 c0       	rjmp	.+166    	; 0xa50a <fat16_delete_file+0xda>
    a464:	61 15       	cp	r22, r1
    a466:	71 05       	cpc	r23, r1
    a468:	09 f4       	brne	.+2      	; 0xa46c <fat16_delete_file+0x3c>
    a46a:	4f c0       	rjmp	.+158    	; 0xa50a <fat16_delete_file+0xda>
        return 0;

    /* get offset of the file's directory entry */
    uint32_t dir_entry_offset = dir_entry->entry_offset;
    a46c:	db 01       	movw	r26, r22
    a46e:	9b 96       	adiw	r26, 0x2b	; 43
    a470:	ed 90       	ld	r14, X+
    a472:	fd 90       	ld	r15, X+
    a474:	0d 91       	ld	r16, X+
    a476:	1c 91       	ld	r17, X
    a478:	9e 97       	sbiw	r26, 0x2e	; 46
    if(!dir_entry_offset)
    a47a:	e1 14       	cp	r14, r1
    a47c:	f1 04       	cpc	r15, r1
    a47e:	01 05       	cpc	r16, r1
    a480:	11 05       	cpc	r17, r1
    a482:	09 f4       	brne	.+2      	; 0xa486 <fat16_delete_file+0x56>
    a484:	42 c0       	rjmp	.+132    	; 0xa50a <fat16_delete_file+0xda>

    uint8_t buffer[12];
    while(1)
    {
        /* read directory entry */
        if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
    a486:	4e 01       	movw	r8, r28
    a488:	08 94       	sec
    a48a:	81 1c       	adc	r8, r1
    a48c:	91 1c       	adc	r9, r1
            return 0;
        
        /* mark the directory entry as deleted */
        buffer[0] = FAT16_DIRENTRY_DELETED;
    a48e:	95 ee       	ldi	r25, 0xE5	; 229
    a490:	79 2e       	mov	r7, r25

    uint8_t buffer[12];
    while(1)
    {
        /* read directory entry */
        if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
    a492:	d6 01       	movw	r26, r12
    a494:	ed 91       	ld	r30, X+
    a496:	fc 91       	ld	r31, X
    a498:	01 90       	ld	r0, Z+
    a49a:	f0 81       	ld	r31, Z
    a49c:	e0 2d       	mov	r30, r0
    a49e:	c8 01       	movw	r24, r16
    a4a0:	b7 01       	movw	r22, r14
    a4a2:	a4 01       	movw	r20, r8
    a4a4:	2c e0       	ldi	r18, 0x0C	; 12
    a4a6:	30 e0       	ldi	r19, 0x00	; 0
    a4a8:	09 95       	icall
    a4aa:	88 23       	and	r24, r24
    a4ac:	71 f1       	breq	.+92     	; 0xa50a <fat16_delete_file+0xda>
            return 0;
        
        /* mark the directory entry as deleted */
        buffer[0] = FAT16_DIRENTRY_DELETED;
    a4ae:	79 82       	std	Y+1, r7	; 0x01
        
        /* write back entry */
        if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
    a4b0:	d6 01       	movw	r26, r12
    a4b2:	ed 91       	ld	r30, X+
    a4b4:	fc 91       	ld	r31, X
    a4b6:	04 80       	ldd	r0, Z+4	; 0x04
    a4b8:	f5 81       	ldd	r31, Z+5	; 0x05
    a4ba:	e0 2d       	mov	r30, r0
    a4bc:	c8 01       	movw	r24, r16
    a4be:	b7 01       	movw	r22, r14
    a4c0:	a4 01       	movw	r20, r8
    a4c2:	2c e0       	ldi	r18, 0x0C	; 12
    a4c4:	30 e0       	ldi	r19, 0x00	; 0
    a4c6:	09 95       	icall
    a4c8:	88 23       	and	r24, r24
    a4ca:	f9 f0       	breq	.+62     	; 0xa50a <fat16_delete_file+0xda>
            return 0;

        /* check if we deleted the whole entry */
        if(buffer[11] != 0x0f)
    a4cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    a4ce:	8f 30       	cpi	r24, 0x0F	; 15
    a4d0:	49 f4       	brne	.+18     	; 0xa4e4 <fat16_delete_file+0xb4>
            break;

        dir_entry_offset += 32;
    a4d2:	80 e2       	ldi	r24, 0x20	; 32
    a4d4:	90 e0       	ldi	r25, 0x00	; 0
    a4d6:	a0 e0       	ldi	r26, 0x00	; 0
    a4d8:	b0 e0       	ldi	r27, 0x00	; 0
    a4da:	e8 0e       	add	r14, r24
    a4dc:	f9 1e       	adc	r15, r25
    a4de:	0a 1f       	adc	r16, r26
    a4e0:	1b 1f       	adc	r17, r27
    a4e2:	d7 cf       	rjmp	.-82     	; 0xa492 <fat16_delete_file+0x62>
    }

    /* We deleted the directory entry. The next thing to do is
     * marking all occupied clusters as free.
     */
    return (dir_entry->cluster == 0 || fat16_free_clusters(fs, dir_entry->cluster));
    a4e4:	d5 01       	movw	r26, r10
    a4e6:	95 96       	adiw	r26, 0x25	; 37
    a4e8:	6d 91       	ld	r22, X+
    a4ea:	7c 91       	ld	r23, X
    a4ec:	96 97       	sbiw	r26, 0x26	; 38
    a4ee:	61 15       	cp	r22, r1
    a4f0:	71 05       	cpc	r23, r1
    a4f2:	39 f0       	breq	.+14     	; 0xa502 <fat16_delete_file+0xd2>
    a4f4:	c6 01       	movw	r24, r12
    a4f6:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <fat16_free_clusters>
    a4fa:	20 e0       	ldi	r18, 0x00	; 0
    a4fc:	30 e0       	ldi	r19, 0x00	; 0
    a4fe:	88 23       	and	r24, r24
    a500:	11 f0       	breq	.+4      	; 0xa506 <fat16_delete_file+0xd6>
    a502:	21 e0       	ldi	r18, 0x01	; 1
    a504:	30 e0       	ldi	r19, 0x00	; 0
    a506:	82 2f       	mov	r24, r18
    a508:	01 c0       	rjmp	.+2      	; 0xa50c <fat16_delete_file+0xdc>
    a50a:	80 e0       	ldi	r24, 0x00	; 0
#else
    return 0;
#endif
}
    a50c:	2c 96       	adiw	r28, 0x0c	; 12
    a50e:	0f b6       	in	r0, 0x3f	; 63
    a510:	f8 94       	cli
    a512:	de bf       	out	0x3e, r29	; 62
    a514:	0f be       	out	0x3f, r0	; 63
    a516:	cd bf       	out	0x3d, r28	; 61
    a518:	cf 91       	pop	r28
    a51a:	df 91       	pop	r29
    a51c:	1f 91       	pop	r17
    a51e:	0f 91       	pop	r16
    a520:	ff 90       	pop	r15
    a522:	ef 90       	pop	r14
    a524:	df 90       	pop	r13
    a526:	cf 90       	pop	r12
    a528:	bf 90       	pop	r11
    a52a:	af 90       	pop	r10
    a52c:	9f 90       	pop	r9
    a52e:	8f 90       	pop	r8
    a530:	7f 90       	pop	r7
    a532:	08 95       	ret

0000a534 <fat16_get_file_modification_date>:
 * \param[out] year The year the file was last modified.
 * \param[out] month The month the file was last modified.
 * \param[out] day The day the file was last modified.
 */
void fat16_get_file_modification_date(const struct fat16_dir_entry_struct* dir_entry, uint16_t* year, uint8_t* month, uint8_t* day)
{
    a534:	cf 93       	push	r28
    a536:	df 93       	push	r29
    a538:	fc 01       	movw	r30, r24
    a53a:	db 01       	movw	r26, r22
    a53c:	ea 01       	movw	r28, r20
    a53e:	a9 01       	movw	r20, r18
#if FAT16_DATETIME_SUPPORT
    if(!dir_entry)
    a540:	00 97       	sbiw	r24, 0x00	; 0
    a542:	a9 f0       	breq	.+42     	; 0xa56e <fat16_get_file_modification_date+0x3a>
        return;

    *year = 1980 + ((dir_entry->modification_date >> 9) & 0x7f);
    a544:	24 a1       	ldd	r18, Z+36	; 0x24
    a546:	82 2f       	mov	r24, r18
    a548:	86 95       	lsr	r24
    a54a:	90 e0       	ldi	r25, 0x00	; 0
    a54c:	84 54       	subi	r24, 0x44	; 68
    a54e:	98 4f       	sbci	r25, 0xF8	; 248
    a550:	8d 93       	st	X+, r24
    a552:	9c 93       	st	X, r25
    *month = (dir_entry->modification_date >> 5) & 0x0f;
    a554:	83 a1       	ldd	r24, Z+35	; 0x23
    a556:	94 a1       	ldd	r25, Z+36	; 0x24
    a558:	25 e0       	ldi	r18, 0x05	; 5
    a55a:	96 95       	lsr	r25
    a55c:	87 95       	ror	r24
    a55e:	2a 95       	dec	r18
    a560:	e1 f7       	brne	.-8      	; 0xa55a <fat16_get_file_modification_date+0x26>
    a562:	8f 70       	andi	r24, 0x0F	; 15
    a564:	88 83       	st	Y, r24
    *day = (dir_entry->modification_date >> 0) & 0x1f;
    a566:	83 a1       	ldd	r24, Z+35	; 0x23
    a568:	8f 71       	andi	r24, 0x1F	; 31
    a56a:	fa 01       	movw	r30, r20
    a56c:	80 83       	st	Z, r24
#endif
}
    a56e:	df 91       	pop	r29
    a570:	cf 91       	pop	r28
    a572:	08 95       	ret

0000a574 <fat16_get_file_modification_time>:
 * \param[out] hour The hour the file was last modified.
 * \param[out] min The min the file was last modified.
 * \param[out] sec The sec the file was last modified.
 */
void fat16_get_file_modification_time(const struct fat16_dir_entry_struct* dir_entry, uint8_t* hour, uint8_t* min, uint8_t* sec)
{
    a574:	cf 93       	push	r28
    a576:	df 93       	push	r29
    a578:	fc 01       	movw	r30, r24
    a57a:	db 01       	movw	r26, r22
    a57c:	ea 01       	movw	r28, r20
#if FAT16_DATETIME_SUPPORT
    if(!dir_entry)
    a57e:	00 97       	sbiw	r24, 0x00	; 0
    a580:	b1 f0       	breq	.+44     	; 0xa5ae <fat16_get_file_modification_time+0x3a>
        return;

    *hour = (dir_entry->modification_time >> 11) & 0x1f;
    a582:	82 a1       	ldd	r24, Z+34	; 0x22
    a584:	86 95       	lsr	r24
    a586:	86 95       	lsr	r24
    a588:	86 95       	lsr	r24
    a58a:	8c 93       	st	X, r24
    *min = (dir_entry->modification_time >> 5) & 0x3f;
    a58c:	81 a1       	ldd	r24, Z+33	; 0x21
    a58e:	92 a1       	ldd	r25, Z+34	; 0x22
    a590:	55 e0       	ldi	r21, 0x05	; 5
    a592:	96 95       	lsr	r25
    a594:	87 95       	ror	r24
    a596:	5a 95       	dec	r21
    a598:	e1 f7       	brne	.-8      	; 0xa592 <fat16_get_file_modification_time+0x1e>
    a59a:	8f 73       	andi	r24, 0x3F	; 63
    a59c:	88 83       	st	Y, r24
    *sec = ((dir_entry->modification_time >> 0) & 0x1f) * 2;
    a59e:	81 a1       	ldd	r24, Z+33	; 0x21
    a5a0:	92 a1       	ldd	r25, Z+34	; 0x22
    a5a2:	8f 71       	andi	r24, 0x1F	; 31
    a5a4:	90 70       	andi	r25, 0x00	; 0
    a5a6:	88 0f       	add	r24, r24
    a5a8:	99 1f       	adc	r25, r25
    a5aa:	f9 01       	movw	r30, r18
    a5ac:	80 83       	st	Z, r24
#endif
}
    a5ae:	df 91       	pop	r29
    a5b0:	cf 91       	pop	r28
    a5b2:	08 95       	ret

0000a5b4 <fat16_get_fs_size>:
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    a5b4:	fc 01       	movw	r30, r24
    if(!fs)
    a5b6:	00 97       	sbiw	r24, 0x00	; 0
    a5b8:	29 f4       	brne	.+10     	; 0xa5c4 <fat16_get_fs_size+0x10>
    a5ba:	20 e0       	ldi	r18, 0x00	; 0
    a5bc:	30 e0       	ldi	r19, 0x00	; 0
    a5be:	40 e0       	ldi	r20, 0x00	; 0
    a5c0:	50 e0       	ldi	r21, 0x00	; 0
    a5c2:	14 c0       	rjmp	.+40     	; 0xa5ec <fat16_get_fs_size+0x38>
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
    a5c4:	62 85       	ldd	r22, Z+10	; 0x0a
    a5c6:	73 85       	ldd	r23, Z+11	; 0x0b
    a5c8:	84 85       	ldd	r24, Z+12	; 0x0c
    a5ca:	95 85       	ldd	r25, Z+13	; 0x0d
    a5cc:	96 95       	lsr	r25
    a5ce:	87 95       	ror	r24
    a5d0:	77 95       	ror	r23
    a5d2:	67 95       	ror	r22
    a5d4:	62 50       	subi	r22, 0x02	; 2
    a5d6:	70 40       	sbci	r23, 0x00	; 0
    a5d8:	80 40       	sbci	r24, 0x00	; 0
    a5da:	90 40       	sbci	r25, 0x00	; 0
    a5dc:	20 89       	ldd	r18, Z+16	; 0x10
    a5de:	31 89       	ldd	r19, Z+17	; 0x11
    a5e0:	40 e0       	ldi	r20, 0x00	; 0
    a5e2:	50 e0       	ldi	r21, 0x00	; 0
    a5e4:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    a5e8:	9b 01       	movw	r18, r22
    a5ea:	ac 01       	movw	r20, r24
}
    a5ec:	b9 01       	movw	r22, r18
    a5ee:	ca 01       	movw	r24, r20
    a5f0:	08 95       	ret

0000a5f2 <fat16_get_fs_free>:
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
    a5f2:	2f 92       	push	r2
    a5f4:	3f 92       	push	r3
    a5f6:	4f 92       	push	r4
    a5f8:	5f 92       	push	r5
    a5fa:	6f 92       	push	r6
    a5fc:	7f 92       	push	r7
    a5fe:	8f 92       	push	r8
    a600:	9f 92       	push	r9
    a602:	af 92       	push	r10
    a604:	bf 92       	push	r11
    a606:	cf 92       	push	r12
    a608:	df 92       	push	r13
    a60a:	ef 92       	push	r14
    a60c:	ff 92       	push	r15
    a60e:	0f 93       	push	r16
    a610:	1f 93       	push	r17
    a612:	df 93       	push	r29
    a614:	cf 93       	push	r28
    a616:	cd b7       	in	r28, 0x3d	; 61
    a618:	de b7       	in	r29, 0x3e	; 62
    a61a:	a5 97       	sbiw	r28, 0x25	; 37
    a61c:	0f b6       	in	r0, 0x3f	; 63
    a61e:	f8 94       	cli
    a620:	de bf       	out	0x3e, r29	; 62
    a622:	0f be       	out	0x3f, r0	; 63
    a624:	cd bf       	out	0x3d, r28	; 61
    a626:	9d a3       	std	Y+37, r25	; 0x25
    a628:	8c a3       	std	Y+36, r24	; 0x24
    if(!fs)
    a62a:	89 2b       	or	r24, r25
    a62c:	09 f4       	brne	.+2      	; 0xa630 <fat16_get_fs_free+0x3e>
    a62e:	5b c0       	rjmp	.+182    	; 0xa6e6 <fat16_get_fs_free+0xf4>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    a630:	1a 82       	std	Y+2, r1	; 0x02
    a632:	19 82       	std	Y+1, r1	; 0x01
    count_arg.buffer_size = sizeof(fat);
    a634:	80 e2       	ldi	r24, 0x20	; 32
    a636:	8b 83       	std	Y+3, r24	; 0x03

    uint32_t fat_offset = fs->header.fat_offset;
    a638:	ac a1       	ldd	r26, Y+36	; 0x24
    a63a:	bd a1       	ldd	r27, Y+37	; 0x25
    a63c:	16 96       	adiw	r26, 0x06	; 6
    a63e:	4d 90       	ld	r4, X+
    a640:	5d 90       	ld	r5, X+
    a642:	6d 90       	ld	r6, X+
    a644:	7c 90       	ld	r7, X
    a646:	19 97       	sbiw	r26, 0x09	; 9
    uint32_t fat_size = fs->header.fat_size;
    a648:	1a 96       	adiw	r26, 0x0a	; 10
    a64a:	8d 90       	ld	r8, X+
    a64c:	9d 90       	ld	r9, X+
    a64e:	ad 90       	ld	r10, X+
    a650:	bc 90       	ld	r11, X
    a652:	1d 97       	sbiw	r26, 0x0d	; 13
    a654:	34 c0       	rjmp	.+104    	; 0xa6be <fat16_get_fs_free+0xcc>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
    a656:	be ef       	ldi	r27, 0xFE	; 254
    a658:	8b 16       	cp	r8, r27
    a65a:	bf ef       	ldi	r27, 0xFF	; 255
    a65c:	9b 06       	cpc	r9, r27
    a65e:	b0 e0       	ldi	r27, 0x00	; 0
    a660:	ab 06       	cpc	r10, r27
    a662:	b0 e0       	ldi	r27, 0x00	; 0
    a664:	bb 06       	cpc	r11, r27
    a666:	28 f0       	brcs	.+10     	; 0xa672 <fat16_get_fs_free+0x80>
    a668:	1e ef       	ldi	r17, 0xFE	; 254
    a66a:	21 2e       	mov	r2, r17
    a66c:	1f ef       	ldi	r17, 0xFF	; 255
    a66e:	31 2e       	mov	r3, r17
    a670:	01 c0       	rjmp	.+2      	; 0xa674 <fat16_get_fs_free+0x82>
            length = fat_size;
    a672:	14 01       	movw	r2, r8

        if(!fs->partition->device_read_interval(fat_offset,
    a674:	ac a1       	ldd	r26, Y+36	; 0x24
    a676:	bd a1       	ldd	r27, Y+37	; 0x25
    a678:	ed 91       	ld	r30, X+
    a67a:	fc 91       	ld	r31, X
    a67c:	02 80       	ldd	r0, Z+2	; 0x02
    a67e:	f3 81       	ldd	r31, Z+3	; 0x03
    a680:	e0 2d       	mov	r30, r0
    a682:	c3 01       	movw	r24, r6
    a684:	b2 01       	movw	r22, r4
    a686:	ae 01       	movw	r20, r28
    a688:	4c 5f       	subi	r20, 0xFC	; 252
    a68a:	5f 4f       	sbci	r21, 0xFF	; 255
    a68c:	20 e2       	ldi	r18, 0x20	; 32
    a68e:	30 e0       	ldi	r19, 0x00	; 0
    a690:	81 01       	movw	r16, r2
    a692:	b2 e9       	ldi	r27, 0x92	; 146
    a694:	eb 2e       	mov	r14, r27
    a696:	b3 e5       	ldi	r27, 0x53	; 83
    a698:	fb 2e       	mov	r15, r27
    a69a:	6e 01       	movw	r12, r28
    a69c:	08 94       	sec
    a69e:	c1 1c       	adc	r12, r1
    a6a0:	d1 1c       	adc	r13, r1
    a6a2:	09 95       	icall
    a6a4:	88 23       	and	r24, r24
    a6a6:	f9 f0       	breq	.+62     	; 0xa6e6 <fat16_get_fs_free+0xf4>
                                                &count_arg
                                               )
          )
            return 0;

        fat_offset += length;
    a6a8:	c1 01       	movw	r24, r2
    a6aa:	a0 e0       	ldi	r26, 0x00	; 0
    a6ac:	b0 e0       	ldi	r27, 0x00	; 0
    a6ae:	48 0e       	add	r4, r24
    a6b0:	59 1e       	adc	r5, r25
    a6b2:	6a 1e       	adc	r6, r26
    a6b4:	7b 1e       	adc	r7, r27
        fat_size -= length;
    a6b6:	88 1a       	sub	r8, r24
    a6b8:	99 0a       	sbc	r9, r25
    a6ba:	aa 0a       	sbc	r10, r26
    a6bc:	bb 0a       	sbc	r11, r27
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);

    uint32_t fat_offset = fs->header.fat_offset;
    uint32_t fat_size = fs->header.fat_size;
    while(fat_size > 0)
    a6be:	81 14       	cp	r8, r1
    a6c0:	91 04       	cpc	r9, r1
    a6c2:	a1 04       	cpc	r10, r1
    a6c4:	b1 04       	cpc	r11, r1
    a6c6:	39 f6       	brne	.-114    	; 0xa656 <fat16_get_fs_free+0x64>

        fat_offset += length;
        fat_size -= length;
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
    a6c8:	ec a1       	ldd	r30, Y+36	; 0x24
    a6ca:	fd a1       	ldd	r31, Y+37	; 0x25
    a6cc:	60 89       	ldd	r22, Z+16	; 0x10
    a6ce:	71 89       	ldd	r23, Z+17	; 0x11
    a6d0:	80 e0       	ldi	r24, 0x00	; 0
    a6d2:	90 e0       	ldi	r25, 0x00	; 0
    a6d4:	29 81       	ldd	r18, Y+1	; 0x01
    a6d6:	3a 81       	ldd	r19, Y+2	; 0x02
    a6d8:	40 e0       	ldi	r20, 0x00	; 0
    a6da:	50 e0       	ldi	r21, 0x00	; 0
    a6dc:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    a6e0:	9b 01       	movw	r18, r22
    a6e2:	ac 01       	movw	r20, r24
    a6e4:	04 c0       	rjmp	.+8      	; 0xa6ee <fat16_get_fs_free+0xfc>
    a6e6:	20 e0       	ldi	r18, 0x00	; 0
    a6e8:	30 e0       	ldi	r19, 0x00	; 0
    a6ea:	40 e0       	ldi	r20, 0x00	; 0
    a6ec:	50 e0       	ldi	r21, 0x00	; 0
}
    a6ee:	b9 01       	movw	r22, r18
    a6f0:	ca 01       	movw	r24, r20
    a6f2:	a5 96       	adiw	r28, 0x25	; 37
    a6f4:	0f b6       	in	r0, 0x3f	; 63
    a6f6:	f8 94       	cli
    a6f8:	de bf       	out	0x3e, r29	; 62
    a6fa:	0f be       	out	0x3f, r0	; 63
    a6fc:	cd bf       	out	0x3d, r28	; 61
    a6fe:	cf 91       	pop	r28
    a700:	df 91       	pop	r29
    a702:	1f 91       	pop	r17
    a704:	0f 91       	pop	r16
    a706:	ff 90       	pop	r15
    a708:	ef 90       	pop	r14
    a70a:	df 90       	pop	r13
    a70c:	cf 90       	pop	r12
    a70e:	bf 90       	pop	r11
    a710:	af 90       	pop	r10
    a712:	9f 90       	pop	r9
    a714:	8f 90       	pop	r8
    a716:	7f 90       	pop	r7
    a718:	6f 90       	pop	r6
    a71a:	5f 90       	pop	r5
    a71c:	4f 90       	pop	r4
    a71e:	3f 90       	pop	r3
    a720:	2f 90       	pop	r2
    a722:	08 95       	ret

0000a724 <fat16_get_fs_free_callback>:
/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    a724:	48 2f       	mov	r20, r24
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    a726:	f9 01       	movw	r30, r18
    uint8_t buffer_size = count_arg->buffer_size;
    a728:	52 81       	ldd	r21, Z+2	; 0x02
    a72a:	28 2f       	mov	r18, r24
    a72c:	39 2f       	mov	r19, r25
    a72e:	c9 01       	movw	r24, r18
    a730:	dc 01       	movw	r26, r24
    a732:	10 c0       	rjmp	.+32     	; 0xa754 <fat16_get_fs_free_callback+0x30>

    for(uint8_t i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
    a734:	11 96       	adiw	r26, 0x01	; 1
    a736:	3c 91       	ld	r19, X
    a738:	11 97       	sbiw	r26, 0x01	; 1
    a73a:	20 e0       	ldi	r18, 0x00	; 0
    a73c:	8c 91       	ld	r24, X
    a73e:	90 e0       	ldi	r25, 0x00	; 0
    a740:	82 2b       	or	r24, r18
    a742:	93 2b       	or	r25, r19
    a744:	89 2b       	or	r24, r25
    a746:	29 f4       	brne	.+10     	; 0xa752 <fat16_get_fs_free_callback+0x2e>
            ++(count_arg->cluster_count);
    a748:	80 81       	ld	r24, Z
    a74a:	91 81       	ldd	r25, Z+1	; 0x01
    a74c:	01 96       	adiw	r24, 0x01	; 1
    a74e:	91 83       	std	Z+1, r25	; 0x01
    a750:	80 83       	st	Z, r24

        buffer += 2;
    a752:	12 96       	adiw	r26, 0x02	; 2
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;

    for(uint8_t i = 0; i < buffer_size; i += 2)
    a754:	8a 2f       	mov	r24, r26
    a756:	84 1b       	sub	r24, r20
    a758:	85 17       	cp	r24, r21
    a75a:	60 f3       	brcs	.-40     	; 0xa734 <fat16_get_fs_free_callback+0x10>

        buffer += 2;
    }

    return 1;
}
    a75c:	81 e0       	ldi	r24, 0x01	; 1
    a75e:	08 95       	ret

0000a760 <fat16_clear_cluster_callback>:
 * Callback function for clearing a cluster.
 */
uint16_t fat16_clear_cluster_callback(uint8_t* buffer, uint32_t offset, void* p)
{
#if FAT16_WRITE_SUPPORT
    memset(buffer, 0, 16);
    a760:	fc 01       	movw	r30, r24
    a762:	80 e1       	ldi	r24, 0x10	; 16
    a764:	df 01       	movw	r26, r30
    a766:	1d 92       	st	X+, r1
    a768:	8a 95       	dec	r24
    a76a:	e9 f7       	brne	.-6      	; 0xa766 <fat16_clear_cluster_callback+0x6>
    return 16;
#else
    return 0;
#endif
}
    a76c:	80 e1       	ldi	r24, 0x10	; 16
    a76e:	90 e0       	ldi	r25, 0x00	; 0
    a770:	08 95       	ret

0000a772 <fat16_read_dir>:
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
    a772:	2f 92       	push	r2
    a774:	3f 92       	push	r3
    a776:	4f 92       	push	r4
    a778:	5f 92       	push	r5
    a77a:	6f 92       	push	r6
    a77c:	7f 92       	push	r7
    a77e:	8f 92       	push	r8
    a780:	9f 92       	push	r9
    a782:	af 92       	push	r10
    a784:	bf 92       	push	r11
    a786:	cf 92       	push	r12
    a788:	df 92       	push	r13
    a78a:	ef 92       	push	r14
    a78c:	ff 92       	push	r15
    a78e:	0f 93       	push	r16
    a790:	1f 93       	push	r17
    a792:	df 93       	push	r29
    a794:	cf 93       	push	r28
    a796:	cd b7       	in	r28, 0x3d	; 61
    a798:	de b7       	in	r29, 0x3e	; 62
    a79a:	a7 97       	sbiw	r28, 0x27	; 39
    a79c:	0f b6       	in	r0, 0x3f	; 63
    a79e:	f8 94       	cli
    a7a0:	de bf       	out	0x3e, r29	; 62
    a7a2:	0f be       	out	0x3f, r0	; 63
    a7a4:	cd bf       	out	0x3d, r28	; 61
    a7a6:	4c 01       	movw	r8, r24
    a7a8:	7f a3       	std	Y+39, r23	; 0x27
    a7aa:	6e a3       	std	Y+38, r22	; 0x26
    if(!dd || !dir_entry)
    a7ac:	00 97       	sbiw	r24, 0x00	; 0
    a7ae:	09 f4       	brne	.+2      	; 0xa7b2 <fat16_read_dir+0x40>
    a7b0:	b9 c0       	rjmp	.+370    	; 0xa924 <fat16_read_dir+0x1b2>
    a7b2:	61 15       	cp	r22, r1
    a7b4:	71 05       	cpc	r23, r1
    a7b6:	09 f4       	brne	.+2      	; 0xa7ba <fat16_read_dir+0x48>
    a7b8:	b5 c0       	rjmp	.+362    	; 0xa924 <fat16_read_dir+0x1b2>
        return 0;

    /* get current position of directory handle */
    const struct fat16_header_struct* header = &dd->fs->header;
    a7ba:	dc 01       	movw	r26, r24
    a7bc:	2d 90       	ld	r2, X+
    a7be:	3c 90       	ld	r3, X
    a7c0:	11 97       	sbiw	r26, 0x01	; 1
    uint16_t cluster_size = header->cluster_size;
    a7c2:	f1 01       	movw	r30, r2
    a7c4:	40 88       	ldd	r4, Z+16	; 0x10
    a7c6:	51 88       	ldd	r5, Z+17	; 0x11
    uint16_t cluster_num = dd->entry_cluster;
    a7c8:	d1 96       	adiw	r26, 0x31	; 49
    a7ca:	ad 90       	ld	r10, X+
    a7cc:	bc 90       	ld	r11, X
    a7ce:	d2 97       	sbiw	r26, 0x32	; 50
    uint16_t cluster_offset = dd->entry_offset;
    a7d0:	d3 96       	adiw	r26, 0x33	; 51
    a7d2:	6d 90       	ld	r6, X+
    a7d4:	7c 90       	ld	r7, X
    a7d6:	d4 97       	sbiw	r26, 0x34	; 52
    struct fat16_read_dir_callback_arg arg;

    /* reset directory entry */
    memset(dir_entry, 0, sizeof(*dir_entry));
    a7d8:	8f e2       	ldi	r24, 0x2F	; 47
    a7da:	db 01       	movw	r26, r22
    a7dc:	1d 92       	st	X+, r1
    a7de:	8a 95       	dec	r24
    a7e0:	e9 f7       	brne	.-6      	; 0xa7dc <fat16_read_dir+0x6a>

    /* reset callback arguments */
    memset(&arg, 0, sizeof(arg));
    a7e2:	fe 01       	movw	r30, r28
    a7e4:	31 96       	adiw	r30, 0x01	; 1
    a7e6:	85 e0       	ldi	r24, 0x05	; 5
    a7e8:	df 01       	movw	r26, r30
    a7ea:	1d 92       	st	X+, r1
    a7ec:	8a 95       	dec	r24
    a7ee:	e9 f7       	brne	.-6      	; 0xa7ea <fat16_read_dir+0x78>
    arg.dir_entry = dir_entry;

    /* check if we read from the root directory */
    if(cluster_num == 0)
    a7f0:	a1 14       	cp	r10, r1
    a7f2:	b1 04       	cpc	r11, r1
    a7f4:	09 f0       	breq	.+2      	; 0xa7f8 <fat16_read_dir+0x86>
    a7f6:	7e c0       	rjmp	.+252    	; 0xa8f4 <fat16_read_dir+0x182>
        cluster_size = header->cluster_zero_offset - header->root_dir_offset;
    a7f8:	f1 01       	movw	r30, r2
    a7fa:	46 88       	ldd	r4, Z+22	; 0x16
    a7fc:	57 88       	ldd	r5, Z+23	; 0x17
    a7fe:	82 89       	ldd	r24, Z+18	; 0x12
    a800:	93 89       	ldd	r25, Z+19	; 0x13
    a802:	48 1a       	sub	r4, r24
    a804:	59 0a       	sbc	r5, r25
    a806:	76 c0       	rjmp	.+236    	; 0xa8f4 <fat16_read_dir+0x182>
    uint8_t buffer[32];
    while(!arg.finished)
    {
        /* read directory entries up to the cluster border */
        uint16_t cluster_left = cluster_size - cluster_offset;
        uint32_t pos = cluster_offset;
    a808:	63 01       	movw	r12, r6
    a80a:	ee 24       	eor	r14, r14
    a80c:	ff 24       	eor	r15, r15
        if(cluster_num == 0)
    a80e:	a1 14       	cp	r10, r1
    a810:	b1 04       	cpc	r11, r1
    a812:	41 f4       	brne	.+16     	; 0xa824 <fat16_read_dir+0xb2>
            pos += header->root_dir_offset;
    a814:	d1 01       	movw	r26, r2
    a816:	52 96       	adiw	r26, 0x12	; 18
    a818:	6d 91       	ld	r22, X+
    a81a:	7d 91       	ld	r23, X+
    a81c:	8d 91       	ld	r24, X+
    a81e:	9c 91       	ld	r25, X
    a820:	55 97       	sbiw	r26, 0x15	; 21
    a822:	2e c0       	rjmp	.+92     	; 0xa880 <fat16_read_dir+0x10e>
        else
            pos += fat16_cluster_offset(dd->fs, cluster_num);
    a824:	f4 01       	movw	r30, r8
    a826:	00 81       	ld	r16, Z
    a828:	11 81       	ldd	r17, Z+1	; 0x01
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
uint32_t fat16_cluster_offset(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    if(!fs || cluster_num < 2)
    a82a:	01 15       	cp	r16, r1
    a82c:	11 05       	cpc	r17, r1
    a82e:	11 f1       	breq	.+68     	; 0xa874 <fat16_read_dir+0x102>
    a830:	f2 e0       	ldi	r31, 0x02	; 2
    a832:	af 16       	cp	r10, r31
    a834:	b1 04       	cpc	r11, r1
    a836:	f0 f0       	brcs	.+60     	; 0xa874 <fat16_read_dir+0x102>
        return 0;

    return fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
    a838:	2e ef       	ldi	r18, 0xFE	; 254
    a83a:	3f ef       	ldi	r19, 0xFF	; 255
    a83c:	a2 0e       	add	r10, r18
    a83e:	b3 1e       	adc	r11, r19
    a840:	b5 01       	movw	r22, r10
    a842:	80 e0       	ldi	r24, 0x00	; 0
    a844:	90 e0       	ldi	r25, 0x00	; 0
    a846:	a2 e0       	ldi	r26, 0x02	; 2
    a848:	b0 e0       	ldi	r27, 0x00	; 0
    a84a:	aa 0e       	add	r10, r26
    a84c:	bb 1e       	adc	r11, r27
    a84e:	f8 01       	movw	r30, r16
    a850:	20 89       	ldd	r18, Z+16	; 0x10
    a852:	31 89       	ldd	r19, Z+17	; 0x11
    a854:	40 e0       	ldi	r20, 0x00	; 0
    a856:	50 e0       	ldi	r21, 0x00	; 0
    a858:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    a85c:	9b 01       	movw	r18, r22
    a85e:	ac 01       	movw	r20, r24
    a860:	f8 01       	movw	r30, r16
    a862:	86 89       	ldd	r24, Z+22	; 0x16
    a864:	97 89       	ldd	r25, Z+23	; 0x17
    a866:	a0 8d       	ldd	r26, Z+24	; 0x18
    a868:	b1 8d       	ldd	r27, Z+25	; 0x19
    a86a:	28 0f       	add	r18, r24
    a86c:	39 1f       	adc	r19, r25
    a86e:	4a 1f       	adc	r20, r26
    a870:	5b 1f       	adc	r21, r27
    a872:	04 c0       	rjmp	.+8      	; 0xa87c <fat16_read_dir+0x10a>
    a874:	20 e0       	ldi	r18, 0x00	; 0
    a876:	30 e0       	ldi	r19, 0x00	; 0
    a878:	40 e0       	ldi	r20, 0x00	; 0
    a87a:	50 e0       	ldi	r21, 0x00	; 0
        uint16_t cluster_left = cluster_size - cluster_offset;
        uint32_t pos = cluster_offset;
        if(cluster_num == 0)
            pos += header->root_dir_offset;
        else
            pos += fat16_cluster_offset(dd->fs, cluster_num);
    a87c:	ca 01       	movw	r24, r20
    a87e:	b9 01       	movw	r22, r18
    a880:	6c 0d       	add	r22, r12
    a882:	7d 1d       	adc	r23, r13
    a884:	8e 1d       	adc	r24, r14
    a886:	9f 1d       	adc	r25, r15

        arg.bytes_read = 0;
    a888:	1c 82       	std	Y+4, r1	; 0x04
    a88a:	1b 82       	std	Y+3, r1	; 0x03
        if(!dd->fs->partition->device_read_interval(pos,
    a88c:	d4 01       	movw	r26, r8
    a88e:	ed 91       	ld	r30, X+
    a890:	fc 91       	ld	r31, X
    a892:	01 90       	ld	r0, Z+
    a894:	f0 81       	ld	r31, Z
    a896:	e0 2d       	mov	r30, r0
    a898:	82 01       	movw	r16, r4
    a89a:	06 19       	sub	r16, r6
    a89c:	17 09       	sbc	r17, r7
    a89e:	02 80       	ldd	r0, Z+2	; 0x02
    a8a0:	f3 81       	ldd	r31, Z+3	; 0x03
    a8a2:	e0 2d       	mov	r30, r0
    a8a4:	ae 01       	movw	r20, r28
    a8a6:	4a 5f       	subi	r20, 0xFA	; 250
    a8a8:	5f 4f       	sbci	r21, 0xFF	; 255
    a8aa:	20 e2       	ldi	r18, 0x20	; 32
    a8ac:	30 e0       	ldi	r19, 0x00	; 0
    a8ae:	af ef       	ldi	r26, 0xFF	; 255
    a8b0:	ea 2e       	mov	r14, r26
    a8b2:	a0 e5       	ldi	r26, 0x50	; 80
    a8b4:	fa 2e       	mov	r15, r26
    a8b6:	6e 01       	movw	r12, r28
    a8b8:	08 94       	sec
    a8ba:	c1 1c       	adc	r12, r1
    a8bc:	d1 1c       	adc	r13, r1
    a8be:	09 95       	icall
    a8c0:	88 23       	and	r24, r24
    a8c2:	81 f1       	breq	.+96     	; 0xa924 <fat16_read_dir+0x1b2>
                                                    fat16_dir_entry_read_callback,
                                                    &arg)
          )
            return 0;

        cluster_offset += arg.bytes_read;
    a8c4:	8b 81       	ldd	r24, Y+3	; 0x03
    a8c6:	9c 81       	ldd	r25, Y+4	; 0x04
    a8c8:	68 0e       	add	r6, r24
    a8ca:	79 1e       	adc	r7, r25

        if(cluster_offset >= cluster_size)
    a8cc:	64 14       	cp	r6, r4
    a8ce:	75 04       	cpc	r7, r5
    a8d0:	a8 f0       	brcs	.+42     	; 0xa8fc <fat16_read_dir+0x18a>
        {
            /* we reached the cluster border and switch to the next cluster */
            cluster_offset = 0;

            /* get number of next cluster */
            if(!(cluster_num = fat16_get_next_cluster(dd->fs, cluster_num)))
    a8d2:	f4 01       	movw	r30, r8
    a8d4:	80 81       	ld	r24, Z
    a8d6:	91 81       	ldd	r25, Z+1	; 0x01
    a8d8:	b5 01       	movw	r22, r10
    a8da:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
    a8de:	5c 01       	movw	r10, r24
    a8e0:	66 24       	eor	r6, r6
    a8e2:	77 24       	eor	r7, r7
    a8e4:	00 97       	sbiw	r24, 0x00	; 0
    a8e6:	51 f4       	brne	.+20     	; 0xa8fc <fat16_read_dir+0x18a>
            {
                /* directory entry not found, reset directory handle */
                cluster_num = dd->dir_entry.cluster;
    a8e8:	d4 01       	movw	r26, r8
    a8ea:	97 96       	adiw	r26, 0x27	; 39
    a8ec:	ad 90       	ld	r10, X+
    a8ee:	bc 90       	ld	r11, X
    a8f0:	98 97       	sbiw	r26, 0x28	; 40
    a8f2:	08 c0       	rjmp	.+16     	; 0xa904 <fat16_read_dir+0x192>
    /* reset directory entry */
    memset(dir_entry, 0, sizeof(*dir_entry));

    /* reset callback arguments */
    memset(&arg, 0, sizeof(arg));
    arg.dir_entry = dir_entry;
    a8f4:	ee a1       	ldd	r30, Y+38	; 0x26
    a8f6:	ff a1       	ldd	r31, Y+39	; 0x27
    a8f8:	fa 83       	std	Y+2, r31	; 0x02
    a8fa:	e9 83       	std	Y+1, r30	; 0x01
    if(cluster_num == 0)
        cluster_size = header->cluster_zero_offset - header->root_dir_offset;

    /* read entries */
    uint8_t buffer[32];
    while(!arg.finished)
    a8fc:	8d 81       	ldd	r24, Y+5	; 0x05
    a8fe:	88 23       	and	r24, r24
    a900:	09 f4       	brne	.+2      	; 0xa904 <fat16_read_dir+0x192>
    a902:	82 cf       	rjmp	.-252    	; 0xa808 <fat16_read_dir+0x96>
                break;
            }
        }
    }

    dd->entry_cluster = cluster_num;
    a904:	d4 01       	movw	r26, r8
    a906:	d2 96       	adiw	r26, 0x32	; 50
    a908:	bc 92       	st	X, r11
    a90a:	ae 92       	st	-X, r10
    a90c:	d1 97       	sbiw	r26, 0x31	; 49
    dd->entry_offset = cluster_offset;
    a90e:	d4 96       	adiw	r26, 0x34	; 52
    a910:	7c 92       	st	X, r7
    a912:	6e 92       	st	-X, r6
    a914:	d3 97       	sbiw	r26, 0x33	; 51

    return dir_entry->long_name[0] != '\0' ? 1 : 0;
    a916:	ee a1       	ldd	r30, Y+38	; 0x26
    a918:	ff a1       	ldd	r31, Y+39	; 0x27
    a91a:	80 81       	ld	r24, Z
    a91c:	88 23       	and	r24, r24
    a91e:	19 f0       	breq	.+6      	; 0xa926 <fat16_read_dir+0x1b4>
    a920:	81 e0       	ldi	r24, 0x01	; 1
    a922:	01 c0       	rjmp	.+2      	; 0xa926 <fat16_read_dir+0x1b4>
    a924:	80 e0       	ldi	r24, 0x00	; 0
}
    a926:	a7 96       	adiw	r28, 0x27	; 39
    a928:	0f b6       	in	r0, 0x3f	; 63
    a92a:	f8 94       	cli
    a92c:	de bf       	out	0x3e, r29	; 62
    a92e:	0f be       	out	0x3f, r0	; 63
    a930:	cd bf       	out	0x3d, r28	; 61
    a932:	cf 91       	pop	r28
    a934:	df 91       	pop	r29
    a936:	1f 91       	pop	r17
    a938:	0f 91       	pop	r16
    a93a:	ff 90       	pop	r15
    a93c:	ef 90       	pop	r14
    a93e:	df 90       	pop	r13
    a940:	cf 90       	pop	r12
    a942:	bf 90       	pop	r11
    a944:	af 90       	pop	r10
    a946:	9f 90       	pop	r9
    a948:	8f 90       	pop	r8
    a94a:	7f 90       	pop	r7
    a94c:	6f 90       	pop	r6
    a94e:	5f 90       	pop	r5
    a950:	4f 90       	pop	r4
    a952:	3f 90       	pop	r3
    a954:	2f 90       	pop	r2
    a956:	08 95       	ret

0000a958 <fat16_open>:
 * \param[in] partition Discriptor of partition on which the filesystem resides.
 * \returns 0 on error, a FAT16 filesystem descriptor on success.
 * \see fat16_open
 */
struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
{
    a958:	2f 92       	push	r2
    a95a:	3f 92       	push	r3
    a95c:	4f 92       	push	r4
    a95e:	5f 92       	push	r5
    a960:	6f 92       	push	r6
    a962:	7f 92       	push	r7
    a964:	8f 92       	push	r8
    a966:	9f 92       	push	r9
    a968:	af 92       	push	r10
    a96a:	bf 92       	push	r11
    a96c:	cf 92       	push	r12
    a96e:	df 92       	push	r13
    a970:	ef 92       	push	r14
    a972:	ff 92       	push	r15
    a974:	0f 93       	push	r16
    a976:	1f 93       	push	r17
    a978:	df 93       	push	r29
    a97a:	cf 93       	push	r28
    a97c:	cd b7       	in	r28, 0x3d	; 61
    a97e:	de b7       	in	r29, 0x3e	; 62
    a980:	e0 97       	sbiw	r28, 0x30	; 48
    a982:	0f b6       	in	r0, 0x3f	; 63
    a984:	f8 94       	cli
    a986:	de bf       	out	0x3e, r29	; 62
    a988:	0f be       	out	0x3f, r0	; 63
    a98a:	cd bf       	out	0x3d, r28	; 61
    a98c:	6c 01       	movw	r12, r24
    if(!partition ||
    a98e:	00 97       	sbiw	r24, 0x00	; 0
    a990:	09 f4       	brne	.+2      	; 0xa994 <fat16_open+0x3c>
    a992:	9f c1       	rjmp	.+830    	; 0xacd2 <fat16_open+0x37a>
    a994:	dc 01       	movw	r26, r24
    a996:	14 96       	adiw	r26, 0x04	; 4
    a998:	8d 91       	ld	r24, X+
    a99a:	9c 91       	ld	r25, X
    a99c:	15 97       	sbiw	r26, 0x05	; 5
    a99e:	89 2b       	or	r24, r25
    a9a0:	09 f4       	brne	.+2      	; 0xa9a4 <fat16_open+0x4c>
    a9a2:	97 c1       	rjmp	.+814    	; 0xacd2 <fat16_open+0x37a>
    a9a4:	16 96       	adiw	r26, 0x06	; 6
    a9a6:	8d 91       	ld	r24, X+
    a9a8:	9c 91       	ld	r25, X
    a9aa:	17 97       	sbiw	r26, 0x07	; 7
    a9ac:	89 2b       	or	r24, r25
    a9ae:	09 f4       	brne	.+2      	; 0xa9b2 <fat16_open+0x5a>
    a9b0:	90 c1       	rjmp	.+800    	; 0xacd2 <fat16_open+0x37a>
    a9b2:	ab c1       	rjmp	.+854    	; 0xad0a <fat16_open+0x3b2>
    }
    if(i >= FAT16_FS_COUNT)
        return 0;
#endif

    memset(fs, 0, sizeof(*fs));
    a9b4:	ea e1       	ldi	r30, 0x1A	; 26
    a9b6:	f2 e0       	ldi	r31, 0x02	; 2
    a9b8:	8a e1       	ldi	r24, 0x1A	; 26
    a9ba:	df 01       	movw	r26, r30
    a9bc:	1d 92       	st	X+, r1
    a9be:	8a 95       	dec	r24
    a9c0:	e9 f7       	brne	.-6      	; 0xa9bc <fat16_open+0x64>

    fs->partition = partition;
    a9c2:	d0 92 1b 02 	sts	0x021B, r13
    a9c6:	c0 92 1a 02 	sts	0x021A, r12
    if(!partition)
        return 0;

    /* read fat parameters */
    uint8_t buffer[25];
    uint32_t partition_offset = partition->offset * 512;
    a9ca:	d6 01       	movw	r26, r12
    a9cc:	19 96       	adiw	r26, 0x09	; 9
    a9ce:	2d 91       	ld	r18, X+
    a9d0:	3d 91       	ld	r19, X+
    a9d2:	4d 91       	ld	r20, X+
    a9d4:	5c 91       	ld	r21, X
    a9d6:	1c 97       	sbiw	r26, 0x0c	; 12
    a9d8:	19 e0       	ldi	r17, 0x09	; 9
    a9da:	22 0f       	add	r18, r18
    a9dc:	33 1f       	adc	r19, r19
    a9de:	44 1f       	adc	r20, r20
    a9e0:	55 1f       	adc	r21, r21
    a9e2:	1a 95       	dec	r17
    a9e4:	d1 f7       	brne	.-12     	; 0xa9da <fat16_open+0x82>
    a9e6:	2a a3       	std	Y+34, r18	; 0x22
    a9e8:	3b a3       	std	Y+35, r19	; 0x23
    a9ea:	4c a3       	std	Y+36, r20	; 0x24
    a9ec:	5d a3       	std	Y+37, r21	; 0x25
    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
    a9ee:	ca 01       	movw	r24, r20
    a9f0:	b9 01       	movw	r22, r18
    a9f2:	65 5f       	subi	r22, 0xF5	; 245
    a9f4:	7f 4f       	sbci	r23, 0xFF	; 255
    a9f6:	8f 4f       	sbci	r24, 0xFF	; 255
    a9f8:	9f 4f       	sbci	r25, 0xFF	; 255
    a9fa:	ed 91       	ld	r30, X+
    a9fc:	fc 91       	ld	r31, X
    a9fe:	ae 01       	movw	r20, r28
    aa00:	4f 5f       	subi	r20, 0xFF	; 255
    aa02:	5f 4f       	sbci	r21, 0xFF	; 255
    aa04:	29 e1       	ldi	r18, 0x19	; 25
    aa06:	30 e0       	ldi	r19, 0x00	; 0
    aa08:	09 95       	icall
    aa0a:	88 23       	and	r24, r24
    aa0c:	09 f4       	brne	.+2      	; 0xaa10 <fat16_open+0xb8>
    aa0e:	84 c1       	rjmp	.+776    	; 0xad18 <fat16_open+0x3c0>
        return 0;

    uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
                                ((uint16_t) buffer[0x01] << 8);
    aa10:	a9 80       	ldd	r10, Y+1	; 0x01
    aa12:	4a 80       	ldd	r4, Y+2	; 0x02
    uint8_t sectors_per_cluster = buffer[0x02];
    aa14:	bb 81       	ldd	r27, Y+3	; 0x03
    aa16:	be a3       	std	Y+38, r27	; 0x26
    uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
                                ((uint16_t) buffer[0x04] << 8);
    aa18:	0c 81       	ldd	r16, Y+4	; 0x04
    aa1a:	fd 80       	ldd	r15, Y+5	; 0x05
    uint8_t fat_copies = buffer[0x05];
    aa1c:	1e 81       	ldd	r17, Y+6	; 0x06
    uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
                                ((uint16_t) buffer[0x07] << 8);
    aa1e:	3f 81       	ldd	r19, Y+7	; 0x07
    aa20:	58 84       	ldd	r5, Y+8	; 0x08
    uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
                               ((uint16_t) buffer[0x09] << 8);
    aa22:	69 84       	ldd	r6, Y+9	; 0x09
    aa24:	7a 84       	ldd	r7, Y+10	; 0x0a
    uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
                               ((uint16_t) buffer[0x0c] << 8);
    aa26:	9d 85       	ldd	r25, Y+13	; 0x0d
    aa28:	80 e0       	ldi	r24, 0x00	; 0
    aa2a:	2c 85       	ldd	r18, Y+12	; 0x0c
    aa2c:	e2 2f       	mov	r30, r18
    aa2e:	f0 e0       	ldi	r31, 0x00	; 0
    aa30:	e8 2b       	or	r30, r24
    aa32:	f9 2b       	or	r31, r25
    uint32_t sector_count = ((uint32_t) buffer[0x15]) |
                            ((uint32_t) buffer[0x16] << 8) |
                            ((uint32_t) buffer[0x17] << 16) |
                            ((uint32_t) buffer[0x18] << 24);
    aa34:	8e 88       	ldd	r8, Y+22	; 0x16
    aa36:	3f 88       	ldd	r3, Y+23	; 0x17
    aa38:	28 8d       	ldd	r18, Y+24	; 0x18
    aa3a:	e9 8c       	ldd	r14, Y+25	; 0x19
    
    if(sectors_per_fat == 0)
    aa3c:	30 97       	sbiw	r30, 0x00	; 0
    aa3e:	09 f4       	brne	.+2      	; 0xaa42 <fat16_open+0xea>
    aa40:	6b c1       	rjmp	.+726    	; 0xad18 <fat16_open+0x3c0>
    uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
                               ((uint16_t) buffer[0x0c] << 8);
    uint32_t sector_count = ((uint32_t) buffer[0x15]) |
                            ((uint32_t) buffer[0x16] << 8) |
                            ((uint32_t) buffer[0x17] << 16) |
                            ((uint32_t) buffer[0x18] << 24);
    aa42:	43 2d       	mov	r20, r3
    aa44:	50 e0       	ldi	r21, 0x00	; 0
    aa46:	60 e0       	ldi	r22, 0x00	; 0
    aa48:	70 e0       	ldi	r23, 0x00	; 0
    aa4a:	96 2f       	mov	r25, r22
    aa4c:	85 2f       	mov	r24, r21
    aa4e:	74 2f       	mov	r23, r20
    aa50:	66 27       	eor	r22, r22
    aa52:	69 a7       	std	Y+41, r22	; 0x29
    aa54:	7a a7       	std	Y+42, r23	; 0x2a
    aa56:	8b a7       	std	Y+43, r24	; 0x2b
    aa58:	9c a7       	std	Y+44, r25	; 0x2c
    aa5a:	82 2f       	mov	r24, r18
    aa5c:	90 e0       	ldi	r25, 0x00	; 0
    aa5e:	a0 e0       	ldi	r26, 0x00	; 0
    aa60:	b0 e0       	ldi	r27, 0x00	; 0
    aa62:	bc 01       	movw	r22, r24
    aa64:	55 27       	eor	r21, r21
    aa66:	44 27       	eor	r20, r20
    aa68:	89 a5       	ldd	r24, Y+41	; 0x29
    aa6a:	9a a5       	ldd	r25, Y+42	; 0x2a
    aa6c:	ab a5       	ldd	r26, Y+43	; 0x2b
    aa6e:	bc a5       	ldd	r27, Y+44	; 0x2c
    aa70:	84 2b       	or	r24, r20
    aa72:	95 2b       	or	r25, r21
    aa74:	a6 2b       	or	r26, r22
    aa76:	b7 2b       	or	r27, r23
    aa78:	48 2d       	mov	r20, r8
    aa7a:	50 e0       	ldi	r21, 0x00	; 0
    aa7c:	60 e0       	ldi	r22, 0x00	; 0
    aa7e:	70 e0       	ldi	r23, 0x00	; 0
    aa80:	84 2b       	or	r24, r20
    aa82:	95 2b       	or	r25, r21
    aa84:	a6 2b       	or	r26, r22
    aa86:	b7 2b       	or	r27, r23
    aa88:	89 a7       	std	Y+41, r24	; 0x29
    aa8a:	9a a7       	std	Y+42, r25	; 0x2a
    aa8c:	ab a7       	std	Y+43, r26	; 0x2b
    aa8e:	bc a7       	std	Y+44, r27	; 0x2c
    aa90:	8e 2d       	mov	r24, r14
    aa92:	90 e0       	ldi	r25, 0x00	; 0
    aa94:	a0 e0       	ldi	r26, 0x00	; 0
    aa96:	b0 e0       	ldi	r27, 0x00	; 0
    aa98:	78 2f       	mov	r23, r24
    aa9a:	66 27       	eor	r22, r22
    aa9c:	55 27       	eor	r21, r21
    aa9e:	44 27       	eor	r20, r20
    aaa0:	89 a5       	ldd	r24, Y+41	; 0x29
    aaa2:	9a a5       	ldd	r25, Y+42	; 0x2a
    aaa4:	ab a5       	ldd	r26, Y+43	; 0x2b
    aaa6:	bc a5       	ldd	r27, Y+44	; 0x2c
    aaa8:	84 2b       	or	r24, r20
    aaaa:	95 2b       	or	r25, r21
    aaac:	a6 2b       	or	r26, r22
    aaae:	b7 2b       	or	r27, r23
    aab0:	89 a7       	std	Y+41, r24	; 0x29
    aab2:	9a a7       	std	Y+42, r25	; 0x2a
    aab4:	ab a7       	std	Y+43, r26	; 0x2b
    aab6:	bc a7       	std	Y+44, r27	; 0x2c
    
    if(sectors_per_fat == 0)
        /* this is not a FAT16 */
        return 0;

    if(sector_count == 0)
    aab8:	00 97       	sbiw	r24, 0x00	; 0
    aaba:	a1 05       	cpc	r26, r1
    aabc:	b1 05       	cpc	r27, r1
    aabe:	89 f4       	brne	.+34     	; 0xaae2 <fat16_open+0x18a>
                                ((uint16_t) buffer[0x04] << 8);
    uint8_t fat_copies = buffer[0x05];
    uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
                                ((uint16_t) buffer[0x07] << 8);
    uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
                               ((uint16_t) buffer[0x09] << 8);
    aac0:	97 2d       	mov	r25, r7
    aac2:	80 e0       	ldi	r24, 0x00	; 0
    aac4:	66 2d       	mov	r22, r6
    aac6:	70 e0       	ldi	r23, 0x00	; 0
    aac8:	68 2b       	or	r22, r24
    aaca:	79 2b       	or	r23, r25
        /* this is not a FAT16 */
        return 0;

    if(sector_count == 0)
    {
        if(sector_count_16 == 0)
    aacc:	61 15       	cp	r22, r1
    aace:	71 05       	cpc	r23, r1
    aad0:	09 f4       	brne	.+2      	; 0xaad4 <fat16_open+0x17c>
    aad2:	22 c1       	rjmp	.+580    	; 0xad18 <fat16_open+0x3c0>
            /* illegal volume size */
            return 0;
        else
            sector_count = sector_count_16;
    aad4:	cb 01       	movw	r24, r22
    aad6:	a0 e0       	ldi	r26, 0x00	; 0
    aad8:	b0 e0       	ldi	r27, 0x00	; 0
    aada:	89 a7       	std	Y+41, r24	; 0x29
    aadc:	9a a7       	std	Y+42, r25	; 0x2a
    aade:	ab a7       	std	Y+43, r26	; 0x2b
    aae0:	bc a7       	std	Y+44, r27	; 0x2c
    uint32_t partition_offset = partition->offset * 512;
    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
        return 0;

    uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
                                ((uint16_t) buffer[0x01] << 8);
    aae2:	94 2d       	mov	r25, r4
    aae4:	80 e0       	ldi	r24, 0x00	; 0
    aae6:	2a 2c       	mov	r2, r10
    aae8:	33 24       	eor	r3, r3
    aaea:	28 2a       	or	r2, r24
    aaec:	39 2a       	or	r3, r25
    uint8_t sectors_per_cluster = buffer[0x02];
    uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
                                ((uint16_t) buffer[0x04] << 8);
    uint8_t fat_copies = buffer[0x05];
    uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
                                ((uint16_t) buffer[0x07] << 8);
    aaee:	95 2d       	mov	r25, r5
    aaf0:	80 e0       	ldi	r24, 0x00	; 0
    aaf2:	a3 2f       	mov	r26, r19
    aaf4:	b0 e0       	ldi	r27, 0x00	; 0
    aaf6:	a8 2b       	or	r26, r24
    aaf8:	b9 2b       	or	r27, r25
    aafa:	b8 a7       	std	Y+40, r27	; 0x28
    aafc:	af a3       	std	Y+39, r26	; 0x27

    /* ensure we really have a FAT16 fs here */
    uint32_t data_sector_count = sector_count
                                 - reserved_sectors
                                 - (uint32_t) sectors_per_fat * fat_copies
                                 - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
    aafe:	9f 2d       	mov	r25, r15
    ab00:	80 e0       	ldi	r24, 0x00	; 0
    ab02:	20 2f       	mov	r18, r16
    ab04:	30 e0       	ldi	r19, 0x00	; 0
    ab06:	82 2b       	or	r24, r18
    ab08:	93 2b       	or	r25, r19
    ab0a:	9c 01       	movw	r18, r24
    ab0c:	40 e0       	ldi	r20, 0x00	; 0
    ab0e:	50 e0       	ldi	r21, 0x00	; 0
    ab10:	2e 8f       	std	Y+30, r18	; 0x1e
    ab12:	3f 8f       	std	Y+31, r19	; 0x1f
    ab14:	48 a3       	std	Y+32, r20	; 0x20
    ab16:	59 a3       	std	Y+33, r21	; 0x21
    ab18:	bf 01       	movw	r22, r30
    ab1a:	80 e0       	ldi	r24, 0x00	; 0
    ab1c:	90 e0       	ldi	r25, 0x00	; 0
    ab1e:	21 2f       	mov	r18, r17
    ab20:	30 e0       	ldi	r19, 0x00	; 0
    ab22:	40 e0       	ldi	r20, 0x00	; 0
    ab24:	50 e0       	ldi	r21, 0x00	; 0
    ab26:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    ab2a:	6a 8f       	std	Y+26, r22	; 0x1a
    ab2c:	7b 8f       	std	Y+27, r23	; 0x1b
    ab2e:	8c 8f       	std	Y+28, r24	; 0x1c
    ab30:	9d 8f       	std	Y+29, r25	; 0x1d
    uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
    ab32:	e9 a4       	ldd	r14, Y+41	; 0x29
    ab34:	fa a4       	ldd	r15, Y+42	; 0x2a
    ab36:	0b a5       	ldd	r16, Y+43	; 0x2b
    ab38:	1c a5       	ldd	r17, Y+44	; 0x2c
    ab3a:	4e 8d       	ldd	r20, Y+30	; 0x1e
    ab3c:	5f 8d       	ldd	r21, Y+31	; 0x1f
    ab3e:	68 a1       	ldd	r22, Y+32	; 0x20
    ab40:	79 a1       	ldd	r23, Y+33	; 0x21
    ab42:	e4 1a       	sub	r14, r20
    ab44:	f5 0a       	sbc	r15, r21
    ab46:	06 0b       	sbc	r16, r22
    ab48:	17 0b       	sbc	r17, r23
    ab4a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ab4c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    ab4e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    ab50:	9d 8d       	ldd	r25, Y+29	; 0x1d
    ab52:	e6 1a       	sub	r14, r22
    ab54:	f7 0a       	sbc	r15, r23
    ab56:	08 0b       	sbc	r16, r24
    ab58:	19 0b       	sbc	r17, r25
    ab5a:	c1 01       	movw	r24, r2
    ab5c:	01 97       	sbiw	r24, 0x01	; 1
    ab5e:	2f a1       	ldd	r18, Y+39	; 0x27
    ab60:	38 a5       	ldd	r19, Y+40	; 0x28
    ab62:	45 e0       	ldi	r20, 0x05	; 5
    ab64:	22 0f       	add	r18, r18
    ab66:	33 1f       	adc	r19, r19
    ab68:	4a 95       	dec	r20
    ab6a:	e1 f7       	brne	.-8      	; 0xab64 <fat16_open+0x20c>
    ab6c:	82 0f       	add	r24, r18
    ab6e:	93 1f       	adc	r25, r19
    ab70:	b1 01       	movw	r22, r2
    ab72:	0e 94 3b 6b 	call	0xd676	; 0xd676 <__udivmodhi4>
    ab76:	80 e0       	ldi	r24, 0x00	; 0
    ab78:	90 e0       	ldi	r25, 0x00	; 0
    ab7a:	e6 1a       	sub	r14, r22
    ab7c:	f7 0a       	sbc	r15, r23
    ab7e:	08 0b       	sbc	r16, r24
    ab80:	19 0b       	sbc	r17, r25
    ab82:	7e a1       	ldd	r23, Y+38	; 0x26
    ab84:	27 2f       	mov	r18, r23
    ab86:	30 e0       	ldi	r19, 0x00	; 0
    ab88:	40 e0       	ldi	r20, 0x00	; 0
    ab8a:	50 e0       	ldi	r21, 0x00	; 0
    ab8c:	c8 01       	movw	r24, r16
    ab8e:	b7 01       	movw	r22, r14
    ab90:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    ab94:	29 01       	movw	r4, r18
    ab96:	3a 01       	movw	r6, r20
    if(data_cluster_count < 4085 || data_cluster_count >= 65525)
    ab98:	d3 01       	movw	r26, r6
    ab9a:	c2 01       	movw	r24, r4
    ab9c:	85 5f       	subi	r24, 0xF5	; 245
    ab9e:	9f 40       	sbci	r25, 0x0F	; 15
    aba0:	a0 40       	sbci	r26, 0x00	; 0
    aba2:	b0 40       	sbci	r27, 0x00	; 0
    aba4:	80 50       	subi	r24, 0x00	; 0
    aba6:	90 4f       	sbci	r25, 0xF0	; 240
    aba8:	a0 40       	sbci	r26, 0x00	; 0
    abaa:	b0 40       	sbci	r27, 0x00	; 0
    abac:	08 f0       	brcs	.+2      	; 0xabb0 <fat16_open+0x258>
    abae:	b4 c0       	rjmp	.+360    	; 0xad18 <fat16_open+0x3c0>
        /* this is not a FAT16 */
        return 0;

    partition->type = PARTITION_TYPE_FAT16;
    abb0:	86 e0       	ldi	r24, 0x06	; 6
    abb2:	d6 01       	movw	r26, r12
    abb4:	18 96       	adiw	r26, 0x08	; 8
    abb6:	8c 93       	st	X, r24

    /* fill header information */
    struct fat16_header_struct* header = &fs->header;
    memset(header, 0, sizeof(*header));
    abb8:	9c e1       	ldi	r25, 0x1C	; 28
    abba:	89 2e       	mov	r8, r25
    abbc:	92 e0       	ldi	r25, 0x02	; 2
    abbe:	99 2e       	mov	r9, r25
    abc0:	88 e1       	ldi	r24, 0x18	; 24
    abc2:	f4 01       	movw	r30, r8
    abc4:	11 92       	st	Z+, r1
    abc6:	8a 95       	dec	r24
    abc8:	e9 f7       	brne	.-6      	; 0xabc4 <fat16_open+0x26c>
    
    header->size = sector_count * bytes_per_sector;
    abca:	51 01       	movw	r10, r2
    abcc:	cc 24       	eor	r12, r12
    abce:	dd 24       	eor	r13, r13
    abd0:	69 a5       	ldd	r22, Y+41	; 0x29
    abd2:	7a a5       	ldd	r23, Y+42	; 0x2a
    abd4:	8b a5       	ldd	r24, Y+43	; 0x2b
    abd6:	9c a5       	ldd	r25, Y+44	; 0x2c
    abd8:	a6 01       	movw	r20, r12
    abda:	95 01       	movw	r18, r10
    abdc:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    abe0:	60 93 1c 02 	sts	0x021C, r22
    abe4:	70 93 1d 02 	sts	0x021D, r23
    abe8:	80 93 1e 02 	sts	0x021E, r24
    abec:	90 93 1f 02 	sts	0x021F, r25

    header->fat_offset = /* jump to partition */
    abf0:	c6 01       	movw	r24, r12
    abf2:	b5 01       	movw	r22, r10
    abf4:	2e 8d       	ldd	r18, Y+30	; 0x1e
    abf6:	3f 8d       	ldd	r19, Y+31	; 0x1f
    abf8:	48 a1       	ldd	r20, Y+32	; 0x20
    abfa:	59 a1       	ldd	r21, Y+33	; 0x21
    abfc:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    ac00:	7b 01       	movw	r14, r22
    ac02:	8c 01       	movw	r16, r24
    ac04:	2a a1       	ldd	r18, Y+34	; 0x22
    ac06:	3b a1       	ldd	r19, Y+35	; 0x23
    ac08:	4c a1       	ldd	r20, Y+36	; 0x24
    ac0a:	5d a1       	ldd	r21, Y+37	; 0x25
    ac0c:	e2 0e       	add	r14, r18
    ac0e:	f3 1e       	adc	r15, r19
    ac10:	04 1f       	adc	r16, r20
    ac12:	15 1f       	adc	r17, r21
    ac14:	e0 92 20 02 	sts	0x0220, r14
    ac18:	f0 92 21 02 	sts	0x0221, r15
    ac1c:	00 93 22 02 	sts	0x0222, r16
    ac20:	10 93 23 02 	sts	0x0223, r17
                         partition_offset +
                         /* jump to fat */
                         (uint32_t) reserved_sectors * bytes_per_sector;
    header->fat_size = (data_cluster_count + 2) * 2;
    ac24:	42 e0       	ldi	r20, 0x02	; 2
    ac26:	50 e0       	ldi	r21, 0x00	; 0
    ac28:	60 e0       	ldi	r22, 0x00	; 0
    ac2a:	70 e0       	ldi	r23, 0x00	; 0
    ac2c:	44 0e       	add	r4, r20
    ac2e:	55 1e       	adc	r5, r21
    ac30:	66 1e       	adc	r6, r22
    ac32:	77 1e       	adc	r7, r23
    ac34:	44 0c       	add	r4, r4
    ac36:	55 1c       	adc	r5, r5
    ac38:	66 1c       	adc	r6, r6
    ac3a:	77 1c       	adc	r7, r7
    ac3c:	40 92 24 02 	sts	0x0224, r4
    ac40:	50 92 25 02 	sts	0x0225, r5
    ac44:	60 92 26 02 	sts	0x0226, r6
    ac48:	70 92 27 02 	sts	0x0227, r7

    header->sector_size = bytes_per_sector;
    ac4c:	30 92 29 02 	sts	0x0229, r3
    ac50:	20 92 28 02 	sts	0x0228, r2
    header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
    ac54:	5e a1       	ldd	r21, Y+38	; 0x26
    ac56:	85 2f       	mov	r24, r21
    ac58:	90 e0       	ldi	r25, 0x00	; 0
    ac5a:	bc 01       	movw	r22, r24
    ac5c:	26 9e       	mul	r2, r22
    ac5e:	c0 01       	movw	r24, r0
    ac60:	27 9e       	mul	r2, r23
    ac62:	90 0d       	add	r25, r0
    ac64:	36 9e       	mul	r3, r22
    ac66:	90 0d       	add	r25, r0
    ac68:	11 24       	eor	r1, r1
    ac6a:	90 93 2b 02 	sts	0x022B, r25
    ac6e:	80 93 2a 02 	sts	0x022A, r24

    header->root_dir_offset = /* jump to fats */
    ac72:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ac74:	7b 8d       	ldd	r23, Y+27	; 0x1b
    ac76:	8c 8d       	ldd	r24, Y+28	; 0x1c
    ac78:	9d 8d       	ldd	r25, Y+29	; 0x1d
    ac7a:	a6 01       	movw	r20, r12
    ac7c:	95 01       	movw	r18, r10
    ac7e:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    ac82:	6e 0d       	add	r22, r14
    ac84:	7f 1d       	adc	r23, r15
    ac86:	80 1f       	adc	r24, r16
    ac88:	91 1f       	adc	r25, r17
    ac8a:	60 93 2c 02 	sts	0x022C, r22
    ac8e:	70 93 2d 02 	sts	0x022D, r23
    ac92:	80 93 2e 02 	sts	0x022E, r24
    ac96:	90 93 2f 02 	sts	0x022F, r25
                              header->fat_offset +
                              /* jump to root directory entries */
                              (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;

    header->cluster_zero_offset = /* jump to root directory entries */
    ac9a:	af a1       	ldd	r26, Y+39	; 0x27
    ac9c:	b8 a5       	ldd	r27, Y+40	; 0x28
    ac9e:	9d 01       	movw	r18, r26
    aca0:	40 e0       	ldi	r20, 0x00	; 0
    aca2:	50 e0       	ldi	r21, 0x00	; 0
    aca4:	b5 e0       	ldi	r27, 0x05	; 5
    aca6:	22 0f       	add	r18, r18
    aca8:	33 1f       	adc	r19, r19
    acaa:	44 1f       	adc	r20, r20
    acac:	55 1f       	adc	r21, r21
    acae:	ba 95       	dec	r27
    acb0:	d1 f7       	brne	.-12     	; 0xaca6 <fat16_open+0x34e>
    acb2:	62 0f       	add	r22, r18
    acb4:	73 1f       	adc	r23, r19
    acb6:	84 1f       	adc	r24, r20
    acb8:	95 1f       	adc	r25, r21
    acba:	60 93 30 02 	sts	0x0230, r22
    acbe:	70 93 31 02 	sts	0x0231, r23
    acc2:	80 93 32 02 	sts	0x0232, r24
    acc6:	90 93 33 02 	sts	0x0233, r25
    acca:	94 01       	movw	r18, r8
    accc:	22 50       	subi	r18, 0x02	; 2
    acce:	30 40       	sbci	r19, 0x00	; 0
    acd0:	02 c0       	rjmp	.+4      	; 0xacd6 <fat16_open+0x37e>
    acd2:	20 e0       	ldi	r18, 0x00	; 0
    acd4:	30 e0       	ldi	r19, 0x00	; 0
#endif
        return 0;
    }
    
    return fs;
}
    acd6:	c9 01       	movw	r24, r18
    acd8:	e0 96       	adiw	r28, 0x30	; 48
    acda:	0f b6       	in	r0, 0x3f	; 63
    acdc:	f8 94       	cli
    acde:	de bf       	out	0x3e, r29	; 62
    ace0:	0f be       	out	0x3f, r0	; 63
    ace2:	cd bf       	out	0x3d, r28	; 61
    ace4:	cf 91       	pop	r28
    ace6:	df 91       	pop	r29
    ace8:	1f 91       	pop	r17
    acea:	0f 91       	pop	r16
    acec:	ff 90       	pop	r15
    acee:	ef 90       	pop	r14
    acf0:	df 90       	pop	r13
    acf2:	cf 90       	pop	r12
    acf4:	bf 90       	pop	r11
    acf6:	af 90       	pop	r10
    acf8:	9f 90       	pop	r9
    acfa:	8f 90       	pop	r8
    acfc:	7f 90       	pop	r7
    acfe:	6f 90       	pop	r6
    ad00:	5f 90       	pop	r5
    ad02:	4f 90       	pop	r4
    ad04:	3f 90       	pop	r3
    ad06:	2f 90       	pop	r2
    ad08:	08 95       	ret
#else
    struct fat16_fs_struct* fs = fat16_fs_handles;
    uint8_t i;
    for(i = 0; i < FAT16_FS_COUNT; ++i)
    {
        if(!fs->partition)
    ad0a:	80 91 1a 02 	lds	r24, 0x021A
    ad0e:	90 91 1b 02 	lds	r25, 0x021B
    ad12:	89 2b       	or	r24, r25
    ad14:	f1 f6       	brne	.-68     	; 0xacd2 <fat16_open+0x37a>
    ad16:	4e ce       	rjmp	.-868    	; 0xa9b4 <fat16_open+0x5c>
    if(!fat16_read_header(fs))
    {
#if USE_DYNAMIC_MEMORY
        free(fs);
#else
        fs->partition = 0;
    ad18:	10 92 1b 02 	sts	0x021B, r1
    ad1c:	10 92 1a 02 	sts	0x021A, r1
    ad20:	d8 cf       	rjmp	.-80     	; 0xacd2 <fat16_open+0x37a>

0000ad22 <fat16_find_offset_for_dir_entry>:
 * \param[in] parent The directory in which to search.
 * \param[in] dir_entry The directory entry for which to search space.
 * \returns 0 on failure, a device offset on success.
 */
uint32_t fat16_find_offset_for_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_struct* parent, const struct fat16_dir_entry_struct* dir_entry)
{
    ad22:	2f 92       	push	r2
    ad24:	3f 92       	push	r3
    ad26:	4f 92       	push	r4
    ad28:	5f 92       	push	r5
    ad2a:	6f 92       	push	r6
    ad2c:	7f 92       	push	r7
    ad2e:	8f 92       	push	r8
    ad30:	9f 92       	push	r9
    ad32:	af 92       	push	r10
    ad34:	bf 92       	push	r11
    ad36:	cf 92       	push	r12
    ad38:	df 92       	push	r13
    ad3a:	ef 92       	push	r14
    ad3c:	ff 92       	push	r15
    ad3e:	0f 93       	push	r16
    ad40:	1f 93       	push	r17
    ad42:	df 93       	push	r29
    ad44:	cf 93       	push	r28
    ad46:	00 d0       	rcall	.+0      	; 0xad48 <fat16_find_offset_for_dir_entry+0x26>
    ad48:	0f 92       	push	r0
    ad4a:	cd b7       	in	r28, 0x3d	; 61
    ad4c:	de b7       	in	r29, 0x3e	; 62
    ad4e:	1c 01       	movw	r2, r24
    ad50:	9b 01       	movw	r18, r22
#if FAT16_WRITE_SUPPORT
    if(!fs || !dir_entry)
    ad52:	00 97       	sbiw	r24, 0x00	; 0
    ad54:	09 f4       	brne	.+2      	; 0xad58 <fat16_find_offset_for_dir_entry+0x36>
    ad56:	d2 c0       	rjmp	.+420    	; 0xaefc <fat16_find_offset_for_dir_entry+0x1da>
    ad58:	41 15       	cp	r20, r1
    ad5a:	51 05       	cpc	r21, r1
    ad5c:	09 f4       	brne	.+2      	; 0xad60 <fat16_find_offset_for_dir_entry+0x3e>
    ad5e:	ce c0       	rjmp	.+412    	; 0xaefc <fat16_find_offset_for_dir_entry+0x1da>
        return 0;

    /* search for a place where to write the directory entry to disk */
    uint8_t free_dir_entries_needed = (strlen(dir_entry->long_name) + 12) / 13 + 1;
    ad60:	fa 01       	movw	r30, r20
    ad62:	01 90       	ld	r0, Z+
    ad64:	00 20       	and	r0, r0
    ad66:	e9 f7       	brne	.-6      	; 0xad62 <fat16_find_offset_for_dir_entry+0x40>
    ad68:	e4 1b       	sub	r30, r20
    ad6a:	f5 0b       	sbc	r31, r21
    ad6c:	cf 01       	movw	r24, r30
    ad6e:	0b 96       	adiw	r24, 0x0b	; 11
    ad70:	6d e0       	ldi	r22, 0x0D	; 13
    ad72:	70 e0       	ldi	r23, 0x00	; 0
    ad74:	0e 94 3b 6b 	call	0xd676	; 0xd676 <__udivmodhi4>
    ad78:	86 2f       	mov	r24, r22
    ad7a:	8f 5f       	subi	r24, 0xFF	; 255
    ad7c:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t free_dir_entries_found = 0;
    uint16_t cluster_num = parent->dir_entry.cluster;
    ad7e:	d9 01       	movw	r26, r18
    ad80:	97 96       	adiw	r26, 0x27	; 39
    ad82:	4d 90       	ld	r4, X+
    ad84:	5c 90       	ld	r5, X
    ad86:	98 97       	sbiw	r26, 0x28	; 40
    uint32_t dir_entry_offset = 0;
    uint32_t offset = 0;
    uint32_t offset_to = 0;

    if(cluster_num == 0)
    ad88:	41 14       	cp	r4, r1
    ad8a:	51 04       	cpc	r5, r1
    ad8c:	51 f0       	breq	.+20     	; 0xada2 <fat16_find_offset_for_dir_entry+0x80>
    ad8e:	aa 24       	eor	r10, r10
    ad90:	bb 24       	eor	r11, r11
    ad92:	65 01       	movw	r12, r10
    ad94:	ee 24       	eor	r14, r14
    ad96:	ff 24       	eor	r15, r15
    ad98:	87 01       	movw	r16, r14
    ad9a:	66 24       	eor	r6, r6
    ad9c:	77 24       	eor	r7, r7
    ad9e:	43 01       	movw	r8, r6
    ada0:	0b c0       	rjmp	.+22     	; 0xadb8 <fat16_find_offset_for_dir_entry+0x96>
    {
        /* we read/write from the root directory entry */
        offset = fs->header.root_dir_offset;
    ada2:	f1 01       	movw	r30, r2
    ada4:	e2 88       	ldd	r14, Z+18	; 0x12
    ada6:	f3 88       	ldd	r15, Z+19	; 0x13
    ada8:	04 89       	ldd	r16, Z+20	; 0x14
    adaa:	15 89       	ldd	r17, Z+21	; 0x15
        offset_to = fs->header.cluster_zero_offset;
    adac:	66 88       	ldd	r6, Z+22	; 0x16
    adae:	77 88       	ldd	r7, Z+23	; 0x17
    adb0:	80 8c       	ldd	r8, Z+24	; 0x18
    adb2:	91 8c       	ldd	r9, Z+25	; 0x19
    adb4:	57 01       	movw	r10, r14
    adb6:	68 01       	movw	r12, r16
    adb8:	1a 82       	std	Y+2, r1	; 0x02
        dir_entry_offset = offset;
    }
    
    while(1)
    {
        if(offset == offset_to)
    adba:	e6 14       	cp	r14, r6
    adbc:	f7 04       	cpc	r15, r7
    adbe:	08 05       	cpc	r16, r8
    adc0:	19 05       	cpc	r17, r9
    adc2:	09 f0       	breq	.+2      	; 0xadc6 <fat16_find_offset_for_dir_entry+0xa4>
    adc4:	6e c0       	rjmp	.+220    	; 0xaea2 <fat16_find_offset_for_dir_entry+0x180>
        {
            if(cluster_num == 0)
    adc6:	41 14       	cp	r4, r1
    adc8:	51 04       	cpc	r5, r1
    adca:	09 f4       	brne	.+2      	; 0xadce <fat16_find_offset_for_dir_entry+0xac>
    adcc:	97 c0       	rjmp	.+302    	; 0xaefc <fat16_find_offset_for_dir_entry+0x1da>
                /* We iterated through the whole root directory entry
                 * and could not find enough space for the directory entry.
                 */
                return 0;

            if(offset)
    adce:	e1 14       	cp	r14, r1
    add0:	f1 04       	cpc	r15, r1
    add2:	01 05       	cpc	r16, r1
    add4:	11 05       	cpc	r17, r1
    add6:	89 f1       	breq	.+98     	; 0xae3a <fat16_find_offset_for_dir_entry+0x118>
            {
                /* We reached a cluster boundary and have to
                 * switch to the next cluster.
                 */

                uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
    add8:	c1 01       	movw	r24, r2
    adda:	b2 01       	movw	r22, r4
    addc:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
                if(!cluster_next)
    ade0:	00 97       	sbiw	r24, 0x00	; 0
    ade2:	51 f5       	brne	.+84     	; 0xae38 <fat16_find_offset_for_dir_entry+0x116>
                {
                    cluster_next = fat16_append_clusters(fs, cluster_num, 1);
    ade4:	c1 01       	movw	r24, r2
    ade6:	b2 01       	movw	r22, r4
    ade8:	41 e0       	ldi	r20, 0x01	; 1
    adea:	50 e0       	ldi	r21, 0x00	; 0
    adec:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
    adf0:	8c 01       	movw	r16, r24
                    if(!cluster_next)
    adf2:	00 97       	sbiw	r24, 0x00	; 0
    adf4:	09 f4       	brne	.+2      	; 0xadf8 <fat16_find_offset_for_dir_entry+0xd6>
    adf6:	82 c0       	rjmp	.+260    	; 0xaefc <fat16_find_offset_for_dir_entry+0x1da>
                        return 0;

                    /* we appended a new cluster and know it is free */
                    dir_entry_offset = fs->header.cluster_zero_offset +
    adf8:	02 50       	subi	r16, 0x02	; 2
    adfa:	10 40       	sbci	r17, 0x00	; 0
    adfc:	b8 01       	movw	r22, r16
    adfe:	80 e0       	ldi	r24, 0x00	; 0
    ae00:	90 e0       	ldi	r25, 0x00	; 0
    ae02:	0e 5f       	subi	r16, 0xFE	; 254
    ae04:	1f 4f       	sbci	r17, 0xFF	; 255
    ae06:	d1 01       	movw	r26, r2
    ae08:	50 96       	adiw	r26, 0x10	; 16
    ae0a:	2d 91       	ld	r18, X+
    ae0c:	3c 91       	ld	r19, X
    ae0e:	51 97       	sbiw	r26, 0x11	; 17
    ae10:	40 e0       	ldi	r20, 0x00	; 0
    ae12:	50 e0       	ldi	r21, 0x00	; 0
    ae14:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    ae18:	5b 01       	movw	r10, r22
    ae1a:	6c 01       	movw	r12, r24
    ae1c:	f1 01       	movw	r30, r2
    ae1e:	86 89       	ldd	r24, Z+22	; 0x16
    ae20:	97 89       	ldd	r25, Z+23	; 0x17
    ae22:	a0 8d       	ldd	r26, Z+24	; 0x18
    ae24:	b1 8d       	ldd	r27, Z+25	; 0x19
    ae26:	a8 0e       	add	r10, r24
    ae28:	b9 1e       	adc	r11, r25
    ae2a:	ca 1e       	adc	r12, r26
    ae2c:	db 1e       	adc	r13, r27
                                       (uint32_t) (cluster_next - 2) * fs->header.cluster_size;

                    /* clear cluster to avoid garbage directory entries */
                    fat16_clear_cluster(fs, cluster_next);
    ae2e:	c1 01       	movw	r24, r2
    ae30:	b8 01       	movw	r22, r16
    ae32:	0e 94 4b 4f 	call	0x9e96	; 0x9e96 <fat16_clear_cluster>
    ae36:	65 c0       	rjmp	.+202    	; 0xaf02 <fat16_find_offset_for_dir_entry+0x1e0>

                    break;
    ae38:	2c 01       	movw	r4, r24
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
uint32_t fat16_cluster_offset(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    if(!fs || cluster_num < 2)
    ae3a:	f2 e0       	ldi	r31, 0x02	; 2
    ae3c:	4f 16       	cp	r4, r31
    ae3e:	51 04       	cpc	r5, r1
    ae40:	20 f4       	brcc	.+8      	; 0xae4a <fat16_find_offset_for_dir_entry+0x128>
    ae42:	ee 24       	eor	r14, r14
    ae44:	ff 24       	eor	r15, r15
    ae46:	87 01       	movw	r16, r14
    ae48:	1d c0       	rjmp	.+58     	; 0xae84 <fat16_find_offset_for_dir_entry+0x162>
        return 0;

    return fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
    ae4a:	2e ef       	ldi	r18, 0xFE	; 254
    ae4c:	3f ef       	ldi	r19, 0xFF	; 255
    ae4e:	42 0e       	add	r4, r18
    ae50:	53 1e       	adc	r5, r19
    ae52:	b2 01       	movw	r22, r4
    ae54:	80 e0       	ldi	r24, 0x00	; 0
    ae56:	90 e0       	ldi	r25, 0x00	; 0
    ae58:	a2 e0       	ldi	r26, 0x02	; 2
    ae5a:	b0 e0       	ldi	r27, 0x00	; 0
    ae5c:	4a 0e       	add	r4, r26
    ae5e:	5b 1e       	adc	r5, r27
    ae60:	f1 01       	movw	r30, r2
    ae62:	20 89       	ldd	r18, Z+16	; 0x10
    ae64:	31 89       	ldd	r19, Z+17	; 0x11
    ae66:	40 e0       	ldi	r20, 0x00	; 0
    ae68:	50 e0       	ldi	r21, 0x00	; 0
    ae6a:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    ae6e:	7b 01       	movw	r14, r22
    ae70:	8c 01       	movw	r16, r24
    ae72:	f1 01       	movw	r30, r2
    ae74:	86 89       	ldd	r24, Z+22	; 0x16
    ae76:	97 89       	ldd	r25, Z+23	; 0x17
    ae78:	a0 8d       	ldd	r26, Z+24	; 0x18
    ae7a:	b1 8d       	ldd	r27, Z+25	; 0x19
    ae7c:	e8 0e       	add	r14, r24
    ae7e:	f9 1e       	adc	r15, r25
    ae80:	0a 1f       	adc	r16, r26
    ae82:	1b 1f       	adc	r17, r27
                }
                cluster_num = cluster_next;
            }

            offset = fat16_cluster_offset(fs, cluster_num);
            offset_to = offset + fs->header.cluster_size;
    ae84:	d1 01       	movw	r26, r2
    ae86:	50 96       	adiw	r26, 0x10	; 16
    ae88:	8d 91       	ld	r24, X+
    ae8a:	9c 91       	ld	r25, X
    ae8c:	51 97       	sbiw	r26, 0x11	; 17
    ae8e:	3c 01       	movw	r6, r24
    ae90:	88 24       	eor	r8, r8
    ae92:	99 24       	eor	r9, r9
    ae94:	6e 0c       	add	r6, r14
    ae96:	7f 1c       	adc	r7, r15
    ae98:	80 1e       	adc	r8, r16
    ae9a:	91 1e       	adc	r9, r17
    ae9c:	57 01       	movw	r10, r14
    ae9e:	68 01       	movw	r12, r16
    aea0:	1a 82       	std	Y+2, r1	; 0x02
            free_dir_entries_found = 0;
        }
        
        /* read next lfn or 8.3 entry */
        uint8_t first_char;
        if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
    aea2:	d1 01       	movw	r26, r2
    aea4:	ed 91       	ld	r30, X+
    aea6:	fc 91       	ld	r31, X
    aea8:	01 90       	ld	r0, Z+
    aeaa:	f0 81       	ld	r31, Z
    aeac:	e0 2d       	mov	r30, r0
    aeae:	c8 01       	movw	r24, r16
    aeb0:	b7 01       	movw	r22, r14
    aeb2:	ae 01       	movw	r20, r28
    aeb4:	4f 5f       	subi	r20, 0xFF	; 255
    aeb6:	5f 4f       	sbci	r21, 0xFF	; 255
    aeb8:	21 e0       	ldi	r18, 0x01	; 1
    aeba:	30 e0       	ldi	r19, 0x00	; 0
    aebc:	09 95       	icall
    aebe:	88 23       	and	r24, r24
    aec0:	e9 f0       	breq	.+58     	; 0xaefc <fat16_find_offset_for_dir_entry+0x1da>
            return 0;

        /* check if we found a free directory entry */
        if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
    aec2:	89 81       	ldd	r24, Y+1	; 0x01
    aec4:	85 3e       	cpi	r24, 0xE5	; 229
    aec6:	11 f0       	breq	.+4      	; 0xaecc <fat16_find_offset_for_dir_entry+0x1aa>
    aec8:	88 23       	and	r24, r24
    aeca:	79 f4       	brne	.+30     	; 0xaeea <fat16_find_offset_for_dir_entry+0x1c8>
        {
            /* check if we have the needed number of available entries */
            ++free_dir_entries_found;
    aecc:	ba 81       	ldd	r27, Y+2	; 0x02
    aece:	bf 5f       	subi	r27, 0xFF	; 255
    aed0:	ba 83       	std	Y+2, r27	; 0x02
            if(free_dir_entries_found >= free_dir_entries_needed)
    aed2:	eb 81       	ldd	r30, Y+3	; 0x03
    aed4:	be 17       	cp	r27, r30
    aed6:	a8 f4       	brcc	.+42     	; 0xaf02 <fat16_find_offset_for_dir_entry+0x1e0>
                break;

            offset += 32;
    aed8:	80 e2       	ldi	r24, 0x20	; 32
    aeda:	90 e0       	ldi	r25, 0x00	; 0
    aedc:	a0 e0       	ldi	r26, 0x00	; 0
    aede:	b0 e0       	ldi	r27, 0x00	; 0
    aee0:	e8 0e       	add	r14, r24
    aee2:	f9 1e       	adc	r15, r25
    aee4:	0a 1f       	adc	r16, r26
    aee6:	1b 1f       	adc	r17, r27
    aee8:	68 cf       	rjmp	.-304    	; 0xadba <fat16_find_offset_for_dir_entry+0x98>
        }
        else
        {
            offset += 32;
    aeea:	80 e2       	ldi	r24, 0x20	; 32
    aeec:	90 e0       	ldi	r25, 0x00	; 0
    aeee:	a0 e0       	ldi	r26, 0x00	; 0
    aef0:	b0 e0       	ldi	r27, 0x00	; 0
    aef2:	e8 0e       	add	r14, r24
    aef4:	f9 1e       	adc	r15, r25
    aef6:	0a 1f       	adc	r16, r26
    aef8:	1b 1f       	adc	r17, r27
    aefa:	5c cf       	rjmp	.-328    	; 0xadb4 <fat16_find_offset_for_dir_entry+0x92>
    aefc:	aa 24       	eor	r10, r10
    aefe:	bb 24       	eor	r11, r11
    af00:	65 01       	movw	r12, r10
    return dir_entry_offset;

#else
    return 0;
#endif
}
    af02:	b5 01       	movw	r22, r10
    af04:	c6 01       	movw	r24, r12
    af06:	0f 90       	pop	r0
    af08:	0f 90       	pop	r0
    af0a:	0f 90       	pop	r0
    af0c:	cf 91       	pop	r28
    af0e:	df 91       	pop	r29
    af10:	1f 91       	pop	r17
    af12:	0f 91       	pop	r16
    af14:	ff 90       	pop	r15
    af16:	ef 90       	pop	r14
    af18:	df 90       	pop	r13
    af1a:	cf 90       	pop	r12
    af1c:	bf 90       	pop	r11
    af1e:	af 90       	pop	r10
    af20:	9f 90       	pop	r9
    af22:	8f 90       	pop	r8
    af24:	7f 90       	pop	r7
    af26:	6f 90       	pop	r6
    af28:	5f 90       	pop	r5
    af2a:	4f 90       	pop	r4
    af2c:	3f 90       	pop	r3
    af2e:	2f 90       	pop	r2
    af30:	08 95       	ret

0000af32 <fat16_write_dir_entry>:
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
    af32:	2f 92       	push	r2
    af34:	3f 92       	push	r3
    af36:	4f 92       	push	r4
    af38:	5f 92       	push	r5
    af3a:	6f 92       	push	r6
    af3c:	7f 92       	push	r7
    af3e:	8f 92       	push	r8
    af40:	9f 92       	push	r9
    af42:	af 92       	push	r10
    af44:	bf 92       	push	r11
    af46:	cf 92       	push	r12
    af48:	df 92       	push	r13
    af4a:	ef 92       	push	r14
    af4c:	ff 92       	push	r15
    af4e:	0f 93       	push	r16
    af50:	1f 93       	push	r17
    af52:	df 93       	push	r29
    af54:	cf 93       	push	r28
    af56:	cd b7       	in	r28, 0x3d	; 61
    af58:	de b7       	in	r29, 0x3e	; 62
    af5a:	a7 97       	sbiw	r28, 0x27	; 39
    af5c:	0f b6       	in	r0, 0x3f	; 63
    af5e:	f8 94       	cli
    af60:	de bf       	out	0x3e, r29	; 62
    af62:	0f be       	out	0x3f, r0	; 63
    af64:	cd bf       	out	0x3d, r28	; 61
    af66:	5c 01       	movw	r10, r24
    af68:	6b 01       	movw	r12, r22
#if FAT16_WRITE_SUPPORT
    if(!fs || !dir_entry)
    af6a:	00 97       	sbiw	r24, 0x00	; 0
    af6c:	09 f4       	brne	.+2      	; 0xaf70 <fat16_write_dir_entry+0x3e>
    af6e:	81 c1       	rjmp	.+770    	; 0xb272 <fat16_write_dir_entry+0x340>
    af70:	61 15       	cp	r22, r1
    af72:	71 05       	cpc	r23, r1
    af74:	09 f4       	brne	.+2      	; 0xaf78 <fat16_write_dir_entry+0x46>
    af76:	7d c1       	rjmp	.+762    	; 0xb272 <fat16_write_dir_entry+0x340>
        uint8_t day;
        uint8_t hour;
        uint8_t min;
        uint8_t sec;

        fat16_get_datetime(&year, &month, &day, &hour, &min, &sec);
    af78:	ce 01       	movw	r24, r28
    af7a:	06 96       	adiw	r24, 0x06	; 6
    af7c:	be 01       	movw	r22, r28
    af7e:	6f 5f       	subi	r22, 0xFF	; 255
    af80:	7f 4f       	sbci	r23, 0xFF	; 255
    af82:	ae 01       	movw	r20, r28
    af84:	4e 5f       	subi	r20, 0xFE	; 254
    af86:	5f 4f       	sbci	r21, 0xFF	; 255
    af88:	9e 01       	movw	r18, r28
    af8a:	2d 5f       	subi	r18, 0xFD	; 253
    af8c:	3f 4f       	sbci	r19, 0xFF	; 255
    af8e:	8e 01       	movw	r16, r28
    af90:	0c 5f       	subi	r16, 0xFC	; 252
    af92:	1f 4f       	sbci	r17, 0xFF	; 255
    af94:	e5 e0       	ldi	r30, 0x05	; 5
    af96:	ee 2e       	mov	r14, r30
    af98:	f1 2c       	mov	r15, r1
    af9a:	ec 0e       	add	r14, r28
    af9c:	fd 1e       	adc	r15, r29
    af9e:	0e 94 4e 20 	call	0x409c	; 0x409c <get_datetime>
#if FAT16_WRITE_SUPPORT
#if FAT16_DATETIME_SUPPORT
    if(!dir_entry)
        return;

    dir_entry->modification_date =
    afa2:	2e 81       	ldd	r18, Y+6	; 0x06
    afa4:	3f 81       	ldd	r19, Y+7	; 0x07
    afa6:	2c 5b       	subi	r18, 0xBC	; 188
    afa8:	37 40       	sbci	r19, 0x07	; 7
    afaa:	32 2f       	mov	r19, r18
    afac:	22 27       	eor	r18, r18
    afae:	33 0f       	add	r19, r19
    afb0:	89 81       	ldd	r24, Y+1	; 0x01
    afb2:	90 e0       	ldi	r25, 0x00	; 0
    afb4:	a5 e0       	ldi	r26, 0x05	; 5
    afb6:	88 0f       	add	r24, r24
    afb8:	99 1f       	adc	r25, r25
    afba:	aa 95       	dec	r26
    afbc:	e1 f7       	brne	.-8      	; 0xafb6 <fat16_write_dir_entry+0x84>
    afbe:	28 2b       	or	r18, r24
    afc0:	39 2b       	or	r19, r25
    afc2:	8a 81       	ldd	r24, Y+2	; 0x02
    afc4:	90 e0       	ldi	r25, 0x00	; 0
    afc6:	28 2b       	or	r18, r24
    afc8:	39 2b       	or	r19, r25
    afca:	d6 01       	movw	r26, r12
    afcc:	94 96       	adiw	r26, 0x24	; 36
    afce:	3c 93       	st	X, r19
    afd0:	2e 93       	st	-X, r18
    afd2:	93 97       	sbiw	r26, 0x23	; 35
#if FAT16_WRITE_SUPPORT
#if FAT16_DATETIME_SUPPORT
    if(!dir_entry)
        return;

    dir_entry->modification_time =
    afd4:	2c 81       	ldd	r18, Y+4	; 0x04
    afd6:	30 e0       	ldi	r19, 0x00	; 0
    afd8:	f5 e0       	ldi	r31, 0x05	; 5
    afda:	22 0f       	add	r18, r18
    afdc:	33 1f       	adc	r19, r19
    afde:	fa 95       	dec	r31
    afe0:	e1 f7       	brne	.-8      	; 0xafda <fat16_write_dir_entry+0xa8>
    afe2:	4b 81       	ldd	r20, Y+3	; 0x03
    afe4:	94 2f       	mov	r25, r20
    afe6:	99 0f       	add	r25, r25
    afe8:	99 0f       	add	r25, r25
    afea:	99 0f       	add	r25, r25
    afec:	80 e0       	ldi	r24, 0x00	; 0
    afee:	28 2b       	or	r18, r24
    aff0:	39 2b       	or	r19, r25
    aff2:	8d 81       	ldd	r24, Y+5	; 0x05
    aff4:	86 95       	lsr	r24
    aff6:	90 e0       	ldi	r25, 0x00	; 0
    aff8:	28 2b       	or	r18, r24
    affa:	39 2b       	or	r19, r25
    affc:	92 96       	adiw	r26, 0x22	; 34
    affe:	3c 93       	st	X, r19
    b000:	2e 93       	st	-X, r18
    b002:	91 97       	sbiw	r26, 0x21	; 33
        fat16_set_file_modification_date(dir_entry, year, month, day);
        fat16_set_file_modification_time(dir_entry, hour, min, sec);
    }
#endif

    device_write_t device_write = fs->partition->device_write;
    b004:	d5 01       	movw	r26, r10
    b006:	ed 91       	ld	r30, X+
    b008:	fc 91       	ld	r31, X
    b00a:	24 80       	ldd	r2, Z+4	; 0x04
    b00c:	35 80       	ldd	r3, Z+5	; 0x05
    uint32_t offset = dir_entry->entry_offset;
    b00e:	f6 01       	movw	r30, r12
    b010:	83 a4       	ldd	r8, Z+43	; 0x2b
    b012:	94 a4       	ldd	r9, Z+44	; 0x2c
    b014:	a5 a4       	ldd	r10, Z+45	; 0x2d
    b016:	b6 a4       	ldd	r11, Z+46	; 0x2e
    const char* name = dir_entry->long_name;
    b018:	0c 2d       	mov	r16, r12
    b01a:	6d 2c       	mov	r6, r13
    uint8_t name_len = strlen(name);
    b01c:	f6 01       	movw	r30, r12
    b01e:	01 90       	ld	r0, Z+
    b020:	00 20       	and	r0, r0
    b022:	e9 f7       	brne	.-6      	; 0xb01e <fat16_write_dir_entry+0xec>
    b024:	31 97       	sbiw	r30, 0x01	; 1
    b026:	1e 2f       	mov	r17, r30
    b028:	1c 19       	sub	r17, r12
    uint8_t lfn_entry_count = (name_len + 12) / 13;
    b02a:	81 2f       	mov	r24, r17
    b02c:	90 e0       	ldi	r25, 0x00	; 0
    b02e:	0c 96       	adiw	r24, 0x0c	; 12
    b030:	6d e0       	ldi	r22, 0x0D	; 13
    b032:	70 e0       	ldi	r23, 0x00	; 0
    b034:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divmodhi4>
    b038:	76 2e       	mov	r7, r22
    uint8_t buffer[32];

    /* write 8.3 entry */

    /* generate 8.3 file name */
    memset(&buffer[0], ' ', 11);
    b03a:	e8 e0       	ldi	r30, 0x08	; 8
    b03c:	ee 2e       	mov	r14, r30
    b03e:	f1 2c       	mov	r15, r1
    b040:	ec 0e       	add	r14, r28
    b042:	fd 1e       	adc	r15, r29
    b044:	c7 01       	movw	r24, r14
    b046:	60 e2       	ldi	r22, 0x20	; 32
    b048:	70 e0       	ldi	r23, 0x00	; 0
    b04a:	4b e0       	ldi	r20, 0x0B	; 11
    b04c:	50 e0       	ldi	r21, 0x00	; 0
    b04e:	0e 94 47 6e 	call	0xdc8e	; 0xdc8e <memset>
    char* name_ext = strrchr(name, '.');
    b052:	c6 01       	movw	r24, r12
    b054:	6e e2       	ldi	r22, 0x2E	; 46
    b056:	70 e0       	ldi	r23, 0x00	; 0
    b058:	0e 94 d1 6e 	call	0xdda2	; 0xdda2 <strrchr>
    b05c:	fc 01       	movw	r30, r24
    if(name_ext && *++name_ext)
    b05e:	00 97       	sbiw	r24, 0x00	; 0
    b060:	e1 f0       	breq	.+56     	; 0xb09a <fat16_write_dir_entry+0x168>
    b062:	9c 01       	movw	r18, r24
    b064:	2f 5f       	subi	r18, 0xFF	; 255
    b066:	3f 4f       	sbci	r19, 0xFF	; 255
    b068:	81 81       	ldd	r24, Z+1	; 0x01
    b06a:	88 23       	and	r24, r24
    b06c:	b1 f0       	breq	.+44     	; 0xb09a <fat16_write_dir_entry+0x168>
    {
        uint8_t name_ext_len = strlen(name_ext);
    b06e:	d9 01       	movw	r26, r18
    b070:	0d 90       	ld	r0, X+
    b072:	00 20       	and	r0, r0
    b074:	e9 f7       	brne	.-6      	; 0xb070 <fat16_write_dir_entry+0x13e>
    b076:	11 97       	sbiw	r26, 0x01	; 1
    b078:	a2 1b       	sub	r26, r18
    b07a:	b3 0b       	sbc	r27, r19
        name_len -= name_ext_len + 1;
    b07c:	8a 2f       	mov	r24, r26
    b07e:	80 95       	com	r24
    b080:	18 0f       	add	r17, r24

        if(name_ext_len > 3)
            name_ext_len = 3;
        
        memcpy(&buffer[8], name_ext, name_ext_len);
    b082:	b7 01       	movw	r22, r14
    b084:	68 5f       	subi	r22, 0xF8	; 248
    b086:	7f 4f       	sbci	r23, 0xFF	; 255
    b088:	4a 2f       	mov	r20, r26
    b08a:	a4 30       	cpi	r26, 0x04	; 4
    b08c:	08 f0       	brcs	.+2      	; 0xb090 <fat16_write_dir_entry+0x15e>
    b08e:	43 e0       	ldi	r20, 0x03	; 3
    b090:	cb 01       	movw	r24, r22
    b092:	b9 01       	movw	r22, r18
    b094:	50 e0       	ldi	r21, 0x00	; 0
    b096:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <memcpy>
    b09a:	9e 01       	movw	r18, r28
    b09c:	28 5f       	subi	r18, 0xF8	; 248
    b09e:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    
    if(name_len <= 8)
    b0a0:	19 30       	cpi	r17, 0x09	; 9
    b0a2:	a8 f4       	brcc	.+42     	; 0xb0ce <fat16_write_dir_entry+0x19c>
    {
        memcpy(buffer, name, name_len);
    b0a4:	c9 01       	movw	r24, r18
    b0a6:	60 2f       	mov	r22, r16
    b0a8:	76 2d       	mov	r23, r6
    b0aa:	41 2f       	mov	r20, r17
    b0ac:	50 e0       	ldi	r21, 0x00	; 0
    b0ae:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <memcpy>
         *
         * Theoretically it would be possible to leave
         * the 8.3 entry alone if the basename and the
         * extension have no mixed capitalization.
         */
        if(name[0] == '.' &&
    b0b2:	d6 01       	movw	r26, r12
    b0b4:	8c 91       	ld	r24, X
    b0b6:	8e 32       	cpi	r24, 0x2E	; 46
    b0b8:	41 f5       	brne	.+80     	; 0xb10a <fat16_write_dir_entry+0x1d8>
    b0ba:	11 96       	adiw	r26, 0x01	; 1
    b0bc:	8c 91       	ld	r24, X
    b0be:	11 97       	sbiw	r26, 0x01	; 1
    b0c0:	8e 32       	cpi	r24, 0x2E	; 46
    b0c2:	11 f4       	brne	.+4      	; 0xb0c8 <fat16_write_dir_entry+0x196>
    b0c4:	12 96       	adiw	r26, 0x02	; 2
    b0c6:	8c 91       	ld	r24, X
    b0c8:	88 23       	and	r24, r24
    b0ca:	f1 f0       	breq	.+60     	; 0xb108 <fat16_write_dir_entry+0x1d6>
    b0cc:	1e c0       	rjmp	.+60     	; 0xb10a <fat16_write_dir_entry+0x1d8>
          )
            lfn_entry_count = 0;
    }
    else
    {
        memcpy(buffer, name, 8);
    b0ce:	d9 01       	movw	r26, r18
    b0d0:	80 2f       	mov	r24, r16
    b0d2:	96 2d       	mov	r25, r6
    b0d4:	9c 01       	movw	r18, r24
    b0d6:	f9 01       	movw	r30, r18
    b0d8:	88 e0       	ldi	r24, 0x08	; 8
    b0da:	01 90       	ld	r0, Z+
    b0dc:	0d 92       	st	X+, r0
    b0de:	81 50       	subi	r24, 0x01	; 1
    b0e0:	e1 f7       	brne	.-8      	; 0xb0da <fat16_write_dir_entry+0x1a8>

        /* Minimize 8.3 name clashes by appending
         * the lower byte of the cluster number.
         */
        uint8_t num = dir_entry->cluster & 0xff;
    b0e2:	f6 01       	movw	r30, r12
    b0e4:	85 a1       	ldd	r24, Z+37	; 0x25
    b0e6:	98 2f       	mov	r25, r24
    b0e8:	92 95       	swap	r25
    b0ea:	9f 70       	andi	r25, 0x0F	; 15

        buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
    b0ec:	80 3a       	cpi	r24, 0xA0	; 160
    b0ee:	10 f4       	brcc	.+4      	; 0xb0f4 <fat16_write_dir_entry+0x1c2>
    b0f0:	90 5d       	subi	r25, 0xD0	; 208
    b0f2:	01 c0       	rjmp	.+2      	; 0xb0f6 <fat16_write_dir_entry+0x1c4>
    b0f4:	9f 59       	subi	r25, 0x9F	; 159
        num &= 0x0f;
    b0f6:	8f 70       	andi	r24, 0x0F	; 15
        buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
    b0f8:	8a 30       	cpi	r24, 0x0A	; 10
    b0fa:	10 f4       	brcc	.+4      	; 0xb100 <fat16_write_dir_entry+0x1ce>
    b0fc:	80 5d       	subi	r24, 0xD0	; 208
    b0fe:	01 c0       	rjmp	.+2      	; 0xb102 <fat16_write_dir_entry+0x1d0>
    b100:	8f 59       	subi	r24, 0x9F	; 159
        /* Minimize 8.3 name clashes by appending
         * the lower byte of the cluster number.
         */
        uint8_t num = dir_entry->cluster & 0xff;

        buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
    b102:	9e 87       	std	Y+14, r25	; 0x0e
        num &= 0x0f;
        buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
    b104:	8f 87       	std	Y+15, r24	; 0x0f
    b106:	01 c0       	rjmp	.+2      	; 0xb10a <fat16_write_dir_entry+0x1d8>
    b108:	77 24       	eor	r7, r7
    }
    if(buffer[0] == FAT16_DIRENTRY_DELETED)
    b10a:	88 85       	ldd	r24, Y+8	; 0x08
    b10c:	85 3e       	cpi	r24, 0xE5	; 229
    b10e:	11 f4       	brne	.+4      	; 0xb114 <fat16_write_dir_entry+0x1e2>
        buffer[0] = 0x05;
    b110:	85 e0       	ldi	r24, 0x05	; 5
    b112:	88 87       	std	Y+8, r24	; 0x08

    /* fill directory entry buffer */
    memset(&buffer[11], 0, sizeof(buffer) - 11);
    b114:	73 e1       	ldi	r23, 0x13	; 19
    b116:	e7 2e       	mov	r14, r23
    b118:	f1 2c       	mov	r15, r1
    b11a:	ec 0e       	add	r14, r28
    b11c:	fd 1e       	adc	r15, r29
    b11e:	85 e1       	ldi	r24, 0x15	; 21
    b120:	d7 01       	movw	r26, r14
    b122:	1d 92       	st	X+, r1
    b124:	8a 95       	dec	r24
    b126:	e9 f7       	brne	.-6      	; 0xb122 <fat16_write_dir_entry+0x1f0>
    buffer[0x0b] = dir_entry->attributes;
    b128:	f6 01       	movw	r30, r12
    b12a:	80 a1       	ldd	r24, Z+32	; 0x20
    b12c:	8b 8b       	std	Y+19, r24	; 0x13
#if FAT16_DATETIME_SUPPORT
    buffer[0x16] = (dir_entry->modification_time >> 0) & 0xff;
    b12e:	81 a1       	ldd	r24, Z+33	; 0x21
    b130:	92 a1       	ldd	r25, Z+34	; 0x22
    b132:	8e 8f       	std	Y+30, r24	; 0x1e
    buffer[0x17] = (dir_entry->modification_time >> 8) & 0xff;
    b134:	9f 8f       	std	Y+31, r25	; 0x1f
    buffer[0x18] = (dir_entry->modification_date >> 0) & 0xff;
    b136:	83 a1       	ldd	r24, Z+35	; 0x23
    b138:	94 a1       	ldd	r25, Z+36	; 0x24
    b13a:	88 a3       	std	Y+32, r24	; 0x20
    buffer[0x19] = (dir_entry->modification_date >> 8) & 0xff;
    b13c:	99 a3       	std	Y+33, r25	; 0x21
#endif
    buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
    b13e:	85 a1       	ldd	r24, Z+37	; 0x25
    b140:	96 a1       	ldd	r25, Z+38	; 0x26
    b142:	8a a3       	std	Y+34, r24	; 0x22
    buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
    b144:	9b a3       	std	Y+35, r25	; 0x23
    buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
    b146:	87 a1       	ldd	r24, Z+39	; 0x27
    b148:	90 a5       	ldd	r25, Z+40	; 0x28
    b14a:	a1 a5       	ldd	r26, Z+41	; 0x29
    b14c:	b2 a5       	ldd	r27, Z+42	; 0x2a
    b14e:	8c a3       	std	Y+36, r24	; 0x24
    buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
    b150:	29 2f       	mov	r18, r25
    b152:	3a 2f       	mov	r19, r26
    b154:	4b 2f       	mov	r20, r27
    b156:	55 27       	eor	r21, r21
    b158:	2d a3       	std	Y+37, r18	; 0x25
    buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
    b15a:	9d 01       	movw	r18, r26
    b15c:	44 27       	eor	r20, r20
    b15e:	55 27       	eor	r21, r21
    b160:	2e a3       	std	Y+38, r18	; 0x26
    buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
    b162:	8b 2f       	mov	r24, r27
    b164:	99 27       	eor	r25, r25
    b166:	aa 27       	eor	r26, r26
    b168:	bb 27       	eor	r27, r27
    b16a:	8f a3       	std	Y+39, r24	; 0x27

    /* write to disk */
    if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
    b16c:	67 2d       	mov	r22, r7
    b16e:	70 e0       	ldi	r23, 0x00	; 0
    b170:	80 e0       	ldi	r24, 0x00	; 0
    b172:	90 e0       	ldi	r25, 0x00	; 0
    b174:	35 e0       	ldi	r19, 0x05	; 5
    b176:	66 0f       	add	r22, r22
    b178:	77 1f       	adc	r23, r23
    b17a:	88 1f       	adc	r24, r24
    b17c:	99 1f       	adc	r25, r25
    b17e:	3a 95       	dec	r19
    b180:	d1 f7       	brne	.-12     	; 0xb176 <fat16_write_dir_entry+0x244>
    b182:	68 0d       	add	r22, r8
    b184:	79 1d       	adc	r23, r9
    b186:	8a 1d       	adc	r24, r10
    b188:	9b 1d       	adc	r25, r11
    b18a:	ae 01       	movw	r20, r28
    b18c:	48 5f       	subi	r20, 0xF8	; 248
    b18e:	5f 4f       	sbci	r21, 0xFF	; 255
    b190:	20 e2       	ldi	r18, 0x20	; 32
    b192:	30 e0       	ldi	r19, 0x00	; 0
    b194:	f1 01       	movw	r30, r2
    b196:	09 95       	icall
    b198:	88 23       	and	r24, r24
    b19a:	09 f4       	brne	.+2      	; 0xb19e <fat16_write_dir_entry+0x26c>
    b19c:	6a c0       	rjmp	.+212    	; 0xb272 <fat16_write_dir_entry+0x340>
        return 0;
    
    /* calculate checksum of 8.3 name */
    uint8_t checksum = buffer[0];
    b19e:	08 85       	ldd	r16, Y+8	; 0x08
    b1a0:	fe 01       	movw	r30, r28
    b1a2:	39 96       	adiw	r30, 0x09	; 9
    for(uint8_t i = 1; i < 11; ++i)
    b1a4:	97 01       	movw	r18, r14
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    b1a6:	80 2f       	mov	r24, r16
    b1a8:	86 95       	lsr	r24
    b1aa:	07 95       	ror	r16
    b1ac:	00 27       	eor	r16, r16
    b1ae:	07 95       	ror	r16
    b1b0:	08 2b       	or	r16, r24
    b1b2:	81 91       	ld	r24, Z+
    b1b4:	08 0f       	add	r16, r24
    if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
        return 0;
    
    /* calculate checksum of 8.3 name */
    uint8_t checksum = buffer[0];
    for(uint8_t i = 1; i < 11; ++i)
    b1b6:	e2 17       	cp	r30, r18
    b1b8:	f3 07       	cpc	r31, r19
    b1ba:	a9 f7       	brne	.-22     	; 0xb1a6 <fat16_write_dir_entry+0x274>
    b1bc:	17 2d       	mov	r17, r7
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    {
        memset(buffer, 0xff, sizeof(buffer));
    b1be:	28 e0       	ldi	r18, 0x08	; 8
    b1c0:	e2 2e       	mov	r14, r18
    b1c2:	f1 2c       	mov	r15, r1
    b1c4:	ec 0e       	add	r14, r28
    b1c6:	fd 1e       	adc	r15, r29
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
    b1c8:	9d e0       	ldi	r25, 0x0D	; 13
    b1ca:	49 2e       	mov	r4, r25
    b1cc:	51 2c       	mov	r5, r1
        buffer[0x00] = lfn_entry;
        if(lfn_entry == lfn_entry_count)
            buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;

        /* mark as lfn entry */
        buffer[0x0b] = 0x0f;
    b1ce:	8f e0       	ldi	r24, 0x0F	; 15
    b1d0:	68 2e       	mov	r6, r24
    b1d2:	4a c0       	rjmp	.+148    	; 0xb268 <fat16_write_dir_entry+0x336>
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    {
        memset(buffer, 0xff, sizeof(buffer));
    b1d4:	c7 01       	movw	r24, r14
    b1d6:	6f ef       	ldi	r22, 0xFF	; 255
    b1d8:	70 e0       	ldi	r23, 0x00	; 0
    b1da:	40 e2       	ldi	r20, 0x20	; 32
    b1dc:	50 e0       	ldi	r21, 0x00	; 0
    b1de:	0e 94 47 6e 	call	0xdc8e	; 0xdc8e <memset>
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
    b1e2:	81 2f       	mov	r24, r17
    b1e4:	90 e0       	ldi	r25, 0x00	; 0
    b1e6:	01 97       	sbiw	r24, 0x01	; 1
    b1e8:	84 9d       	mul	r24, r4
    b1ea:	d0 01       	movw	r26, r0
    b1ec:	85 9d       	mul	r24, r5
    b1ee:	b0 0d       	add	r27, r0
    b1f0:	94 9d       	mul	r25, r4
    b1f2:	b0 0d       	add	r27, r0
    b1f4:	11 24       	eor	r1, r1
    b1f6:	ac 0d       	add	r26, r12
    b1f8:	bd 1d       	adc	r27, r13
    b1fa:	91 e0       	ldi	r25, 0x01	; 1
        uint8_t i = 1;
        while(i < 0x1f)
        {
            buffer[i++] = *long_name_curr;
    b1fc:	f7 01       	movw	r30, r14
    b1fe:	e9 0f       	add	r30, r25
    b200:	f1 1d       	adc	r31, r1
    b202:	8c 91       	ld	r24, X
    b204:	80 83       	st	Z, r24
    b206:	89 2f       	mov	r24, r25
    b208:	8f 5f       	subi	r24, 0xFF	; 255
            buffer[i++] = 0;
    b20a:	f7 01       	movw	r30, r14
    b20c:	e8 0f       	add	r30, r24
    b20e:	f1 1d       	adc	r31, r1
    b210:	10 82       	st	Z, r1
    b212:	9e 5f       	subi	r25, 0xFE	; 254

            switch(i)
    b214:	9b 30       	cpi	r25, 0x0B	; 11
    b216:	19 f0       	breq	.+6      	; 0xb21e <fat16_write_dir_entry+0x2ec>
    b218:	9a 31       	cpi	r25, 0x1A	; 26
    b21a:	21 f4       	brne	.+8      	; 0xb224 <fat16_write_dir_entry+0x2f2>
    b21c:	02 c0       	rjmp	.+4      	; 0xb222 <fat16_write_dir_entry+0x2f0>
    b21e:	9e e0       	ldi	r25, 0x0E	; 14
    b220:	01 c0       	rjmp	.+2      	; 0xb224 <fat16_write_dir_entry+0x2f2>
    b222:	9c e1       	ldi	r25, 0x1C	; 28
                case 0x1a:
                    i = 0x1c;
                    break;
            }

            if(!*long_name_curr++)
    b224:	8c 91       	ld	r24, X
    b226:	88 23       	and	r24, r24
    b228:	21 f0       	breq	.+8      	; 0xb232 <fat16_write_dir_entry+0x300>
        memset(buffer, 0xff, sizeof(buffer));
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
        uint8_t i = 1;
        while(i < 0x1f)
    b22a:	9f 31       	cpi	r25, 0x1F	; 31
    b22c:	10 f4       	brcc	.+4      	; 0xb232 <fat16_write_dir_entry+0x300>
                case 0x1a:
                    i = 0x1c;
                    break;
            }

            if(!*long_name_curr++)
    b22e:	11 96       	adiw	r26, 0x01	; 1
    b230:	e5 cf       	rjmp	.-54     	; 0xb1fc <fat16_write_dir_entry+0x2ca>
                break;
        }
        
        /* set index of lfn entry */
        buffer[0x00] = lfn_entry;
    b232:	18 87       	std	Y+8, r17	; 0x08
        if(lfn_entry == lfn_entry_count)
    b234:	17 15       	cp	r17, r7
    b236:	19 f4       	brne	.+6      	; 0xb23e <fat16_write_dir_entry+0x30c>
            buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
    b238:	81 2f       	mov	r24, r17
    b23a:	80 64       	ori	r24, 0x40	; 64
    b23c:	88 87       	std	Y+8, r24	; 0x08

        /* mark as lfn entry */
        buffer[0x0b] = 0x0f;
    b23e:	6b 8a       	std	Y+19, r6	; 0x13

        /* set 8.3 checksum */
        buffer[0x0d] = checksum;
    b240:	0d 8b       	std	Y+21, r16	; 0x15

        /* clear reserved bytes */
        buffer[0x0c] = 0;
    b242:	1c 8a       	std	Y+20, r1	; 0x14
        buffer[0x1a] = 0;
    b244:	1a a2       	std	Y+34, r1	; 0x22
        buffer[0x1b] = 0;
    b246:	1b a2       	std	Y+35, r1	; 0x23

        /* write entry */
        device_write(offset, buffer, sizeof(buffer));
    b248:	c5 01       	movw	r24, r10
    b24a:	b4 01       	movw	r22, r8
    b24c:	a7 01       	movw	r20, r14
    b24e:	20 e2       	ldi	r18, 0x20	; 32
    b250:	30 e0       	ldi	r19, 0x00	; 0
    b252:	f1 01       	movw	r30, r2
    b254:	09 95       	icall
    
        offset += sizeof(buffer);
    b256:	80 e2       	ldi	r24, 0x20	; 32
    b258:	90 e0       	ldi	r25, 0x00	; 0
    b25a:	a0 e0       	ldi	r26, 0x00	; 0
    b25c:	b0 e0       	ldi	r27, 0x00	; 0
    b25e:	88 0e       	add	r8, r24
    b260:	99 1e       	adc	r9, r25
    b262:	aa 1e       	adc	r10, r26
    b264:	bb 1e       	adc	r11, r27
    uint8_t checksum = buffer[0];
    for(uint8_t i = 1; i < 11; ++i)
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    b266:	11 50       	subi	r17, 0x01	; 1
    b268:	11 23       	and	r17, r17
    b26a:	09 f0       	breq	.+2      	; 0xb26e <fat16_write_dir_entry+0x33c>
    b26c:	b3 cf       	rjmp	.-154    	; 0xb1d4 <fat16_write_dir_entry+0x2a2>
    b26e:	81 e0       	ldi	r24, 0x01	; 1
    b270:	01 c0       	rjmp	.+2      	; 0xb274 <fat16_write_dir_entry+0x342>
    b272:	80 e0       	ldi	r24, 0x00	; 0
    return 1;

#else
    return 0;
#endif
}
    b274:	a7 96       	adiw	r28, 0x27	; 39
    b276:	0f b6       	in	r0, 0x3f	; 63
    b278:	f8 94       	cli
    b27a:	de bf       	out	0x3e, r29	; 62
    b27c:	0f be       	out	0x3f, r0	; 63
    b27e:	cd bf       	out	0x3d, r28	; 61
    b280:	cf 91       	pop	r28
    b282:	df 91       	pop	r29
    b284:	1f 91       	pop	r17
    b286:	0f 91       	pop	r16
    b288:	ff 90       	pop	r15
    b28a:	ef 90       	pop	r14
    b28c:	df 90       	pop	r13
    b28e:	cf 90       	pop	r12
    b290:	bf 90       	pop	r11
    b292:	af 90       	pop	r10
    b294:	9f 90       	pop	r9
    b296:	8f 90       	pop	r8
    b298:	7f 90       	pop	r7
    b29a:	6f 90       	pop	r6
    b29c:	5f 90       	pop	r5
    b29e:	4f 90       	pop	r4
    b2a0:	3f 90       	pop	r3
    b2a2:	2f 90       	pop	r2
    b2a4:	08 95       	ret

0000b2a6 <fat16_create_dir>:
 * \param[out] dir_entry The directory entry to fill for the new directory.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_dir
 */
uint8_t fat16_create_dir(struct fat16_dir_struct* parent, const char* dir, struct fat16_dir_entry_struct* dir_entry)
{
    b2a6:	7f 92       	push	r7
    b2a8:	8f 92       	push	r8
    b2aa:	9f 92       	push	r9
    b2ac:	af 92       	push	r10
    b2ae:	bf 92       	push	r11
    b2b0:	cf 92       	push	r12
    b2b2:	df 92       	push	r13
    b2b4:	ef 92       	push	r14
    b2b6:	ff 92       	push	r15
    b2b8:	0f 93       	push	r16
    b2ba:	1f 93       	push	r17
    b2bc:	cf 93       	push	r28
    b2be:	df 93       	push	r29
    b2c0:	6c 01       	movw	r12, r24
    b2c2:	5b 01       	movw	r10, r22
    b2c4:	ea 01       	movw	r28, r20
#if FAT16_WRITE_SUPPORT
    if(!parent || !dir || !dir[0] || !dir_entry)
    b2c6:	00 97       	sbiw	r24, 0x00	; 0
    b2c8:	09 f4       	brne	.+2      	; 0xb2cc <fat16_create_dir+0x26>
    b2ca:	9d c0       	rjmp	.+314    	; 0xb406 <fat16_create_dir+0x160>
    b2cc:	61 15       	cp	r22, r1
    b2ce:	71 05       	cpc	r23, r1
    b2d0:	09 f4       	brne	.+2      	; 0xb2d4 <fat16_create_dir+0x2e>
    b2d2:	99 c0       	rjmp	.+306    	; 0xb406 <fat16_create_dir+0x160>
    b2d4:	fb 01       	movw	r30, r22
    b2d6:	80 81       	ld	r24, Z
    b2d8:	88 23       	and	r24, r24
    b2da:	09 f4       	brne	.+2      	; 0xb2de <fat16_create_dir+0x38>
    b2dc:	94 c0       	rjmp	.+296    	; 0xb406 <fat16_create_dir+0x160>
    b2de:	41 15       	cp	r20, r1
    b2e0:	51 05       	cpc	r21, r1
    b2e2:	09 f4       	brne	.+2      	; 0xb2e6 <fat16_create_dir+0x40>
    b2e4:	90 c0       	rjmp	.+288    	; 0xb406 <fat16_create_dir+0x160>
    while(1)
    {
        if(!fat16_read_dir(parent, dir_entry))
            break;

        if(strcmp(dir, dir_entry->long_name) == 0)
    b2e6:	84 2e       	mov	r8, r20
    b2e8:	7d 2e       	mov	r7, r29
        return 0;

    /* check if the file or directory already exists */
    while(1)
    {
        if(!fat16_read_dir(parent, dir_entry))
    b2ea:	c6 01       	movw	r24, r12
    b2ec:	be 01       	movw	r22, r28
    b2ee:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    b2f2:	88 23       	and	r24, r24
    b2f4:	79 f0       	breq	.+30     	; 0xb314 <fat16_create_dir+0x6e>
            break;

        if(strcmp(dir, dir_entry->long_name) == 0)
    b2f6:	c5 01       	movw	r24, r10
    b2f8:	68 2d       	mov	r22, r8
    b2fa:	77 2d       	mov	r23, r7
    b2fc:	0e 94 a4 6e 	call	0xdd48	; 0xdd48 <strcmp>
    b300:	00 97       	sbiw	r24, 0x00	; 0
    b302:	99 f7       	brne	.-26     	; 0xb2ea <fat16_create_dir+0x44>
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
        return 0;

    dd->entry_cluster = dd->dir_entry.cluster;
    b304:	f6 01       	movw	r30, r12
    b306:	87 a1       	ldd	r24, Z+39	; 0x27
    b308:	90 a5       	ldd	r25, Z+40	; 0x28
    b30a:	92 ab       	std	Z+50, r25	; 0x32
    b30c:	81 ab       	std	Z+49, r24	; 0x31
    dd->entry_offset = 0;
    b30e:	14 aa       	std	Z+52, r1	; 0x34
    b310:	13 aa       	std	Z+51, r1	; 0x33
    b312:	79 c0       	rjmp	.+242    	; 0xb406 <fat16_create_dir+0x160>
            fat16_reset_dir(parent);
            return 0;
        }
    }

    struct fat16_fs_struct* fs = parent->fs;
    b314:	f6 01       	movw	r30, r12
    b316:	e0 80       	ld	r14, Z
    b318:	f1 80       	ldd	r15, Z+1	; 0x01

    /* allocate cluster which will hold directory entries */
    uint16_t dir_cluster = fat16_append_clusters(fs, 0, 1);
    b31a:	c7 01       	movw	r24, r14
    b31c:	60 e0       	ldi	r22, 0x00	; 0
    b31e:	70 e0       	ldi	r23, 0x00	; 0
    b320:	41 e0       	ldi	r20, 0x01	; 1
    b322:	50 e0       	ldi	r21, 0x00	; 0
    b324:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
    b328:	8c 01       	movw	r16, r24
    if(!dir_cluster)
    b32a:	00 97       	sbiw	r24, 0x00	; 0
    b32c:	09 f4       	brne	.+2      	; 0xb330 <fat16_create_dir+0x8a>
    b32e:	6b c0       	rjmp	.+214    	; 0xb406 <fat16_create_dir+0x160>
        return 0;

    /* clear cluster to prevent bogus directory entries */
    fat16_clear_cluster(fs, dir_cluster);
    b330:	c7 01       	movw	r24, r14
    b332:	b8 01       	movw	r22, r16
    b334:	0e 94 4b 4f 	call	0x9e96	; 0x9e96 <fat16_clear_cluster>
    
    memset(dir_entry, 0, sizeof(*dir_entry));
    b338:	8f e2       	ldi	r24, 0x2F	; 47
    b33a:	fe 01       	movw	r30, r28
    b33c:	11 92       	st	Z+, r1
    b33e:	8a 95       	dec	r24
    b340:	e9 f7       	brne	.-6      	; 0xb33c <fat16_create_dir+0x96>
    dir_entry->attributes = FAT16_ATTRIB_DIR;
    b342:	80 e1       	ldi	r24, 0x10	; 16
    b344:	88 a3       	std	Y+32, r24	; 0x20

    /* create "." directory self reference */
    dir_entry->entry_offset = fs->header.cluster_zero_offset +
    b346:	02 50       	subi	r16, 0x02	; 2
    b348:	10 40       	sbci	r17, 0x00	; 0
    b34a:	b8 01       	movw	r22, r16
    b34c:	80 e0       	ldi	r24, 0x00	; 0
    b34e:	90 e0       	ldi	r25, 0x00	; 0
    b350:	0e 5f       	subi	r16, 0xFE	; 254
    b352:	1f 4f       	sbci	r17, 0xFF	; 255
    b354:	f7 01       	movw	r30, r14
    b356:	20 89       	ldd	r18, Z+16	; 0x10
    b358:	31 89       	ldd	r19, Z+17	; 0x11
    b35a:	40 e0       	ldi	r20, 0x00	; 0
    b35c:	50 e0       	ldi	r21, 0x00	; 0
    b35e:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    b362:	f7 01       	movw	r30, r14
    b364:	26 89       	ldd	r18, Z+22	; 0x16
    b366:	37 89       	ldd	r19, Z+23	; 0x17
    b368:	40 8d       	ldd	r20, Z+24	; 0x18
    b36a:	51 8d       	ldd	r21, Z+25	; 0x19
    b36c:	26 0f       	add	r18, r22
    b36e:	37 1f       	adc	r19, r23
    b370:	48 1f       	adc	r20, r24
    b372:	59 1f       	adc	r21, r25
    b374:	2b a7       	std	Y+43, r18	; 0x2b
    b376:	3c a7       	std	Y+44, r19	; 0x2c
    b378:	4d a7       	std	Y+45, r20	; 0x2d
    b37a:	5e a7       	std	Y+46, r21	; 0x2e
                              (uint32_t) (dir_cluster - 2) * fs->header.cluster_size;
    dir_entry->long_name[0] = '.';
    b37c:	fe e2       	ldi	r31, 0x2E	; 46
    b37e:	9f 2e       	mov	r9, r31
    b380:	98 82       	st	Y, r9
    dir_entry->cluster = dir_cluster;
    b382:	1e a3       	std	Y+38, r17	; 0x26
    b384:	0d a3       	std	Y+37, r16	; 0x25
    if(!fat16_write_dir_entry(fs, dir_entry))
    b386:	c7 01       	movw	r24, r14
    b388:	be 01       	movw	r22, r28
    b38a:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    b38e:	88 23       	and	r24, r24
    b390:	b1 f1       	breq	.+108    	; 0xb3fe <fat16_create_dir+0x158>
        fat16_free_clusters(fs, dir_cluster);
        return 0;
    }

    /* create ".." parent directory reference */
    dir_entry->entry_offset += 32;
    b392:	8b a5       	ldd	r24, Y+43	; 0x2b
    b394:	9c a5       	ldd	r25, Y+44	; 0x2c
    b396:	ad a5       	ldd	r26, Y+45	; 0x2d
    b398:	be a5       	ldd	r27, Y+46	; 0x2e
    b39a:	80 96       	adiw	r24, 0x20	; 32
    b39c:	a1 1d       	adc	r26, r1
    b39e:	b1 1d       	adc	r27, r1
    b3a0:	8b a7       	std	Y+43, r24	; 0x2b
    b3a2:	9c a7       	std	Y+44, r25	; 0x2c
    b3a4:	ad a7       	std	Y+45, r26	; 0x2d
    b3a6:	be a7       	std	Y+46, r27	; 0x2e
    dir_entry->long_name[1] = '.';
    b3a8:	99 82       	std	Y+1, r9	; 0x01
    dir_entry->cluster = parent->dir_entry.cluster;
    b3aa:	f6 01       	movw	r30, r12
    b3ac:	87 a1       	ldd	r24, Z+39	; 0x27
    b3ae:	90 a5       	ldd	r25, Z+40	; 0x28
    b3b0:	9e a3       	std	Y+38, r25	; 0x26
    b3b2:	8d a3       	std	Y+37, r24	; 0x25
    if(!fat16_write_dir_entry(fs, dir_entry))
    b3b4:	c7 01       	movw	r24, r14
    b3b6:	be 01       	movw	r22, r28
    b3b8:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    b3bc:	88 23       	and	r24, r24
    b3be:	f9 f0       	breq	.+62     	; 0xb3fe <fat16_create_dir+0x158>
        fat16_free_clusters(fs, dir_cluster);
        return 0;
    }

    /* fill directory entry */
    strncpy(dir_entry->long_name, dir, sizeof(dir_entry->long_name) - 1);
    b3c0:	88 2d       	mov	r24, r8
    b3c2:	97 2d       	mov	r25, r7
    b3c4:	b5 01       	movw	r22, r10
    b3c6:	4f e1       	ldi	r20, 0x1F	; 31
    b3c8:	50 e0       	ldi	r21, 0x00	; 0
    b3ca:	0e 94 c2 6e 	call	0xdd84	; 0xdd84 <strncpy>
    dir_entry->cluster = dir_cluster;
    b3ce:	1e a3       	std	Y+38, r17	; 0x26
    b3d0:	0d a3       	std	Y+37, r16	; 0x25

    /* find place where to store directory entry */
    if(!(dir_entry->entry_offset = fat16_find_offset_for_dir_entry(fs, parent, dir_entry)))
    b3d2:	c7 01       	movw	r24, r14
    b3d4:	b6 01       	movw	r22, r12
    b3d6:	ae 01       	movw	r20, r28
    b3d8:	0e 94 91 56 	call	0xad22	; 0xad22 <fat16_find_offset_for_dir_entry>
    b3dc:	6b a7       	std	Y+43, r22	; 0x2b
    b3de:	7c a7       	std	Y+44, r23	; 0x2c
    b3e0:	8d a7       	std	Y+45, r24	; 0x2d
    b3e2:	9e a7       	std	Y+46, r25	; 0x2e
    b3e4:	61 15       	cp	r22, r1
    b3e6:	71 05       	cpc	r23, r1
    b3e8:	81 05       	cpc	r24, r1
    b3ea:	91 05       	cpc	r25, r1
    b3ec:	41 f0       	breq	.+16     	; 0xb3fe <fat16_create_dir+0x158>
        fat16_free_clusters(fs, dir_cluster);
        return 0;
    }

    /* write directory to disk */
    if(!fat16_write_dir_entry(fs, dir_entry))
    b3ee:	c7 01       	movw	r24, r14
    b3f0:	be 01       	movw	r22, r28
    b3f2:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    b3f6:	88 23       	and	r24, r24
    b3f8:	11 f0       	breq	.+4      	; 0xb3fe <fat16_create_dir+0x158>
    b3fa:	81 e0       	ldi	r24, 0x01	; 1
    b3fc:	05 c0       	rjmp	.+10     	; 0xb408 <fat16_create_dir+0x162>
    {
        fat16_free_clusters(fs, dir_cluster);
    b3fe:	c7 01       	movw	r24, r14
    b400:	b8 01       	movw	r22, r16
    b402:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <fat16_free_clusters>
        return 0;
    b406:	80 e0       	ldi	r24, 0x00	; 0
    return 1;
    
#else
    return 0;
#endif
}
    b408:	df 91       	pop	r29
    b40a:	cf 91       	pop	r28
    b40c:	1f 91       	pop	r17
    b40e:	0f 91       	pop	r16
    b410:	ff 90       	pop	r15
    b412:	ef 90       	pop	r14
    b414:	df 90       	pop	r13
    b416:	cf 90       	pop	r12
    b418:	bf 90       	pop	r11
    b41a:	af 90       	pop	r10
    b41c:	9f 90       	pop	r9
    b41e:	8f 90       	pop	r8
    b420:	7f 90       	pop	r7
    b422:	08 95       	ret

0000b424 <fat16_create_file>:
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    b424:	af 92       	push	r10
    b426:	bf 92       	push	r11
    b428:	cf 92       	push	r12
    b42a:	df 92       	push	r13
    b42c:	ef 92       	push	r14
    b42e:	ff 92       	push	r15
    b430:	0f 93       	push	r16
    b432:	1f 93       	push	r17
    b434:	cf 93       	push	r28
    b436:	df 93       	push	r29
    b438:	8c 01       	movw	r16, r24
    b43a:	7b 01       	movw	r14, r22
    b43c:	ea 01       	movw	r28, r20
#if FAT16_WRITE_SUPPORT
    if(!parent || !file || !file[0] || !dir_entry)
    b43e:	00 97       	sbiw	r24, 0x00	; 0
    b440:	09 f4       	brne	.+2      	; 0xb444 <fat16_create_file+0x20>
    b442:	48 c0       	rjmp	.+144    	; 0xb4d4 <fat16_create_file+0xb0>
    b444:	61 15       	cp	r22, r1
    b446:	71 05       	cpc	r23, r1
    b448:	09 f4       	brne	.+2      	; 0xb44c <fat16_create_file+0x28>
    b44a:	44 c0       	rjmp	.+136    	; 0xb4d4 <fat16_create_file+0xb0>
    b44c:	fb 01       	movw	r30, r22
    b44e:	80 81       	ld	r24, Z
    b450:	88 23       	and	r24, r24
    b452:	09 f4       	brne	.+2      	; 0xb456 <fat16_create_file+0x32>
    b454:	3f c0       	rjmp	.+126    	; 0xb4d4 <fat16_create_file+0xb0>
    b456:	41 15       	cp	r20, r1
    b458:	51 05       	cpc	r21, r1
    b45a:	e1 f1       	breq	.+120    	; 0xb4d4 <fat16_create_file+0xb0>
    while(1)
    {
        if(!fat16_read_dir(parent, dir_entry))
            break;

        if(strcmp(file, dir_entry->long_name) == 0)
    b45c:	b4 2e       	mov	r11, r20
    b45e:	ad 2e       	mov	r10, r29
        return 0;

    /* check if the file already exists */
    while(1)
    {
        if(!fat16_read_dir(parent, dir_entry))
    b460:	c8 01       	movw	r24, r16
    b462:	be 01       	movw	r22, r28
    b464:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    b468:	88 23       	and	r24, r24
    b46a:	79 f0       	breq	.+30     	; 0xb48a <fat16_create_file+0x66>
            break;

        if(strcmp(file, dir_entry->long_name) == 0)
    b46c:	c7 01       	movw	r24, r14
    b46e:	6b 2d       	mov	r22, r11
    b470:	7a 2d       	mov	r23, r10
    b472:	0e 94 a4 6e 	call	0xdd48	; 0xdd48 <strcmp>
    b476:	00 97       	sbiw	r24, 0x00	; 0
    b478:	99 f7       	brne	.-26     	; 0xb460 <fat16_create_file+0x3c>
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
        return 0;

    dd->entry_cluster = dd->dir_entry.cluster;
    b47a:	f8 01       	movw	r30, r16
    b47c:	87 a1       	ldd	r24, Z+39	; 0x27
    b47e:	90 a5       	ldd	r25, Z+40	; 0x28
    b480:	92 ab       	std	Z+50, r25	; 0x32
    b482:	81 ab       	std	Z+49, r24	; 0x31
    dd->entry_offset = 0;
    b484:	14 aa       	std	Z+52, r1	; 0x34
    b486:	13 aa       	std	Z+51, r1	; 0x33
    b488:	25 c0       	rjmp	.+74     	; 0xb4d4 <fat16_create_file+0xb0>
            fat16_reset_dir(parent);
            return 0;
        }
    }

    struct fat16_fs_struct* fs = parent->fs;
    b48a:	f8 01       	movw	r30, r16
    b48c:	c0 80       	ld	r12, Z
    b48e:	d1 80       	ldd	r13, Z+1	; 0x01

    /* prepare directory entry with values already known */
    memset(dir_entry, 0, sizeof(*dir_entry));
    b490:	8f e2       	ldi	r24, 0x2F	; 47
    b492:	fe 01       	movw	r30, r28
    b494:	11 92       	st	Z+, r1
    b496:	8a 95       	dec	r24
    b498:	e9 f7       	brne	.-6      	; 0xb494 <fat16_create_file+0x70>
    strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    b49a:	8b 2d       	mov	r24, r11
    b49c:	9a 2d       	mov	r25, r10
    b49e:	b7 01       	movw	r22, r14
    b4a0:	4f e1       	ldi	r20, 0x1F	; 31
    b4a2:	50 e0       	ldi	r21, 0x00	; 0
    b4a4:	0e 94 c2 6e 	call	0xdd84	; 0xdd84 <strncpy>

    /* find place where to store directory entry */
    if(!(dir_entry->entry_offset = fat16_find_offset_for_dir_entry(fs, parent, dir_entry)))
    b4a8:	c6 01       	movw	r24, r12
    b4aa:	b8 01       	movw	r22, r16
    b4ac:	ae 01       	movw	r20, r28
    b4ae:	0e 94 91 56 	call	0xad22	; 0xad22 <fat16_find_offset_for_dir_entry>
    b4b2:	6b a7       	std	Y+43, r22	; 0x2b
    b4b4:	7c a7       	std	Y+44, r23	; 0x2c
    b4b6:	8d a7       	std	Y+45, r24	; 0x2d
    b4b8:	9e a7       	std	Y+46, r25	; 0x2e
    b4ba:	61 15       	cp	r22, r1
    b4bc:	71 05       	cpc	r23, r1
    b4be:	81 05       	cpc	r24, r1
    b4c0:	91 05       	cpc	r25, r1
    b4c2:	41 f0       	breq	.+16     	; 0xb4d4 <fat16_create_file+0xb0>
        return 0;
    
    /* write directory entry to disk */
    if(!fat16_write_dir_entry(fs, dir_entry))
    b4c4:	c6 01       	movw	r24, r12
    b4c6:	be 01       	movw	r22, r28
    b4c8:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    b4cc:	88 23       	and	r24, r24
    b4ce:	19 f0       	breq	.+6      	; 0xb4d6 <fat16_create_file+0xb2>
    b4d0:	81 e0       	ldi	r24, 0x01	; 1
    b4d2:	01 c0       	rjmp	.+2      	; 0xb4d6 <fat16_create_file+0xb2>
    b4d4:	80 e0       	ldi	r24, 0x00	; 0
    return 1;
    
#else
    return 0;
#endif
}
    b4d6:	df 91       	pop	r29
    b4d8:	cf 91       	pop	r28
    b4da:	1f 91       	pop	r17
    b4dc:	0f 91       	pop	r16
    b4de:	ff 90       	pop	r15
    b4e0:	ef 90       	pop	r14
    b4e2:	df 90       	pop	r13
    b4e4:	cf 90       	pop	r12
    b4e6:	bf 90       	pop	r11
    b4e8:	af 90       	pop	r10
    b4ea:	08 95       	ret

0000b4ec <fat16_resize_file>:
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    b4ec:	2f 92       	push	r2
    b4ee:	3f 92       	push	r3
    b4f0:	4f 92       	push	r4
    b4f2:	5f 92       	push	r5
    b4f4:	6f 92       	push	r6
    b4f6:	7f 92       	push	r7
    b4f8:	8f 92       	push	r8
    b4fa:	9f 92       	push	r9
    b4fc:	af 92       	push	r10
    b4fe:	bf 92       	push	r11
    b500:	cf 92       	push	r12
    b502:	df 92       	push	r13
    b504:	ef 92       	push	r14
    b506:	ff 92       	push	r15
    b508:	0f 93       	push	r16
    b50a:	1f 93       	push	r17
    b50c:	df 93       	push	r29
    b50e:	cf 93       	push	r28
    b510:	cd b7       	in	r28, 0x3d	; 61
    b512:	de b7       	in	r29, 0x3e	; 62
    b514:	2c 97       	sbiw	r28, 0x0c	; 12
    b516:	0f b6       	in	r0, 0x3f	; 63
    b518:	f8 94       	cli
    b51a:	de bf       	out	0x3e, r29	; 62
    b51c:	0f be       	out	0x3f, r0	; 63
    b51e:	cd bf       	out	0x3d, r28	; 61
    b520:	1c 01       	movw	r2, r24
    b522:	2a 01       	movw	r4, r20
    b524:	3b 01       	movw	r6, r22
#if FAT16_WRITE_SUPPORT
    if(!fd)
    b526:	00 97       	sbiw	r24, 0x00	; 0
    b528:	09 f4       	brne	.+2      	; 0xb52c <fat16_resize_file+0x40>
    b52a:	fa c0       	rjmp	.+500    	; 0xb720 <fat16_resize_file+0x234>
        return 0;

    uint16_t cluster_num = fd->dir_entry.cluster;
    b52c:	dc 01       	movw	r26, r24
    b52e:	97 96       	adiw	r26, 0x27	; 39
    b530:	8d 90       	ld	r8, X+
    b532:	9c 90       	ld	r9, X
    b534:	98 97       	sbiw	r26, 0x28	; 40
    uint16_t cluster_size = fd->fs->header.cluster_size;
    b536:	ed 91       	ld	r30, X+
    b538:	fc 91       	ld	r31, X
    b53a:	80 89       	ldd	r24, Z+16	; 0x10
    b53c:	91 89       	ldd	r25, Z+17	; 0x11
    uint32_t size_new = size;

    do
    {
        if(cluster_num == 0 && size_new == 0)
    b53e:	81 14       	cp	r8, r1
    b540:	91 04       	cpc	r9, r1
    b542:	99 f0       	breq	.+38     	; 0xb56a <fat16_resize_file+0x7e>
    b544:	4b 82       	std	Y+3, r4	; 0x03
    b546:	5c 82       	std	Y+4, r5	; 0x04
    b548:	6d 82       	std	Y+5, r6	; 0x05
    b54a:	7e 82       	std	Y+6, r7	; 0x06
            /* the file stays empty */
            break;

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
    b54c:	5c 01       	movw	r10, r24
    b54e:	cc 24       	eor	r12, r12
    b550:	dd 24       	eor	r13, r13
                cluster_num = cluster_num_next;
                size_new -= cluster_size;
            }
            else
            {
                break;
    b552:	ee 24       	eor	r14, r14
    b554:	ff 24       	eor	r15, r15
    b556:	87 01       	movw	r16, r14
    b558:	ea 18       	sub	r14, r10
    b55a:	fb 08       	sbc	r15, r11
    b55c:	0c 09       	sbc	r16, r12
    b55e:	1d 09       	sbc	r17, r13
    b560:	e9 86       	std	Y+9, r14	; 0x09
    b562:	fa 86       	std	Y+10, r15	; 0x0a
    b564:	0b 87       	std	Y+11, r16	; 0x0b
    b566:	1c 87       	std	Y+12, r17	; 0x0c
    b568:	20 c0       	rjmp	.+64     	; 0xb5aa <fat16_resize_file+0xbe>
    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint32_t size_new = size;

    do
    {
        if(cluster_num == 0 && size_new == 0)
    b56a:	41 15       	cp	r20, r1
    b56c:	51 05       	cpc	r21, r1
    b56e:	61 05       	cpc	r22, r1
    b570:	71 05       	cpc	r23, r1
    b572:	09 f4       	brne	.+2      	; 0xb576 <fat16_resize_file+0x8a>
    b574:	be c0       	rjmp	.+380    	; 0xb6f2 <fat16_resize_file+0x206>
    b576:	e6 cf       	rjmp	.-52     	; 0xb544 <fat16_resize_file+0x58>

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
        {
            /* get next cluster of file */
            uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
    b578:	d1 01       	movw	r26, r2
    b57a:	8d 91       	ld	r24, X+
    b57c:	9c 91       	ld	r25, X
    b57e:	b4 01       	movw	r22, r8
    b580:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
            if(cluster_num_next)
    b584:	00 97       	sbiw	r24, 0x00	; 0
    b586:	e9 f0       	breq	.+58     	; 0xb5c2 <fat16_resize_file+0xd6>
                cluster_num = cluster_num_next;
                size_new -= cluster_size;
            }
            else
            {
                break;
    b588:	eb 80       	ldd	r14, Y+3	; 0x03
    b58a:	fc 80       	ldd	r15, Y+4	; 0x04
    b58c:	0d 81       	ldd	r16, Y+5	; 0x05
    b58e:	1e 81       	ldd	r17, Y+6	; 0x06
    b590:	29 85       	ldd	r18, Y+9	; 0x09
    b592:	3a 85       	ldd	r19, Y+10	; 0x0a
    b594:	4b 85       	ldd	r20, Y+11	; 0x0b
    b596:	5c 85       	ldd	r21, Y+12	; 0x0c
    b598:	e2 0e       	add	r14, r18
    b59a:	f3 1e       	adc	r15, r19
    b59c:	04 1f       	adc	r16, r20
    b59e:	15 1f       	adc	r17, r21
    b5a0:	eb 82       	std	Y+3, r14	; 0x03
    b5a2:	fc 82       	std	Y+4, r15	; 0x04
    b5a4:	0d 83       	std	Y+5, r16	; 0x05
    b5a6:	1e 83       	std	Y+6, r17	; 0x06
    b5a8:	4c 01       	movw	r8, r24
        if(cluster_num == 0 && size_new == 0)
            /* the file stays empty */
            break;

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
    b5aa:	86 01       	movw	r16, r12
    b5ac:	75 01       	movw	r14, r10
    b5ae:	8b 81       	ldd	r24, Y+3	; 0x03
    b5b0:	9c 81       	ldd	r25, Y+4	; 0x04
    b5b2:	ad 81       	ldd	r26, Y+5	; 0x05
    b5b4:	be 81       	ldd	r27, Y+6	; 0x06
    b5b6:	a8 16       	cp	r10, r24
    b5b8:	b9 06       	cpc	r11, r25
    b5ba:	ca 06       	cpc	r12, r26
    b5bc:	db 06       	cpc	r13, r27
    b5be:	e0 f2       	brcs	.-72     	; 0xb578 <fat16_resize_file+0x8c>
    b5c0:	c9 c0       	rjmp	.+402    	; 0xb754 <fat16_resize_file+0x268>
    b5c2:	ef 82       	std	Y+7, r14	; 0x07
    b5c4:	f8 86       	std	Y+8, r15	; 0x08
    b5c6:	58 01       	movw	r10, r16
    b5c8:	c7 01       	movw	r24, r14
    b5ca:	d8 01       	movw	r26, r16
    b5cc:	7c 01       	movw	r14, r24
    b5ce:	8d 01       	movw	r16, r26
        if(size_new > cluster_size || cluster_num == 0)
        {
            /* Allocate new cluster chain and append
             * it to the existing one, if available.
             */
            uint16_t cluster_count = size_new / cluster_size;
    b5d0:	6b 81       	ldd	r22, Y+3	; 0x03
    b5d2:	7c 81       	ldd	r23, Y+4	; 0x04
    b5d4:	8d 81       	ldd	r24, Y+5	; 0x05
    b5d6:	9e 81       	ldd	r25, Y+6	; 0x06
    b5d8:	a8 01       	movw	r20, r16
    b5da:	97 01       	movw	r18, r14
    b5dc:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    b5e0:	69 01       	movw	r12, r18
            if((uint32_t) cluster_count * cluster_size < size_new)
    b5e2:	b9 01       	movw	r22, r18
    b5e4:	80 e0       	ldi	r24, 0x00	; 0
    b5e6:	90 e0       	ldi	r25, 0x00	; 0
    b5e8:	2f 81       	ldd	r18, Y+7	; 0x07
    b5ea:	38 85       	ldd	r19, Y+8	; 0x08
    b5ec:	a5 01       	movw	r20, r10
    b5ee:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    b5f2:	2b 81       	ldd	r18, Y+3	; 0x03
    b5f4:	3c 81       	ldd	r19, Y+4	; 0x04
    b5f6:	4d 81       	ldd	r20, Y+5	; 0x05
    b5f8:	5e 81       	ldd	r21, Y+6	; 0x06
    b5fa:	62 17       	cp	r22, r18
    b5fc:	73 07       	cpc	r23, r19
    b5fe:	84 07       	cpc	r24, r20
    b600:	95 07       	cpc	r25, r21
    b602:	18 f4       	brcc	.+6      	; 0xb60a <fat16_resize_file+0x11e>
                ++cluster_count;
    b604:	08 94       	sec
    b606:	c1 1c       	adc	r12, r1
    b608:	d1 1c       	adc	r13, r1
            uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
    b60a:	d1 01       	movw	r26, r2
    b60c:	8d 91       	ld	r24, X+
    b60e:	9c 91       	ld	r25, X
    b610:	b4 01       	movw	r22, r8
    b612:	a6 01       	movw	r20, r12
    b614:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
            if(!cluster_new_chain)
    b618:	00 97       	sbiw	r24, 0x00	; 0
    b61a:	09 f4       	brne	.+2      	; 0xb61e <fat16_resize_file+0x132>
    b61c:	81 c0       	rjmp	.+258    	; 0xb720 <fat16_resize_file+0x234>
                return 0;

            if(!cluster_num)
    b61e:	81 14       	cp	r8, r1
    b620:	91 04       	cpc	r9, r1
    b622:	21 f4       	brne	.+8      	; 0xb62c <fat16_resize_file+0x140>
            {
                cluster_num = cluster_new_chain;
                fd->dir_entry.cluster = cluster_num;
    b624:	f1 01       	movw	r30, r2
    b626:	90 a7       	std	Z+40, r25	; 0x28
    b628:	87 a3       	std	Z+39, r24	; 0x27
    b62a:	4c 01       	movw	r8, r24
            }
        }

        /* write new directory entry */
        fd->dir_entry.file_size = size;
    b62c:	d1 01       	movw	r26, r2
    b62e:	99 96       	adiw	r26, 0x29	; 41
    b630:	4d 92       	st	X+, r4
    b632:	5d 92       	st	X+, r5
    b634:	6d 92       	st	X+, r6
    b636:	7c 92       	st	X, r7
    b638:	9c 97       	sbiw	r26, 0x2c	; 44
        if(size == 0)
    b63a:	41 14       	cp	r4, r1
    b63c:	51 04       	cpc	r5, r1
    b63e:	61 04       	cpc	r6, r1
    b640:	71 04       	cpc	r7, r1
    b642:	21 f4       	brne	.+8      	; 0xb64c <fat16_resize_file+0x160>
            fd->dir_entry.cluster = 0;
    b644:	98 96       	adiw	r26, 0x28	; 40
    b646:	1c 92       	st	X, r1
    b648:	1e 92       	st	-X, r1
    b64a:	97 97       	sbiw	r26, 0x27	; 39
        if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
    b64c:	f1 01       	movw	r30, r2
    b64e:	81 91       	ld	r24, Z+
    b650:	91 91       	ld	r25, Z+
    b652:	bf 01       	movw	r22, r30
    b654:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    b658:	88 23       	and	r24, r24
    b65a:	09 f4       	brne	.+2      	; 0xb65e <fat16_resize_file+0x172>
    b65c:	61 c0       	rjmp	.+194    	; 0xb720 <fat16_resize_file+0x234>
            return 0;

        if(size == 0)
    b65e:	41 14       	cp	r4, r1
    b660:	51 04       	cpc	r5, r1
    b662:	61 04       	cpc	r6, r1
    b664:	71 04       	cpc	r7, r1
    b666:	29 f4       	brne	.+10     	; 0xb672 <fat16_resize_file+0x186>
        {
            /* free all clusters of file */
            fat16_free_clusters(fd->fs, cluster_num);
    b668:	f1 01       	movw	r30, r2
    b66a:	80 81       	ld	r24, Z
    b66c:	91 81       	ldd	r25, Z+1	; 0x01
    b66e:	b4 01       	movw	r22, r8
    b670:	3e c0       	rjmp	.+124    	; 0xb6ee <fat16_resize_file+0x202>
        }
        else if(size_new <= cluster_size)
    b672:	2b 81       	ldd	r18, Y+3	; 0x03
    b674:	3c 81       	ldd	r19, Y+4	; 0x04
    b676:	4d 81       	ldd	r20, Y+5	; 0x05
    b678:	5e 81       	ldd	r21, Y+6	; 0x06
    b67a:	e2 16       	cp	r14, r18
    b67c:	f3 06       	cpc	r15, r19
    b67e:	04 07       	cpc	r16, r20
    b680:	15 07       	cpc	r17, r21
    b682:	b8 f1       	brcs	.+110    	; 0xb6f2 <fat16_resize_file+0x206>
        {
            /* free all clusters no longer needed */
            fat16_terminate_clusters(fd->fs, cluster_num);
    b684:	d1 01       	movw	r26, r2
    b686:	0d 91       	ld	r16, X+
    b688:	1c 91       	ld	r17, X
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
#if FAT16_WRITE_SUPPORT
    if(!fs || cluster_num < 2)
    b68a:	01 15       	cp	r16, r1
    b68c:	11 05       	cpc	r17, r1
    b68e:	89 f1       	breq	.+98     	; 0xb6f2 <fat16_resize_file+0x206>
    b690:	b2 e0       	ldi	r27, 0x02	; 2
    b692:	8b 16       	cp	r8, r27
    b694:	91 04       	cpc	r9, r1
    b696:	68 f1       	brcs	.+90     	; 0xb6f2 <fat16_resize_file+0x206>
        return 0;

    /* fetch next cluster before overwriting the cluster entry */
    uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    b698:	c8 01       	movw	r24, r16
    b69a:	b4 01       	movw	r22, r8
    b69c:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
    b6a0:	7c 01       	movw	r14, r24

    /* mark cluster as the last one */
    uint8_t buffer[2];
    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
    b6a2:	8f ef       	ldi	r24, 0xFF	; 255
    b6a4:	89 83       	std	Y+1, r24	; 0x01
    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
    b6a6:	8a 83       	std	Y+2, r24	; 0x02
    if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
    b6a8:	d8 01       	movw	r26, r16
    b6aa:	ed 91       	ld	r30, X+
    b6ac:	fc 91       	ld	r31, X
    b6ae:	11 97       	sbiw	r26, 0x01	; 1
    b6b0:	88 0c       	add	r8, r8
    b6b2:	99 1c       	adc	r9, r9
    b6b4:	b4 01       	movw	r22, r8
    b6b6:	80 e0       	ldi	r24, 0x00	; 0
    b6b8:	90 e0       	ldi	r25, 0x00	; 0
    b6ba:	16 96       	adiw	r26, 0x06	; 6
    b6bc:	2d 91       	ld	r18, X+
    b6be:	3d 91       	ld	r19, X+
    b6c0:	4d 91       	ld	r20, X+
    b6c2:	5c 91       	ld	r21, X
    b6c4:	19 97       	sbiw	r26, 0x09	; 9
    b6c6:	62 0f       	add	r22, r18
    b6c8:	73 1f       	adc	r23, r19
    b6ca:	84 1f       	adc	r24, r20
    b6cc:	95 1f       	adc	r25, r21
    b6ce:	04 80       	ldd	r0, Z+4	; 0x04
    b6d0:	f5 81       	ldd	r31, Z+5	; 0x05
    b6d2:	e0 2d       	mov	r30, r0
    b6d4:	ae 01       	movw	r20, r28
    b6d6:	4f 5f       	subi	r20, 0xFF	; 255
    b6d8:	5f 4f       	sbci	r21, 0xFF	; 255
    b6da:	22 e0       	ldi	r18, 0x02	; 2
    b6dc:	30 e0       	ldi	r19, 0x00	; 0
    b6de:	09 95       	icall
    b6e0:	88 23       	and	r24, r24
    b6e2:	39 f0       	breq	.+14     	; 0xb6f2 <fat16_resize_file+0x206>
        return 0;

    /* free remaining clusters */
    if(cluster_num_next)
    b6e4:	e1 14       	cp	r14, r1
    b6e6:	f1 04       	cpc	r15, r1
    b6e8:	21 f0       	breq	.+8      	; 0xb6f2 <fat16_resize_file+0x206>
        return fat16_free_clusters(fs, cluster_num_next);
    b6ea:	c8 01       	movw	r24, r16
    b6ec:	b7 01       	movw	r22, r14
    b6ee:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <fat16_free_clusters>
        }

    } while(0);

    /* correct file position */
    if(size < fd->pos)
    b6f2:	f1 01       	movw	r30, r2
    b6f4:	81 a9       	ldd	r24, Z+49	; 0x31
    b6f6:	92 a9       	ldd	r25, Z+50	; 0x32
    b6f8:	a3 a9       	ldd	r26, Z+51	; 0x33
    b6fa:	b4 a9       	ldd	r27, Z+52	; 0x34
    b6fc:	48 16       	cp	r4, r24
    b6fe:	59 06       	cpc	r5, r25
    b700:	6a 06       	cpc	r6, r26
    b702:	7b 06       	cpc	r7, r27
    b704:	58 f4       	brcc	.+22     	; 0xb71c <fat16_resize_file+0x230>
    {
        fd->pos = size;
    b706:	d1 01       	movw	r26, r2
    b708:	d1 96       	adiw	r26, 0x31	; 49
    b70a:	4d 92       	st	X+, r4
    b70c:	5d 92       	st	X+, r5
    b70e:	6d 92       	st	X+, r6
    b710:	7c 92       	st	X, r7
    b712:	d4 97       	sbiw	r26, 0x34	; 52
        fd->pos_cluster = 0;
    b714:	d6 96       	adiw	r26, 0x36	; 54
    b716:	1c 92       	st	X, r1
    b718:	1e 92       	st	-X, r1
    b71a:	d5 97       	sbiw	r26, 0x35	; 53
    b71c:	81 e0       	ldi	r24, 0x01	; 1
    b71e:	01 c0       	rjmp	.+2      	; 0xb722 <fat16_resize_file+0x236>
    b720:	80 e0       	ldi	r24, 0x00	; 0

    return 1;
#else
    return 0;
#endif
}
    b722:	2c 96       	adiw	r28, 0x0c	; 12
    b724:	0f b6       	in	r0, 0x3f	; 63
    b726:	f8 94       	cli
    b728:	de bf       	out	0x3e, r29	; 62
    b72a:	0f be       	out	0x3f, r0	; 63
    b72c:	cd bf       	out	0x3d, r28	; 61
    b72e:	cf 91       	pop	r28
    b730:	df 91       	pop	r29
    b732:	1f 91       	pop	r17
    b734:	0f 91       	pop	r16
    b736:	ff 90       	pop	r15
    b738:	ef 90       	pop	r14
    b73a:	df 90       	pop	r13
    b73c:	cf 90       	pop	r12
    b73e:	bf 90       	pop	r11
    b740:	af 90       	pop	r10
    b742:	9f 90       	pop	r9
    b744:	8f 90       	pop	r8
    b746:	7f 90       	pop	r7
    b748:	6f 90       	pop	r6
    b74a:	5f 90       	pop	r5
    b74c:	4f 90       	pop	r4
    b74e:	3f 90       	pop	r3
    b750:	2f 90       	pop	r2
    b752:	08 95       	ret

    /* correct file position */
    if(size < fd->pos)
    {
        fd->pos = size;
        fd->pos_cluster = 0;
    b754:	af 82       	std	Y+7, r10	; 0x07
    b756:	f8 86       	std	Y+8, r15	; 0x08
    b758:	58 01       	movw	r10, r16
            {
                break;
            }
        }

        if(size_new > cluster_size || cluster_num == 0)
    b75a:	81 14       	cp	r8, r1
    b75c:	91 04       	cpc	r9, r1
    b75e:	09 f4       	brne	.+2      	; 0xb762 <fat16_resize_file+0x276>
    b760:	37 cf       	rjmp	.-402    	; 0xb5d0 <fat16_resize_file+0xe4>
    b762:	64 cf       	rjmp	.-312    	; 0xb62c <fat16_resize_file+0x140>

0000b764 <fat16_seek_file>:
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    b764:	cf 92       	push	r12
    b766:	df 92       	push	r13
    b768:	ef 92       	push	r14
    b76a:	ff 92       	push	r15
    b76c:	0f 93       	push	r16
    b76e:	1f 93       	push	r17
    b770:	cf 93       	push	r28
    b772:	df 93       	push	r29
    b774:	ec 01       	movw	r28, r24
    b776:	6b 01       	movw	r12, r22
    if(!fd || !offset)
    b778:	00 97       	sbiw	r24, 0x00	; 0
    b77a:	09 f4       	brne	.+2      	; 0xb77e <fat16_seek_file+0x1a>
    b77c:	45 c0       	rjmp	.+138    	; 0xb808 <fat16_seek_file+0xa4>
    b77e:	61 15       	cp	r22, r1
    b780:	71 05       	cpc	r23, r1
    b782:	09 f4       	brne	.+2      	; 0xb786 <fat16_seek_file+0x22>
    b784:	41 c0       	rjmp	.+130    	; 0xb808 <fat16_seek_file+0xa4>
        return 0;

    uint32_t new_pos = fd->pos;
    b786:	89 a9       	ldd	r24, Y+49	; 0x31
    b788:	9a a9       	ldd	r25, Y+50	; 0x32
    b78a:	ab a9       	ldd	r26, Y+51	; 0x33
    b78c:	bc a9       	ldd	r27, Y+52	; 0x34
    switch(whence)
    b78e:	41 30       	cpi	r20, 0x01	; 1
    b790:	59 f0       	breq	.+22     	; 0xb7a8 <fat16_seek_file+0x44>
    b792:	41 30       	cpi	r20, 0x01	; 1
    b794:	18 f0       	brcs	.+6      	; 0xb79c <fat16_seek_file+0x38>
    b796:	42 30       	cpi	r20, 0x02	; 2
    b798:	b9 f5       	brne	.+110    	; 0xb808 <fat16_seek_file+0xa4>
    b79a:	0c c0       	rjmp	.+24     	; 0xb7b4 <fat16_seek_file+0x50>
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
    b79c:	fb 01       	movw	r30, r22
    b79e:	e0 80       	ld	r14, Z
    b7a0:	f1 80       	ldd	r15, Z+1	; 0x01
    b7a2:	02 81       	ldd	r16, Z+2	; 0x02
    b7a4:	13 81       	ldd	r17, Z+3	; 0x03
    b7a6:	13 c0       	rjmp	.+38     	; 0xb7ce <fat16_seek_file+0x6a>
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
    b7a8:	fb 01       	movw	r30, r22
    b7aa:	e0 80       	ld	r14, Z
    b7ac:	f1 80       	ldd	r15, Z+1	; 0x01
    b7ae:	02 81       	ldd	r16, Z+2	; 0x02
    b7b0:	13 81       	ldd	r17, Z+3	; 0x03
    b7b2:	09 c0       	rjmp	.+18     	; 0xb7c6 <fat16_seek_file+0x62>
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
    b7b4:	fb 01       	movw	r30, r22
    b7b6:	e0 80       	ld	r14, Z
    b7b8:	f1 80       	ldd	r15, Z+1	; 0x01
    b7ba:	02 81       	ldd	r16, Z+2	; 0x02
    b7bc:	13 81       	ldd	r17, Z+3	; 0x03
    b7be:	89 a5       	ldd	r24, Y+41	; 0x29
    b7c0:	9a a5       	ldd	r25, Y+42	; 0x2a
    b7c2:	ab a5       	ldd	r26, Y+43	; 0x2b
    b7c4:	bc a5       	ldd	r27, Y+44	; 0x2c
    b7c6:	e8 0e       	add	r14, r24
    b7c8:	f9 1e       	adc	r15, r25
    b7ca:	0a 1f       	adc	r16, r26
    b7cc:	1b 1f       	adc	r17, r27
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
    b7ce:	89 a5       	ldd	r24, Y+41	; 0x29
    b7d0:	9a a5       	ldd	r25, Y+42	; 0x2a
    b7d2:	ab a5       	ldd	r26, Y+43	; 0x2b
    b7d4:	bc a5       	ldd	r27, Y+44	; 0x2c
    b7d6:	8e 15       	cp	r24, r14
    b7d8:	9f 05       	cpc	r25, r15
    b7da:	a0 07       	cpc	r26, r16
    b7dc:	b1 07       	cpc	r27, r17
    b7de:	38 f4       	brcc	.+14     	; 0xb7ee <fat16_seek_file+0x8a>
    b7e0:	ce 01       	movw	r24, r28
    b7e2:	b8 01       	movw	r22, r16
    b7e4:	a7 01       	movw	r20, r14
    b7e6:	0e 94 76 5a 	call	0xb4ec	; 0xb4ec <fat16_resize_file>
    b7ea:	88 23       	and	r24, r24
    b7ec:	69 f0       	breq	.+26     	; 0xb808 <fat16_seek_file+0xa4>
        return 0;

    fd->pos = new_pos;
    b7ee:	e9 aa       	std	Y+49, r14	; 0x31
    b7f0:	fa aa       	std	Y+50, r15	; 0x32
    b7f2:	0b ab       	std	Y+51, r16	; 0x33
    b7f4:	1c ab       	std	Y+52, r17	; 0x34
    fd->pos_cluster = 0;
    b7f6:	1e aa       	std	Y+54, r1	; 0x36
    b7f8:	1d aa       	std	Y+53, r1	; 0x35

    *offset = new_pos;
    b7fa:	f6 01       	movw	r30, r12
    b7fc:	e0 82       	st	Z, r14
    b7fe:	f1 82       	std	Z+1, r15	; 0x01
    b800:	02 83       	std	Z+2, r16	; 0x02
    b802:	13 83       	std	Z+3, r17	; 0x03
    b804:	81 e0       	ldi	r24, 0x01	; 1
    b806:	01 c0       	rjmp	.+2      	; 0xb80a <fat16_seek_file+0xa6>
    return 1;
    b808:	80 e0       	ldi	r24, 0x00	; 0
}
    b80a:	df 91       	pop	r29
    b80c:	cf 91       	pop	r28
    b80e:	1f 91       	pop	r17
    b810:	0f 91       	pop	r16
    b812:	ff 90       	pop	r15
    b814:	ef 90       	pop	r14
    b816:	df 90       	pop	r13
    b818:	cf 90       	pop	r12
    b81a:	08 95       	ret

0000b81c <fat16_write_file>:
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    b81c:	2f 92       	push	r2
    b81e:	3f 92       	push	r3
    b820:	4f 92       	push	r4
    b822:	5f 92       	push	r5
    b824:	6f 92       	push	r6
    b826:	7f 92       	push	r7
    b828:	8f 92       	push	r8
    b82a:	9f 92       	push	r9
    b82c:	af 92       	push	r10
    b82e:	bf 92       	push	r11
    b830:	cf 92       	push	r12
    b832:	df 92       	push	r13
    b834:	ef 92       	push	r14
    b836:	ff 92       	push	r15
    b838:	0f 93       	push	r16
    b83a:	1f 93       	push	r17
    b83c:	df 93       	push	r29
    b83e:	cf 93       	push	r28
    b840:	00 d0       	rcall	.+0      	; 0xb842 <fat16_write_file+0x26>
    b842:	00 d0       	rcall	.+0      	; 0xb844 <fat16_write_file+0x28>
    b844:	00 d0       	rcall	.+0      	; 0xb846 <fat16_write_file+0x2a>
    b846:	cd b7       	in	r28, 0x3d	; 61
    b848:	de b7       	in	r29, 0x3e	; 62
    b84a:	6c 01       	movw	r12, r24
    b84c:	1b 01       	movw	r2, r22
    b84e:	5c 83       	std	Y+4, r21	; 0x04
    b850:	4b 83       	std	Y+3, r20	; 0x03
#if FAT16_WRITE_SUPPORT
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    b852:	00 97       	sbiw	r24, 0x00	; 0
    b854:	09 f4       	brne	.+2      	; 0xb858 <fat16_write_file+0x3c>
    b856:	49 c1       	rjmp	.+658    	; 0xbaea <fat16_write_file+0x2ce>
    b858:	61 15       	cp	r22, r1
    b85a:	71 05       	cpc	r23, r1
    b85c:	09 f4       	brne	.+2      	; 0xb860 <fat16_write_file+0x44>
    b85e:	45 c1       	rjmp	.+650    	; 0xbaea <fat16_write_file+0x2ce>
    b860:	45 2b       	or	r20, r21
    b862:	09 f4       	brne	.+2      	; 0xb866 <fat16_write_file+0x4a>
    b864:	42 c1       	rjmp	.+644    	; 0xbaea <fat16_write_file+0x2ce>
        return -1;
    if(fd->pos > fd->dir_entry.file_size)
    b866:	dc 01       	movw	r26, r24
    b868:	d1 96       	adiw	r26, 0x31	; 49
    b86a:	4d 90       	ld	r4, X+
    b86c:	5d 90       	ld	r5, X+
    b86e:	6d 90       	ld	r6, X+
    b870:	7c 90       	ld	r7, X
    b872:	d4 97       	sbiw	r26, 0x34	; 52
    b874:	99 96       	adiw	r26, 0x29	; 41
    b876:	8d 91       	ld	r24, X+
    b878:	9d 91       	ld	r25, X+
    b87a:	0d 90       	ld	r0, X+
    b87c:	bc 91       	ld	r27, X
    b87e:	a0 2d       	mov	r26, r0
    b880:	84 15       	cp	r24, r4
    b882:	95 05       	cpc	r25, r5
    b884:	a6 05       	cpc	r26, r6
    b886:	b7 05       	cpc	r27, r7
    b888:	08 f4       	brcc	.+2      	; 0xb88c <fat16_write_file+0x70>
    b88a:	2f c1       	rjmp	.+606    	; 0xbaea <fat16_write_file+0x2ce>
        return -1;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    b88c:	d6 01       	movw	r26, r12
    b88e:	ed 91       	ld	r30, X+
    b890:	fc 91       	ld	r31, X
    b892:	11 97       	sbiw	r26, 0x01	; 1
    b894:	20 89       	ldd	r18, Z+16	; 0x10
    b896:	31 89       	ldd	r19, Z+17	; 0x11
    b898:	3a 83       	std	Y+2, r19	; 0x02
    b89a:	29 83       	std	Y+1, r18	; 0x01
    uint16_t cluster_num = fd->pos_cluster;
    b89c:	d5 96       	adiw	r26, 0x35	; 53
    b89e:	8d 91       	ld	r24, X+
    b8a0:	9c 91       	ld	r25, X
    b8a2:	d6 97       	sbiw	r26, 0x36	; 54
    b8a4:	9e 83       	std	Y+6, r25	; 0x06
    b8a6:	8d 83       	std	Y+5, r24	; 0x05
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;
    b8a8:	49 01       	movw	r8, r18
    b8aa:	aa 24       	eor	r10, r10
    b8ac:	bb 24       	eor	r11, r11

    /* find cluster in which to start writing */
    if(!cluster_num)
    b8ae:	89 2b       	or	r24, r25
    b8b0:	09 f0       	breq	.+2      	; 0xb8b4 <fat16_write_file+0x98>
    b8b2:	53 c0       	rjmp	.+166    	; 0xb95a <fat16_write_file+0x13e>
    {
        cluster_num = fd->dir_entry.cluster;
    b8b4:	97 96       	adiw	r26, 0x27	; 39
    b8b6:	0d 90       	ld	r0, X+
    b8b8:	bc 91       	ld	r27, X
    b8ba:	a0 2d       	mov	r26, r0
    b8bc:	be 83       	std	Y+6, r27	; 0x06
    b8be:	ad 83       	std	Y+5, r26	; 0x05
        
        if(!cluster_num)
    b8c0:	ab 2b       	or	r26, r27
    b8c2:	a9 f4       	brne	.+42     	; 0xb8ee <fat16_write_file+0xd2>
        {
            if(!fd->pos)
    b8c4:	41 14       	cp	r4, r1
    b8c6:	51 04       	cpc	r5, r1
    b8c8:	61 04       	cpc	r6, r1
    b8ca:	71 04       	cpc	r7, r1
    b8cc:	09 f0       	breq	.+2      	; 0xb8d0 <fat16_write_file+0xb4>
    b8ce:	0d c1       	rjmp	.+538    	; 0xbaea <fat16_write_file+0x2ce>
            {
                /* empty file */
                fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
    b8d0:	cf 01       	movw	r24, r30
    b8d2:	60 e0       	ldi	r22, 0x00	; 0
    b8d4:	70 e0       	ldi	r23, 0x00	; 0
    b8d6:	41 e0       	ldi	r20, 0x01	; 1
    b8d8:	50 e0       	ldi	r21, 0x00	; 0
    b8da:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
    b8de:	9e 83       	std	Y+6, r25	; 0x06
    b8e0:	8d 83       	std	Y+5, r24	; 0x05
    b8e2:	f6 01       	movw	r30, r12
    b8e4:	90 a7       	std	Z+40, r25	; 0x28
    b8e6:	87 a3       	std	Z+39, r24	; 0x27
                if(!cluster_num)
    b8e8:	89 2b       	or	r24, r25
    b8ea:	09 f4       	brne	.+2      	; 0xb8ee <fat16_write_file+0xd2>
    b8ec:	fe c0       	rjmp	.+508    	; 0xbaea <fat16_write_file+0x2ce>
            {
                return -1;
            }
        }

        if(fd->pos)
    b8ee:	d6 01       	movw	r26, r12
    b8f0:	d1 96       	adiw	r26, 0x31	; 49
    b8f2:	ed 90       	ld	r14, X+
    b8f4:	fd 90       	ld	r15, X+
    b8f6:	0d 91       	ld	r16, X+
    b8f8:	1c 91       	ld	r17, X
    b8fa:	d4 97       	sbiw	r26, 0x34	; 52
    b8fc:	e1 14       	cp	r14, r1
    b8fe:	f1 04       	cpc	r15, r1
    b900:	01 05       	cpc	r16, r1
    b902:	11 05       	cpc	r17, r1
    b904:	29 f5       	brne	.+74     	; 0xb950 <fat16_write_file+0x134>
    b906:	29 c0       	rjmp	.+82     	; 0xb95a <fat16_write_file+0x13e>
        {
            uint32_t pos = fd->pos;
            uint16_t cluster_num_next;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
    b908:	e8 18       	sub	r14, r8
    b90a:	f9 08       	sbc	r15, r9
    b90c:	0a 09       	sbc	r16, r10
    b90e:	1b 09       	sbc	r17, r11
                cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
    b910:	f6 01       	movw	r30, r12
    b912:	80 81       	ld	r24, Z
    b914:	91 81       	ldd	r25, Z+1	; 0x01
    b916:	6d 81       	ldd	r22, Y+5	; 0x05
    b918:	7e 81       	ldd	r23, Y+6	; 0x06
    b91a:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
                if(!cluster_num_next && pos == 0)
    b91e:	00 97       	sbiw	r24, 0x00	; 0
    b920:	19 f0       	breq	.+6      	; 0xb928 <fat16_write_file+0x10c>
    b922:	9e 83       	std	Y+6, r25	; 0x06
    b924:	8d 83       	std	Y+5, r24	; 0x05
    b926:	14 c0       	rjmp	.+40     	; 0xb950 <fat16_write_file+0x134>
    b928:	e1 14       	cp	r14, r1
    b92a:	f1 04       	cpc	r15, r1
    b92c:	01 05       	cpc	r16, r1
    b92e:	11 05       	cpc	r17, r1
    b930:	09 f0       	breq	.+2      	; 0xb934 <fat16_write_file+0x118>
    b932:	db c0       	rjmp	.+438    	; 0xbaea <fat16_write_file+0x2ce>
                    /* the file exactly ends on a cluster boundary, and we append to it */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
    b934:	d6 01       	movw	r26, r12
    b936:	8d 91       	ld	r24, X+
    b938:	9c 91       	ld	r25, X
    b93a:	6d 81       	ldd	r22, Y+5	; 0x05
    b93c:	7e 81       	ldd	r23, Y+6	; 0x06
    b93e:	41 e0       	ldi	r20, 0x01	; 1
    b940:	50 e0       	ldi	r21, 0x00	; 0
    b942:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
                if(!cluster_num_next)
    b946:	00 97       	sbiw	r24, 0x00	; 0
    b948:	09 f4       	brne	.+2      	; 0xb94c <fat16_write_file+0x130>
    b94a:	cf c0       	rjmp	.+414    	; 0xbaea <fat16_write_file+0x2ce>
    b94c:	9e 83       	std	Y+6, r25	; 0x06
    b94e:	8d 83       	std	Y+5, r24	; 0x05

        if(fd->pos)
        {
            uint32_t pos = fd->pos;
            uint16_t cluster_num_next;
            while(pos >= cluster_size)
    b950:	e8 14       	cp	r14, r8
    b952:	f9 04       	cpc	r15, r9
    b954:	0a 05       	cpc	r16, r10
    b956:	1b 05       	cpc	r17, r11
    b958:	b8 f6       	brcc	.-82     	; 0xb908 <fat16_write_file+0xec>
        return -1;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;
    b95a:	c3 01       	movw	r24, r6
    b95c:	b2 01       	movw	r22, r4
    b95e:	a5 01       	movw	r20, r10
    b960:	94 01       	movw	r18, r8
    b962:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    b966:	4b 01       	movw	r8, r22
    b968:	ab 80       	ldd	r10, Y+3	; 0x03
    b96a:	bc 80       	ldd	r11, Y+4	; 0x04
    
    /* write data */
    do
    {
        /* calculate data size to write to cluster */
        uint32_t cluster_offset = fat16_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
    b96c:	f6 01       	movw	r30, r12
    b96e:	e0 80       	ld	r14, Z
    b970:	f1 80       	ldd	r15, Z+1	; 0x01
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
uint32_t fat16_cluster_offset(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    if(!fs || cluster_num < 2)
    b972:	e1 14       	cp	r14, r1
    b974:	f1 04       	cpc	r15, r1
    b976:	19 f1       	breq	.+70     	; 0xb9be <fat16_write_file+0x1a2>
    b978:	2d 81       	ldd	r18, Y+5	; 0x05
    b97a:	3e 81       	ldd	r19, Y+6	; 0x06
    b97c:	22 30       	cpi	r18, 0x02	; 2
    b97e:	31 05       	cpc	r19, r1
    b980:	f0 f0       	brcs	.+60     	; 0xb9be <fat16_write_file+0x1a2>
        return 0;

    return fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
    b982:	22 50       	subi	r18, 0x02	; 2
    b984:	30 40       	sbci	r19, 0x00	; 0
    b986:	b9 01       	movw	r22, r18
    b988:	80 e0       	ldi	r24, 0x00	; 0
    b98a:	90 e0       	ldi	r25, 0x00	; 0
    b98c:	2e 5f       	subi	r18, 0xFE	; 254
    b98e:	3f 4f       	sbci	r19, 0xFF	; 255
    b990:	3e 83       	std	Y+6, r19	; 0x06
    b992:	2d 83       	std	Y+5, r18	; 0x05
    b994:	d7 01       	movw	r26, r14
    b996:	50 96       	adiw	r26, 0x10	; 16
    b998:	2d 91       	ld	r18, X+
    b99a:	3c 91       	ld	r19, X
    b99c:	51 97       	sbiw	r26, 0x11	; 17
    b99e:	40 e0       	ldi	r20, 0x00	; 0
    b9a0:	50 e0       	ldi	r21, 0x00	; 0
    b9a2:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    b9a6:	9b 01       	movw	r18, r22
    b9a8:	ac 01       	movw	r20, r24
    b9aa:	f7 01       	movw	r30, r14
    b9ac:	86 89       	ldd	r24, Z+22	; 0x16
    b9ae:	97 89       	ldd	r25, Z+23	; 0x17
    b9b0:	a0 8d       	ldd	r26, Z+24	; 0x18
    b9b2:	b1 8d       	ldd	r27, Z+25	; 0x19
    b9b4:	28 0f       	add	r18, r24
    b9b6:	39 1f       	adc	r19, r25
    b9b8:	4a 1f       	adc	r20, r26
    b9ba:	5b 1f       	adc	r21, r27
    b9bc:	04 c0       	rjmp	.+8      	; 0xb9c6 <fat16_write_file+0x1aa>
    b9be:	20 e0       	ldi	r18, 0x00	; 0
    b9c0:	30 e0       	ldi	r19, 0x00	; 0
    b9c2:	40 e0       	ldi	r20, 0x00	; 0
    b9c4:	50 e0       	ldi	r21, 0x00	; 0
    /* write data */
    do
    {
        /* calculate data size to write to cluster */
        uint32_t cluster_offset = fat16_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
        uint16_t write_length = cluster_size - first_cluster_offset;
    b9c6:	09 81       	ldd	r16, Y+1	; 0x01
    b9c8:	1a 81       	ldd	r17, Y+2	; 0x02
    b9ca:	08 19       	sub	r16, r8
    b9cc:	19 09       	sbc	r17, r9
    b9ce:	a0 16       	cp	r10, r16
    b9d0:	b1 06       	cpc	r11, r17
    b9d2:	08 f4       	brcc	.+2      	; 0xb9d6 <fat16_write_file+0x1ba>
    b9d4:	85 01       	movw	r16, r10
        if(write_length > buffer_left)
            write_length = buffer_left;

        /* write data which fits into the current cluster */
        if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
    b9d6:	d7 01       	movw	r26, r14
    b9d8:	ed 91       	ld	r30, X+
    b9da:	fc 91       	ld	r31, X
    b9dc:	c4 01       	movw	r24, r8
    b9de:	a0 e0       	ldi	r26, 0x00	; 0
    b9e0:	b0 e0       	ldi	r27, 0x00	; 0
    b9e2:	28 0f       	add	r18, r24
    b9e4:	39 1f       	adc	r19, r25
    b9e6:	4a 1f       	adc	r20, r26
    b9e8:	5b 1f       	adc	r21, r27
    b9ea:	04 80       	ldd	r0, Z+4	; 0x04
    b9ec:	f5 81       	ldd	r31, Z+5	; 0x05
    b9ee:	e0 2d       	mov	r30, r0
    b9f0:	ca 01       	movw	r24, r20
    b9f2:	b9 01       	movw	r22, r18
    b9f4:	a1 01       	movw	r20, r2
    b9f6:	98 01       	movw	r18, r16
    b9f8:	09 95       	icall
    b9fa:	88 23       	and	r24, r24
    b9fc:	09 f4       	brne	.+2      	; 0xba00 <fat16_write_file+0x1e4>
    b9fe:	4b c0       	rjmp	.+150    	; 0xba96 <fat16_write_file+0x27a>
            break;

        /* calculate new file position */
        buffer += write_length;
        buffer_left -= write_length;
    ba00:	a0 1a       	sub	r10, r16
    ba02:	b1 0a       	sbc	r11, r17
        fd->pos += write_length;
    ba04:	c8 01       	movw	r24, r16
    ba06:	a0 e0       	ldi	r26, 0x00	; 0
    ba08:	b0 e0       	ldi	r27, 0x00	; 0
    ba0a:	f6 01       	movw	r30, r12
    ba0c:	21 a9       	ldd	r18, Z+49	; 0x31
    ba0e:	32 a9       	ldd	r19, Z+50	; 0x32
    ba10:	43 a9       	ldd	r20, Z+51	; 0x33
    ba12:	54 a9       	ldd	r21, Z+52	; 0x34
    ba14:	28 0f       	add	r18, r24
    ba16:	39 1f       	adc	r19, r25
    ba18:	4a 1f       	adc	r20, r26
    ba1a:	5b 1f       	adc	r21, r27
    ba1c:	d6 01       	movw	r26, r12
    ba1e:	d1 96       	adiw	r26, 0x31	; 49
    ba20:	2d 93       	st	X+, r18
    ba22:	3d 93       	st	X+, r19
    ba24:	4d 93       	st	X+, r20
    ba26:	5c 93       	st	X, r21
    ba28:	d4 97       	sbiw	r26, 0x34	; 52

        if(first_cluster_offset + write_length >= cluster_size)
    ba2a:	c8 01       	movw	r24, r16
    ba2c:	88 0d       	add	r24, r8
    ba2e:	99 1d       	adc	r25, r9
    ba30:	e9 81       	ldd	r30, Y+1	; 0x01
    ba32:	fa 81       	ldd	r31, Y+2	; 0x02
    ba34:	8e 17       	cp	r24, r30
    ba36:	9f 07       	cpc	r25, r31
    ba38:	08 f1       	brcs	.+66     	; 0xba7c <fat16_write_file+0x260>
        {
            /* we are on a cluster boundary, so get the next cluster */
            uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
    ba3a:	8d 91       	ld	r24, X+
    ba3c:	9c 91       	ld	r25, X
    ba3e:	6d 81       	ldd	r22, Y+5	; 0x05
    ba40:	7e 81       	ldd	r23, Y+6	; 0x06
    ba42:	0e 94 b9 4d 	call	0x9b72	; 0x9b72 <fat16_get_next_cluster>
            if(!cluster_num_next && buffer_left > 0)
    ba46:	00 97       	sbiw	r24, 0x00	; 0
    ba48:	19 f0       	breq	.+6      	; 0xba50 <fat16_write_file+0x234>
    ba4a:	9e 83       	std	Y+6, r25	; 0x06
    ba4c:	8d 83       	std	Y+5, r24	; 0x05
    ba4e:	14 c0       	rjmp	.+40     	; 0xba78 <fat16_write_file+0x25c>
    ba50:	a1 14       	cp	r10, r1
    ba52:	b1 04       	cpc	r11, r1
    ba54:	59 f0       	breq	.+22     	; 0xba6c <fat16_write_file+0x250>
                /* we reached the last cluster, append a new one */
                cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
    ba56:	d6 01       	movw	r26, r12
    ba58:	8d 91       	ld	r24, X+
    ba5a:	9c 91       	ld	r25, X
    ba5c:	6d 81       	ldd	r22, Y+5	; 0x05
    ba5e:	7e 81       	ldd	r23, Y+6	; 0x06
    ba60:	41 e0       	ldi	r20, 0x01	; 1
    ba62:	50 e0       	ldi	r21, 0x00	; 0
    ba64:	0e 94 7b 4e 	call	0x9cf6	; 0x9cf6 <fat16_append_clusters>
            if(!cluster_num_next)
    ba68:	00 97       	sbiw	r24, 0x00	; 0
    ba6a:	21 f4       	brne	.+8      	; 0xba74 <fat16_write_file+0x258>
            {
                fd->pos_cluster = 0;
    ba6c:	f6 01       	movw	r30, r12
    ba6e:	16 aa       	std	Z+54, r1	; 0x36
    ba70:	15 aa       	std	Z+53, r1	; 0x35
    ba72:	11 c0       	rjmp	.+34     	; 0xba96 <fat16_write_file+0x27a>
                break;
    ba74:	9e 83       	std	Y+6, r25	; 0x06
    ba76:	8d 83       	std	Y+5, r24	; 0x05
    ba78:	88 24       	eor	r8, r8
    ba7a:	99 24       	eor	r9, r9

            cluster_num = cluster_num_next;
            first_cluster_offset = 0;
        }

        fd->pos_cluster = cluster_num;
    ba7c:	ed 81       	ldd	r30, Y+5	; 0x05
    ba7e:	fe 81       	ldd	r31, Y+6	; 0x06
    ba80:	d6 01       	movw	r26, r12
    ba82:	d6 96       	adiw	r26, 0x36	; 54
    ba84:	fc 93       	st	X, r31
    ba86:	ee 93       	st	-X, r30
    ba88:	d5 97       	sbiw	r26, 0x35	; 53

    } while(buffer_left > 0); /* check if we are done */
    ba8a:	a1 14       	cp	r10, r1
    ba8c:	b1 04       	cpc	r11, r1
    ba8e:	19 f0       	breq	.+6      	; 0xba96 <fat16_write_file+0x27a>
        /* write data which fits into the current cluster */
        if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
            break;

        /* calculate new file position */
        buffer += write_length;
    ba90:	20 0e       	add	r2, r16
    ba92:	31 1e       	adc	r3, r17
    ba94:	6b cf       	rjmp	.-298    	; 0xb96c <fat16_write_file+0x150>
        fd->pos_cluster = cluster_num;

    } while(buffer_left > 0); /* check if we are done */

    /* update directory entry */
    if(fd->pos > fd->dir_entry.file_size)
    ba96:	f6 01       	movw	r30, r12
    ba98:	81 a9       	ldd	r24, Z+49	; 0x31
    ba9a:	92 a9       	ldd	r25, Z+50	; 0x32
    ba9c:	a3 a9       	ldd	r26, Z+51	; 0x33
    ba9e:	b4 a9       	ldd	r27, Z+52	; 0x34
    baa0:	e1 a4       	ldd	r14, Z+41	; 0x29
    baa2:	f2 a4       	ldd	r15, Z+42	; 0x2a
    baa4:	03 a5       	ldd	r16, Z+43	; 0x2b
    baa6:	14 a5       	ldd	r17, Z+44	; 0x2c
    baa8:	e8 16       	cp	r14, r24
    baaa:	f9 06       	cpc	r15, r25
    baac:	0a 07       	cpc	r16, r26
    baae:	1b 07       	cpc	r17, r27
    bab0:	b8 f4       	brcc	.+46     	; 0xbae0 <fat16_write_file+0x2c4>
    {
        uint32_t size_old = fd->dir_entry.file_size;

        /* update file size */
        fd->dir_entry.file_size = fd->pos;
    bab2:	81 a7       	std	Z+41, r24	; 0x29
    bab4:	92 a7       	std	Z+42, r25	; 0x2a
    bab6:	a3 a7       	std	Z+43, r26	; 0x2b
    bab8:	b4 a7       	std	Z+44, r27	; 0x2c
        /* write directory entry */
        if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
    baba:	81 91       	ld	r24, Z+
    babc:	91 91       	ld	r25, Z+
    babe:	bf 01       	movw	r22, r30
    bac0:	0e 94 99 57 	call	0xaf32	; 0xaf32 <fat16_write_dir_entry>
    bac4:	88 23       	and	r24, r24
    bac6:	61 f4       	brne	.+24     	; 0xbae0 <fat16_write_file+0x2c4>
        {
            /* We do not return an error here since we actually wrote
             * some data to disk. So we calculate the amount of data
             * we wrote to disk and which lies within the old file size.
             */
            buffer_left = fd->pos - size_old;
    bac8:	d6 01       	movw	r26, r12
    baca:	d1 96       	adiw	r26, 0x31	; 49
    bacc:	ad 90       	ld	r10, X+
    bace:	bc 90       	ld	r11, X
    bad0:	d2 97       	sbiw	r26, 0x32	; 50
    bad2:	ae 18       	sub	r10, r14
    bad4:	bf 08       	sbc	r11, r15
            fd->pos = size_old;
    bad6:	f6 01       	movw	r30, r12
    bad8:	e1 aa       	std	Z+49, r14	; 0x31
    bada:	f2 aa       	std	Z+50, r15	; 0x32
    badc:	03 ab       	std	Z+51, r16	; 0x33
    bade:	14 ab       	std	Z+52, r17	; 0x34
        }
    }

    return buffer_len - buffer_left;
    bae0:	4b 81       	ldd	r20, Y+3	; 0x03
    bae2:	5c 81       	ldd	r21, Y+4	; 0x04
    bae4:	4a 19       	sub	r20, r10
    bae6:	5b 09       	sbc	r21, r11
    bae8:	02 c0       	rjmp	.+4      	; 0xbaee <fat16_write_file+0x2d2>
    baea:	4f ef       	ldi	r20, 0xFF	; 255
    baec:	5f ef       	ldi	r21, 0xFF	; 255

#else
    return -1;
#endif
}
    baee:	ca 01       	movw	r24, r20
    baf0:	26 96       	adiw	r28, 0x06	; 6
    baf2:	0f b6       	in	r0, 0x3f	; 63
    baf4:	f8 94       	cli
    baf6:	de bf       	out	0x3e, r29	; 62
    baf8:	0f be       	out	0x3f, r0	; 63
    bafa:	cd bf       	out	0x3d, r28	; 61
    bafc:	cf 91       	pop	r28
    bafe:	df 91       	pop	r29
    bb00:	1f 91       	pop	r17
    bb02:	0f 91       	pop	r16
    bb04:	ff 90       	pop	r15
    bb06:	ef 90       	pop	r14
    bb08:	df 90       	pop	r13
    bb0a:	cf 90       	pop	r12
    bb0c:	bf 90       	pop	r11
    bb0e:	af 90       	pop	r10
    bb10:	9f 90       	pop	r9
    bb12:	8f 90       	pop	r8
    bb14:	7f 90       	pop	r7
    bb16:	6f 90       	pop	r6
    bb18:	5f 90       	pop	r5
    bb1a:	4f 90       	pop	r4
    bb1c:	3f 90       	pop	r3
    bb1e:	2f 90       	pop	r2
    bb20:	08 95       	ret

0000bb22 <fat16_open_dir>:
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    bb22:	cf 93       	push	r28
    bb24:	df 93       	push	r29
    bb26:	ac 01       	movw	r20, r24
    bb28:	9b 01       	movw	r18, r22
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
    bb2a:	00 97       	sbiw	r24, 0x00	; 0
    bb2c:	09 f4       	brne	.+2      	; 0xbb30 <fat16_open_dir+0xe>
    bb2e:	3f c0       	rjmp	.+126    	; 0xbbae <fat16_open_dir+0x8c>
    bb30:	61 15       	cp	r22, r1
    bb32:	71 05       	cpc	r23, r1
    bb34:	e1 f1       	breq	.+120    	; 0xbbae <fat16_open_dir+0x8c>
    bb36:	db 01       	movw	r26, r22
    bb38:	90 96       	adiw	r26, 0x20	; 32
    bb3a:	8c 91       	ld	r24, X
    bb3c:	84 ff       	sbrs	r24, 4
    bb3e:	37 c0       	rjmp	.+110    	; 0xbbae <fat16_open_dir+0x8c>
#else
    struct fat16_dir_struct* dd = fat16_dir_handles;
    uint8_t i;
    for(i = 0; i < FAT16_DIR_COUNT; ++i)
    {
        if(!dd->fs)
    bb40:	80 91 4c 03 	lds	r24, 0x034C
    bb44:	90 91 4d 03 	lds	r25, 0x034D
    bb48:	89 2b       	or	r24, r25
    bb4a:	19 f4       	brne	.+6      	; 0xbb52 <fat16_open_dir+0x30>
    bb4c:	ec e4       	ldi	r30, 0x4C	; 76
    bb4e:	f3 e0       	ldi	r31, 0x03	; 3
    bb50:	1a c0       	rjmp	.+52     	; 0xbb86 <fat16_open_dir+0x64>
    bb52:	80 91 81 03 	lds	r24, 0x0381
    bb56:	90 91 82 03 	lds	r25, 0x0382
    bb5a:	89 2b       	or	r24, r25
    bb5c:	19 f4       	brne	.+6      	; 0xbb64 <fat16_open_dir+0x42>
    bb5e:	e1 e8       	ldi	r30, 0x81	; 129
    bb60:	f3 e0       	ldi	r31, 0x03	; 3
    bb62:	11 c0       	rjmp	.+34     	; 0xbb86 <fat16_open_dir+0x64>
    bb64:	80 91 b6 03 	lds	r24, 0x03B6
    bb68:	90 91 b7 03 	lds	r25, 0x03B7
    bb6c:	89 2b       	or	r24, r25
    bb6e:	19 f4       	brne	.+6      	; 0xbb76 <fat16_open_dir+0x54>
    bb70:	e6 eb       	ldi	r30, 0xB6	; 182
    bb72:	f3 e0       	ldi	r31, 0x03	; 3
    bb74:	08 c0       	rjmp	.+16     	; 0xbb86 <fat16_open_dir+0x64>
    bb76:	80 91 eb 03 	lds	r24, 0x03EB
    bb7a:	90 91 ec 03 	lds	r25, 0x03EC
    bb7e:	89 2b       	or	r24, r25
    bb80:	b1 f4       	brne	.+44     	; 0xbbae <fat16_open_dir+0x8c>
    bb82:	eb ee       	ldi	r30, 0xEB	; 235
    bb84:	f3 e0       	ldi	r31, 0x03	; 3
    }
    if(i >= FAT16_DIR_COUNT)
        return 0;
#endif
    
    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    bb86:	ef 01       	movw	r28, r30
    bb88:	22 96       	adiw	r28, 0x02	; 2
    bb8a:	d9 01       	movw	r26, r18
    bb8c:	8f e2       	ldi	r24, 0x2F	; 47
    bb8e:	0d 90       	ld	r0, X+
    bb90:	09 92       	st	Y+, r0
    bb92:	81 50       	subi	r24, 0x01	; 1
    bb94:	e1 f7       	brne	.-8      	; 0xbb8e <fat16_open_dir+0x6c>
    dd->fs = fs;
    bb96:	51 83       	std	Z+1, r21	; 0x01
    bb98:	40 83       	st	Z, r20
    dd->entry_cluster = dir_entry->cluster;
    bb9a:	d9 01       	movw	r26, r18
    bb9c:	95 96       	adiw	r26, 0x25	; 37
    bb9e:	8d 91       	ld	r24, X+
    bba0:	9c 91       	ld	r25, X
    bba2:	96 97       	sbiw	r26, 0x26	; 38
    bba4:	92 ab       	std	Z+50, r25	; 0x32
    bba6:	81 ab       	std	Z+49, r24	; 0x31
    dd->entry_offset = 0;
    bba8:	14 aa       	std	Z+52, r1	; 0x34
    bbaa:	13 aa       	std	Z+51, r1	; 0x33
    bbac:	02 c0       	rjmp	.+4      	; 0xbbb2 <fat16_open_dir+0x90>

    return dd;
    bbae:	e0 e0       	ldi	r30, 0x00	; 0
    bbb0:	f0 e0       	ldi	r31, 0x00	; 0
}
    bbb2:	cf 01       	movw	r24, r30
    bbb4:	df 91       	pop	r29
    bbb6:	cf 91       	pop	r28
    bbb8:	08 95       	ret

0000bbba <fat16_open_file>:
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    bbba:	cf 93       	push	r28
    bbbc:	df 93       	push	r29
    bbbe:	ac 01       	movw	r20, r24
    bbc0:	eb 01       	movw	r28, r22
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
    bbc2:	00 97       	sbiw	r24, 0x00	; 0
    bbc4:	49 f1       	breq	.+82     	; 0xbc18 <fat16_open_file+0x5e>
    bbc6:	61 15       	cp	r22, r1
    bbc8:	71 05       	cpc	r23, r1
    bbca:	31 f1       	breq	.+76     	; 0xbc18 <fat16_open_file+0x5e>
    bbcc:	88 a1       	ldd	r24, Y+32	; 0x20
    bbce:	84 fd       	sbrc	r24, 4
    bbd0:	23 c0       	rjmp	.+70     	; 0xbc18 <fat16_open_file+0x5e>
    bbd2:	e4 e3       	ldi	r30, 0x34	; 52
    bbd4:	f2 e0       	ldi	r31, 0x02	; 2
    bbd6:	20 e0       	ldi	r18, 0x00	; 0
#else
    struct fat16_file_struct* fd = fat16_file_handles;
    uint8_t i;
    for(i = 0; i < FAT16_FILE_COUNT; ++i)
    {
        if(!fd->fs)
    bbd8:	80 81       	ld	r24, Z
    bbda:	91 81       	ldd	r25, Z+1	; 0x01
    bbdc:	89 2b       	or	r24, r25
    bbde:	c1 f4       	brne	.+48     	; 0xbc10 <fat16_open_file+0x56>
    }
    if(i >= FAT16_FILE_COUNT)
        return 0;
#endif
    
    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    bbe0:	9f 01       	movw	r18, r30
    bbe2:	2e 5f       	subi	r18, 0xFE	; 254
    bbe4:	3f 4f       	sbci	r19, 0xFF	; 255
    bbe6:	be 01       	movw	r22, r28
    bbe8:	8f e2       	ldi	r24, 0x2F	; 47
    bbea:	db 01       	movw	r26, r22
    bbec:	0d 90       	ld	r0, X+
    bbee:	bd 01       	movw	r22, r26
    bbf0:	d9 01       	movw	r26, r18
    bbf2:	0d 92       	st	X+, r0
    bbf4:	9d 01       	movw	r18, r26
    bbf6:	81 50       	subi	r24, 0x01	; 1
    bbf8:	c1 f7       	brne	.-16     	; 0xbbea <fat16_open_file+0x30>
    fd->fs = fs;
    bbfa:	51 83       	std	Z+1, r21	; 0x01
    bbfc:	40 83       	st	Z, r20
    fd->pos = 0;
    bbfe:	11 aa       	std	Z+49, r1	; 0x31
    bc00:	12 aa       	std	Z+50, r1	; 0x32
    bc02:	13 aa       	std	Z+51, r1	; 0x33
    bc04:	14 aa       	std	Z+52, r1	; 0x34
    fd->pos_cluster = dir_entry->cluster;
    bc06:	8d a1       	ldd	r24, Y+37	; 0x25
    bc08:	9e a1       	ldd	r25, Y+38	; 0x26
    bc0a:	96 ab       	std	Z+54, r25	; 0x36
    bc0c:	85 ab       	std	Z+53, r24	; 0x35
    bc0e:	06 c0       	rjmp	.+12     	; 0xbc1c <fat16_open_file+0x62>
    for(i = 0; i < FAT16_FILE_COUNT; ++i)
    {
        if(!fd->fs)
            break;

        ++fd;
    bc10:	f8 96       	adiw	r30, 0x38	; 56
    if(!fd)
        return 0;
#else
    struct fat16_file_struct* fd = fat16_file_handles;
    uint8_t i;
    for(i = 0; i < FAT16_FILE_COUNT; ++i)
    bc12:	2f 5f       	subi	r18, 0xFF	; 255
    bc14:	25 30       	cpi	r18, 0x05	; 5
    bc16:	01 f7       	brne	.-64     	; 0xbbd8 <fat16_open_file+0x1e>
    bc18:	e0 e0       	ldi	r30, 0x00	; 0
    bc1a:	f0 e0       	ldi	r31, 0x00	; 0
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}
    bc1c:	cf 01       	movw	r24, r30
    bc1e:	df 91       	pop	r29
    bc20:	cf 91       	pop	r28
    bc22:	08 95       	ret

0000bc24 <fat16_get_dir_entry_of_path>:
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    bc24:	6f 92       	push	r6
    bc26:	7f 92       	push	r7
    bc28:	8f 92       	push	r8
    bc2a:	9f 92       	push	r9
    bc2c:	af 92       	push	r10
    bc2e:	bf 92       	push	r11
    bc30:	cf 92       	push	r12
    bc32:	df 92       	push	r13
    bc34:	ef 92       	push	r14
    bc36:	ff 92       	push	r15
    bc38:	0f 93       	push	r16
    bc3a:	1f 93       	push	r17
    bc3c:	cf 93       	push	r28
    bc3e:	df 93       	push	r29
    bc40:	4c 01       	movw	r8, r24
    bc42:	eb 01       	movw	r28, r22
    bc44:	7a 01       	movw	r14, r20
    if(!fs || !path || path[0] == '\0' || !dir_entry)
    bc46:	00 97       	sbiw	r24, 0x00	; 0
    bc48:	09 f4       	brne	.+2      	; 0xbc4c <fat16_get_dir_entry_of_path+0x28>
    bc4a:	67 c0       	rjmp	.+206    	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
    bc4c:	61 15       	cp	r22, r1
    bc4e:	71 05       	cpc	r23, r1
    bc50:	09 f4       	brne	.+2      	; 0xbc54 <fat16_get_dir_entry_of_path+0x30>
    bc52:	63 c0       	rjmp	.+198    	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
    bc54:	88 81       	ld	r24, Y
    bc56:	88 23       	and	r24, r24
    bc58:	09 f4       	brne	.+2      	; 0xbc5c <fat16_get_dir_entry_of_path+0x38>
    bc5a:	5f c0       	rjmp	.+190    	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
    bc5c:	41 15       	cp	r20, r1
    bc5e:	51 05       	cpc	r21, r1
    bc60:	09 f4       	brne	.+2      	; 0xbc64 <fat16_get_dir_entry_of_path+0x40>
    bc62:	5b c0       	rjmp	.+182    	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
        return 0;

    if(path[0] == '/')
    bc64:	8f 32       	cpi	r24, 0x2F	; 47
    bc66:	09 f4       	brne	.+2      	; 0xbc6a <fat16_get_dir_entry_of_path+0x46>
        ++path;
    bc68:	21 96       	adiw	r28, 0x01	; 1

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    bc6a:	8f e2       	ldi	r24, 0x2F	; 47
    bc6c:	f7 01       	movw	r30, r14
    bc6e:	11 92       	st	Z+, r1
    bc70:	8a 95       	dec	r24
    bc72:	e9 f7       	brne	.-6      	; 0xbc6e <fat16_get_dir_entry_of_path+0x4a>
    dir_entry->attributes = FAT16_ATTRIB_DIR;
    bc74:	80 e1       	ldi	r24, 0x10	; 16
    bc76:	f7 01       	movw	r30, r14
    bc78:	80 a3       	std	Z+32, r24	; 0x20
        
        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    bc7a:	37 01       	movw	r6, r14
    bc7c:	01 c0       	rjmp	.+2      	; 0xbc80 <fat16_get_dir_entry_of_path+0x5c>
    bc7e:	e5 01       	movw	r28, r10
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    while(1)
    {
        if(path[0] == '\0')
    bc80:	88 81       	ld	r24, Y
    bc82:	88 23       	and	r24, r24
    bc84:	09 f4       	brne	.+2      	; 0xbc88 <fat16_get_dir_entry_of_path+0x64>
    bc86:	4b c0       	rjmp	.+150    	; 0xbd1e <fat16_get_dir_entry_of_path+0xfa>
            return 1;

        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
    bc88:	c4 01       	movw	r24, r8
    bc8a:	b7 01       	movw	r22, r14
    bc8c:	0e 94 91 5d 	call	0xbb22	; 0xbb22 <fat16_open_dir>
    bc90:	6c 01       	movw	r12, r24
        if(!dd)
    bc92:	00 97       	sbiw	r24, 0x00	; 0
    bc94:	09 f4       	brne	.+2      	; 0xbc98 <fat16_get_dir_entry_of_path+0x74>
    bc96:	41 c0       	rjmp	.+130    	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
            break;

        /* extract the next hierarchy we will search for */
        const char* sub_path = strchr(path, '/');
    bc98:	ce 01       	movw	r24, r28
    bc9a:	6f e2       	ldi	r22, 0x2F	; 47
    bc9c:	70 e0       	ldi	r23, 0x00	; 0
    bc9e:	0e 94 91 6e 	call	0xdd22	; 0xdd22 <strchr>
        uint8_t length_to_sep;
        if(sub_path)
    bca2:	00 97       	sbiw	r24, 0x00	; 0
    bca4:	39 f0       	breq	.+14     	; 0xbcb4 <fat16_get_dir_entry_of_path+0x90>
        {
            length_to_sep = sub_path - path;
    bca6:	48 2f       	mov	r20, r24
    bca8:	4c 1b       	sub	r20, r28
            ++sub_path;
    bcaa:	5c 01       	movw	r10, r24
    bcac:	08 94       	sec
    bcae:	a1 1c       	adc	r10, r1
    bcb0:	b1 1c       	adc	r11, r1
    bcb2:	2a c0       	rjmp	.+84     	; 0xbd08 <fat16_get_dir_entry_of_path+0xe4>
        }
        else
        {
            length_to_sep = strlen(path);
    bcb4:	fe 01       	movw	r30, r28
    bcb6:	01 90       	ld	r0, Z+
    bcb8:	00 20       	and	r0, r0
    bcba:	e9 f7       	brne	.-6      	; 0xbcb6 <fat16_get_dir_entry_of_path+0x92>
    bcbc:	31 97       	sbiw	r30, 0x01	; 1
    bcbe:	4e 2f       	mov	r20, r30
    bcc0:	4c 1b       	sub	r20, r28
            sub_path = path + length_to_sep;
    bcc2:	5e 01       	movw	r10, r28
    bcc4:	a4 0e       	add	r10, r20
    bcc6:	b1 1c       	adc	r11, r1
    bcc8:	1f c0       	rjmp	.+62     	; 0xbd08 <fat16_get_dir_entry_of_path+0xe4>
        
        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    bcca:	f3 01       	movw	r30, r6
    bccc:	01 90       	ld	r0, Z+
    bcce:	00 20       	and	r0, r0
    bcd0:	e9 f7       	brne	.-6      	; 0xbccc <fat16_get_dir_entry_of_path+0xa8>
    bcd2:	31 97       	sbiw	r30, 0x01	; 1
    bcd4:	e6 19       	sub	r30, r6
    bcd6:	f7 09       	sbc	r31, r7
    bcd8:	e0 17       	cp	r30, r16
    bcda:	f1 07       	cpc	r31, r17
    bcdc:	b9 f4       	brne	.+46     	; 0xbd0c <fat16_get_dir_entry_of_path+0xe8>
    bcde:	ce 01       	movw	r24, r28
    bce0:	b3 01       	movw	r22, r6
    bce2:	a8 01       	movw	r20, r16
    bce4:	0e 94 b4 6e 	call	0xdd68	; 0xdd68 <strncmp>
    bce8:	00 97       	sbiw	r24, 0x00	; 0
    bcea:	81 f4       	brne	.+32     	; 0xbd0c <fat16_get_dir_entry_of_path+0xe8>
{
    if(dd)
#if USE_DYNAMIC_MEMORY
        free(dd);
#else
        dd->fs = 0;
    bcec:	f6 01       	movw	r30, r12
    bcee:	11 82       	std	Z+1, r1	; 0x01
    bcf0:	10 82       	st	Z, r1
                continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    bcf2:	0c 0f       	add	r16, r28
    bcf4:	1d 1f       	adc	r17, r29
    bcf6:	f8 01       	movw	r30, r16
    bcf8:	80 81       	ld	r24, Z
    bcfa:	88 23       	and	r24, r24
    bcfc:	81 f0       	breq	.+32     	; 0xbd1e <fat16_get_dir_entry_of_path+0xfa>
                /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
    bcfe:	f7 01       	movw	r30, r14
    bd00:	80 a1       	ldd	r24, Z+32	; 0x20
    bd02:	84 fd       	sbrc	r24, 4
    bd04:	bc cf       	rjmp	.-136    	; 0xbc7e <fat16_get_dir_entry_of_path+0x5a>
    bd06:	09 c0       	rjmp	.+18     	; 0xbd1a <fat16_get_dir_entry_of_path+0xf6>
        
        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    bd08:	04 2f       	mov	r16, r20
    bd0a:	10 e0       	ldi	r17, 0x00	; 0
            length_to_sep = strlen(path);
            sub_path = path + length_to_sep;
        }
        
        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
    bd0c:	c6 01       	movw	r24, r12
    bd0e:	b7 01       	movw	r22, r14
    bd10:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    bd14:	88 23       	and	r24, r24
    bd16:	c9 f6       	brne	.-78     	; 0xbcca <fat16_get_dir_entry_of_path+0xa6>
    bd18:	12 c0       	rjmp	.+36     	; 0xbd3e <fat16_get_dir_entry_of_path+0x11a>
    bd1a:	80 e0       	ldi	r24, 0x00	; 0
    bd1c:	01 c0       	rjmp	.+2      	; 0xbd20 <fat16_get_dir_entry_of_path+0xfc>
    bd1e:	81 e0       	ldi	r24, 0x01	; 1

        fat16_close_dir(dd);
    }
    
    return 0;
}
    bd20:	df 91       	pop	r29
    bd22:	cf 91       	pop	r28
    bd24:	1f 91       	pop	r17
    bd26:	0f 91       	pop	r16
    bd28:	ff 90       	pop	r15
    bd2a:	ef 90       	pop	r14
    bd2c:	df 90       	pop	r13
    bd2e:	cf 90       	pop	r12
    bd30:	bf 90       	pop	r11
    bd32:	af 90       	pop	r10
    bd34:	9f 90       	pop	r9
    bd36:	8f 90       	pop	r8
    bd38:	7f 90       	pop	r7
    bd3a:	6f 90       	pop	r6
    bd3c:	08 95       	ret
{
    if(dd)
#if USE_DYNAMIC_MEMORY
        free(dd);
#else
        dd->fs = 0;
    bd3e:	f6 01       	movw	r30, r12
    bd40:	11 82       	std	Z+1, r1	; 0x01
    bd42:	10 82       	st	Z, r1
    bd44:	9d cf       	rjmp	.-198    	; 0xbc80 <fat16_get_dir_entry_of_path+0x5c>

0000bd46 <sd_get_fs>:
}

struct fat16_fs_struct* sd_get_fs()
{
    return sd_fs;
}
    bd46:	80 91 22 04 	lds	r24, 0x0422
    bd4a:	90 91 23 04 	lds	r25, 0x0423
    bd4e:	08 95       	ret

0000bd50 <sd_get_root_dir>:

struct fat16_dir_struct* sd_get_root_dir()
{
    return sd_dd;
}
    bd50:	80 91 24 04 	lds	r24, 0x0424
    bd54:	90 91 25 04 	lds	r25, 0x0425
    bd58:	08 95       	ret

0000bd5a <sd_find_file_in_dir>:

uint8_t sd_find_file_in_dir(struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    bd5a:	ef 92       	push	r14
    bd5c:	ff 92       	push	r15
    bd5e:	0f 93       	push	r16
    bd60:	1f 93       	push	r17
    bd62:	cf 93       	push	r28
    bd64:	df 93       	push	r29
    bd66:	ec 01       	movw	r28, r24
    bd68:	8b 01       	movw	r16, r22
    bd6a:	7a 01       	movw	r14, r20
    bd6c:	0b c0       	rjmp	.+22     	; 0xbd84 <sd_find_file_in_dir+0x2a>
    while(fat16_read_dir(dd, dir_entry))
    bd6e:	c7 01       	movw	r24, r14
    bd70:	b8 01       	movw	r22, r16
    bd72:	0e 94 a4 6e 	call	0xdd48	; 0xdd48 <strcmp>
    {
        if(strcmp(dir_entry->long_name, name) == 0)
    bd76:	00 97       	sbiw	r24, 0x00	; 0
    bd78:	29 f4       	brne	.+10     	; 0xbd84 <sd_find_file_in_dir+0x2a>
        {
            fat16_reset_dir(dd);
    bd7a:	ce 01       	movw	r24, r28
    bd7c:	0e 94 f2 50 	call	0xa1e4	; 0xa1e4 <fat16_reset_dir>
    bd80:	81 e0       	ldi	r24, 0x01	; 1
    bd82:	06 c0       	rjmp	.+12     	; 0xbd90 <sd_find_file_in_dir+0x36>
    return sd_dd;
}

uint8_t sd_find_file_in_dir(struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    bd84:	ce 01       	movw	r24, r28
    bd86:	b7 01       	movw	r22, r14
    bd88:	0e 94 b9 53 	call	0xa772	; 0xa772 <fat16_read_dir>
    bd8c:	88 23       	and	r24, r24
    bd8e:	79 f7       	brne	.-34     	; 0xbd6e <sd_find_file_in_dir+0x14>
            return 1;
        }
    }

    return 0;
}
    bd90:	df 91       	pop	r29
    bd92:	cf 91       	pop	r28
    bd94:	1f 91       	pop	r17
    bd96:	0f 91       	pop	r16
    bd98:	ff 90       	pop	r15
    bd9a:	ef 90       	pop	r14
    bd9c:	08 95       	ret

0000bd9e <sd_open_file_in_dir>:

struct fat16_file_struct* sd_open_file_in_dir(struct fat16_dir_struct* dd, const char* name)
{
    bd9e:	0f 93       	push	r16
    bda0:	1f 93       	push	r17
    bda2:	df 93       	push	r29
    bda4:	cf 93       	push	r28
    bda6:	cd b7       	in	r28, 0x3d	; 61
    bda8:	de b7       	in	r29, 0x3e	; 62
    bdaa:	af 97       	sbiw	r28, 0x2f	; 47
    bdac:	0f b6       	in	r0, 0x3f	; 63
    bdae:	f8 94       	cli
    bdb0:	de bf       	out	0x3e, r29	; 62
    bdb2:	0f be       	out	0x3f, r0	; 63
    bdb4:	cd bf       	out	0x3d, r28	; 61
    struct fat16_dir_entry_struct file_entry;
    if(!sd_find_file_in_dir(dd, name, &file_entry))
    bdb6:	8e 01       	movw	r16, r28
    bdb8:	0f 5f       	subi	r16, 0xFF	; 255
    bdba:	1f 4f       	sbci	r17, 0xFF	; 255
    bdbc:	a8 01       	movw	r20, r16
    bdbe:	0e 94 ad 5e 	call	0xbd5a	; 0xbd5a <sd_find_file_in_dir>
    bdc2:	88 23       	and	r24, r24
    bdc4:	19 f4       	brne	.+6      	; 0xbdcc <sd_open_file_in_dir+0x2e>
    bdc6:	20 e0       	ldi	r18, 0x00	; 0
    bdc8:	30 e0       	ldi	r19, 0x00	; 0
    bdca:	08 c0       	rjmp	.+16     	; 0xbddc <sd_open_file_in_dir+0x3e>
        return 0;

    return fat16_open_file(sd_fs, &file_entry);
    bdcc:	80 91 22 04 	lds	r24, 0x0422
    bdd0:	90 91 23 04 	lds	r25, 0x0423
    bdd4:	b8 01       	movw	r22, r16
    bdd6:	0e 94 dd 5d 	call	0xbbba	; 0xbbba <fat16_open_file>
    bdda:	9c 01       	movw	r18, r24
}
    bddc:	c9 01       	movw	r24, r18
    bdde:	af 96       	adiw	r28, 0x2f	; 47
    bde0:	0f b6       	in	r0, 0x3f	; 63
    bde2:	f8 94       	cli
    bde4:	de bf       	out	0x3e, r29	; 62
    bde6:	0f be       	out	0x3f, r0	; 63
    bde8:	cd bf       	out	0x3d, r28	; 61
    bdea:	cf 91       	pop	r28
    bdec:	df 91       	pop	r29
    bdee:	1f 91       	pop	r17
    bdf0:	0f 91       	pop	r16
    bdf2:	08 95       	ret

0000bdf4 <sd_close>:
    return SD_ERROR_NONE;
}

void sd_close()
{
    fat16_close_dir(sd_dd);
    bdf4:	80 91 24 04 	lds	r24, 0x0424
    bdf8:	90 91 25 04 	lds	r25, 0x0425
    bdfc:	0e 94 ec 50 	call	0xa1d8	; 0xa1d8 <fat16_close_dir>
    fat16_close(sd_fs);
    be00:	80 91 22 04 	lds	r24, 0x0422
    be04:	90 91 23 04 	lds	r25, 0x0423
    be08:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <fat16_close>
    partition_close(sd_partition);
    be0c:	80 91 20 04 	lds	r24, 0x0420
    be10:	90 91 21 04 	lds	r25, 0x0421
    be14:	0e 94 9d 63 	call	0xc73a	; 0xc73a <partition_close>
    sd_dd = 0;
    be18:	10 92 25 04 	sts	0x0425, r1
    be1c:	10 92 24 04 	sts	0x0424, r1
    sd_fs = 0;
    be20:	10 92 23 04 	sts	0x0423, r1
    be24:	10 92 22 04 	sts	0x0422, r1
    sd_partition = 0;
    be28:	10 92 21 04 	sts	0x0421, r1
    be2c:	10 92 20 04 	sts	0x0420, r1
}
    be30:	08 95       	ret

0000be32 <sd_open>:
static struct partition_struct* sd_partition;
static struct fat16_fs_struct* sd_fs;
static struct fat16_dir_struct* sd_dd;

int8_t sd_open()
{
    be32:	0f 93       	push	r16
    be34:	1f 93       	push	r17
    be36:	df 93       	push	r29
    be38:	cf 93       	push	r28
    be3a:	cd b7       	in	r28, 0x3d	; 61
    be3c:	de b7       	in	r29, 0x3e	; 62
    be3e:	af 97       	sbiw	r28, 0x2f	; 47
    be40:	0f b6       	in	r0, 0x3f	; 63
    be42:	f8 94       	cli
    be44:	de bf       	out	0x3e, r29	; 62
    be46:	0f be       	out	0x3f, r0	; 63
    be48:	cd bf       	out	0x3d, r28	; 61
    sd_close();
    be4a:	0e 94 fa 5e 	call	0xbdf4	; 0xbdf4 <sd_close>

    /* setup sd card slot */
    if(!sd_raw_init())
    be4e:	0e 94 2a 63 	call	0xc654	; 0xc654 <sd_raw_init>
    be52:	88 23       	and	r24, r24
    be54:	11 f4       	brne	.+4      	; 0xbe5a <sd_open+0x28>
    be56:	8f ef       	ldi	r24, 0xFF	; 255
    be58:	4e c0       	rjmp	.+156    	; 0xbef6 <sd_open+0xc4>
        return SD_ERROR_INIT;

    /* open first partition */
    sd_partition = partition_open(sd_raw_read,
    be5a:	85 ee       	ldi	r24, 0xE5	; 229
    be5c:	90 e6       	ldi	r25, 0x60	; 96
    be5e:	6a eb       	ldi	r22, 0xBA	; 186
    be60:	72 e6       	ldi	r23, 0x62	; 98
    be62:	4a e8       	ldi	r20, 0x8A	; 138
    be64:	51 e6       	ldi	r21, 0x61	; 97
    be66:	2f e5       	ldi	r18, 0x5F	; 95
    be68:	32 e6       	ldi	r19, 0x62	; 98
    be6a:	00 e0       	ldi	r16, 0x00	; 0
    be6c:	0e 94 a5 63 	call	0xc74a	; 0xc74a <partition_open>
    be70:	90 93 21 04 	sts	0x0421, r25
    be74:	80 93 20 04 	sts	0x0420, r24
                                  sd_raw_write,
                                  sd_raw_write_interval,
                                  0
                                 );

    if(!sd_partition)
    be78:	89 2b       	or	r24, r25
    be7a:	99 f4       	brne	.+38     	; 0xbea2 <sd_open+0x70>
    {
        /* If the partition did not open, assume the storage device
         * is a "superfloppy", i.e. has no MBR.
         */
        sd_partition = partition_open(sd_raw_read,
    be7c:	85 ee       	ldi	r24, 0xE5	; 229
    be7e:	90 e6       	ldi	r25, 0x60	; 96
    be80:	6a eb       	ldi	r22, 0xBA	; 186
    be82:	72 e6       	ldi	r23, 0x62	; 98
    be84:	4a e8       	ldi	r20, 0x8A	; 138
    be86:	51 e6       	ldi	r21, 0x61	; 97
    be88:	2f e5       	ldi	r18, 0x5F	; 95
    be8a:	32 e6       	ldi	r19, 0x62	; 98
    be8c:	0f ef       	ldi	r16, 0xFF	; 255
    be8e:	0e 94 a5 63 	call	0xc74a	; 0xc74a <partition_open>
    be92:	90 93 21 04 	sts	0x0421, r25
    be96:	80 93 20 04 	sts	0x0420, r24
                                      sd_raw_write,
                                      sd_raw_write_interval,
                                      -1
                                     );

        if(!sd_partition)
    be9a:	89 2b       	or	r24, r25
    be9c:	11 f4       	brne	.+4      	; 0xbea2 <sd_open+0x70>
    be9e:	8e ef       	ldi	r24, 0xFE	; 254
    bea0:	2a c0       	rjmp	.+84     	; 0xbef6 <sd_open+0xc4>
            return SD_ERROR_PARTITION;
    }

    /* open file system */
    sd_fs = fat16_open(sd_partition);
    bea2:	80 91 20 04 	lds	r24, 0x0420
    bea6:	90 91 21 04 	lds	r25, 0x0421
    beaa:	0e 94 ac 54 	call	0xa958	; 0xa958 <fat16_open>
    beae:	90 93 23 04 	sts	0x0423, r25
    beb2:	80 93 22 04 	sts	0x0422, r24
    if(!sd_fs)
    beb6:	00 97       	sbiw	r24, 0x00	; 0
    beb8:	21 f4       	brne	.+8      	; 0xbec2 <sd_open+0x90>
    {
        sd_close();
    beba:	0e 94 fa 5e 	call	0xbdf4	; 0xbdf4 <sd_close>
    bebe:	8d ef       	ldi	r24, 0xFD	; 253
    bec0:	1a c0       	rjmp	.+52     	; 0xbef6 <sd_open+0xc4>
        return SD_ERROR_FS;
    }

    /* open root directory */
    struct fat16_dir_entry_struct directory;
    fat16_get_dir_entry_of_path(sd_fs, "/", &directory);
    bec2:	65 ec       	ldi	r22, 0xC5	; 197
    bec4:	71 e0       	ldi	r23, 0x01	; 1
    bec6:	8e 01       	movw	r16, r28
    bec8:	0f 5f       	subi	r16, 0xFF	; 255
    beca:	1f 4f       	sbci	r17, 0xFF	; 255
    becc:	a8 01       	movw	r20, r16
    bece:	0e 94 12 5e 	call	0xbc24	; 0xbc24 <fat16_get_dir_entry_of_path>

    sd_dd = fat16_open_dir(sd_fs, &directory);
    bed2:	80 91 22 04 	lds	r24, 0x0422
    bed6:	90 91 23 04 	lds	r25, 0x0423
    beda:	b8 01       	movw	r22, r16
    bedc:	0e 94 91 5d 	call	0xbb22	; 0xbb22 <fat16_open_dir>
    bee0:	90 93 25 04 	sts	0x0425, r25
    bee4:	80 93 24 04 	sts	0x0424, r24
    if(!sd_dd)
    bee8:	89 2b       	or	r24, r25
    beea:	11 f0       	breq	.+4      	; 0xbef0 <sd_open+0xbe>
    beec:	80 e0       	ldi	r24, 0x00	; 0
    beee:	03 c0       	rjmp	.+6      	; 0xbef6 <sd_open+0xc4>
    {
        sd_close();
    bef0:	0e 94 fa 5e 	call	0xbdf4	; 0xbdf4 <sd_close>
    bef4:	8c ef       	ldi	r24, 0xFC	; 252
        return SD_ERROR_ROOTDIR;
    }

    return SD_ERROR_NONE;
}
    bef6:	af 96       	adiw	r28, 0x2f	; 47
    bef8:	0f b6       	in	r0, 0x3f	; 63
    befa:	f8 94       	cli
    befc:	de bf       	out	0x3e, r29	; 62
    befe:	0f be       	out	0x3f, r0	; 63
    bf00:	cd bf       	out	0x3d, r28	; 61
    bf02:	cf 91       	pop	r28
    bf04:	df 91       	pop	r29
    bf06:	1f 91       	pop	r17
    bf08:	0f 91       	pop	r16
    bf0a:	08 95       	ret

0000bf0c <sd_raw_available>:
 *
 * \returns 1 if the card is available, 0 if it is not.
 */
uint8_t sd_raw_available()
{
    return get_pin_available() == 0x00;
    bf0c:	80 b1       	in	r24, 0x00	; 0
    bf0e:	82 95       	swap	r24
    bf10:	86 95       	lsr	r24
    bf12:	86 95       	lsr	r24
    bf14:	83 70       	andi	r24, 0x03	; 3
    bf16:	80 95       	com	r24
}
    bf18:	81 70       	andi	r24, 0x01	; 1
    bf1a:	08 95       	ret

0000bf1c <sd_raw_locked>:
 * \returns 1 if the card is locked, 0 if it is not.
 */
uint8_t sd_raw_locked()
{
    return 0;	//get_pin_locked() == 0x00;
}
    bf1c:	80 e0       	ldi	r24, 0x00	; 0
    bf1e:	08 95       	ret

0000bf20 <sd_raw_send_command_r1>:
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
uint8_t sd_raw_send_command_r1(uint8_t command, uint32_t arg)
{
    bf20:	df 92       	push	r13
    bf22:	ef 92       	push	r14
    bf24:	ff 92       	push	r15
    bf26:	0f 93       	push	r16
    bf28:	1f 93       	push	r17
    bf2a:	d8 2e       	mov	r13, r24
    bf2c:	7a 01       	movw	r14, r20
    bf2e:	8b 01       	movw	r16, r22
    uint8_t response;

    /* wait some clock cycles */
    spi_rec_byte();
    bf30:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>

    /* send command via SPI */
    spi_send_byte(0x40 | command);
    bf34:	8d 2d       	mov	r24, r13
    bf36:	80 64       	ori	r24, 0x40	; 64
    bf38:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    spi_send_byte((arg >> 24) & 0xff);
    bf3c:	81 2f       	mov	r24, r17
    bf3e:	99 27       	eor	r25, r25
    bf40:	aa 27       	eor	r26, r26
    bf42:	bb 27       	eor	r27, r27
    bf44:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    spi_send_byte((arg >> 16) & 0xff);
    bf48:	c8 01       	movw	r24, r16
    bf4a:	aa 27       	eor	r26, r26
    bf4c:	bb 27       	eor	r27, r27
    bf4e:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    spi_send_byte((arg >> 8) & 0xff);
    bf52:	bb 27       	eor	r27, r27
    bf54:	a1 2f       	mov	r26, r17
    bf56:	90 2f       	mov	r25, r16
    bf58:	8f 2d       	mov	r24, r15
    bf5a:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    spi_send_byte((arg >> 0) & 0xff);
    bf5e:	8e 2d       	mov	r24, r14
    bf60:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    spi_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);
    bf64:	dd 20       	and	r13, r13
    bf66:	11 f0       	breq	.+4      	; 0xbf6c <sd_raw_send_command_r1+0x4c>
    bf68:	8f ef       	ldi	r24, 0xFF	; 255
    bf6a:	01 c0       	rjmp	.+2      	; 0xbf6e <sd_raw_send_command_r1+0x4e>
    bf6c:	85 e9       	ldi	r24, 0x95	; 149
    bf6e:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
    bf72:	10 e0       	ldi	r17, 0x00	; 0
    
    /* receive response */
    for(uint8_t i = 0; i < 10; ++i)
    {
        response = spi_rec_byte();
    bf74:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
        if(response != 0xff)
    bf78:	8f 3f       	cpi	r24, 0xFF	; 255
    bf7a:	19 f4       	brne	.+6      	; 0xbf82 <sd_raw_send_command_r1+0x62>
    spi_send_byte((arg >> 8) & 0xff);
    spi_send_byte((arg >> 0) & 0xff);
    spi_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);
    
    /* receive response */
    for(uint8_t i = 0; i < 10; ++i)
    bf7c:	1f 5f       	subi	r17, 0xFF	; 255
    bf7e:	1a 30       	cpi	r17, 0x0A	; 10
    bf80:	c9 f7       	brne	.-14     	; 0xbf74 <sd_raw_send_command_r1+0x54>
        if(response != 0xff)
            break;
    }

    return response;
}
    bf82:	1f 91       	pop	r17
    bf84:	0f 91       	pop	r16
    bf86:	ff 90       	pop	r15
    bf88:	ef 90       	pop	r14
    bf8a:	df 90       	pop	r13
    bf8c:	08 95       	ret

0000bf8e <sd_raw_get_info>:
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
uint8_t sd_raw_get_info(struct sd_raw_info* info)
{
    bf8e:	cf 92       	push	r12
    bf90:	df 92       	push	r13
    bf92:	ef 92       	push	r14
    bf94:	ff 92       	push	r15
    bf96:	0f 93       	push	r16
    bf98:	1f 93       	push	r17
    bf9a:	cf 93       	push	r28
    bf9c:	df 93       	push	r29
    bf9e:	8c 01       	movw	r16, r24
    if(!info || !sd_raw_available())
    bfa0:	00 97       	sbiw	r24, 0x00	; 0
    bfa2:	09 f4       	brne	.+2      	; 0xbfa6 <sd_raw_get_info+0x18>
    bfa4:	08 c1       	rjmp	.+528    	; 0xc1b6 <sd_raw_get_info+0x228>
    bfa6:	06 99       	sbic	0x00, 6	; 0
    bfa8:	06 c1       	rjmp	.+524    	; 0xc1b6 <sd_raw_get_info+0x228>
        return 0;

    memset(info, 0, sizeof(*info));
    bfaa:	89 e1       	ldi	r24, 0x19	; 25
    bfac:	f8 01       	movw	r30, r16
    bfae:	11 92       	st	Z+, r1
    bfb0:	8a 95       	dec	r24
    bfb2:	e9 f7       	brne	.-6      	; 0xbfae <sd_raw_get_info+0x20>

    select_card();
    bfb4:	29 98       	cbi	0x05, 1	; 5

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
    bfb6:	8a e0       	ldi	r24, 0x0A	; 10
    bfb8:	40 e0       	ldi	r20, 0x00	; 0
    bfba:	50 e0       	ldi	r21, 0x00	; 0
    bfbc:	60 e0       	ldi	r22, 0x00	; 0
    bfbe:	70 e0       	ldi	r23, 0x00	; 0
    bfc0:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
    bfc4:	88 23       	and	r24, r24
    bfc6:	09 f0       	breq	.+2      	; 0xbfca <sd_raw_get_info+0x3c>
    bfc8:	78 c0       	rjmp	.+240    	; 0xc0ba <sd_raw_get_info+0x12c>
    {
        unselect_card();
        spi_rec_byte();
        return 0;
    bfca:	c0 e0       	ldi	r28, 0x00	; 0
    bfcc:	d0 e0       	ldi	r29, 0x00	; 0
    }

    uint16_t i;
    for(i = 0; i < 0x1fff; ++i)
    {
        if(spi_rec_byte() == 0xfe)
    bfce:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    bfd2:	8e 3f       	cpi	r24, 0xFE	; 254
    bfd4:	31 f0       	breq	.+12     	; 0xbfe2 <sd_raw_get_info+0x54>
        spi_rec_byte();
        return 0;
    }

    uint16_t i;
    for(i = 0; i < 0x1fff; ++i)
    bfd6:	21 96       	adiw	r28, 0x01	; 1
    bfd8:	ff e1       	ldi	r31, 0x1F	; 31
    bfda:	cf 3f       	cpi	r28, 0xFF	; 255
    bfdc:	df 07       	cpc	r29, r31
    bfde:	b9 f7       	brne	.-18     	; 0xbfce <sd_raw_get_info+0x40>
    bfe0:	6c c0       	rjmp	.+216    	; 0xc0ba <sd_raw_get_info+0x12c>
    }
    if(i >= 0x1fff)
    {
        unselect_card();
        spi_rec_byte();
        return 0;
    bfe2:	d0 2e       	mov	r13, r16
    bfe4:	c8 01       	movw	r24, r16
    bfe6:	ec 01       	movw	r28, r24
    bfe8:	e0 e6       	ldi	r30, 0x60	; 96
    bfea:	ee 2e       	mov	r14, r30
    bfec:	f1 2c       	mov	r15, r1
    }

    for(uint8_t i = 0; i < 18; ++i)
    {
        uint8_t b = spi_rec_byte();
    bfee:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    bff2:	28 2f       	mov	r18, r24

        switch(i)
    bff4:	ae 01       	movw	r20, r28
    bff6:	4d 19       	sub	r20, r13
    bff8:	48 30       	cpi	r20, 0x08	; 8
    bffa:	28 f4       	brcc	.+10     	; 0xc006 <sd_raw_get_info+0x78>
    bffc:	43 30       	cpi	r20, 0x03	; 3
    bffe:	90 f4       	brcc	.+36     	; 0xc024 <sd_raw_get_info+0x96>
    c000:	44 23       	and	r20, r20
    c002:	59 f0       	breq	.+22     	; 0xc01a <sd_raw_get_info+0x8c>
    c004:	0d c0       	rjmp	.+26     	; 0xc020 <sd_raw_get_info+0x92>
    c006:	4d 30       	cpi	r20, 0x0D	; 13
    c008:	18 f4       	brcc	.+6      	; 0xc010 <sd_raw_get_info+0x82>
    c00a:	49 30       	cpi	r20, 0x09	; 9
    c00c:	80 f4       	brcc	.+32     	; 0xc02e <sd_raw_get_info+0xa0>
    c00e:	0c c0       	rjmp	.+24     	; 0xc028 <sd_raw_get_info+0x9a>
    c010:	4d 30       	cpi	r20, 0x0D	; 13
    c012:	31 f1       	breq	.+76     	; 0xc060 <sd_raw_get_info+0xd2>
    c014:	4e 30       	cpi	r20, 0x0E	; 14
    c016:	91 f5       	brne	.+100    	; 0xc07c <sd_raw_get_info+0xee>
    c018:	28 c0       	rjmp	.+80     	; 0xc06a <sd_raw_get_info+0xdc>
        {
            case 0:
                info->manufacturer = b;
    c01a:	f8 01       	movw	r30, r16
    c01c:	20 83       	st	Z, r18
    c01e:	2e c0       	rjmp	.+92     	; 0xc07c <sd_raw_get_info+0xee>
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
    c020:	28 83       	st	Y, r18
    c022:	2c c0       	rjmp	.+88     	; 0xc07c <sd_raw_get_info+0xee>
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
    c024:	29 83       	std	Y+1, r18	; 0x01
    c026:	2a c0       	rjmp	.+84     	; 0xc07c <sd_raw_get_info+0xee>
                break;
            case 8:
                info->revision = b;
    c028:	f8 01       	movw	r30, r16
    c02a:	22 87       	std	Z+10, r18	; 0x0a
    c02c:	27 c0       	rjmp	.+78     	; 0xc07c <sd_raw_get_info+0xee>
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (uint32_t) b << ((12 - i) * 8);
    c02e:	30 e0       	ldi	r19, 0x00	; 0
    c030:	40 e0       	ldi	r20, 0x00	; 0
    c032:	50 e0       	ldi	r21, 0x00	; 0
    c034:	0e 2c       	mov	r0, r14
    c036:	04 c0       	rjmp	.+8      	; 0xc040 <sd_raw_get_info+0xb2>
    c038:	22 0f       	add	r18, r18
    c03a:	33 1f       	adc	r19, r19
    c03c:	44 1f       	adc	r20, r20
    c03e:	55 1f       	adc	r21, r21
    c040:	0a 94       	dec	r0
    c042:	d2 f7       	brpl	.-12     	; 0xc038 <sd_raw_get_info+0xaa>
    c044:	f8 01       	movw	r30, r16
    c046:	83 85       	ldd	r24, Z+11	; 0x0b
    c048:	94 85       	ldd	r25, Z+12	; 0x0c
    c04a:	a5 85       	ldd	r26, Z+13	; 0x0d
    c04c:	b6 85       	ldd	r27, Z+14	; 0x0e
    c04e:	82 2b       	or	r24, r18
    c050:	93 2b       	or	r25, r19
    c052:	a4 2b       	or	r26, r20
    c054:	b5 2b       	or	r27, r21
    c056:	83 87       	std	Z+11, r24	; 0x0b
    c058:	94 87       	std	Z+12, r25	; 0x0c
    c05a:	a5 87       	std	Z+13, r26	; 0x0d
    c05c:	b6 87       	std	Z+14, r27	; 0x0e
    c05e:	0e c0       	rjmp	.+28     	; 0xc07c <sd_raw_get_info+0xee>
                break;
            case 13:
                info->manufacturing_year = b << 4;
    c060:	22 95       	swap	r18
    c062:	20 7f       	andi	r18, 0xF0	; 240
    c064:	f8 01       	movw	r30, r16
    c066:	27 87       	std	Z+15, r18	; 0x0f
    c068:	09 c0       	rjmp	.+18     	; 0xc07c <sd_raw_get_info+0xee>
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
    c06a:	92 2f       	mov	r25, r18
    c06c:	92 95       	swap	r25
    c06e:	9f 70       	andi	r25, 0x0F	; 15
    c070:	f8 01       	movw	r30, r16
    c072:	87 85       	ldd	r24, Z+15	; 0x0f
    c074:	89 2b       	or	r24, r25
    c076:	87 87       	std	Z+15, r24	; 0x0f
                info->manufacturing_month = b & 0x0f;
    c078:	2f 70       	andi	r18, 0x0F	; 15
    c07a:	20 8b       	std	Z+16, r18	; 0x10
    c07c:	21 96       	adiw	r28, 0x01	; 1
    c07e:	48 ef       	ldi	r20, 0xF8	; 248
    c080:	5f ef       	ldi	r21, 0xFF	; 255
    c082:	e4 0e       	add	r14, r20
    c084:	f5 1e       	adc	r15, r21
        unselect_card();
        spi_rec_byte();
        return 0;
    }

    for(uint8_t i = 0; i < 18; ++i)
    c086:	50 ed       	ldi	r21, 0xD0	; 208
    c088:	e5 16       	cp	r14, r21
    c08a:	5f ef       	ldi	r21, 0xFF	; 255
    c08c:	f5 06       	cpc	r15, r21
    c08e:	09 f0       	breq	.+2      	; 0xc092 <sd_raw_get_info+0x104>
    c090:	ae cf       	rjmp	.-164    	; 0xbfee <sd_raw_get_info+0x60>

    /* read csd register */
    uint8_t csd_read_bl_len = 0;
    uint8_t csd_c_size_mult = 0;
    uint16_t csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
    c092:	89 e0       	ldi	r24, 0x09	; 9
    c094:	40 e0       	ldi	r20, 0x00	; 0
    c096:	50 e0       	ldi	r21, 0x00	; 0
    c098:	60 e0       	ldi	r22, 0x00	; 0
    c09a:	70 e0       	ldi	r23, 0x00	; 0
    c09c:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
    c0a0:	88 23       	and	r24, r24
    c0a2:	59 f4       	brne	.+22     	; 0xc0ba <sd_raw_get_info+0x12c>
    {
        unselect_card();
        spi_rec_byte();
        return 0;
    c0a4:	c0 e0       	ldi	r28, 0x00	; 0
    c0a6:	d0 e0       	ldi	r29, 0x00	; 0
    }

    for(i = 0; i < 0x1fff; ++i)
    {
        if(spi_rec_byte() == 0xfe)
    c0a8:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c0ac:	8e 3f       	cpi	r24, 0xFE	; 254
    c0ae:	49 f0       	breq	.+18     	; 0xc0c2 <sd_raw_get_info+0x134>
        unselect_card();
        spi_rec_byte();
        return 0;
    }

    for(i = 0; i < 0x1fff; ++i)
    c0b0:	21 96       	adiw	r28, 0x01	; 1
    c0b2:	8f e1       	ldi	r24, 0x1F	; 31
    c0b4:	cf 3f       	cpi	r28, 0xFF	; 255
    c0b6:	d8 07       	cpc	r29, r24
    c0b8:	b9 f7       	brne	.-18     	; 0xc0a8 <sd_raw_get_info+0x11a>
        if(spi_rec_byte() == 0xfe)
            break;
    }
    if(i >= 0x1fff)
    {
        unselect_card();
    c0ba:	29 9a       	sbi	0x05, 1	; 5
        spi_rec_byte();
    c0bc:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c0c0:	7a c0       	rjmp	.+244    	; 0xc1b6 <sd_raw_get_info+0x228>
        return 0;
    c0c2:	cc 24       	eor	r12, r12
    c0c4:	ee 24       	eor	r14, r14
    c0c6:	c0 e0       	ldi	r28, 0x00	; 0
    c0c8:	d0 e0       	ldi	r29, 0x00	; 0
    c0ca:	ff 24       	eor	r15, r15
                if(b & 0x40)
                    info->flag_copy = 1;
                if(b & 0x20)
                    info->flag_write_protect = 1;
                if(b & 0x10)
                    info->flag_write_protect_temp = 1;
    c0cc:	dd 24       	eor	r13, r13
    c0ce:	d3 94       	inc	r13
        return 0;
    }

    for(uint8_t i = 0; i < 18; ++i)
    {
        uint8_t b = spi_rec_byte();
    c0d0:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>

        switch(i)
    c0d4:	98 e0       	ldi	r25, 0x08	; 8
    c0d6:	f9 16       	cp	r15, r25
    c0d8:	41 f1       	breq	.+80     	; 0xc12a <sd_raw_get_info+0x19c>
    c0da:	9f 15       	cp	r25, r15
    c0dc:	50 f0       	brcs	.+20     	; 0xc0f2 <sd_raw_get_info+0x164>
    c0de:	e6 e0       	ldi	r30, 0x06	; 6
    c0e0:	fe 16       	cp	r15, r30
    c0e2:	a9 f0       	breq	.+42     	; 0xc10e <sd_raw_get_info+0x180>
    c0e4:	ef 15       	cp	r30, r15
    c0e6:	c8 f0       	brcs	.+50     	; 0xc11a <sd_raw_get_info+0x18c>
    c0e8:	f5 e0       	ldi	r31, 0x05	; 5
    c0ea:	ff 16       	cp	r15, r31
    c0ec:	09 f0       	breq	.+2      	; 0xc0f0 <sd_raw_get_info+0x162>
    c0ee:	59 c0       	rjmp	.+178    	; 0xc1a2 <sd_raw_get_info+0x214>
    c0f0:	0a c0       	rjmp	.+20     	; 0xc106 <sd_raw_get_info+0x178>
    c0f2:	4a e0       	ldi	r20, 0x0A	; 10
    c0f4:	f4 16       	cp	r15, r20
    c0f6:	39 f1       	breq	.+78     	; 0xc146 <sd_raw_get_info+0x1b8>
    c0f8:	f4 16       	cp	r15, r20
    c0fa:	00 f1       	brcs	.+64     	; 0xc13c <sd_raw_get_info+0x1ae>
    c0fc:	5e e0       	ldi	r21, 0x0E	; 14
    c0fe:	f5 16       	cp	r15, r21
    c100:	09 f0       	breq	.+2      	; 0xc104 <sd_raw_get_info+0x176>
    c102:	4f c0       	rjmp	.+158    	; 0xc1a2 <sd_raw_get_info+0x214>
    c104:	39 c0       	rjmp	.+114    	; 0xc178 <sd_raw_get_info+0x1ea>
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
    c106:	7f e0       	ldi	r23, 0x0F	; 15
    c108:	c7 2e       	mov	r12, r23
    c10a:	c8 22       	and	r12, r24
    c10c:	4a c0       	rjmp	.+148    	; 0xc1a2 <sd_raw_get_info+0x214>
                break;
            case 6:
                csd_c_size = (uint16_t) (b & 0x03) << 8;
    c10e:	90 e0       	ldi	r25, 0x00	; 0
    c110:	83 70       	andi	r24, 0x03	; 3
    c112:	90 70       	andi	r25, 0x00	; 0
    c114:	d8 2f       	mov	r29, r24
    c116:	cc 27       	eor	r28, r28
    c118:	44 c0       	rjmp	.+136    	; 0xc1a2 <sd_raw_get_info+0x214>
                break;
            case 7:
                csd_c_size |= b;
    c11a:	90 e0       	ldi	r25, 0x00	; 0
    c11c:	c8 2b       	or	r28, r24
    c11e:	d9 2b       	or	r29, r25
                csd_c_size <<= 2;
    c120:	cc 0f       	add	r28, r28
    c122:	dd 1f       	adc	r29, r29
    c124:	cc 0f       	add	r28, r28
    c126:	dd 1f       	adc	r29, r29
    c128:	3c c0       	rjmp	.+120    	; 0xc1a2 <sd_raw_get_info+0x214>
                break;
            case 8:
                csd_c_size |= b >> 6;
    c12a:	82 95       	swap	r24
    c12c:	86 95       	lsr	r24
    c12e:	86 95       	lsr	r24
    c130:	83 70       	andi	r24, 0x03	; 3
    c132:	90 e0       	ldi	r25, 0x00	; 0
    c134:	c8 2b       	or	r28, r24
    c136:	d9 2b       	or	r29, r25
                ++csd_c_size;
    c138:	21 96       	adiw	r28, 0x01	; 1
    c13a:	33 c0       	rjmp	.+102    	; 0xc1a2 <sd_raw_get_info+0x214>
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
    c13c:	43 e0       	ldi	r20, 0x03	; 3
    c13e:	e4 2e       	mov	r14, r20
    c140:	e8 22       	and	r14, r24
    c142:	ee 0c       	add	r14, r14
    c144:	2e c0       	rjmp	.+92     	; 0xc1a2 <sd_raw_get_info+0x214>
                break;
            case 10:
                csd_c_size_mult |= b >> 7;
    c146:	88 1f       	adc	r24, r24
    c148:	88 27       	eor	r24, r24
    c14a:	88 1f       	adc	r24, r24
    c14c:	e8 2a       	or	r14, r24

                info->capacity = (uint32_t) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);
    c14e:	9e 01       	movw	r18, r28
    c150:	40 e0       	ldi	r20, 0x00	; 0
    c152:	50 e0       	ldi	r21, 0x00	; 0
    c154:	8c 2d       	mov	r24, r12
    c156:	90 e0       	ldi	r25, 0x00	; 0
    c158:	02 96       	adiw	r24, 0x02	; 2
    c15a:	8e 0d       	add	r24, r14
    c15c:	91 1d       	adc	r25, r1
    c15e:	04 c0       	rjmp	.+8      	; 0xc168 <sd_raw_get_info+0x1da>
    c160:	22 0f       	add	r18, r18
    c162:	33 1f       	adc	r19, r19
    c164:	44 1f       	adc	r20, r20
    c166:	55 1f       	adc	r21, r21
    c168:	8a 95       	dec	r24
    c16a:	d2 f7       	brpl	.-12     	; 0xc160 <sd_raw_get_info+0x1d2>
    c16c:	f8 01       	movw	r30, r16
    c16e:	21 8b       	std	Z+17, r18	; 0x11
    c170:	32 8b       	std	Z+18, r19	; 0x12
    c172:	43 8b       	std	Z+19, r20	; 0x13
    c174:	54 8b       	std	Z+20, r21	; 0x14
    c176:	15 c0       	rjmp	.+42     	; 0xc1a2 <sd_raw_get_info+0x214>

                break;
            case 14:
                if(b & 0x40)
    c178:	90 e0       	ldi	r25, 0x00	; 0
    c17a:	86 ff       	sbrs	r24, 6
    c17c:	02 c0       	rjmp	.+4      	; 0xc182 <sd_raw_get_info+0x1f4>
                    info->flag_copy = 1;
    c17e:	f8 01       	movw	r30, r16
    c180:	d5 8a       	std	Z+21, r13	; 0x15
                if(b & 0x20)
    c182:	85 ff       	sbrs	r24, 5
    c184:	02 c0       	rjmp	.+4      	; 0xc18a <sd_raw_get_info+0x1fc>
                    info->flag_write_protect = 1;
    c186:	f8 01       	movw	r30, r16
    c188:	d6 8a       	std	Z+22, r13	; 0x16
                if(b & 0x10)
    c18a:	84 ff       	sbrs	r24, 4
    c18c:	02 c0       	rjmp	.+4      	; 0xc192 <sd_raw_get_info+0x204>
                    info->flag_write_protect_temp = 1;
    c18e:	f8 01       	movw	r30, r16
    c190:	d7 8a       	std	Z+23, r13	; 0x17
                info->format = (b & 0x0c) >> 2;
    c192:	8c 70       	andi	r24, 0x0C	; 12
    c194:	90 70       	andi	r25, 0x00	; 0
    c196:	95 95       	asr	r25
    c198:	87 95       	ror	r24
    c19a:	95 95       	asr	r25
    c19c:	87 95       	ror	r24
    c19e:	f8 01       	movw	r30, r16
    c1a0:	80 8f       	std	Z+24, r24	; 0x18
        unselect_card();
        spi_rec_byte();
        return 0;
    }

    for(uint8_t i = 0; i < 18; ++i)
    c1a2:	f3 94       	inc	r15
    c1a4:	f2 e1       	ldi	r31, 0x12	; 18
    c1a6:	ff 16       	cp	r15, r31
    c1a8:	09 f0       	breq	.+2      	; 0xc1ac <sd_raw_get_info+0x21e>
    c1aa:	92 cf       	rjmp	.-220    	; 0xc0d0 <sd_raw_get_info+0x142>
                info->format = (b & 0x0c) >> 2;
                break;
        }
    }

    unselect_card();
    c1ac:	29 9a       	sbi	0x05, 1	; 5
    spi_rec_byte();
    c1ae:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c1b2:	81 e0       	ldi	r24, 0x01	; 1
    c1b4:	01 c0       	rjmp	.+2      	; 0xc1b8 <sd_raw_get_info+0x22a>

    return 1;
    c1b6:	80 e0       	ldi	r24, 0x00	; 0
}
    c1b8:	df 91       	pop	r29
    c1ba:	cf 91       	pop	r28
    c1bc:	1f 91       	pop	r17
    c1be:	0f 91       	pop	r16
    c1c0:	ff 90       	pop	r15
    c1c2:	ef 90       	pop	r14
    c1c4:	df 90       	pop	r13
    c1c6:	cf 90       	pop	r12
    c1c8:	08 95       	ret

0000c1ca <sd_raw_read>:
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write, sd_raw_write_interval
 */
uint8_t sd_raw_read(uint32_t offset, uint8_t* buffer, uint16_t length)
{
    c1ca:	2f 92       	push	r2
    c1cc:	3f 92       	push	r3
    c1ce:	4f 92       	push	r4
    c1d0:	5f 92       	push	r5
    c1d2:	6f 92       	push	r6
    c1d4:	7f 92       	push	r7
    c1d6:	8f 92       	push	r8
    c1d8:	9f 92       	push	r9
    c1da:	af 92       	push	r10
    c1dc:	bf 92       	push	r11
    c1de:	cf 92       	push	r12
    c1e0:	df 92       	push	r13
    c1e2:	ef 92       	push	r14
    c1e4:	ff 92       	push	r15
    c1e6:	0f 93       	push	r16
    c1e8:	1f 93       	push	r17
    c1ea:	cf 93       	push	r28
    c1ec:	df 93       	push	r29
    c1ee:	3b 01       	movw	r6, r22
    c1f0:	4c 01       	movw	r8, r24
    c1f2:	5a 01       	movw	r10, r20
    c1f4:	19 01       	movw	r2, r18
    c1f6:	76 c0       	rjmp	.+236    	; 0xc2e4 <sd_raw_read+0x11a>
    uint16_t block_offset;
    uint16_t read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
    c1f8:	c1 2c       	mov	r12, r1
    c1fa:	ae ef       	ldi	r26, 0xFE	; 254
    c1fc:	da 2e       	mov	r13, r26
    c1fe:	af ef       	ldi	r26, 0xFF	; 255
    c200:	ea 2e       	mov	r14, r26
    c202:	af ef       	ldi	r26, 0xFF	; 255
    c204:	fa 2e       	mov	r15, r26
    c206:	c6 20       	and	r12, r6
    c208:	d7 20       	and	r13, r7
    c20a:	e8 20       	and	r14, r8
    c20c:	f9 20       	and	r15, r9
        block_offset = offset & 0x01ff;
    c20e:	ff ef       	ldi	r31, 0xFF	; 255
    c210:	4f 2e       	mov	r4, r31
    c212:	f1 e0       	ldi	r31, 0x01	; 1
    c214:	5f 2e       	mov	r5, r31
    c216:	46 20       	and	r4, r6
    c218:	57 20       	and	r5, r7
        read_length = 512 - block_offset; /* read up to block border */
    c21a:	00 e0       	ldi	r16, 0x00	; 0
    c21c:	12 e0       	ldi	r17, 0x02	; 2
    c21e:	04 19       	sub	r16, r4
    c220:	15 09       	sbc	r17, r5
    c222:	20 16       	cp	r2, r16
    c224:	31 06       	cpc	r3, r17
    c226:	08 f4       	brcc	.+2      	; 0xc22a <sd_raw_read+0x60>
    c228:	81 01       	movw	r16, r2
        if(read_length > length)
            read_length = length;
        
#if !SD_RAW_SAVE_RAM
        /* check if the requested data is cached */
        if(block_address != raw_block_address)
    c22a:	80 91 26 06 	lds	r24, 0x0626
    c22e:	90 91 27 06 	lds	r25, 0x0627
    c232:	a0 91 28 06 	lds	r26, 0x0628
    c236:	b0 91 29 06 	lds	r27, 0x0629
    c23a:	c8 16       	cp	r12, r24
    c23c:	d9 06       	cpc	r13, r25
    c23e:	ea 06       	cpc	r14, r26
    c240:	fb 06       	cpc	r15, r27
    c242:	e9 f1       	breq	.+122    	; 0xc2be <sd_raw_read+0xf4>
#endif
        {
#if SD_RAW_WRITE_BUFFERING
            if(!sd_raw_sync())
    c244:	0e 94 45 62 	call	0xc48a	; 0xc48a <sd_raw_sync>
    c248:	88 23       	and	r24, r24
    c24a:	09 f4       	brne	.+2      	; 0xc24e <sd_raw_read+0x84>
    c24c:	50 c0       	rjmp	.+160    	; 0xc2ee <sd_raw_read+0x124>
                return 0;
#endif

            /* address card */
            select_card();
    c24e:	29 98       	cbi	0x05, 1	; 5

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
    c250:	81 e1       	ldi	r24, 0x11	; 17
    c252:	b7 01       	movw	r22, r14
    c254:	a6 01       	movw	r20, r12
    c256:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
    c25a:	88 23       	and	r24, r24
    c25c:	59 f4       	brne	.+22     	; 0xc274 <sd_raw_read+0xaa>
            {
                unselect_card();
                spi_rec_byte();
                return 0;
    c25e:	c0 e0       	ldi	r28, 0x00	; 0
    c260:	d0 e0       	ldi	r29, 0x00	; 0

            /* wait for data block (start byte 0xfe) */
            uint16_t i;
            for(i = 0; i < 0x1fff; ++i)
            {
                if(spi_rec_byte() == 0xfe)
    c262:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c266:	8e 3f       	cpi	r24, 0xFE	; 254
    c268:	51 f0       	breq	.+20     	; 0xc27e <sd_raw_read+0xb4>
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            uint16_t i;
            for(i = 0; i < 0x1fff; ++i)
    c26a:	21 96       	adiw	r28, 0x01	; 1
    c26c:	8f e1       	ldi	r24, 0x1F	; 31
    c26e:	cf 3f       	cpi	r28, 0xFF	; 255
    c270:	d8 07       	cpc	r29, r24
    c272:	b9 f7       	brne	.-18     	; 0xc262 <sd_raw_read+0x98>
                if(spi_rec_byte() == 0xfe)
                    break;
            }
            if(i >= 0x1fff)
            {
                unselect_card();
    c274:	29 9a       	sbi	0x05, 1	; 5
                spi_rec_byte();
    c276:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c27a:	80 e0       	ldi	r24, 0x00	; 0
    c27c:	38 c0       	rjmp	.+112    	; 0xc2ee <sd_raw_read+0x124>
                if(i >= block_offset && i < read_to)
                    *buffer++ = b;
            }
#else
            /* read byte block */
            spi_rec_data(raw_block, 512);
    c27e:	86 e2       	ldi	r24, 0x26	; 38
    c280:	94 e0       	ldi	r25, 0x04	; 4
    c282:	60 e0       	ldi	r22, 0x00	; 0
    c284:	72 e0       	ldi	r23, 0x02	; 2
    c286:	0e 94 a6 64 	call	0xc94c	; 0xc94c <spi_rec_data>
            raw_block_address = block_address;
    c28a:	c0 92 26 06 	sts	0x0626, r12
    c28e:	d0 92 27 06 	sts	0x0627, r13
    c292:	e0 92 28 06 	sts	0x0628, r14
    c296:	f0 92 29 06 	sts	0x0629, r15

            memcpy(buffer, raw_block + block_offset, read_length);
    c29a:	92 01       	movw	r18, r4
    c29c:	2a 5d       	subi	r18, 0xDA	; 218
    c29e:	3b 4f       	sbci	r19, 0xFB	; 251
    c2a0:	c5 01       	movw	r24, r10
    c2a2:	b9 01       	movw	r22, r18
    c2a4:	a8 01       	movw	r20, r16
    c2a6:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <memcpy>
            buffer += read_length;
    c2aa:	a0 0e       	add	r10, r16
    c2ac:	b1 1e       	adc	r11, r17
#endif
            
            /* read crc16 */
            spi_rec_byte();
    c2ae:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
            spi_rec_byte();
    c2b2:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
            
            /* deaddress card */
            unselect_card();
    c2b6:	29 9a       	sbi	0x05, 1	; 5
            spi_rec_byte();
    c2b8:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c2bc:	0a c0       	rjmp	.+20     	; 0xc2d2 <sd_raw_read+0x108>
        }
#if !SD_RAW_SAVE_RAM
        else
        {
            /* use cached data */
            memcpy(buffer, raw_block + block_offset, read_length);
    c2be:	92 01       	movw	r18, r4
    c2c0:	2a 5d       	subi	r18, 0xDA	; 218
    c2c2:	3b 4f       	sbci	r19, 0xFB	; 251
    c2c4:	c5 01       	movw	r24, r10
    c2c6:	b9 01       	movw	r22, r18
    c2c8:	a8 01       	movw	r20, r16
    c2ca:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <memcpy>
            buffer += read_length;
    c2ce:	a0 0e       	add	r10, r16
    c2d0:	b1 1e       	adc	r11, r17
        }
#endif

        length -= read_length;
    c2d2:	20 1a       	sub	r2, r16
    c2d4:	31 0a       	sbc	r3, r17
        offset += read_length;
    c2d6:	c8 01       	movw	r24, r16
    c2d8:	a0 e0       	ldi	r26, 0x00	; 0
    c2da:	b0 e0       	ldi	r27, 0x00	; 0
    c2dc:	68 0e       	add	r6, r24
    c2de:	79 1e       	adc	r7, r25
    c2e0:	8a 1e       	adc	r8, r26
    c2e2:	9b 1e       	adc	r9, r27
uint8_t sd_raw_read(uint32_t offset, uint8_t* buffer, uint16_t length)
{
    uint32_t block_address;
    uint16_t block_offset;
    uint16_t read_length;
    while(length > 0)
    c2e4:	21 14       	cp	r2, r1
    c2e6:	31 04       	cpc	r3, r1
    c2e8:	09 f0       	breq	.+2      	; 0xc2ec <sd_raw_read+0x122>
    c2ea:	86 cf       	rjmp	.-244    	; 0xc1f8 <sd_raw_read+0x2e>
    c2ec:	81 e0       	ldi	r24, 0x01	; 1
        length -= read_length;
        offset += read_length;
    }

    return 1;
}
    c2ee:	df 91       	pop	r29
    c2f0:	cf 91       	pop	r28
    c2f2:	1f 91       	pop	r17
    c2f4:	0f 91       	pop	r16
    c2f6:	ff 90       	pop	r15
    c2f8:	ef 90       	pop	r14
    c2fa:	df 90       	pop	r13
    c2fc:	cf 90       	pop	r12
    c2fe:	bf 90       	pop	r11
    c300:	af 90       	pop	r10
    c302:	9f 90       	pop	r9
    c304:	8f 90       	pop	r8
    c306:	7f 90       	pop	r7
    c308:	6f 90       	pop	r6
    c30a:	5f 90       	pop	r5
    c30c:	4f 90       	pop	r4
    c30e:	3f 90       	pop	r3
    c310:	2f 90       	pop	r2
    c312:	08 95       	ret

0000c314 <sd_raw_write>:
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write_interval, sd_raw_read, sd_raw_read_interval
 */
uint8_t sd_raw_write(uint32_t offset, const uint8_t* buffer, uint16_t length)
{
    c314:	2f 92       	push	r2
    c316:	3f 92       	push	r3
    c318:	4f 92       	push	r4
    c31a:	5f 92       	push	r5
    c31c:	6f 92       	push	r6
    c31e:	7f 92       	push	r7
    c320:	8f 92       	push	r8
    c322:	9f 92       	push	r9
    c324:	af 92       	push	r10
    c326:	bf 92       	push	r11
    c328:	cf 92       	push	r12
    c32a:	df 92       	push	r13
    c32c:	ef 92       	push	r14
    c32e:	ff 92       	push	r15
    c330:	0f 93       	push	r16
    c332:	1f 93       	push	r17
    c334:	cf 93       	push	r28
    c336:	df 93       	push	r29
    c338:	4b 01       	movw	r8, r22
    c33a:	5c 01       	movw	r10, r24
    c33c:	2a 01       	movw	r4, r20
    c33e:	39 01       	movw	r6, r18
    while(length > 0)
    {
        /* determine byte count to write at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
        write_length = 512 - block_offset; /* write up to block border */
    c340:	21 2c       	mov	r2, r1
    c342:	92 e0       	ldi	r25, 0x02	; 2
    c344:	39 2e       	mov	r3, r25
    c346:	86 c0       	rjmp	.+268    	; 0xc454 <sd_raw_write+0x140>
    uint16_t block_offset;
    uint16_t write_length;
    while(length > 0)
    {
        /* determine byte count to write at once */
        block_address = offset & 0xfffffe00;
    c348:	e1 2c       	mov	r14, r1
    c34a:	8e ef       	ldi	r24, 0xFE	; 254
    c34c:	f8 2e       	mov	r15, r24
    c34e:	8f ef       	ldi	r24, 0xFF	; 255
    c350:	08 2f       	mov	r16, r24
    c352:	8f ef       	ldi	r24, 0xFF	; 255
    c354:	18 2f       	mov	r17, r24
    c356:	e8 20       	and	r14, r8
    c358:	f9 20       	and	r15, r9
    c35a:	0a 21       	and	r16, r10
    c35c:	1b 21       	and	r17, r11
        block_offset = offset & 0x01ff;
    c35e:	bf ef       	ldi	r27, 0xFF	; 255
    c360:	cb 2e       	mov	r12, r27
    c362:	b1 e0       	ldi	r27, 0x01	; 1
    c364:	db 2e       	mov	r13, r27
    c366:	c8 20       	and	r12, r8
    c368:	d9 20       	and	r13, r9
        write_length = 512 - block_offset; /* write up to block border */
    c36a:	e1 01       	movw	r28, r2
    c36c:	cc 19       	sub	r28, r12
    c36e:	dd 09       	sbc	r29, r13
    c370:	6c 16       	cp	r6, r28
    c372:	7d 06       	cpc	r7, r29
    c374:	08 f4       	brcc	.+2      	; 0xc378 <sd_raw_write+0x64>
    c376:	e3 01       	movw	r28, r6
            write_length = length;
        
        /* Merge the data to write with the content of the block.
         * Use the cached block if available.
         */
        if(block_address != raw_block_address)
    c378:	80 91 26 06 	lds	r24, 0x0626
    c37c:	90 91 27 06 	lds	r25, 0x0627
    c380:	a0 91 28 06 	lds	r26, 0x0628
    c384:	b0 91 29 06 	lds	r27, 0x0629
    c388:	e8 16       	cp	r14, r24
    c38a:	f9 06       	cpc	r15, r25
    c38c:	0a 07       	cpc	r16, r26
    c38e:	1b 07       	cpc	r17, r27
    c390:	f9 f0       	breq	.+62     	; 0xc3d0 <sd_raw_write+0xbc>
        {
#if SD_RAW_WRITE_BUFFERING
            if(!sd_raw_sync())
    c392:	0e 94 45 62 	call	0xc48a	; 0xc48a <sd_raw_sync>
    c396:	88 23       	and	r24, r24
    c398:	09 f4       	brne	.+2      	; 0xc39c <sd_raw_write+0x88>
    c39a:	61 c0       	rjmp	.+194    	; 0xc45e <sd_raw_write+0x14a>
                return 0;
#endif

            if(block_offset || write_length < 512)
    c39c:	c1 14       	cp	r12, r1
    c39e:	d1 04       	cpc	r13, r1
    c3a0:	21 f4       	brne	.+8      	; 0xc3aa <sd_raw_write+0x96>
    c3a2:	82 e0       	ldi	r24, 0x02	; 2
    c3a4:	c0 30       	cpi	r28, 0x00	; 0
    c3a6:	d8 07       	cpc	r29, r24
    c3a8:	58 f4       	brcc	.+22     	; 0xc3c0 <sd_raw_write+0xac>
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
    c3aa:	c8 01       	movw	r24, r16
    c3ac:	b7 01       	movw	r22, r14
    c3ae:	46 e2       	ldi	r20, 0x26	; 38
    c3b0:	54 e0       	ldi	r21, 0x04	; 4
    c3b2:	20 e0       	ldi	r18, 0x00	; 0
    c3b4:	32 e0       	ldi	r19, 0x02	; 2
    c3b6:	0e 94 e5 60 	call	0xc1ca	; 0xc1ca <sd_raw_read>
    c3ba:	88 23       	and	r24, r24
    c3bc:	09 f4       	brne	.+2      	; 0xc3c0 <sd_raw_write+0xac>
    c3be:	4f c0       	rjmp	.+158    	; 0xc45e <sd_raw_write+0x14a>
                    return 0;
            }
            raw_block_address = block_address;
    c3c0:	e0 92 26 06 	sts	0x0626, r14
    c3c4:	f0 92 27 06 	sts	0x0627, r15
    c3c8:	00 93 28 06 	sts	0x0628, r16
    c3cc:	10 93 29 06 	sts	0x0629, r17
        }

        if(buffer != raw_block)
    c3d0:	86 e2       	ldi	r24, 0x26	; 38
    c3d2:	48 16       	cp	r4, r24
    c3d4:	84 e0       	ldi	r24, 0x04	; 4
    c3d6:	58 06       	cpc	r5, r24
    c3d8:	69 f0       	breq	.+26     	; 0xc3f4 <sd_raw_write+0xe0>
        {
            memcpy(raw_block + block_offset, buffer, write_length);
    c3da:	96 01       	movw	r18, r12
    c3dc:	2a 5d       	subi	r18, 0xDA	; 218
    c3de:	3b 4f       	sbci	r19, 0xFB	; 251
    c3e0:	c9 01       	movw	r24, r18
    c3e2:	b2 01       	movw	r22, r4
    c3e4:	ae 01       	movw	r20, r28
    c3e6:	0e 94 3e 6e 	call	0xdc7c	; 0xdc7c <memcpy>

#if SD_RAW_WRITE_BUFFERING
            raw_block_written = 0;
    c3ea:	10 92 2a 06 	sts	0x062A, r1

            if(length == write_length)
    c3ee:	6c 16       	cp	r6, r28
    c3f0:	7d 06       	cpc	r7, r29
    c3f2:	b9 f1       	breq	.+110    	; 0xc462 <sd_raw_write+0x14e>
                return 1;
#endif
        }

        /* address card */
        select_card();
    c3f4:	29 98       	cbi	0x05, 1	; 5

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
    c3f6:	88 e1       	ldi	r24, 0x18	; 24
    c3f8:	b8 01       	movw	r22, r16
    c3fa:	a7 01       	movw	r20, r14
    c3fc:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
    c400:	88 23       	and	r24, r24
    c402:	21 f0       	breq	.+8      	; 0xc40c <sd_raw_write+0xf8>
        {
            unselect_card();
    c404:	29 9a       	sbi	0x05, 1	; 5
            spi_rec_byte();
    c406:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c40a:	29 c0       	rjmp	.+82     	; 0xc45e <sd_raw_write+0x14a>
            return 0;
        }

        /* send start byte */
        spi_send_byte(0xfe);
    c40c:	8e ef       	ldi	r24, 0xFE	; 254
    c40e:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>

        /* write byte block */
        spi_send_data(raw_block, 512);
    c412:	86 e2       	ldi	r24, 0x26	; 38
    c414:	94 e0       	ldi	r25, 0x04	; 4
    c416:	60 e0       	ldi	r22, 0x00	; 0
    c418:	72 e0       	ldi	r23, 0x02	; 2
    c41a:	0e 94 99 64 	call	0xc932	; 0xc932 <spi_send_data>

        /* write dummy crc16 */
        spi_send_byte(0xff);
    c41e:	8f ef       	ldi	r24, 0xFF	; 255
    c420:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
        spi_send_byte(0xff);
    c424:	8f ef       	ldi	r24, 0xFF	; 255
    c426:	0e 94 8d 64 	call	0xc91a	; 0xc91a <spi_send_byte>
        }
*/
		// obiger code reicht bei langsamen Karten nicht aus!
		// daher nachfolgende alte Version mit endlos Warteschleife
		// Wil.
        while(spi_rec_byte() != 0xff);
    c42a:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
    c42e:	8f 3f       	cpi	r24, 0xFF	; 255
    c430:	e1 f7       	brne	.-8      	; 0xc42a <sd_raw_write+0x116>
        spi_rec_byte();
    c432:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>

        /* deaddress card */
        unselect_card();
    c436:	29 9a       	sbi	0x05, 1	; 5

        buffer += write_length;
    c438:	4c 0e       	add	r4, r28
    c43a:	5d 1e       	adc	r5, r29
        offset += write_length;
    c43c:	ce 01       	movw	r24, r28
    c43e:	a0 e0       	ldi	r26, 0x00	; 0
    c440:	b0 e0       	ldi	r27, 0x00	; 0
    c442:	88 0e       	add	r8, r24
    c444:	99 1e       	adc	r9, r25
    c446:	aa 1e       	adc	r10, r26
    c448:	bb 1e       	adc	r11, r27
        length -= write_length;
    c44a:	6c 1a       	sub	r6, r28
    c44c:	7d 0a       	sbc	r7, r29

#if SD_RAW_WRITE_BUFFERING
        raw_block_written = 1;
    c44e:	81 e0       	ldi	r24, 0x01	; 1
    c450:	80 93 2a 06 	sts	0x062A, r24
        return 0;

    uint32_t block_address;
    uint16_t block_offset;
    uint16_t write_length;
    while(length > 0)
    c454:	61 14       	cp	r6, r1
    c456:	71 04       	cpc	r7, r1
    c458:	09 f0       	breq	.+2      	; 0xc45c <sd_raw_write+0x148>
    c45a:	76 cf       	rjmp	.-276    	; 0xc348 <sd_raw_write+0x34>
    c45c:	02 c0       	rjmp	.+4      	; 0xc462 <sd_raw_write+0x14e>
    c45e:	80 e0       	ldi	r24, 0x00	; 0
    c460:	01 c0       	rjmp	.+2      	; 0xc464 <sd_raw_write+0x150>
    c462:	81 e0       	ldi	r24, 0x01	; 1

    return 1;
#else
    return 0;
#endif
}
    c464:	df 91       	pop	r29
    c466:	cf 91       	pop	r28
    c468:	1f 91       	pop	r17
    c46a:	0f 91       	pop	r16
    c46c:	ff 90       	pop	r15
    c46e:	ef 90       	pop	r14
    c470:	df 90       	pop	r13
    c472:	cf 90       	pop	r12
    c474:	bf 90       	pop	r11
    c476:	af 90       	pop	r10
    c478:	9f 90       	pop	r9
    c47a:	8f 90       	pop	r8
    c47c:	7f 90       	pop	r7
    c47e:	6f 90       	pop	r6
    c480:	5f 90       	pop	r5
    c482:	4f 90       	pop	r4
    c484:	3f 90       	pop	r3
    c486:	2f 90       	pop	r2
    c488:	08 95       	ret

0000c48a <sd_raw_sync>:
 */
uint8_t sd_raw_sync()
{
#if SD_RAW_WRITE_SUPPORT
#if SD_RAW_WRITE_BUFFERING
    if(raw_block_written)
    c48a:	80 91 2a 06 	lds	r24, 0x062A
    c48e:	88 23       	and	r24, r24
    c490:	11 f0       	breq	.+4      	; 0xc496 <sd_raw_sync+0xc>
    c492:	81 e0       	ldi	r24, 0x01	; 1
    c494:	08 95       	ret
        return 1;
    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
    c496:	60 91 26 06 	lds	r22, 0x0626
    c49a:	70 91 27 06 	lds	r23, 0x0627
    c49e:	80 91 28 06 	lds	r24, 0x0628
    c4a2:	90 91 29 06 	lds	r25, 0x0629
    c4a6:	46 e2       	ldi	r20, 0x26	; 38
    c4a8:	54 e0       	ldi	r21, 0x04	; 4
    c4aa:	20 e0       	ldi	r18, 0x00	; 0
    c4ac:	32 e0       	ldi	r19, 0x02	; 2
    c4ae:	0e 94 8a 61 	call	0xc314	; 0xc314 <sd_raw_write>
    c4b2:	88 23       	and	r24, r24
    c4b4:	19 f0       	breq	.+6      	; 0xc4bc <sd_raw_sync+0x32>
        return 0;
    raw_block_written = 1;
    c4b6:	81 e0       	ldi	r24, 0x01	; 1
    c4b8:	80 93 2a 06 	sts	0x062A, r24
#endif
    return 1;
#else
    return 0;
#endif
}
    c4bc:	08 95       	ret

0000c4be <sd_raw_write_interval>:
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read_interval, sd_raw_write, sd_raw_read
 */
uint8_t sd_raw_write_interval(uint32_t offset, uint8_t* buffer, uint16_t length, sd_raw_write_interval_handler_t callback, void* p)
{
    c4be:	4f 92       	push	r4
    c4c0:	5f 92       	push	r5
    c4c2:	6f 92       	push	r6
    c4c4:	7f 92       	push	r7
    c4c6:	8f 92       	push	r8
    c4c8:	9f 92       	push	r9
    c4ca:	af 92       	push	r10
    c4cc:	bf 92       	push	r11
    c4ce:	cf 92       	push	r12
    c4d0:	df 92       	push	r13
    c4d2:	ef 92       	push	r14
    c4d4:	ff 92       	push	r15
    c4d6:	0f 93       	push	r16
    c4d8:	1f 93       	push	r17
    c4da:	cf 93       	push	r28
    c4dc:	df 93       	push	r29
    c4de:	5b 01       	movw	r10, r22
    c4e0:	6c 01       	movw	r12, r24
    c4e2:	4a 01       	movw	r8, r20
    c4e4:	e9 01       	movw	r28, r18
    c4e6:	38 01       	movw	r6, r16
    c4e8:	27 01       	movw	r4, r14

#if SD_RAW_SAVE_RAM
    #error "SD_RAW_WRITE_SUPPORT is not supported together with SD_RAW_SAVE_RAM"
#endif

    if(!buffer || !callback)
    c4ea:	41 15       	cp	r20, r1
    c4ec:	51 05       	cpc	r21, r1
    c4ee:	71 f1       	breq	.+92     	; 0xc54c <sd_raw_write_interval+0x8e>
    c4f0:	01 15       	cp	r16, r1
    c4f2:	11 05       	cpc	r17, r1
    c4f4:	59 f1       	breq	.+86     	; 0xc54c <sd_raw_write_interval+0x8e>
        return 0;

    uint8_t endless = (length == 0);
    c4f6:	ff 24       	eor	r15, r15
    c4f8:	21 15       	cp	r18, r1
    c4fa:	31 05       	cpc	r19, r1
    c4fc:	11 f5       	brne	.+68     	; 0xc542 <sd_raw_write_interval+0x84>
    c4fe:	ff 24       	eor	r15, r15
    c500:	f3 94       	inc	r15
    c502:	1f c0       	rjmp	.+62     	; 0xc542 <sd_raw_write_interval+0x84>
    while(endless || length > 0)
    {
        uint16_t bytes_to_write = callback(buffer, offset, p);
    c504:	c4 01       	movw	r24, r8
    c506:	b6 01       	movw	r22, r12
    c508:	a5 01       	movw	r20, r10
    c50a:	92 01       	movw	r18, r4
    c50c:	f3 01       	movw	r30, r6
    c50e:	09 95       	icall
    c510:	8c 01       	movw	r16, r24
        if(!bytes_to_write)
    c512:	00 97       	sbiw	r24, 0x00	; 0
    c514:	e9 f0       	breq	.+58     	; 0xc550 <sd_raw_write_interval+0x92>
            break;
        if(!endless && bytes_to_write > length)
    c516:	ff 20       	and	r15, r15
    c518:	19 f4       	brne	.+6      	; 0xc520 <sd_raw_write_interval+0x62>
    c51a:	c8 17       	cp	r28, r24
    c51c:	d9 07       	cpc	r29, r25
    c51e:	b0 f0       	brcs	.+44     	; 0xc54c <sd_raw_write_interval+0x8e>
            return 0;

        /* as writing is always buffered, we directly
         * hand over the request to sd_raw_write()
         */
        if(!sd_raw_write(offset, buffer, bytes_to_write))
    c520:	c6 01       	movw	r24, r12
    c522:	b5 01       	movw	r22, r10
    c524:	a4 01       	movw	r20, r8
    c526:	98 01       	movw	r18, r16
    c528:	0e 94 8a 61 	call	0xc314	; 0xc314 <sd_raw_write>
    c52c:	88 23       	and	r24, r24
    c52e:	71 f0       	breq	.+28     	; 0xc54c <sd_raw_write_interval+0x8e>
            return 0;

        offset += bytes_to_write;
    c530:	c8 01       	movw	r24, r16
    c532:	a0 e0       	ldi	r26, 0x00	; 0
    c534:	b0 e0       	ldi	r27, 0x00	; 0
    c536:	a8 0e       	add	r10, r24
    c538:	b9 1e       	adc	r11, r25
    c53a:	ca 1e       	adc	r12, r26
    c53c:	db 1e       	adc	r13, r27
        length -= bytes_to_write;
    c53e:	c0 1b       	sub	r28, r16
    c540:	d1 0b       	sbc	r29, r17

    if(!buffer || !callback)
        return 0;

    uint8_t endless = (length == 0);
    while(endless || length > 0)
    c542:	ff 20       	and	r15, r15
    c544:	f9 f6       	brne	.-66     	; 0xc504 <sd_raw_write_interval+0x46>
    c546:	20 97       	sbiw	r28, 0x00	; 0
    c548:	e9 f6       	brne	.-70     	; 0xc504 <sd_raw_write_interval+0x46>
    c54a:	02 c0       	rjmp	.+4      	; 0xc550 <sd_raw_write_interval+0x92>
    c54c:	80 e0       	ldi	r24, 0x00	; 0
    c54e:	01 c0       	rjmp	.+2      	; 0xc552 <sd_raw_write_interval+0x94>
    c550:	81 e0       	ldi	r24, 0x01	; 1
    return 1;

#else
    return 0;
#endif
}
    c552:	df 91       	pop	r29
    c554:	cf 91       	pop	r28
    c556:	1f 91       	pop	r17
    c558:	0f 91       	pop	r16
    c55a:	ff 90       	pop	r15
    c55c:	ef 90       	pop	r14
    c55e:	df 90       	pop	r13
    c560:	cf 90       	pop	r12
    c562:	bf 90       	pop	r11
    c564:	af 90       	pop	r10
    c566:	9f 90       	pop	r9
    c568:	8f 90       	pop	r8
    c56a:	7f 90       	pop	r7
    c56c:	6f 90       	pop	r6
    c56e:	5f 90       	pop	r5
    c570:	4f 90       	pop	r4
    c572:	08 95       	ret

0000c574 <sd_raw_read_interval>:
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_write_interval, sd_raw_read, sd_raw_write
 */
uint8_t sd_raw_read_interval(uint32_t offset, uint8_t* buffer, uint16_t interval, uint16_t length, sd_raw_read_interval_handler_t callback, void* p)
{
    c574:	2f 92       	push	r2
    c576:	3f 92       	push	r3
    c578:	4f 92       	push	r4
    c57a:	5f 92       	push	r5
    c57c:	6f 92       	push	r6
    c57e:	7f 92       	push	r7
    c580:	8f 92       	push	r8
    c582:	9f 92       	push	r9
    c584:	af 92       	push	r10
    c586:	bf 92       	push	r11
    c588:	cf 92       	push	r12
    c58a:	df 92       	push	r13
    c58c:	ef 92       	push	r14
    c58e:	ff 92       	push	r15
    c590:	0f 93       	push	r16
    c592:	1f 93       	push	r17
    c594:	df 93       	push	r29
    c596:	cf 93       	push	r28
    c598:	00 d0       	rcall	.+0      	; 0xc59a <sd_raw_read_interval+0x26>
    c59a:	00 d0       	rcall	.+0      	; 0xc59c <sd_raw_read_interval+0x28>
    c59c:	cd b7       	in	r28, 0x3d	; 61
    c59e:	de b7       	in	r29, 0x3e	; 62
    c5a0:	4b 01       	movw	r8, r22
    c5a2:	5c 01       	movw	r10, r24
    c5a4:	3a 01       	movw	r6, r20
    c5a6:	3c 83       	std	Y+4, r19	; 0x04
    c5a8:	2b 83       	std	Y+3, r18	; 0x03
    c5aa:	27 01       	movw	r4, r14
    c5ac:	da 82       	std	Y+2, r13	; 0x02
    c5ae:	c9 82       	std	Y+1, r12	; 0x01
    if(!buffer || interval == 0 || length < interval || !callback)
    c5b0:	41 15       	cp	r20, r1
    c5b2:	51 05       	cpc	r21, r1
    c5b4:	a9 f1       	breq	.+106    	; 0xc620 <sd_raw_read_interval+0xac>
    c5b6:	21 15       	cp	r18, r1
    c5b8:	31 05       	cpc	r19, r1
    c5ba:	91 f1       	breq	.+100    	; 0xc620 <sd_raw_read_interval+0xac>
    c5bc:	02 17       	cp	r16, r18
    c5be:	13 07       	cpc	r17, r19
    c5c0:	78 f1       	brcs	.+94     	; 0xc620 <sd_raw_read_interval+0xac>
    c5c2:	e1 14       	cp	r14, r1
    c5c4:	f1 04       	cpc	r15, r1
    c5c6:	61 f1       	breq	.+88     	; 0xc620 <sd_raw_read_interval+0xac>
    c5c8:	19 01       	movw	r2, r18
    c5ca:	30 94       	com	r3
    c5cc:	21 94       	neg	r2
    c5ce:	31 08       	sbc	r3, r1
    c5d0:	33 94       	inc	r3
    c5d2:	02 1b       	sub	r16, r18
    c5d4:	13 0b       	sbc	r17, r19
        return 0;

#if !SD_RAW_SAVE_RAM
    while(length >= interval)
    c5d6:	69 01       	movw	r12, r18
    c5d8:	ee 24       	eor	r14, r14
    c5da:	ff 24       	eor	r15, r15
    {
        /* as reading is now buffered, we directly
         * hand over the request to sd_raw_read()
         */
        if(!sd_raw_read(offset, buffer, interval))
    c5dc:	c5 01       	movw	r24, r10
    c5de:	b4 01       	movw	r22, r8
    c5e0:	a3 01       	movw	r20, r6
    c5e2:	2b 81       	ldd	r18, Y+3	; 0x03
    c5e4:	3c 81       	ldd	r19, Y+4	; 0x04
    c5e6:	0e 94 e5 60 	call	0xc1ca	; 0xc1ca <sd_raw_read>
    c5ea:	88 23       	and	r24, r24
    c5ec:	c9 f0       	breq	.+50     	; 0xc620 <sd_raw_read_interval+0xac>
            return 0;
        if(!callback(buffer, offset, p))
    c5ee:	c3 01       	movw	r24, r6
    c5f0:	b5 01       	movw	r22, r10
    c5f2:	a4 01       	movw	r20, r8
    c5f4:	29 81       	ldd	r18, Y+1	; 0x01
    c5f6:	3a 81       	ldd	r19, Y+2	; 0x02
    c5f8:	f2 01       	movw	r30, r4
    c5fa:	09 95       	icall
    c5fc:	88 23       	and	r24, r24
    c5fe:	91 f0       	breq	.+36     	; 0xc624 <sd_raw_read_interval+0xb0>
            break;
    c600:	02 0d       	add	r16, r2
    c602:	13 1d       	adc	r17, r3
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

#if !SD_RAW_SAVE_RAM
    while(length >= interval)
    c604:	8b 81       	ldd	r24, Y+3	; 0x03
    c606:	9c 81       	ldd	r25, Y+4	; 0x04
    c608:	80 0f       	add	r24, r16
    c60a:	91 1f       	adc	r25, r17
    c60c:	2b 81       	ldd	r18, Y+3	; 0x03
    c60e:	3c 81       	ldd	r19, Y+4	; 0x04
    c610:	82 17       	cp	r24, r18
    c612:	93 07       	cpc	r25, r19
    c614:	38 f0       	brcs	.+14     	; 0xc624 <sd_raw_read_interval+0xb0>
    c616:	8c 0c       	add	r8, r12
    c618:	9d 1c       	adc	r9, r13
    c61a:	ae 1c       	adc	r10, r14
    c61c:	bf 1c       	adc	r11, r15
    c61e:	de cf       	rjmp	.-68     	; 0xc5dc <sd_raw_read_interval+0x68>
    c620:	80 e0       	ldi	r24, 0x00	; 0
    c622:	01 c0       	rjmp	.+2      	; 0xc626 <sd_raw_read_interval+0xb2>
    c624:	81 e0       	ldi	r24, 0x01	; 1
    unselect_card();
    spi_rec_byte();

    return 1;
#endif
}
    c626:	0f 90       	pop	r0
    c628:	0f 90       	pop	r0
    c62a:	0f 90       	pop	r0
    c62c:	0f 90       	pop	r0
    c62e:	cf 91       	pop	r28
    c630:	df 91       	pop	r29
    c632:	1f 91       	pop	r17
    c634:	0f 91       	pop	r16
    c636:	ff 90       	pop	r15
    c638:	ef 90       	pop	r14
    c63a:	df 90       	pop	r13
    c63c:	cf 90       	pop	r12
    c63e:	bf 90       	pop	r11
    c640:	af 90       	pop	r10
    c642:	9f 90       	pop	r9
    c644:	8f 90       	pop	r8
    c646:	7f 90       	pop	r7
    c648:	6f 90       	pop	r6
    c64a:	5f 90       	pop	r5
    c64c:	4f 90       	pop	r4
    c64e:	3f 90       	pop	r3
    c650:	2f 90       	pop	r2
    c652:	08 95       	ret

0000c654 <sd_raw_init>:
 * Initializes memory card communication.
 *
 * \returns 0 on failure, 1 on success.
 */
uint8_t sd_raw_init()
{
    c654:	1f 93       	push	r17
    c656:	cf 93       	push	r28
    c658:	df 93       	push	r29
    /* enable inputs for reading card status */
    configure_pin_available();
    c65a:	0e 98       	cbi	0x01, 6	; 1
    c65c:	16 9a       	sbi	0x02, 6	; 2
    //configure_pin_locked();

    /* enable output CS */
    configure_pin_cs();
    c65e:	21 9a       	sbi	0x04, 1	; 4

    unselect_card();
    c660:	29 9a       	sbi	0x05, 1	; 5

    /* initialization procedure */
    if(!sd_raw_available())
    c662:	06 99       	sbic	0x00, 6	; 0
    c664:	21 c0       	rjmp	.+66     	; 0xc6a8 <sd_raw_init+0x54>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    c666:	84 ec       	ldi	r24, 0xC4	; 196
    c668:	99 e0       	ldi	r25, 0x09	; 9
    c66a:	01 97       	sbiw	r24, 0x01	; 1
    c66c:	f1 f7       	brne	.-4      	; 0xc66a <sd_raw_init+0x16>

    /* wait for the card being powered up */
    _delay_ms(10);

    /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
    spi_low_frequency();
    c66e:	0e 94 b2 64 	call	0xc964	; 0xc964 <spi_low_frequency>
    c672:	10 e0       	ldi	r17, 0x00	; 0

    /* card needs 74 cycles minimum to start up */
    for(uint8_t i = 0; i < 32; ++i)
    {
        /* wait 8 clock cycles */
        spi_rec_byte();
    c674:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>

    /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
    spi_low_frequency();

    /* card needs 74 cycles minimum to start up */
    for(uint8_t i = 0; i < 32; ++i)
    c678:	1f 5f       	subi	r17, 0xFF	; 255
    c67a:	10 32       	cpi	r17, 0x20	; 32
    c67c:	d9 f7       	brne	.-10     	; 0xc674 <sd_raw_init+0x20>
        /* wait 8 clock cycles */
        spi_rec_byte();
    }

    /* address card */
    select_card();
    c67e:	29 98       	cbi	0x05, 1	; 5
    c680:	c0 e0       	ldi	r28, 0x00	; 0
    c682:	d0 e0       	ldi	r29, 0x00	; 0

    /* reset card */
    uint8_t response;
    for(uint16_t i = 0; ; ++i)
    {
        response = sd_raw_send_command_r1(CMD_GO_IDLE_STATE, 0);
    c684:	80 e0       	ldi	r24, 0x00	; 0
    c686:	40 e0       	ldi	r20, 0x00	; 0
    c688:	50 e0       	ldi	r21, 0x00	; 0
    c68a:	60 e0       	ldi	r22, 0x00	; 0
    c68c:	70 e0       	ldi	r23, 0x00	; 0
    c68e:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
        if(response == (1 << R1_IDLE_STATE))
    c692:	81 30       	cpi	r24, 0x01	; 1
    c694:	69 f0       	breq	.+26     	; 0xc6b0 <sd_raw_init+0x5c>
            break;

        if(i == 0x1ff)
    c696:	81 e0       	ldi	r24, 0x01	; 1
    c698:	cf 3f       	cpi	r28, 0xFF	; 255
    c69a:	d8 07       	cpc	r29, r24
    c69c:	39 f4       	brne	.+14     	; 0xc6ac <sd_raw_init+0x58>
        {
            unselect_card();
    c69e:	29 9a       	sbi	0x05, 1	; 5
            spi_rec_byte();
    c6a0:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>
            spi_high_frequency();
    c6a4:	0e 94 b8 64 	call	0xc970	; 0xc970 <spi_high_frequency>
    c6a8:	80 e0       	ldi	r24, 0x00	; 0
    c6aa:	43 c0       	rjmp	.+134    	; 0xc732 <sd_raw_init+0xde>
    /* address card */
    select_card();

    /* reset card */
    uint8_t response;
    for(uint16_t i = 0; ; ++i)
    c6ac:	21 96       	adiw	r28, 0x01	; 1
    c6ae:	ea cf       	rjmp	.-44     	; 0xc684 <sd_raw_init+0x30>
            unselect_card();
            spi_rec_byte();
            spi_high_frequency();
            return 0;
        }
    }
    c6b0:	c0 e0       	ldi	r28, 0x00	; 0
    c6b2:	d0 e0       	ldi	r29, 0x00	; 0
    
    /* wait for card to get ready */
    for(uint16_t i = 0; ; ++i)
    {
		// ACMD41 fr "dnne" und "normale" SD-Karten (wil)
        response = sd_raw_send_command_r1(55, 0);	// APP_CMD
    c6b4:	87 e3       	ldi	r24, 0x37	; 55
    c6b6:	40 e0       	ldi	r20, 0x00	; 0
    c6b8:	50 e0       	ldi	r21, 0x00	; 0
    c6ba:	60 e0       	ldi	r22, 0x00	; 0
    c6bc:	70 e0       	ldi	r23, 0x00	; 0
    c6be:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
        response = sd_raw_send_command_r1(41, 0);	// SD_SEND_OP_COND (keine 'high capacity')
    c6c2:	89 e2       	ldi	r24, 0x29	; 41
    c6c4:	40 e0       	ldi	r20, 0x00	; 0
    c6c6:	50 e0       	ldi	r21, 0x00	; 0
    c6c8:	60 e0       	ldi	r22, 0x00	; 0
    c6ca:	70 e0       	ldi	r23, 0x00	; 0
    c6cc:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
        if(!(response & (1 << R1_IDLE_STATE)))
    c6d0:	80 ff       	sbrs	r24, 0
    c6d2:	06 c0       	rjmp	.+12     	; 0xc6e0 <sd_raw_init+0x8c>
            break;

        if(i == 0x7fff)
    c6d4:	8f e7       	ldi	r24, 0x7F	; 127
    c6d6:	cf 3f       	cpi	r28, 0xFF	; 255
    c6d8:	d8 07       	cpc	r29, r24
    c6da:	09 f3       	breq	.-62     	; 0xc69e <sd_raw_init+0x4a>
            return 0;
        }
    }
    
    /* wait for card to get ready */
    for(uint16_t i = 0; ; ++i)
    c6dc:	21 96       	adiw	r28, 0x01	; 1
    c6de:	ea cf       	rjmp	.-44     	; 0xc6b4 <sd_raw_init+0x60>
            return 0;
        }
    }

    /* set block size to 512 bytes */
    if(sd_raw_send_command_r1(CMD_SET_BLOCKLEN, 512))
    c6e0:	80 e1       	ldi	r24, 0x10	; 16
    c6e2:	40 e0       	ldi	r20, 0x00	; 0
    c6e4:	52 e0       	ldi	r21, 0x02	; 2
    c6e6:	60 e0       	ldi	r22, 0x00	; 0
    c6e8:	70 e0       	ldi	r23, 0x00	; 0
    c6ea:	0e 94 90 5f 	call	0xbf20	; 0xbf20 <sd_raw_send_command_r1>
    c6ee:	88 23       	and	r24, r24
    c6f0:	b1 f6       	brne	.-84     	; 0xc69e <sd_raw_init+0x4a>
        spi_high_frequency();
        return 0;
    }

    /* deaddress card */
    unselect_card();
    c6f2:	29 9a       	sbi	0x05, 1	; 5
    spi_rec_byte();
    c6f4:	0e 94 92 64 	call	0xc924	; 0xc924 <spi_rec_byte>

    /* switch to highest SPI frequency possible */
    spi_high_frequency();
    c6f8:	0e 94 b8 64 	call	0xc970	; 0xc970 <spi_high_frequency>

#if !SD_RAW_SAVE_RAM
    /* the first block is likely to be accessed first, so precache it here */
    raw_block_address = 0xffffffff;
    c6fc:	8f ef       	ldi	r24, 0xFF	; 255
    c6fe:	9f ef       	ldi	r25, 0xFF	; 255
    c700:	af ef       	ldi	r26, 0xFF	; 255
    c702:	bf ef       	ldi	r27, 0xFF	; 255
    c704:	80 93 26 06 	sts	0x0626, r24
    c708:	90 93 27 06 	sts	0x0627, r25
    c70c:	a0 93 28 06 	sts	0x0628, r26
    c710:	b0 93 29 06 	sts	0x0629, r27
#if SD_RAW_WRITE_BUFFERING
    raw_block_written = 1;
    c714:	81 e0       	ldi	r24, 0x01	; 1
    c716:	80 93 2a 06 	sts	0x062A, r24
#endif
    if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
    c71a:	60 e0       	ldi	r22, 0x00	; 0
    c71c:	70 e0       	ldi	r23, 0x00	; 0
    c71e:	80 e0       	ldi	r24, 0x00	; 0
    c720:	90 e0       	ldi	r25, 0x00	; 0
    c722:	46 e2       	ldi	r20, 0x26	; 38
    c724:	54 e0       	ldi	r21, 0x04	; 4
    c726:	20 e0       	ldi	r18, 0x00	; 0
    c728:	32 e0       	ldi	r19, 0x02	; 2
    c72a:	0e 94 e5 60 	call	0xc1ca	; 0xc1ca <sd_raw_read>
    c72e:	81 11       	cpse	r24, r1
    c730:	81 e0       	ldi	r24, 0x01	; 1
        return 0;
#endif

    return 1;
}
    c732:	df 91       	pop	r29
    c734:	cf 91       	pop	r28
    c736:	1f 91       	pop	r17
    c738:	08 95       	ret

0000c73a <partition_close>:
 * \param[in] partition The partition descriptor to destroy.
 * \returns 0 on failure, 1 on success.
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    c73a:	fc 01       	movw	r30, r24
    if(!partition)
    c73c:	00 97       	sbiw	r24, 0x00	; 0
    c73e:	11 f4       	brne	.+4      	; 0xc744 <partition_close+0xa>
    c740:	80 e0       	ldi	r24, 0x00	; 0
    c742:	08 95       	ret

    /* destroy partition descriptor */
#if USE_DYNAMIC_MEMORY
    free(partition);
#else
    partition->type = PARTITION_TYPE_FREE;
    c744:	10 86       	std	Z+8, r1	; 0x08
    c746:	81 e0       	ldi	r24, 0x01	; 1
#endif

    return 1;
}
    c748:	08 95       	ret

0000c74a <partition_open>:
 *                  and is of an unknown type.
 * \returns 0 on failure, a partition descriptor on success.
 * \see partition_close
 */
struct partition_struct* partition_open(device_read_t device_read, device_read_interval_t device_read_interval, device_write_t device_write, device_write_interval_t device_write_interval, int8_t index)
{
    c74a:	8f 92       	push	r8
    c74c:	9f 92       	push	r9
    c74e:	af 92       	push	r10
    c750:	bf 92       	push	r11
    c752:	cf 92       	push	r12
    c754:	df 92       	push	r13
    c756:	ef 92       	push	r14
    c758:	ff 92       	push	r15
    c75a:	0f 93       	push	r16
    c75c:	df 93       	push	r29
    c75e:	cf 93       	push	r28
    c760:	cd b7       	in	r28, 0x3d	; 61
    c762:	de b7       	in	r29, 0x3e	; 62
    c764:	60 97       	sbiw	r28, 0x10	; 16
    c766:	0f b6       	in	r0, 0x3f	; 63
    c768:	f8 94       	cli
    c76a:	de bf       	out	0x3e, r29	; 62
    c76c:	0f be       	out	0x3f, r0	; 63
    c76e:	cd bf       	out	0x3d, r28	; 61
    c770:	7c 01       	movw	r14, r24
    c772:	6b 01       	movw	r12, r22
    c774:	5a 01       	movw	r10, r20
    c776:	49 01       	movw	r8, r18
    struct partition_struct* new_partition = 0;
    uint8_t buffer[0x10];

    if(!device_read || !device_read_interval || index >= 4)
    c778:	00 97       	sbiw	r24, 0x00	; 0
    c77a:	09 f4       	brne	.+2      	; 0xc77e <partition_open+0x34>
    c77c:	93 c0       	rjmp	.+294    	; 0xc8a4 <partition_open+0x15a>
    c77e:	61 15       	cp	r22, r1
    c780:	71 05       	cpc	r23, r1
    c782:	09 f4       	brne	.+2      	; 0xc786 <partition_open+0x3c>
    c784:	8f c0       	rjmp	.+286    	; 0xc8a4 <partition_open+0x15a>
    c786:	04 30       	cpi	r16, 0x04	; 4
    c788:	0c f0       	brlt	.+2      	; 0xc78c <partition_open+0x42>
    c78a:	8c c0       	rjmp	.+280    	; 0xc8a4 <partition_open+0x15a>
        return 0;

    if(index >= 0)
    c78c:	07 fd       	sbrc	r16, 7
    c78e:	1d c0       	rjmp	.+58     	; 0xc7ca <partition_open+0x80>
    {
        /* read specified partition table index */
        if(!device_read(0x01be + index * 0x10, buffer, sizeof(buffer)))
    c790:	60 2f       	mov	r22, r16
    c792:	77 27       	eor	r23, r23
    c794:	67 fd       	sbrc	r22, 7
    c796:	70 95       	com	r23
    c798:	e4 e0       	ldi	r30, 0x04	; 4
    c79a:	66 0f       	add	r22, r22
    c79c:	77 1f       	adc	r23, r23
    c79e:	ea 95       	dec	r30
    c7a0:	e1 f7       	brne	.-8      	; 0xc79a <partition_open+0x50>
    c7a2:	62 54       	subi	r22, 0x42	; 66
    c7a4:	7e 4f       	sbci	r23, 0xFE	; 254
    c7a6:	88 27       	eor	r24, r24
    c7a8:	77 fd       	sbrc	r23, 7
    c7aa:	80 95       	com	r24
    c7ac:	98 2f       	mov	r25, r24
    c7ae:	ae 01       	movw	r20, r28
    c7b0:	4f 5f       	subi	r20, 0xFF	; 255
    c7b2:	5f 4f       	sbci	r21, 0xFF	; 255
    c7b4:	20 e1       	ldi	r18, 0x10	; 16
    c7b6:	30 e0       	ldi	r19, 0x00	; 0
    c7b8:	f7 01       	movw	r30, r14
    c7ba:	09 95       	icall
    c7bc:	88 23       	and	r24, r24
    c7be:	09 f4       	brne	.+2      	; 0xc7c2 <partition_open+0x78>
    c7c0:	71 c0       	rjmp	.+226    	; 0xc8a4 <partition_open+0x15a>
            return 0;

        /* abort on empty partition entry */
        if(buffer[4] == 0x00)
    c7c2:	8d 81       	ldd	r24, Y+5	; 0x05
    c7c4:	88 23       	and	r24, r24
    c7c6:	09 f4       	brne	.+2      	; 0xc7ca <partition_open+0x80>
    c7c8:	6d c0       	rjmp	.+218    	; 0xc8a4 <partition_open+0x15a>
#else
    new_partition = partition_handles;
    uint8_t i;
    for(i = 0; i < PARTITION_COUNT; ++i)
    {
        if(new_partition->type == PARTITION_TYPE_FREE)
    c7ca:	80 91 33 06 	lds	r24, 0x0633
    c7ce:	88 23       	and	r24, r24
    c7d0:	09 f0       	breq	.+2      	; 0xc7d4 <partition_open+0x8a>
    c7d2:	68 c0       	rjmp	.+208    	; 0xc8a4 <partition_open+0x15a>
    c7d4:	7c c0       	rjmp	.+248    	; 0xc8ce <partition_open+0x184>
    new_partition->device_write = device_write;
    new_partition->device_write_interval = device_write_interval;

    if(index >= 0)
    {
        new_partition->type = buffer[4];
    c7d6:	8d 81       	ldd	r24, Y+5	; 0x05
    c7d8:	80 93 33 06 	sts	0x0633, r24
        new_partition->offset = ((uint32_t) buffer[8]) |
    c7dc:	2a 85       	ldd	r18, Y+10	; 0x0a
    c7de:	30 e0       	ldi	r19, 0x00	; 0
    c7e0:	40 e0       	ldi	r20, 0x00	; 0
    c7e2:	50 e0       	ldi	r21, 0x00	; 0
    c7e4:	54 2f       	mov	r21, r20
    c7e6:	43 2f       	mov	r20, r19
    c7e8:	32 2f       	mov	r19, r18
    c7ea:	22 27       	eor	r18, r18
    c7ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    c7ee:	90 e0       	ldi	r25, 0x00	; 0
    c7f0:	a0 e0       	ldi	r26, 0x00	; 0
    c7f2:	b0 e0       	ldi	r27, 0x00	; 0
    c7f4:	dc 01       	movw	r26, r24
    c7f6:	99 27       	eor	r25, r25
    c7f8:	88 27       	eor	r24, r24
    c7fa:	28 2b       	or	r18, r24
    c7fc:	39 2b       	or	r19, r25
    c7fe:	4a 2b       	or	r20, r26
    c800:	5b 2b       	or	r21, r27
    c802:	89 85       	ldd	r24, Y+9	; 0x09
    c804:	90 e0       	ldi	r25, 0x00	; 0
    c806:	a0 e0       	ldi	r26, 0x00	; 0
    c808:	b0 e0       	ldi	r27, 0x00	; 0
    c80a:	28 2b       	or	r18, r24
    c80c:	39 2b       	or	r19, r25
    c80e:	4a 2b       	or	r20, r26
    c810:	5b 2b       	or	r21, r27
    c812:	8c 85       	ldd	r24, Y+12	; 0x0c
    c814:	90 e0       	ldi	r25, 0x00	; 0
    c816:	a0 e0       	ldi	r26, 0x00	; 0
    c818:	b0 e0       	ldi	r27, 0x00	; 0
    c81a:	b8 2f       	mov	r27, r24
    c81c:	aa 27       	eor	r26, r26
    c81e:	99 27       	eor	r25, r25
    c820:	88 27       	eor	r24, r24
    c822:	28 2b       	or	r18, r24
    c824:	39 2b       	or	r19, r25
    c826:	4a 2b       	or	r20, r26
    c828:	5b 2b       	or	r21, r27
    c82a:	20 93 34 06 	sts	0x0634, r18
    c82e:	30 93 35 06 	sts	0x0635, r19
    c832:	40 93 36 06 	sts	0x0636, r20
    c836:	50 93 37 06 	sts	0x0637, r21
                                ((uint32_t) buffer[9] << 8) |
                                ((uint32_t) buffer[10] << 16) |
                                ((uint32_t) buffer[11] << 24);
        new_partition->length = ((uint32_t) buffer[12]) |
    c83a:	2e 85       	ldd	r18, Y+14	; 0x0e
    c83c:	30 e0       	ldi	r19, 0x00	; 0
    c83e:	40 e0       	ldi	r20, 0x00	; 0
    c840:	50 e0       	ldi	r21, 0x00	; 0
    c842:	54 2f       	mov	r21, r20
    c844:	43 2f       	mov	r20, r19
    c846:	32 2f       	mov	r19, r18
    c848:	22 27       	eor	r18, r18
    c84a:	8f 85       	ldd	r24, Y+15	; 0x0f
    c84c:	90 e0       	ldi	r25, 0x00	; 0
    c84e:	a0 e0       	ldi	r26, 0x00	; 0
    c850:	b0 e0       	ldi	r27, 0x00	; 0
    c852:	dc 01       	movw	r26, r24
    c854:	99 27       	eor	r25, r25
    c856:	88 27       	eor	r24, r24
    c858:	28 2b       	or	r18, r24
    c85a:	39 2b       	or	r19, r25
    c85c:	4a 2b       	or	r20, r26
    c85e:	5b 2b       	or	r21, r27
    c860:	8d 85       	ldd	r24, Y+13	; 0x0d
    c862:	90 e0       	ldi	r25, 0x00	; 0
    c864:	a0 e0       	ldi	r26, 0x00	; 0
    c866:	b0 e0       	ldi	r27, 0x00	; 0
    c868:	28 2b       	or	r18, r24
    c86a:	39 2b       	or	r19, r25
    c86c:	4a 2b       	or	r20, r26
    c86e:	5b 2b       	or	r21, r27
    c870:	88 89       	ldd	r24, Y+16	; 0x10
    c872:	90 e0       	ldi	r25, 0x00	; 0
    c874:	a0 e0       	ldi	r26, 0x00	; 0
    c876:	b0 e0       	ldi	r27, 0x00	; 0
    c878:	b8 2f       	mov	r27, r24
    c87a:	aa 27       	eor	r26, r26
    c87c:	99 27       	eor	r25, r25
    c87e:	88 27       	eor	r24, r24
    c880:	28 2b       	or	r18, r24
    c882:	39 2b       	or	r19, r25
    c884:	4a 2b       	or	r20, r26
    c886:	5b 2b       	or	r21, r27
    c888:	20 93 38 06 	sts	0x0638, r18
    c88c:	30 93 39 06 	sts	0x0639, r19
    c890:	40 93 3a 06 	sts	0x063A, r20
    c894:	50 93 3b 06 	sts	0x063B, r21
    c898:	03 c0       	rjmp	.+6      	; 0xc8a0 <partition_open+0x156>
                                ((uint32_t) buffer[14] << 16) |
                                ((uint32_t) buffer[15] << 24);
    }
    else
    {
        new_partition->type = 0xff;
    c89a:	8f ef       	ldi	r24, 0xFF	; 255
    c89c:	80 93 33 06 	sts	0x0633, r24
    c8a0:	9f 01       	movw	r18, r30
    c8a2:	02 c0       	rjmp	.+4      	; 0xc8a8 <partition_open+0x15e>
    c8a4:	20 e0       	ldi	r18, 0x00	; 0
    c8a6:	30 e0       	ldi	r19, 0x00	; 0
    }

    return new_partition;
}
    c8a8:	c9 01       	movw	r24, r18
    c8aa:	60 96       	adiw	r28, 0x10	; 16
    c8ac:	0f b6       	in	r0, 0x3f	; 63
    c8ae:	f8 94       	cli
    c8b0:	de bf       	out	0x3e, r29	; 62
    c8b2:	0f be       	out	0x3f, r0	; 63
    c8b4:	cd bf       	out	0x3d, r28	; 61
    c8b6:	cf 91       	pop	r28
    c8b8:	df 91       	pop	r29
    c8ba:	0f 91       	pop	r16
    c8bc:	ff 90       	pop	r15
    c8be:	ef 90       	pop	r14
    c8c0:	df 90       	pop	r13
    c8c2:	cf 90       	pop	r12
    c8c4:	bf 90       	pop	r11
    c8c6:	af 90       	pop	r10
    c8c8:	9f 90       	pop	r9
    c8ca:	8f 90       	pop	r8
    c8cc:	08 95       	ret
    }
    if(i >= PARTITION_COUNT)
        return 0;
#endif

    memset(new_partition, 0, sizeof(*new_partition));
    c8ce:	eb e2       	ldi	r30, 0x2B	; 43
    c8d0:	f6 e0       	ldi	r31, 0x06	; 6
    c8d2:	81 e1       	ldi	r24, 0x11	; 17
    c8d4:	df 01       	movw	r26, r30
    c8d6:	1d 92       	st	X+, r1
    c8d8:	8a 95       	dec	r24
    c8da:	e9 f7       	brne	.-6      	; 0xc8d6 <partition_open+0x18c>

    /* fill partition descriptor */
    new_partition->device_read = device_read;
    c8dc:	f0 92 2c 06 	sts	0x062C, r15
    c8e0:	e0 92 2b 06 	sts	0x062B, r14
    new_partition->device_read_interval = device_read_interval;
    c8e4:	d0 92 2e 06 	sts	0x062E, r13
    c8e8:	c0 92 2d 06 	sts	0x062D, r12
    new_partition->device_write = device_write;
    c8ec:	b0 92 30 06 	sts	0x0630, r11
    c8f0:	a0 92 2f 06 	sts	0x062F, r10
    new_partition->device_write_interval = device_write_interval;
    c8f4:	90 92 32 06 	sts	0x0632, r9
    c8f8:	80 92 31 06 	sts	0x0631, r8

    if(index >= 0)
    c8fc:	07 ff       	sbrs	r16, 7
    c8fe:	6b cf       	rjmp	.-298    	; 0xc7d6 <partition_open+0x8c>
    c900:	cc cf       	rjmp	.-104    	; 0xc89a <partition_open+0x150>

0000c902 <spi_init>:
 *
 * By default, the highest SPI frequency available is used.
 */
void spi_init()
{
    if(SPCR & (1 << SPE))
    c902:	0c b4       	in	r0, 0x2c	; 44
    c904:	06 fc       	sbrc	r0, 6
    c906:	08 c0       	rjmp	.+16     	; 0xc918 <spi_init+0x16>
        return;

    /* configure pins */
    spi_config_pin_mosi();
    c908:	25 9a       	sbi	0x04, 5	; 4
    spi_config_pin_sck();
    c90a:	27 9a       	sbi	0x04, 7	; 4
    spi_config_pin_miso();
    c90c:	26 98       	cbi	0x04, 6	; 4
/**
 * Switches to the highest SPI frequency possible.
 */
void spi_high_frequency()
{
    SPCR = (0 << SPIE) | /* SPI Interrupt Enable */
    c90e:	80 e5       	ldi	r24, 0x50	; 80
    c910:	8c bd       	out	0x2c, r24	; 44
           (1 << MSTR) | /* Master mode */
           (0 << CPOL) | /* Clock Polarity: SCK low when idle */
           (0 << CPHA) | /* Clock Phase: sample on rising SCK edge */
           (0 << SPR1) | /* Clock Frequency: f_OSC / 4 */
           (0 << SPR0);
    SPSR |= (1 << SPI2X); /* Doubled Clock Frequency: f_OSC / 2 */
    c912:	8d b5       	in	r24, 0x2d	; 45
    c914:	81 60       	ori	r24, 0x01	; 1
    c916:	8d bd       	out	0x2d, r24	; 45
    c918:	08 95       	ret

0000c91a <spi_send_byte>:
 *
 * \param[in] b The byte to send.
 */
void spi_send_byte(uint8_t b)
{
    SPDR = b;
    c91a:	8e bd       	out	0x2e, r24	; 46
    /* wait for byte to be shifted out */
    while(!(SPSR & (1 << SPIF)));
    c91c:	0d b4       	in	r0, 0x2d	; 45
    c91e:	07 fe       	sbrs	r0, 7
    c920:	fd cf       	rjmp	.-6      	; 0xc91c <spi_send_byte+0x2>
}
    c922:	08 95       	ret

0000c924 <spi_rec_byte>:
 * \returns The received byte.
 */
uint8_t spi_rec_byte()
{
    /* send dummy data for receiving some */
    SPDR = 0xff;
    c924:	8f ef       	ldi	r24, 0xFF	; 255
    c926:	8e bd       	out	0x2e, r24	; 46
    while(!(SPSR & (1 << SPIF)));
    c928:	0d b4       	in	r0, 0x2d	; 45
    c92a:	07 fe       	sbrs	r0, 7
    c92c:	fd cf       	rjmp	.-6      	; 0xc928 <spi_rec_byte+0x4>

    return SPDR;
    c92e:	8e b5       	in	r24, 0x2e	; 46
}
    c930:	08 95       	ret

0000c932 <spi_send_data>:
 *
 * \param[in] data A pointer to the buffer which contains the data to send.
 * \param[in] data_len The number of bytes to send.
 */
void spi_send_data(const uint8_t* data, uint16_t data_len)
{
    c932:	fc 01       	movw	r30, r24
    do
    {
        uint8_t b = *data++;
    c934:	81 91       	ld	r24, Z+

        while(!(SPSR & (1 << SPIF)));
    c936:	0d b4       	in	r0, 0x2d	; 45
    c938:	07 fe       	sbrs	r0, 7
    c93a:	fd cf       	rjmp	.-6      	; 0xc936 <spi_send_data+0x4>
        SPDR = b;
    c93c:	8e bd       	out	0x2e, r24	; 46

    } while(--data_len);
    c93e:	61 50       	subi	r22, 0x01	; 1
    c940:	70 40       	sbci	r23, 0x00	; 0
    c942:	c1 f7       	brne	.-16     	; 0xc934 <spi_send_data+0x2>

    while(!(SPSR & (1 << SPIF)));
    c944:	0d b4       	in	r0, 0x2d	; 45
    c946:	07 fe       	sbrs	r0, 7
    c948:	fd cf       	rjmp	.-6      	; 0xc944 <spi_send_data+0x12>
}
    c94a:	08 95       	ret

0000c94c <spi_rec_data>:
 *
 * \param[out] buffer A pointer to the buffer into which the data gets written.
 * \param[in] buffer_len The number of bytes to read.
 */
void spi_rec_data(uint8_t* buffer, uint16_t buffer_len)
{
    c94c:	fc 01       	movw	r30, r24
    --buffer;

    do
    {
        SPDR = 0xff;
    c94e:	9f ef       	ldi	r25, 0xFF	; 255
    c950:	9e bd       	out	0x2e, r25	; 46
        ++buffer;

        while(!(SPSR & (1 << SPIF)));
    c952:	0d b4       	in	r0, 0x2d	; 45
    c954:	07 fe       	sbrs	r0, 7
    c956:	fd cf       	rjmp	.-6      	; 0xc952 <spi_rec_data+0x6>
        *buffer = SPDR;
    c958:	8e b5       	in	r24, 0x2e	; 46
    c95a:	81 93       	st	Z+, r24

    } while(--buffer_len);
    c95c:	61 50       	subi	r22, 0x01	; 1
    c95e:	70 40       	sbci	r23, 0x00	; 0
    c960:	b9 f7       	brne	.-18     	; 0xc950 <spi_rec_data+0x4>
}
    c962:	08 95       	ret

0000c964 <spi_low_frequency>:
/**
 * Switches to the lowest SPI frequency possible.
 */
void spi_low_frequency()
{
    SPCR = (0 << SPIE) | /* SPI Interrupt Enable */
    c964:	83 e5       	ldi	r24, 0x53	; 83
    c966:	8c bd       	out	0x2c, r24	; 44
           (1 << MSTR) | /* Master mode */
           (0 << CPOL) | /* Clock Polarity: SCK low when idle */
           (0 << CPHA) | /* Clock Phase: sample on rising SCK edge */
           (1 << SPR1) | /* Clock Frequency: f_OSC / 128 */
           (1 << SPR0);
    SPSR &= ~(1 << SPI2X); /* No Doubled Clock Frequency */
    c968:	8d b5       	in	r24, 0x2d	; 45
    c96a:	8e 7f       	andi	r24, 0xFE	; 254
    c96c:	8d bd       	out	0x2d, r24	; 45
}
    c96e:	08 95       	ret

0000c970 <spi_high_frequency>:
/**
 * Switches to the highest SPI frequency possible.
 */
void spi_high_frequency()
{
    SPCR = (0 << SPIE) | /* SPI Interrupt Enable */
    c970:	80 e5       	ldi	r24, 0x50	; 80
    c972:	8c bd       	out	0x2c, r24	; 44
           (1 << MSTR) | /* Master mode */
           (0 << CPOL) | /* Clock Polarity: SCK low when idle */
           (0 << CPHA) | /* Clock Phase: sample on rising SCK edge */
           (0 << SPR1) | /* Clock Frequency: f_OSC / 4 */
           (0 << SPR0);
    SPSR |= (1 << SPI2X); /* Doubled Clock Frequency: f_OSC / 2 */
    c974:	8d b5       	in	r24, 0x2d	; 45
    c976:	81 60       	ori	r24, 0x01	; 1
    c978:	8d bd       	out	0x2d, r24	; 45
}
    c97a:	08 95       	ret

0000c97c <__vector_4>:
/**
 *	\ingroup messen
 * ISR fr Pinchange-Signal an Port A
 */
ISR(PCINT0_vect)
{
    c97c:	1f 92       	push	r1
    c97e:	0f 92       	push	r0
    c980:	0f b6       	in	r0, 0x3f	; 63
    c982:	0f 92       	push	r0
    c984:	11 24       	eor	r1, r1
    c986:	8f 93       	push	r24
    c988:	9f 93       	push	r25
    c98a:	80 e0       	ldi	r24, 0x00	; 0
    c98c:	90 e9       	ldi	r25, 0x90	; 144
    c98e:	01 97       	sbiw	r24, 0x01	; 1
    c990:	f1 f7       	brne	.-4      	; 0xc98e <__vector_4+0x12>
	_delay_ms(10);	// prellen abwarten

	machineStatus.PINAStatus	= PINA;		// aktuellen Port-Status merken
    c992:	80 b1       	in	r24, 0x00	; 0
    c994:	80 93 45 06 	sts	0x0645, r24
}
    c998:	9f 91       	pop	r25
    c99a:	8f 91       	pop	r24
    c99c:	0f 90       	pop	r0
    c99e:	0f be       	out	0x3f, r0	; 63
    c9a0:	0f 90       	pop	r0
    c9a2:	1f 90       	pop	r1
    c9a4:	18 95       	reti

0000c9a6 <__vector_6>:
 * nderung der Eingnge an PINC gab<br>
 * und in <tt>machineStatus.PINCStatus</tt> wird der aktuelle
 * Zustand der Eingnge gespeichert.
 */
ISR(PCINT2_vect)
{
    c9a6:	1f 92       	push	r1
    c9a8:	0f 92       	push	r0
    c9aa:	0f b6       	in	r0, 0x3f	; 63
    c9ac:	0f 92       	push	r0
    c9ae:	11 24       	eor	r1, r1
    c9b0:	8f 93       	push	r24
    c9b2:	9f 93       	push	r25
    c9b4:	80 e0       	ldi	r24, 0x00	; 0
    c9b6:	98 e4       	ldi	r25, 0x48	; 72
    c9b8:	01 97       	sbiw	r24, 0x01	; 1
    c9ba:	f1 f7       	brne	.-4      	; 0xc9b8 <__vector_6+0x12>
	_delay_ms(5);	// prellen abwarten

	machineStatus.PINCchanged = SENS_Read ^ machineStatus.PINCStatus;
    c9bc:	86 b1       	in	r24, 0x06	; 6
    c9be:	90 91 46 06 	lds	r25, 0x0646
    c9c2:	98 27       	eor	r25, r24
    c9c4:	90 93 44 06 	sts	0x0644, r25
	machineStatus.PINCStatus = SENS_Read;
    c9c8:	86 b1       	in	r24, 0x06	; 6
    c9ca:	80 93 46 06 	sts	0x0646, r24
}
    c9ce:	9f 91       	pop	r25
    c9d0:	8f 91       	pop	r24
    c9d2:	0f 90       	pop	r0
    c9d4:	0f be       	out	0x3f, r0	; 63
    c9d6:	0f 90       	pop	r0
    c9d8:	1f 90       	pop	r1
    c9da:	18 95       	reti

0000c9dc <__vector_7>:
/**
 *	\ingroup messen
 * ISR fr Pinchange-Signal an Port D
 */
ISR(PCINT3_vect)
{
    c9dc:	1f 92       	push	r1
    c9de:	0f 92       	push	r0
    c9e0:	0f b6       	in	r0, 0x3f	; 63
    c9e2:	0f 92       	push	r0
    c9e4:	11 24       	eor	r1, r1
    c9e6:	8f 93       	push	r24
	machineStatus.PINDStatus = PIND;
    c9e8:	89 b1       	in	r24, 0x09	; 9
    c9ea:	80 93 47 06 	sts	0x0647, r24
}
    c9ee:	8f 91       	pop	r24
    c9f0:	0f 90       	pop	r0
    c9f2:	0f be       	out	0x3f, r0	; 63
    c9f4:	0f 90       	pop	r0
    c9f6:	1f 90       	pop	r1
    c9f8:	18 95       	reti

0000c9fa <log_status>:
/**
 *	\ingroup messen
 *	Status mit allen Werten in Logdatei schreiben
 */
void log_status(void)
{
    c9fa:	cf 92       	push	r12
    c9fc:	df 92       	push	r13
    c9fe:	ef 92       	push	r14
    ca00:	ff 92       	push	r15
    ca02:	0f 93       	push	r16
    ca04:	1f 93       	push	r17
    ca06:	cf 93       	push	r28
    ca08:	df 93       	push	r29
	#if USE_LOGDATEI
	if (logStatus.logfile) {
    ca0a:	80 91 e6 0b 	lds	r24, 0x0BE6
    ca0e:	90 91 e7 0b 	lds	r25, 0x0BE7
    ca12:	00 97       	sbiw	r24, 0x00	; 0
    ca14:	09 f4       	brne	.+2      	; 0xca18 <log_status+0x1e>
    ca16:	8b c0       	rjmp	.+278    	; 0xcb2e <log_status+0x134>
		f16_printf_P(logStatus.logfile,PSTR("%2i;%2i:%2i:%2i; S;%c%c%c;%2i;%i;%i;%i;"),
    ca18:	50 91 7b 0c 	lds	r21, 0x0C7B
    ca1c:	f0 90 75 0c 	lds	r15, 0x0C75
    ca20:	e0 90 74 0c 	lds	r14, 0x0C74
    ca24:	d0 90 73 0c 	lds	r13, 0x0C73
    ca28:	20 91 eb 0b 	lds	r18, 0x0BEB
    ca2c:	30 91 ec 0b 	lds	r19, 0x0BEC
    ca30:	40 91 ed 0b 	lds	r20, 0x0BED
    ca34:	c0 90 ee 0b 	lds	r12, 0x0BEE
    ca38:	60 91 ef 0b 	lds	r22, 0x0BEF
    ca3c:	70 91 f0 0b 	lds	r23, 0x0BF0
    ca40:	a0 91 f1 0b 	lds	r26, 0x0BF1
    ca44:	b0 91 f2 0b 	lds	r27, 0x0BF2
    ca48:	00 91 f3 0b 	lds	r16, 0x0BF3
    ca4c:	10 91 f4 0b 	lds	r17, 0x0BF4
    ca50:	cd b7       	in	r28, 0x3d	; 61
    ca52:	de b7       	in	r29, 0x3e	; 62
    ca54:	6a 97       	sbiw	r28, 0x1a	; 26
    ca56:	0f b6       	in	r0, 0x3f	; 63
    ca58:	f8 94       	cli
    ca5a:	de bf       	out	0x3e, r29	; 62
    ca5c:	0f be       	out	0x3f, r0	; 63
    ca5e:	cd bf       	out	0x3d, r28	; 61
    ca60:	ed b7       	in	r30, 0x3d	; 61
    ca62:	fe b7       	in	r31, 0x3e	; 62
    ca64:	31 96       	adiw	r30, 0x01	; 1
    ca66:	9a 83       	std	Y+2, r25	; 0x02
    ca68:	89 83       	std	Y+1, r24	; 0x01
    ca6a:	89 e0       	ldi	r24, 0x09	; 9
    ca6c:	93 e2       	ldi	r25, 0x23	; 35
    ca6e:	93 83       	std	Z+3, r25	; 0x03
    ca70:	82 83       	std	Z+2, r24	; 0x02
    ca72:	54 83       	std	Z+4, r21	; 0x04
    ca74:	15 82       	std	Z+5, r1	; 0x05
    ca76:	f6 82       	std	Z+6, r15	; 0x06
    ca78:	17 82       	std	Z+7, r1	; 0x07
    ca7a:	e0 86       	std	Z+8, r14	; 0x08
    ca7c:	11 86       	std	Z+9, r1	; 0x09
    ca7e:	d2 86       	std	Z+10, r13	; 0x0a
    ca80:	13 86       	std	Z+11, r1	; 0x0b
    ca82:	20 5d       	subi	r18, 0xD0	; 208
    ca84:	24 87       	std	Z+12, r18	; 0x0c
    ca86:	15 86       	std	Z+13, r1	; 0x0d
    ca88:	30 5d       	subi	r19, 0xD0	; 208
    ca8a:	36 87       	std	Z+14, r19	; 0x0e
    ca8c:	17 86       	std	Z+15, r1	; 0x0f
    ca8e:	40 5d       	subi	r20, 0xD0	; 208
    ca90:	40 8b       	std	Z+16, r20	; 0x10
    ca92:	11 8a       	std	Z+17, r1	; 0x11
    ca94:	c2 8a       	std	Z+18, r12	; 0x12
    ca96:	13 8a       	std	Z+19, r1	; 0x13
    ca98:	75 8b       	std	Z+21, r23	; 0x15
    ca9a:	64 8b       	std	Z+20, r22	; 0x14
    ca9c:	b7 8b       	std	Z+23, r27	; 0x17
    ca9e:	a6 8b       	std	Z+22, r26	; 0x16
    caa0:	11 8f       	std	Z+25, r17	; 0x19
    caa2:	00 8f       	std	Z+24, r16	; 0x18
    caa4:	0e 94 fd 4b 	call	0x97fa	; 0x97fa <f16_printf_P>
							(uint8_t)(anlagenStatus.relais1 + '0'),(uint8_t)(anlagenStatus.relais2 + '0'),
							(uint8_t)(anlagenStatus.relais3 + '0'),anlagenStatus.TReglerWert,
							anlagenStatus.Zaehler1,anlagenStatus.Zaehler2,anlagenStatus.Zaehler3);

		// jetzt die Analogwerte
		f16_printf_P(logStatus.logfile,PSTR("%4i;%4i;%4i;%4i;"),var_array[0],var_array[1],var_array[2],var_array[3]);
    caa8:	ed b7       	in	r30, 0x3d	; 61
    caaa:	fe b7       	in	r31, 0x3e	; 62
    caac:	3e 96       	adiw	r30, 0x0e	; 14
    caae:	0f b6       	in	r0, 0x3f	; 63
    cab0:	f8 94       	cli
    cab2:	fe bf       	out	0x3e, r31	; 62
    cab4:	0f be       	out	0x3f, r0	; 63
    cab6:	ed bf       	out	0x3d, r30	; 61
    cab8:	31 96       	adiw	r30, 0x01	; 1
    caba:	80 91 e6 0b 	lds	r24, 0x0BE6
    cabe:	90 91 e7 0b 	lds	r25, 0x0BE7
    cac2:	ad b7       	in	r26, 0x3d	; 61
    cac4:	be b7       	in	r27, 0x3e	; 62
    cac6:	12 96       	adiw	r26, 0x02	; 2
    cac8:	9c 93       	st	X, r25
    caca:	8e 93       	st	-X, r24
    cacc:	11 97       	sbiw	r26, 0x01	; 1
    cace:	88 ef       	ldi	r24, 0xF8	; 248
    cad0:	92 e2       	ldi	r25, 0x22	; 34
    cad2:	93 83       	std	Z+3, r25	; 0x03
    cad4:	82 83       	std	Z+2, r24	; 0x02
    cad6:	80 91 00 01 	lds	r24, 0x0100
    cada:	90 91 01 01 	lds	r25, 0x0101
    cade:	95 83       	std	Z+5, r25	; 0x05
    cae0:	84 83       	std	Z+4, r24	; 0x04
    cae2:	80 91 02 01 	lds	r24, 0x0102
    cae6:	90 91 03 01 	lds	r25, 0x0103
    caea:	97 83       	std	Z+7, r25	; 0x07
    caec:	86 83       	std	Z+6, r24	; 0x06
    caee:	80 91 04 01 	lds	r24, 0x0104
    caf2:	90 91 05 01 	lds	r25, 0x0105
    caf6:	91 87       	std	Z+9, r25	; 0x09
    caf8:	80 87       	std	Z+8, r24	; 0x08
    cafa:	80 91 06 01 	lds	r24, 0x0106
    cafe:	90 91 07 01 	lds	r25, 0x0107
    cb02:	93 87       	std	Z+11, r25	; 0x0b
    cb04:	82 87       	std	Z+10, r24	; 0x0a
    cb06:	0e 94 fd 4b 	call	0x97fa	; 0x97fa <f16_printf_P>
		for (int i=0; i < MAXSENSORS; ++i) {
			f16_printf_P(logStatus.logfile,PSTR("%4i;"),ow_array[i]);
		}
		#endif

		f16_fputs_P(PSTR("\r\n"),logStatus.logfile);
    cb0a:	cd b7       	in	r28, 0x3d	; 61
    cb0c:	de b7       	in	r29, 0x3e	; 62
    cb0e:	2c 96       	adiw	r28, 0x0c	; 12
    cb10:	0f b6       	in	r0, 0x3f	; 63
    cb12:	f8 94       	cli
    cb14:	de bf       	out	0x3e, r29	; 62
    cb16:	0f be       	out	0x3f, r0	; 63
    cb18:	cd bf       	out	0x3d, r28	; 61
    cb1a:	60 91 e6 0b 	lds	r22, 0x0BE6
    cb1e:	70 91 e7 0b 	lds	r23, 0x0BE7
    cb22:	85 ef       	ldi	r24, 0xF5	; 245
    cb24:	92 e2       	ldi	r25, 0x22	; 34
    cb26:	0e 94 ad 4c 	call	0x995a	; 0x995a <f16_fputs_P>
		f16_flush();	// Cache leeren
    cb2a:	0e 94 e1 4c 	call	0x99c2	; 0x99c2 <f16_flush>
	}
	#endif
}
    cb2e:	df 91       	pop	r29
    cb30:	cf 91       	pop	r28
    cb32:	1f 91       	pop	r17
    cb34:	0f 91       	pop	r16
    cb36:	ff 90       	pop	r15
    cb38:	ef 90       	pop	r14
    cb3a:	df 90       	pop	r13
    cb3c:	cf 90       	pop	r12
    cb3e:	08 95       	ret

0000cb40 <regelAnlage>:
/**
 *	\ingroup messen
 * Anlage regeln nach Sollwerten
 */
void regelAnlage(SOLL_STATUS *aktSoll)
{
    cb40:	0f 93       	push	r16
    cb42:	1f 93       	push	r17
    cb44:	cf 93       	push	r28
    cb46:	df 93       	push	r29
    cb48:	ec 01       	movw	r28, r24
	if (aktSoll->Schalter1) {	// Schalter1 schalten
    cb4a:	88 81       	ld	r24, Y
    cb4c:	80 ff       	sbrs	r24, 0
    cb4e:	02 c0       	rjmp	.+4      	; 0xcb54 <regelAnlage+0x14>
		S1An();
    cb50:	5c 9a       	sbi	0x0b, 4	; 11
    cb52:	01 c0       	rjmp	.+2      	; 0xcb56 <regelAnlage+0x16>
	}
	else {
		S1Aus();
    cb54:	5c 98       	cbi	0x0b, 4	; 11
	}

	if (aktSoll->Schalter2) {	// Schalter2 schalten
    cb56:	81 ff       	sbrs	r24, 1
    cb58:	02 c0       	rjmp	.+4      	; 0xcb5e <regelAnlage+0x1e>
		S2An();
    cb5a:	5d 9a       	sbi	0x0b, 5	; 11
    cb5c:	01 c0       	rjmp	.+2      	; 0xcb60 <regelAnlage+0x20>
	}
	else {
		S2Aus();
    cb5e:	5d 98       	cbi	0x0b, 5	; 11
	}

	if (aktSoll->Schalter3) {	// Schalter3 schalten
    cb60:	82 ff       	sbrs	r24, 2
    cb62:	02 c0       	rjmp	.+4      	; 0xcb68 <regelAnlage+0x28>
		S3An();
    cb64:	5e 9a       	sbi	0x0b, 6	; 11
    cb66:	01 c0       	rjmp	.+2      	; 0xcb6a <regelAnlage+0x2a>
	}
	else {
		S3Aus();
    cb68:	5e 98       	cbi	0x0b, 6	; 11
	}

	// Protokoll
	#if USE_LOGDATEI
	if (logStatus.logfile) {	// falls SD-Karte vorhanden
    cb6a:	80 91 e6 0b 	lds	r24, 0x0BE6
    cb6e:	90 91 e7 0b 	lds	r25, 0x0BE7
    cb72:	00 97       	sbiw	r24, 0x00	; 0
    cb74:	09 f4       	brne	.+2      	; 0xcb78 <regelAnlage+0x38>
    cb76:	76 c0       	rjmp	.+236    	; 0xcc64 <regelAnlage+0x124>
		f16_printf_P(logStatus.logfile,PSTR("%2i;%2i:%2i:%2i;alt;%c%c%c;%2i;"),
    cb78:	50 91 7b 0c 	lds	r21, 0x0C7B
    cb7c:	60 91 75 0c 	lds	r22, 0x0C75
    cb80:	70 91 74 0c 	lds	r23, 0x0C74
    cb84:	00 91 73 0c 	lds	r16, 0x0C73
    cb88:	40 91 54 06 	lds	r20, 0x0654
    cb8c:	41 70       	andi	r20, 0x01	; 1
    cb8e:	20 91 54 06 	lds	r18, 0x0654
    cb92:	26 95       	lsr	r18
    cb94:	21 70       	andi	r18, 0x01	; 1
    cb96:	30 91 54 06 	lds	r19, 0x0654
    cb9a:	36 95       	lsr	r19
    cb9c:	36 95       	lsr	r19
    cb9e:	31 70       	andi	r19, 0x01	; 1
    cba0:	10 91 55 06 	lds	r17, 0x0655
    cba4:	ad b7       	in	r26, 0x3d	; 61
    cba6:	be b7       	in	r27, 0x3e	; 62
    cba8:	54 97       	sbiw	r26, 0x14	; 20
    cbaa:	0f b6       	in	r0, 0x3f	; 63
    cbac:	f8 94       	cli
    cbae:	be bf       	out	0x3e, r27	; 62
    cbb0:	0f be       	out	0x3f, r0	; 63
    cbb2:	ad bf       	out	0x3d, r26	; 61
    cbb4:	ed b7       	in	r30, 0x3d	; 61
    cbb6:	fe b7       	in	r31, 0x3e	; 62
    cbb8:	31 96       	adiw	r30, 0x01	; 1
    cbba:	12 96       	adiw	r26, 0x02	; 2
    cbbc:	9c 93       	st	X, r25
    cbbe:	8e 93       	st	-X, r24
    cbc0:	11 97       	sbiw	r26, 0x01	; 1
    cbc2:	82 e7       	ldi	r24, 0x72	; 114
    cbc4:	93 e2       	ldi	r25, 0x23	; 35
    cbc6:	93 83       	std	Z+3, r25	; 0x03
    cbc8:	82 83       	std	Z+2, r24	; 0x02
    cbca:	54 83       	std	Z+4, r21	; 0x04
    cbcc:	15 82       	std	Z+5, r1	; 0x05
    cbce:	66 83       	std	Z+6, r22	; 0x06
    cbd0:	17 82       	std	Z+7, r1	; 0x07
    cbd2:	70 87       	std	Z+8, r23	; 0x08
    cbd4:	11 86       	std	Z+9, r1	; 0x09
    cbd6:	02 87       	std	Z+10, r16	; 0x0a
    cbd8:	13 86       	std	Z+11, r1	; 0x0b
    cbda:	40 5d       	subi	r20, 0xD0	; 208
    cbdc:	44 87       	std	Z+12, r20	; 0x0c
    cbde:	15 86       	std	Z+13, r1	; 0x0d
    cbe0:	20 5d       	subi	r18, 0xD0	; 208
    cbe2:	26 87       	std	Z+14, r18	; 0x0e
    cbe4:	17 86       	std	Z+15, r1	; 0x0f
    cbe6:	30 5d       	subi	r19, 0xD0	; 208
    cbe8:	30 8b       	std	Z+16, r19	; 0x10
    cbea:	11 8a       	std	Z+17, r1	; 0x11
    cbec:	12 8b       	std	Z+18, r17	; 0x12
    cbee:	13 8a       	std	Z+19, r1	; 0x13
    cbf0:	0e 94 fd 4b 	call	0x97fa	; 0x97fa <f16_printf_P>
							(uint8_t)(anlagenSollStatus.Schalter1 + '0'),
							(uint8_t)(anlagenSollStatus.Schalter2 + '0'),
							(uint8_t)(anlagenSollStatus.Schalter3 + '0'),
							anlagenSollStatus.TReglerWert);

		f16_printf_P(logStatus.logfile,PSTR("neu;%c%c%c;%2i;\r\n"),
    cbf4:	48 81       	ld	r20, Y
    cbf6:	41 70       	andi	r20, 0x01	; 1
    cbf8:	28 81       	ld	r18, Y
    cbfa:	26 95       	lsr	r18
    cbfc:	21 70       	andi	r18, 0x01	; 1
    cbfe:	38 81       	ld	r19, Y
    cc00:	36 95       	lsr	r19
    cc02:	36 95       	lsr	r19
    cc04:	31 70       	andi	r19, 0x01	; 1
    cc06:	59 81       	ldd	r21, Y+1	; 0x01
    cc08:	ed b7       	in	r30, 0x3d	; 61
    cc0a:	fe b7       	in	r31, 0x3e	; 62
    cc0c:	38 96       	adiw	r30, 0x08	; 8
    cc0e:	0f b6       	in	r0, 0x3f	; 63
    cc10:	f8 94       	cli
    cc12:	fe bf       	out	0x3e, r31	; 62
    cc14:	0f be       	out	0x3f, r0	; 63
    cc16:	ed bf       	out	0x3d, r30	; 61
    cc18:	31 96       	adiw	r30, 0x01	; 1
    cc1a:	80 91 e6 0b 	lds	r24, 0x0BE6
    cc1e:	90 91 e7 0b 	lds	r25, 0x0BE7
    cc22:	ad b7       	in	r26, 0x3d	; 61
    cc24:	be b7       	in	r27, 0x3e	; 62
    cc26:	12 96       	adiw	r26, 0x02	; 2
    cc28:	9c 93       	st	X, r25
    cc2a:	8e 93       	st	-X, r24
    cc2c:	11 97       	sbiw	r26, 0x01	; 1
    cc2e:	80 e6       	ldi	r24, 0x60	; 96
    cc30:	93 e2       	ldi	r25, 0x23	; 35
    cc32:	93 83       	std	Z+3, r25	; 0x03
    cc34:	82 83       	std	Z+2, r24	; 0x02
    cc36:	40 5d       	subi	r20, 0xD0	; 208
    cc38:	44 83       	std	Z+4, r20	; 0x04
    cc3a:	15 82       	std	Z+5, r1	; 0x05
    cc3c:	20 5d       	subi	r18, 0xD0	; 208
    cc3e:	26 83       	std	Z+6, r18	; 0x06
    cc40:	17 82       	std	Z+7, r1	; 0x07
    cc42:	30 5d       	subi	r19, 0xD0	; 208
    cc44:	30 87       	std	Z+8, r19	; 0x08
    cc46:	11 86       	std	Z+9, r1	; 0x09
    cc48:	52 87       	std	Z+10, r21	; 0x0a
    cc4a:	13 86       	std	Z+11, r1	; 0x0b
    cc4c:	0e 94 fd 4b 	call	0x97fa	; 0x97fa <f16_printf_P>
							(uint8_t)(aktSoll->Schalter1 + '0'),
							(uint8_t)(aktSoll->Schalter2 + '0'),
							(uint8_t)(aktSoll->Schalter3 + '0'),
							aktSoll->TReglerWert);

		f16_flush();	// Cache leeren
    cc50:	ed b7       	in	r30, 0x3d	; 61
    cc52:	fe b7       	in	r31, 0x3e	; 62
    cc54:	3c 96       	adiw	r30, 0x0c	; 12
    cc56:	0f b6       	in	r0, 0x3f	; 63
    cc58:	f8 94       	cli
    cc5a:	fe bf       	out	0x3e, r31	; 62
    cc5c:	0f be       	out	0x3f, r0	; 63
    cc5e:	ed bf       	out	0x3d, r30	; 61
    cc60:	0e 94 e1 4c 	call	0x99c2	; 0x99c2 <f16_flush>
	}
	#endif

	// neue Werte merken
	anlagenSollStatus.Schalter1		= aktSoll->Schalter1;
    cc64:	98 81       	ld	r25, Y
    cc66:	91 70       	andi	r25, 0x01	; 1
    cc68:	80 91 54 06 	lds	r24, 0x0654
    cc6c:	8e 7f       	andi	r24, 0xFE	; 254
    cc6e:	89 2b       	or	r24, r25
    cc70:	80 93 54 06 	sts	0x0654, r24
	anlagenSollStatus.Schalter2		= aktSoll->Schalter2;
    cc74:	98 81       	ld	r25, Y
    cc76:	92 70       	andi	r25, 0x02	; 2
    cc78:	80 91 54 06 	lds	r24, 0x0654
    cc7c:	8d 7f       	andi	r24, 0xFD	; 253
    cc7e:	89 2b       	or	r24, r25
    cc80:	80 93 54 06 	sts	0x0654, r24
	anlagenSollStatus.Schalter3		= aktSoll->Schalter3;
    cc84:	98 81       	ld	r25, Y
    cc86:	94 70       	andi	r25, 0x04	; 4
    cc88:	80 91 54 06 	lds	r24, 0x0654
    cc8c:	8b 7f       	andi	r24, 0xFB	; 251
    cc8e:	89 2b       	or	r24, r25
    cc90:	80 93 54 06 	sts	0x0654, r24
	anlagenSollStatus.TReglerWert 	= aktSoll->TReglerWert;
    cc94:	89 81       	ldd	r24, Y+1	; 0x01
    cc96:	80 93 55 06 	sts	0x0655, r24

}
    cc9a:	df 91       	pop	r29
    cc9c:	cf 91       	pop	r28
    cc9e:	1f 91       	pop	r17
    cca0:	0f 91       	pop	r16
    cca2:	08 95       	ret

0000cca4 <log_init>:
 * SD-Karte initialisieren und Logdatei auf Karte suchen
 */
void log_init()
{
	#if USE_LOGDATEI
	logStatus.logTag	= TM_DD;
    cca4:	80 91 7b 0c 	lds	r24, 0x0C7B
    cca8:	80 93 e8 0b 	sts	0x0BE8, r24
	logStatus.logMonat	= TM_MM;
    ccac:	80 91 32 0c 	lds	r24, 0x0C32
    ccb0:	80 93 e9 0b 	sts	0x0BE9, r24
	logStatus.logJahr	= TM_YY;
    ccb4:	80 91 31 0c 	lds	r24, 0x0C31
    ccb8:	80 93 ea 0b 	sts	0x0BEA, r24
	sprintf_P((char *)logStatus.log_datei,PSTR("lg%2.2i%2.2i%2.2i.csv"),logStatus.logJahr,logStatus.logMonat,logStatus.logTag);
    ccbc:	20 91 ea 0b 	lds	r18, 0x0BEA
    ccc0:	30 91 e9 0b 	lds	r19, 0x0BE9
    ccc4:	40 91 e8 0b 	lds	r20, 0x0BE8
    ccc8:	8d b7       	in	r24, 0x3d	; 61
    ccca:	9e b7       	in	r25, 0x3e	; 62
    cccc:	0a 97       	sbiw	r24, 0x0a	; 10
    ccce:	0f b6       	in	r0, 0x3f	; 63
    ccd0:	f8 94       	cli
    ccd2:	9e bf       	out	0x3e, r25	; 62
    ccd4:	0f be       	out	0x3f, r0	; 63
    ccd6:	8d bf       	out	0x3d, r24	; 61
    ccd8:	ed b7       	in	r30, 0x3d	; 61
    ccda:	fe b7       	in	r31, 0x3e	; 62
    ccdc:	31 96       	adiw	r30, 0x01	; 1
    ccde:	89 ed       	ldi	r24, 0xD9	; 217
    cce0:	9b e0       	ldi	r25, 0x0B	; 11
    cce2:	ad b7       	in	r26, 0x3d	; 61
    cce4:	be b7       	in	r27, 0x3e	; 62
    cce6:	12 96       	adiw	r26, 0x02	; 2
    cce8:	9c 93       	st	X, r25
    ccea:	8e 93       	st	-X, r24
    ccec:	11 97       	sbiw	r26, 0x01	; 1
    ccee:	8a e4       	ldi	r24, 0x4A	; 74
    ccf0:	93 e2       	ldi	r25, 0x23	; 35
    ccf2:	93 83       	std	Z+3, r25	; 0x03
    ccf4:	82 83       	std	Z+2, r24	; 0x02
    ccf6:	24 83       	std	Z+4, r18	; 0x04
    ccf8:	15 82       	std	Z+5, r1	; 0x05
    ccfa:	36 83       	std	Z+6, r19	; 0x06
    ccfc:	17 82       	std	Z+7, r1	; 0x07
    ccfe:	40 87       	std	Z+8, r20	; 0x08
    cd00:	11 86       	std	Z+9, r1	; 0x09
    cd02:	0e 94 22 6f 	call	0xde44	; 0xde44 <sprintf_P>
	MES_DEBUG("\r\nlog_init: %s",logStatus.log_datei);

	if (logStatus.logfile) {
    cd06:	80 91 e6 0b 	lds	r24, 0x0BE6
    cd0a:	90 91 e7 0b 	lds	r25, 0x0BE7
    cd0e:	2d b7       	in	r18, 0x3d	; 61
    cd10:	3e b7       	in	r19, 0x3e	; 62
    cd12:	26 5f       	subi	r18, 0xF6	; 246
    cd14:	3f 4f       	sbci	r19, 0xFF	; 255
    cd16:	0f b6       	in	r0, 0x3f	; 63
    cd18:	f8 94       	cli
    cd1a:	3e bf       	out	0x3e, r19	; 62
    cd1c:	0f be       	out	0x3f, r0	; 63
    cd1e:	2d bf       	out	0x3d, r18	; 61
    cd20:	00 97       	sbiw	r24, 0x00	; 0
    cd22:	31 f0       	breq	.+12     	; 0xcd30 <log_init+0x8c>
		f16_close(logStatus.logfile);
    cd24:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>
		logStatus.logfile = 0;
    cd28:	10 92 e7 0b 	sts	0x0BE7, r1
    cd2c:	10 92 e6 0b 	sts	0x0BE6, r1
	}
	if (cwdir_ptr) {	// falls SD-Karte vorhanden
    cd30:	80 91 cb 0d 	lds	r24, 0x0DCB
    cd34:	90 91 cc 0d 	lds	r25, 0x0DCC
    cd38:	89 2b       	or	r24, r25
    cd3a:	89 f0       	breq	.+34     	; 0xcd5e <log_init+0xba>
		logStatus.logfile = f16_open(logStatus.log_datei,"a");
    cd3c:	89 ed       	ldi	r24, 0xD9	; 217
    cd3e:	9b e0       	ldi	r25, 0x0B	; 11
    cd40:	67 ec       	ldi	r22, 0xC7	; 199
    cd42:	71 e0       	ldi	r23, 0x01	; 1
    cd44:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    cd48:	bc 01       	movw	r22, r24
    cd4a:	90 93 e7 0b 	sts	0x0BE7, r25
    cd4e:	80 93 e6 0b 	sts	0x0BE6, r24
		f16_fputs_P(PSTR("Log gestartet --------\r\n"),logStatus.logfile);
    cd52:	81 e3       	ldi	r24, 0x31	; 49
    cd54:	93 e2       	ldi	r25, 0x23	; 35
    cd56:	0e 94 ad 4c 	call	0x995a	; 0x995a <f16_fputs_P>
		f16_flush();	// Cache leeren
    cd5a:	0e 94 e1 4c 	call	0x99c2	; 0x99c2 <f16_flush>
    cd5e:	08 95       	ret

0000cd60 <initSchaltzeiten>:
/*
 *	\ingroup messen
 * Schaltzeiten von SD-Karte initialisieren
 */
int16_t initSchaltzeiten(char *outbuffer)
{
    cd60:	6f 92       	push	r6
    cd62:	7f 92       	push	r7
    cd64:	8f 92       	push	r8
    cd66:	9f 92       	push	r9
    cd68:	af 92       	push	r10
    cd6a:	bf 92       	push	r11
    cd6c:	cf 92       	push	r12
    cd6e:	df 92       	push	r13
    cd70:	ef 92       	push	r14
    cd72:	ff 92       	push	r15
    cd74:	0f 93       	push	r16
    cd76:	1f 93       	push	r17
    cd78:	df 93       	push	r29
    cd7a:	cf 93       	push	r28
    cd7c:	00 d0       	rcall	.+0      	; 0xcd7e <initSchaltzeiten+0x1e>
    cd7e:	00 d0       	rcall	.+0      	; 0xcd80 <initSchaltzeiten+0x20>
    cd80:	cd b7       	in	r28, 0x3d	; 61
    cd82:	de b7       	in	r29, 0x3e	; 62
	if (cwdir_ptr) {	// falls SD-Karte vorhanden
    cd84:	80 91 cb 0d 	lds	r24, 0x0DCB
    cd88:	90 91 cc 0d 	lds	r25, 0x0DCC
    cd8c:	89 2b       	or	r24, r25
    cd8e:	09 f4       	brne	.+2      	; 0xcd92 <initSchaltzeiten+0x32>
    cd90:	90 c0       	rjmp	.+288    	; 0xceb2 <initSchaltzeiten+0x152>

		uint8_t schaltzeit = 0;
    	uint8_t Wochentag = 0x7f;
		SOLL_STATUS Zustand;

		File *inifile = f16_open(SCHED_INIFILE,"r");
    cd92:	89 ec       	ldi	r24, 0xC9	; 201
    cd94:	91 e0       	ldi	r25, 0x01	; 1
    cd96:	61 ed       	ldi	r22, 0xD1	; 209
    cd98:	71 e0       	ldi	r23, 0x01	; 1
    cd9a:	0e 94 ef 4c 	call	0x99de	; 0x99de <f16_open>
    cd9e:	5c 01       	movw	r10, r24
		if (!inifile) return 0;
    cda0:	00 97       	sbiw	r24, 0x00	; 0
    cda2:	09 f4       	brne	.+2      	; 0xcda6 <initSchaltzeiten+0x46>
    cda4:	86 c0       	rjmp	.+268    	; 0xceb2 <initSchaltzeiten+0x152>

		f16_fseek(inifile,0,FAT16_SEEK_SET);
    cda6:	40 e0       	ldi	r20, 0x00	; 0
    cda8:	50 e0       	ldi	r21, 0x00	; 0
    cdaa:	60 e0       	ldi	r22, 0x00	; 0
    cdac:	70 e0       	ldi	r23, 0x00	; 0
    cdae:	20 e0       	ldi	r18, 0x00	; 0
    cdb0:	0e 94 95 4c 	call	0x992a	; 0x992a <f16_fseek>
		//usart_write_str("\r\nINI-File:\r\n");
		ch = f16_getc(inifile);
    cdb4:	c5 01       	movw	r24, r10
    cdb6:	0e 94 32 4c 	call	0x9864	; 0x9864 <f16_getc>
    cdba:	6c 01       	movw	r12, r24
    cdbc:	ee 24       	eor	r14, r14
    cdbe:	ff 24       	eor	r15, r15
    cdc0:	00 e0       	ldi	r16, 0x00	; 0
    cdc2:	10 e0       	ldi	r17, 0x00	; 0
    cdc4:	88 24       	eor	r8, r8
    cdc6:	6f e7       	ldi	r22, 0x7F	; 127
    cdc8:	96 2e       	mov	r9, r22
				itmp = 0;
			}

			if (ch == '\r') {
				// aktuelle Werte schreiben
				TM_SchaltzeitSet(index1, schaltzeit, Wochentag, &Zustand);
    cdca:	3e 01       	movw	r6, r28
    cdcc:	08 94       	sec
    cdce:	61 1c       	adc	r6, r1
    cdd0:	71 1c       	adc	r7, r1
    cdd2:	5f c0       	rjmp	.+190    	; 0xce92 <initSchaltzeiten+0x132>
		//usart_write_str("\r\nINI-File:\r\n");
		ch = f16_getc(inifile);
		while ( ch > 0 ) {
			//usart_write_char((char)ch);

			if (isdigit(ch)) {
    cdd4:	96 01       	movw	r18, r12
    cdd6:	20 53       	subi	r18, 0x30	; 48
    cdd8:	30 40       	sbci	r19, 0x00	; 0
    cdda:	2a 30       	cpi	r18, 0x0A	; 10
    cddc:	31 05       	cpc	r19, r1
    cdde:	60 f4       	brcc	.+24     	; 0xcdf8 <initSchaltzeiten+0x98>
				itmp *= 10;
    cde0:	c8 01       	movw	r24, r16
    cde2:	53 e0       	ldi	r21, 0x03	; 3
    cde4:	88 0f       	add	r24, r24
    cde6:	99 1f       	adc	r25, r25
    cde8:	5a 95       	dec	r21
    cdea:	e1 f7       	brne	.-8      	; 0xcde4 <initSchaltzeiten+0x84>
    cdec:	00 0f       	add	r16, r16
    cdee:	11 1f       	adc	r17, r17
    cdf0:	08 0f       	add	r16, r24
    cdf2:	19 1f       	adc	r17, r25
				itmp += (ch - '0');
    cdf4:	02 0f       	add	r16, r18
    cdf6:	13 1f       	adc	r17, r19
			}

			if (ispunct(ch)) {		// Feldtrenner ?
    cdf8:	c6 01       	movw	r24, r12
    cdfa:	0e 94 ad 6d 	call	0xdb5a	; 0xdb5a <ispunct>
    cdfe:	89 2b       	or	r24, r25
    ce00:	81 f1       	breq	.+96     	; 0xce62 <initSchaltzeiten+0x102>
				switch (index2) {	// Wert setzen und Zeiger erhhen
    ce02:	82 e0       	ldi	r24, 0x02	; 2
    ce04:	f8 16       	cp	r15, r24
    ce06:	a9 f0       	breq	.+42     	; 0xce32 <initSchaltzeiten+0xd2>
    ce08:	8f 15       	cp	r24, r15
    ce0a:	34 f0       	brlt	.+12     	; 0xce18 <initSchaltzeiten+0xb8>
    ce0c:	ff 20       	and	r15, r15
    ce0e:	69 f0       	breq	.+26     	; 0xce2a <initSchaltzeiten+0xca>
    ce10:	81 e0       	ldi	r24, 0x01	; 1
    ce12:	f8 16       	cp	r15, r24
    ce14:	19 f5       	brne	.+70     	; 0xce5c <initSchaltzeiten+0xfc>
    ce16:	0b c0       	rjmp	.+22     	; 0xce2e <initSchaltzeiten+0xce>
    ce18:	84 e0       	ldi	r24, 0x04	; 4
    ce1a:	f8 16       	cp	r15, r24
    ce1c:	b9 f0       	breq	.+46     	; 0xce4c <initSchaltzeiten+0xec>
    ce1e:	f8 16       	cp	r15, r24
    ce20:	6c f0       	brlt	.+26     	; 0xce3c <initSchaltzeiten+0xdc>
    ce22:	86 e0       	ldi	r24, 0x06	; 6
    ce24:	f8 16       	cp	r15, r24
    ce26:	d1 f4       	brne	.+52     	; 0xce5c <initSchaltzeiten+0xfc>
    ce28:	18 c0       	rjmp	.+48     	; 0xce5a <initSchaltzeiten+0xfa>
					case 0:
						schaltzeit = (uint8_t)itmp;
    ce2a:	80 2e       	mov	r8, r16
    ce2c:	17 c0       	rjmp	.+46     	; 0xce5c <initSchaltzeiten+0xfc>
						break;
					case 1:
						Wochentag = (uint8_t)itmp;
    ce2e:	90 2e       	mov	r9, r16
    ce30:	15 c0       	rjmp	.+42     	; 0xce5c <initSchaltzeiten+0xfc>
						break;
					case 2:
						Zustand.Schalter1 = (uint8_t)itmp;
    ce32:	90 2f       	mov	r25, r16
    ce34:	91 70       	andi	r25, 0x01	; 1
    ce36:	89 81       	ldd	r24, Y+1	; 0x01
    ce38:	8e 7f       	andi	r24, 0xFE	; 254
    ce3a:	05 c0       	rjmp	.+10     	; 0xce46 <initSchaltzeiten+0xe6>
						break;
					case 3:
						Zustand.Schalter2 = (uint8_t)itmp;
    ce3c:	90 2f       	mov	r25, r16
    ce3e:	91 70       	andi	r25, 0x01	; 1
    ce40:	99 0f       	add	r25, r25
    ce42:	89 81       	ldd	r24, Y+1	; 0x01
    ce44:	8d 7f       	andi	r24, 0xFD	; 253
    ce46:	89 2b       	or	r24, r25
    ce48:	89 83       	std	Y+1, r24	; 0x01
    ce4a:	08 c0       	rjmp	.+16     	; 0xce5c <initSchaltzeiten+0xfc>
						break;
					case 4:
						Zustand.Schalter3 = (uint8_t)itmp;
    ce4c:	90 2f       	mov	r25, r16
    ce4e:	91 70       	andi	r25, 0x01	; 1
    ce50:	99 0f       	add	r25, r25
    ce52:	99 0f       	add	r25, r25
    ce54:	89 81       	ldd	r24, Y+1	; 0x01
    ce56:	8b 7f       	andi	r24, 0xFB	; 251
    ce58:	f6 cf       	rjmp	.-20     	; 0xce46 <initSchaltzeiten+0xe6>
						break;
					case 6:
						Zustand.TReglerWert = (uint8_t)itmp;
    ce5a:	0a 83       	std	Y+2, r16	; 0x02
						break;
				}
				++index2;
    ce5c:	f3 94       	inc	r15
    ce5e:	00 e0       	ldi	r16, 0x00	; 0
    ce60:	10 e0       	ldi	r17, 0x00	; 0
				itmp = 0;
			}

			if (ch == '\r') {
    ce62:	8d e0       	ldi	r24, 0x0D	; 13
    ce64:	c8 16       	cp	r12, r24
    ce66:	d1 04       	cpc	r13, r1
    ce68:	81 f4       	brne	.+32     	; 0xce8a <initSchaltzeiten+0x12a>
				// aktuelle Werte schreiben
				TM_SchaltzeitSet(index1, schaltzeit, Wochentag, &Zustand);
    ce6a:	8e 2d       	mov	r24, r14
    ce6c:	68 2d       	mov	r22, r8
    ce6e:	49 2d       	mov	r20, r9
    ce70:	93 01       	movw	r18, r6
    ce72:	0e 94 85 21 	call	0x430a	; 0x430a <TM_SchaltzeitSet>

				ch = f16_getc(inifile);	// read '\n'
    ce76:	c5 01       	movw	r24, r10
    ce78:	0e 94 32 4c 	call	0x9864	; 0x9864 <f16_getc>
				if (++index1 >= TM_MAX_SCHALTZEITEN) {
    ce7c:	e3 94       	inc	r14
    ce7e:	8f e0       	ldi	r24, 0x0F	; 15
    ce80:	8e 15       	cp	r24, r14
    ce82:	5c f0       	brlt	.+22     	; 0xce9a <initSchaltzeiten+0x13a>
					break;
    ce84:	ff 24       	eor	r15, r15
    ce86:	00 e0       	ldi	r16, 0x00	; 0
    ce88:	10 e0       	ldi	r17, 0x00	; 0
				}
				itmp = 0;
				index2 = 0;	// nchsten Eintrag von vorne beginnen
			}
		ch = f16_getc(inifile);
    ce8a:	c5 01       	movw	r24, r10
    ce8c:	0e 94 32 4c 	call	0x9864	; 0x9864 <f16_getc>
    ce90:	6c 01       	movw	r12, r24
		if (!inifile) return 0;

		f16_fseek(inifile,0,FAT16_SEEK_SET);
		//usart_write_str("\r\nINI-File:\r\n");
		ch = f16_getc(inifile);
		while ( ch > 0 ) {
    ce92:	1c 14       	cp	r1, r12
    ce94:	1d 04       	cpc	r1, r13
    ce96:	0c f4       	brge	.+2      	; 0xce9a <initSchaltzeiten+0x13a>
    ce98:	9d cf       	rjmp	.-198    	; 0xcdd4 <initSchaltzeiten+0x74>
				index2 = 0;	// nchsten Eintrag von vorne beginnen
			}
		ch = f16_getc(inifile);
		}

		f16_close(inifile);
    ce9a:	c5 01       	movw	r24, r10
    ce9c:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <f16_close>

		// aktuellen Sollzustand einstellen
		SOLL_STATUS aktSoll;
		TM_SollzustandGetAktuell(&aktSoll);
    cea0:	8e 01       	movw	r16, r28
    cea2:	0d 5f       	subi	r16, 0xFD	; 253
    cea4:	1f 4f       	sbci	r17, 0xFF	; 255
    cea6:	c8 01       	movw	r24, r16
    cea8:	0e 94 21 22 	call	0x4442	; 0x4442 <TM_SollzustandGetAktuell>
		regelAnlage(&aktSoll);
    ceac:	c8 01       	movw	r24, r16
    ceae:	0e 94 a0 65 	call	0xcb40	; 0xcb40 <regelAnlage>
	}
	return 0;
}
    ceb2:	80 e0       	ldi	r24, 0x00	; 0
    ceb4:	90 e0       	ldi	r25, 0x00	; 0
    ceb6:	0f 90       	pop	r0
    ceb8:	0f 90       	pop	r0
    ceba:	0f 90       	pop	r0
    cebc:	0f 90       	pop	r0
    cebe:	cf 91       	pop	r28
    cec0:	df 91       	pop	r29
    cec2:	1f 91       	pop	r17
    cec4:	0f 91       	pop	r16
    cec6:	ff 90       	pop	r15
    cec8:	ef 90       	pop	r14
    ceca:	df 90       	pop	r13
    cecc:	cf 90       	pop	r12
    cece:	bf 90       	pop	r11
    ced0:	af 90       	pop	r10
    ced2:	9f 90       	pop	r9
    ced4:	8f 90       	pop	r8
    ced6:	7f 90       	pop	r7
    ced8:	6f 90       	pop	r6
    ceda:	08 95       	ret

0000cedc <messung_init>:
 *	\ingroup messen
 *	Initialisierung der Ein- und Ausgnge
 */
void messung_init(void)
{
	SENS_DDR &= ~(SENS_ACTIVE_PINS);		// aktive Sensoren auf Eingang
    cedc:	87 b1       	in	r24, 0x07	; 7
    cede:	8c 73       	andi	r24, 0x3C	; 60
    cee0:	87 b9       	out	0x07, r24	; 7
	SENS_PULLUP |= (SENS_ACTIVE_PINS); 		// Pullups einschalten
    cee2:	88 b1       	in	r24, 0x08	; 8
    cee4:	83 6c       	ori	r24, 0xC3	; 195
    cee6:	88 b9       	out	0x08, r24	; 8
	SENS_INTMASK |= SENS_ACTIVE_PINS;		// auf aktive Eingnge reagieren
    cee8:	ed e6       	ldi	r30, 0x6D	; 109
    ceea:	f0 e0       	ldi	r31, 0x00	; 0
    ceec:	80 81       	ld	r24, Z
    ceee:	83 6c       	ori	r24, 0xC3	; 195
    cef0:	80 83       	st	Z, r24
	SENS_INT_ENABLE();
    cef2:	e8 e6       	ldi	r30, 0x68	; 104
    cef4:	f0 e0       	ldi	r31, 0x00	; 0
    cef6:	80 81       	ld	r24, Z
    cef8:	84 60       	ori	r24, 0x04	; 4
    cefa:	80 83       	st	Z, r24

	// Ausgnge fr Relais schalten
	OUT_DDR |= (1<<PORT_SCHALTER1) | (1<<PORT_SCHALTER2) | (1<<PORT_SCHALTER3);
    cefc:	8a b1       	in	r24, 0x0a	; 10
    cefe:	80 67       	ori	r24, 0x70	; 112
    cf00:	8a b9       	out	0x0a, r24	; 10
	S1Aus(); S2Aus(); S3Aus(); 				// alles ausschalten
    cf02:	5c 98       	cbi	0x0b, 4	; 11
    cf04:	5d 98       	cbi	0x0b, 5	; 11
    cf06:	5e 98       	cbi	0x0b, 6	; 11

	machineStatus.Tlesen 		= 1;		// alle Messwerte neu lesen
    cf08:	81 e0       	ldi	r24, 0x01	; 1
    cf0a:	80 93 3e 06 	sts	0x063E, r24
	machineStatus.LogSchreiben 	= 1;
    cf0e:	80 93 41 06 	sts	0x0641, r24
	machineStatus.PINAStatus	= PINA;		// aktuellen Port-Status merken
    cf12:	80 b1       	in	r24, 0x00	; 0
    cf14:	80 93 45 06 	sts	0x0645, r24
	machineStatus.PINCStatus	= PINC;
    cf18:	86 b1       	in	r24, 0x06	; 6
    cf1a:	80 93 46 06 	sts	0x0646, r24
	machineStatus.PINDStatus	= PIND;
    cf1e:	89 b1       	in	r24, 0x09	; 9
    cf20:	80 93 47 06 	sts	0x0647, r24
	machineStatus.sendmail		= 0;		// keine E-Mail zu senden (oder REBOOT-Mail ?)
    cf24:	10 92 43 06 	sts	0x0643, r1

	#if USE_OW
	set_SensorResolution();
	#endif

	log_init();
    cf28:	0e 94 52 66 	call	0xcca4	; 0xcca4 <log_init>
	#if USE_SCHEDULER
	initSchaltzeiten(0);
    cf2c:	80 e0       	ldi	r24, 0x00	; 0
    cf2e:	90 e0       	ldi	r25, 0x00	; 0
    cf30:	0e 94 b0 66 	call	0xcd60	; 0xcd60 <initSchaltzeiten>
	#endif
}
    cf34:	08 95       	ret

0000cf36 <crc8>:

#define CRC8INIT	0x00
#define CRC8POLY	0x18              //0X18 = X^8+X^5+X^4+X^0

uint8_t	crc8 ( uint8_t *data_in, uint16_t number_of_bytes_to_read )
{
    cf36:	dc 01       	movw	r26, r24
    cf38:	20 e0       	ldi	r18, 0x00	; 0
    cf3a:	40 e0       	ldi	r20, 0x00	; 0
    cf3c:	50 e0       	ldi	r21, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
    cf3e:	98 e1       	ldi	r25, 0x18	; 24
    cf40:	15 c0       	rjmp	.+42     	; 0xcf6c <crc8+0x36>
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
	{
		data = data_in[loop_count];
    cf42:	fd 01       	movw	r30, r26
    cf44:	e4 0f       	add	r30, r20
    cf46:	f5 1f       	adc	r31, r21
    cf48:	e0 81       	ld	r30, Z
    cf4a:	38 e0       	ldi	r19, 0x08	; 8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
    cf4c:	8e 2f       	mov	r24, r30
    cf4e:	82 27       	eor	r24, r18
	
			if ( feedback_bit == 0x01 ) {
    cf50:	f8 2f       	mov	r31, r24
    cf52:	f1 70       	andi	r31, 0x01	; 1
    cf54:	80 fd       	sbrc	r24, 0
				crc = crc ^ CRC8POLY;
    cf56:	29 27       	eor	r18, r25
			}
			crc = (crc >> 1) & 0x7F;
    cf58:	26 95       	lsr	r18
			if ( feedback_bit == 0x01 ) {
    cf5a:	f1 30       	cpi	r31, 0x01	; 1
    cf5c:	09 f4       	brne	.+2      	; 0xcf60 <crc8+0x2a>
				crc = crc | 0x80;
    cf5e:	20 68       	ori	r18, 0x80	; 128
			}
		
			data = data >> 1;
			bit_counter--;
    cf60:	31 50       	subi	r19, 0x01	; 1
		
		} while (bit_counter > 0);
    cf62:	11 f0       	breq	.+4      	; 0xcf68 <crc8+0x32>
			crc = (crc >> 1) & 0x7F;
			if ( feedback_bit == 0x01 ) {
				crc = crc | 0x80;
			}
		
			data = data >> 1;
    cf64:	e6 95       	lsr	r30
    cf66:	f2 cf       	rjmp	.-28     	; 0xcf4c <crc8+0x16>
	uint8_t  data;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
    cf68:	4f 5f       	subi	r20, 0xFF	; 255
    cf6a:	5f 4f       	sbci	r21, 0xFF	; 255
    cf6c:	46 17       	cp	r20, r22
    cf6e:	57 07       	cpc	r21, r23
    cf70:	41 f7       	brne	.-48     	; 0xcf42 <crc8+0xc>
		
		} while (bit_counter > 0);
	}
	
	return crc;
}
    cf72:	82 2f       	mov	r24, r18
    cf74:	08 95       	ret

0000cf76 <ow_input_pin_state>:

#endif

uint8_t ow_input_pin_state()
{
	return OW_GET_IN();
    cf76:	89 b1       	in	r24, 0x09	; 9
}
    cf78:	80 78       	andi	r24, 0x80	; 128
    cf7a:	08 95       	ret

0000cf7c <ow_parasite_enable>:

void ow_parasite_enable(void)
{
    OW_OUT_HIGH();
    cf7c:	5f 9a       	sbi	0x0b, 7	; 11
	OW_DIR_OUT();
    cf7e:	57 9a       	sbi	0x0a, 7	; 10
}
    cf80:	08 95       	ret

0000cf82 <ow_parasite_disable>:

void ow_parasite_disable(void)
{
    OW_OUT_LOW();
    cf82:	5f 98       	cbi	0x0b, 7	; 11
	OW_DIR_IN();
    cf84:	57 98       	cbi	0x0a, 7	; 10
}
    cf86:	08 95       	ret

0000cf88 <ow_reset>:
uint8_t ow_reset(void)
{
	uint8_t err;
	uint8_t sreg;
	
	OW_OUT_LOW(); // disable internal pull-up (maybe on from parasite)
    cf88:	5f 98       	cbi	0x0b, 7	; 11
	OW_DIR_OUT(); // pull OW-Pin low for 480us
    cf8a:	57 9a       	sbi	0x0a, 7	; 10
    cf8c:	89 ee       	ldi	r24, 0xE9	; 233
    cf8e:	96 e0       	ldi	r25, 0x06	; 6
    cf90:	01 97       	sbiw	r24, 0x01	; 1
    cf92:	f1 f7       	brne	.-4      	; 0xcf90 <ow_reset+0x8>
	
	_delay_us(480);
	
	sreg=SREG;
    cf94:	8f b7       	in	r24, 0x3f	; 63
	cli();
    cf96:	f8 94       	cli
	
	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
    cf98:	57 98       	cbi	0x0a, 7	; 10
    cf9a:	e3 ef       	ldi	r30, 0xF3	; 243
    cf9c:	f0 e0       	ldi	r31, 0x00	; 0
    cf9e:	31 97       	sbiw	r30, 0x01	; 1
    cfa0:	f1 f7       	brne	.-4      	; 0xcf9e <ow_reset+0x16>
	
	_delay_us(66);

	err = OW_GET_IN();		// no presence detect
    cfa2:	29 b1       	in	r18, 0x09	; 9
	// nobody pulled to low, still high
	
	SREG=sreg; // sei()
    cfa4:	8f bf       	out	0x3f, r24	; 63
    cfa6:	86 ef       	ldi	r24, 0xF6	; 246
    cfa8:	95 e0       	ldi	r25, 0x05	; 5
    cfaa:	01 97       	sbiw	r24, 0x01	; 1
    cfac:	f1 f7       	brne	.-4      	; 0xcfaa <ow_reset+0x22>
	
	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
    cfae:	4f 99       	sbic	0x09, 7	; 9
    cfb0:	02 c0       	rjmp	.+4      	; 0xcfb6 <ow_reset+0x2e>
    cfb2:	81 e0       	ldi	r24, 0x01	; 1
    cfb4:	08 95       	ret
	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
	
	_delay_us(66);

	err = OW_GET_IN();		// no presence detect
    cfb6:	82 2f       	mov	r24, r18
    cfb8:	80 78       	andi	r24, 0x80	; 128
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
		err = 1;
	
	return err;
}
    cfba:	08 95       	ret

0000cfbc <ow_bit_io>:
   cycles than the constant ones so the delays had to be shortened 
   to achive a 15uS overall delay 
   Setting/clearing a bit in I/O Register needs 1 cyle in OW_ONE_BUS
   but around 14 cyles in configureable bus (us-Delay is 4 cyles per uS) */
uint8_t ow_bit_io( uint8_t b )
{
    cfbc:	98 2f       	mov	r25, r24
	uint8_t sreg;
	
	sreg=SREG;
    cfbe:	2f b7       	in	r18, 0x3f	; 63
	cli();
    cfc0:	f8 94       	cli
	
	OW_DIR_OUT(); // drive bus low
    cfc2:	57 9a       	sbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    cfc4:	89 e0       	ldi	r24, 0x09	; 9
    cfc6:	8a 95       	dec	r24
    cfc8:	f1 f7       	brne	.-4      	; 0xcfc6 <ow_bit_io+0xa>
	
	_delay_us(2); // Recovery-Time wuffwuff was 1	// normal 6 us
	if ( b ) OW_DIR_IN(); // if bit is 1 set bus high (by ext. pull-up)
    cfca:	91 11       	cpse	r25, r1
    cfcc:	57 98       	cbi	0x0a, 7	; 10
    cfce:	8f e3       	ldi	r24, 0x3F	; 63
    cfd0:	8a 95       	dec	r24
    cfd2:	f1 f7       	brne	.-4      	; 0xcfd0 <ow_bit_io+0x14>
		
	// wuffwuff delay was 15uS-1 see comment above
	_delay_us(15-2-OW_CONF_DELAYOFFSET);
		
	if( OW_GET_IN() == 0 ) b = 0;  // sample at end of read-timeslot
    cfd4:	89 b1       	in	r24, 0x09	; 9
    cfd6:	88 0f       	add	r24, r24
    cfd8:	88 0b       	sbc	r24, r24
    cfda:	89 23       	and	r24, r25
    cfdc:	9d ed       	ldi	r25, 0xDD	; 221
    cfde:	9a 95       	dec	r25
    cfe0:	f1 f7       	brne	.-4      	; 0xcfde <ow_bit_io+0x22>
	
	_delay_us(60-15);
	OW_DIR_IN();
    cfe2:	57 98       	cbi	0x0a, 7	; 10
	
	SREG=sreg; // sei();
    cfe4:	2f bf       	out	0x3f, r18	; 63
    cfe6:	91 e3       	ldi	r25, 0x31	; 49
    cfe8:	9a 95       	dec	r25
    cfea:	f1 f7       	brne	.-4      	; 0xcfe8 <ow_bit_io+0x2c>
	_delay_us(10);	// bei langen Kabeln kann dieser Wert wohl auch um einiges grer sein! (recovery time)
	
	return b;
}
    cfec:	08 95       	ret

0000cfee <ow_byte_wr>:


uint8_t ow_byte_wr( uint8_t b )
{
    cfee:	0f 93       	push	r16
    cff0:	1f 93       	push	r17
    cff2:	18 2f       	mov	r17, r24
    cff4:	08 e0       	ldi	r16, 0x08	; 8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
    cff6:	81 2f       	mov	r24, r17
    cff8:	81 70       	andi	r24, 0x01	; 1
    cffa:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <ow_bit_io>
		b >>= 1;
    cffe:	16 95       	lsr	r17
		if( j ) b |= 0x80;
    d000:	81 11       	cpse	r24, r1
    d002:	10 68       	ori	r17, 0x80	; 128
	} while( --i );
    d004:	01 50       	subi	r16, 0x01	; 1
    d006:	b9 f7       	brne	.-18     	; 0xcff6 <ow_byte_wr+0x8>
	
	return b;
}
    d008:	81 2f       	mov	r24, r17
    d00a:	1f 91       	pop	r17
    d00c:	0f 91       	pop	r16
    d00e:	08 95       	ret

0000d010 <ow_byte_rd>:


uint8_t ow_byte_rd( void )
{
  // read by sending 0xff (a dontcare?)
  return ow_byte_wr( 0xFF ); 
    d010:	8f ef       	ldi	r24, 0xFF	; 255
    d012:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
}
    d016:	08 95       	ret

0000d018 <ow_rom_search>:


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
    d018:	df 92       	push	r13
    d01a:	ef 92       	push	r14
    d01c:	ff 92       	push	r15
    d01e:	0f 93       	push	r16
    d020:	1f 93       	push	r17
    d022:	cf 93       	push	r28
    d024:	df 93       	push	r29
    d026:	e8 2e       	mov	r14, r24
    d028:	eb 01       	movw	r28, r22
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
    d02a:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
    d02e:	88 23       	and	r24, r24
    d030:	a1 f5       	brne	.+104    	; 0xd09a <ow_rom_search+0x82>
	
	ow_byte_wr( OW_SEARCH_ROM );				// ROM search command
    d032:	80 ef       	ldi	r24, 0xF0	; 240
    d034:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
    d038:	ff 24       	eor	r15, r15
    d03a:	80 e4       	ldi	r24, 0x40	; 64
    d03c:	18 2f       	mov	r17, r24
			*id >>= 1;
			if( b ) *id |= 0x80;			// store bit
			
			i--;
			
		} while( --j );
    d03e:	98 ef       	ldi	r25, 0xF8	; 248
    d040:	d9 2e       	mov	r13, r25
    d042:	d8 0e       	add	r13, r24
	i = OW_ROMCODE_SIZE * 8;					// 8 bytes
	
	do {
		j = 8;									// 8 bits
		do {
			b = ow_bit_io( 1 );					// read bit
    d044:	81 e0       	ldi	r24, 0x01	; 1
    d046:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <ow_bit_io>
    d04a:	08 2f       	mov	r16, r24
			if( ow_bit_io( 1 ) ) {				// read complement bit
    d04c:	81 e0       	ldi	r24, 0x01	; 1
    d04e:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <ow_bit_io>
    d052:	88 23       	and	r24, r24
    d054:	29 f0       	breq	.+10     	; 0xd060 <ow_rom_search+0x48>
				if( b )							// 11
    d056:	00 23       	and	r16, r16
    d058:	71 f0       	breq	.+28     	; 0xd076 <ow_rom_search+0x5e>
    d05a:	8e ef       	ldi	r24, 0xFE	; 254
    d05c:	f8 2e       	mov	r15, r24
    d05e:	1f c0       	rjmp	.+62     	; 0xd09e <ow_rom_search+0x86>
				return OW_DATA_ERR;				// data error
			}
			else {
				if( !b ) {						// 00 = 2 devices
    d060:	00 23       	and	r16, r16
    d062:	49 f4       	brne	.+18     	; 0xd076 <ow_rom_search+0x5e>
					if( diff > i || ((*id & 1) && diff != i) ) {
    d064:	1e 15       	cp	r17, r14
    d066:	28 f0       	brcs	.+10     	; 0xd072 <ow_rom_search+0x5a>
    d068:	88 81       	ld	r24, Y
    d06a:	80 ff       	sbrs	r24, 0
    d06c:	04 c0       	rjmp	.+8      	; 0xd076 <ow_rom_search+0x5e>
    d06e:	e1 16       	cp	r14, r17
    d070:	11 f0       	breq	.+4      	; 0xd076 <ow_rom_search+0x5e>
    d072:	f1 2e       	mov	r15, r17
    d074:	01 e0       	ldi	r16, 0x01	; 1
					b = 1;				// now 1
					next_diff = i;			// next pass 0
					}
				}
			}
			ow_bit_io( b );     			// write bit
    d076:	80 2f       	mov	r24, r16
    d078:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <ow_bit_io>
			*id >>= 1;
    d07c:	88 81       	ld	r24, Y
    d07e:	86 95       	lsr	r24
    d080:	88 83       	st	Y, r24
			if( b ) *id |= 0x80;			// store bit
    d082:	00 23       	and	r16, r16
    d084:	11 f0       	breq	.+4      	; 0xd08a <ow_rom_search+0x72>
    d086:	80 68       	ori	r24, 0x80	; 128
    d088:	88 83       	st	Y, r24
			
			i--;
    d08a:	11 50       	subi	r17, 0x01	; 1
			
		} while( --j );
    d08c:	1d 15       	cp	r17, r13
    d08e:	d1 f6       	brne	.-76     	; 0xd044 <ow_rom_search+0x2c>
		
		id++;					// next byte
	
	} while( i );
    d090:	11 23       	and	r17, r17
    d092:	29 f0       	breq	.+10     	; 0xd09e <ow_rom_search+0x86>
			
			i--;
			
		} while( --j );
		
		id++;					// next byte
    d094:	21 96       	adiw	r28, 0x01	; 1
    d096:	81 2f       	mov	r24, r17
    d098:	d1 cf       	rjmp	.-94     	; 0xd03c <ow_rom_search+0x24>
    d09a:	ff 24       	eor	r15, r15
    d09c:	fa 94       	dec	r15
	
	} while( i );
	
	return next_diff;				// to continue search
}
    d09e:	8f 2d       	mov	r24, r15
    d0a0:	df 91       	pop	r29
    d0a2:	cf 91       	pop	r28
    d0a4:	1f 91       	pop	r17
    d0a6:	0f 91       	pop	r16
    d0a8:	ff 90       	pop	r15
    d0aa:	ef 90       	pop	r14
    d0ac:	df 90       	pop	r13
    d0ae:	08 95       	ret

0000d0b0 <ow_command>:


void ow_command( uint8_t command, uint8_t *id )
{
    d0b0:	0f 93       	push	r16
    d0b2:	1f 93       	push	r17
    d0b4:	cf 93       	push	r28
    d0b6:	df 93       	push	r29
    d0b8:	08 2f       	mov	r16, r24
    d0ba:	eb 01       	movw	r28, r22
	uint8_t i;

	ow_reset();
    d0bc:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>

	if( id ) {
    d0c0:	20 97       	sbiw	r28, 0x00	; 0
    d0c2:	51 f0       	breq	.+20     	; 0xd0d8 <ow_command+0x28>
		ow_byte_wr( OW_MATCH_ROM );			// to a single device
    d0c4:	85 e5       	ldi	r24, 0x55	; 85
    d0c6:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
    d0ca:	18 e0       	ldi	r17, 0x08	; 8
		i = OW_ROMCODE_SIZE;
		do {
			ow_byte_wr( *id );
    d0cc:	89 91       	ld	r24, Y+
    d0ce:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
			id++;
		} while( --i );
    d0d2:	11 50       	subi	r17, 0x01	; 1
    d0d4:	d9 f7       	brne	.-10     	; 0xd0cc <ow_command+0x1c>
    d0d6:	03 c0       	rjmp	.+6      	; 0xd0de <ow_command+0x2e>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
    d0d8:	8c ec       	ldi	r24, 0xCC	; 204
    d0da:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
	}
	
	ow_byte_wr( command );
    d0de:	80 2f       	mov	r24, r16
    d0e0:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
}
    d0e4:	df 91       	pop	r29
    d0e6:	cf 91       	pop	r28
    d0e8:	1f 91       	pop	r17
    d0ea:	0f 91       	pop	r16
    d0ec:	08 95       	ret

0000d0ee <DS18X20_meas_to_cel>:

   TODO invalid-values detection (but should be covered by CRC)
*/
uint8_t DS18X20_meas_to_cel( uint8_t fc, uint8_t *sp, 
	uint8_t* subzero, uint8_t* cel, uint8_t* cel_frac_bits)
{
    d0ee:	ff 92       	push	r15
    d0f0:	0f 93       	push	r16
    d0f2:	1f 93       	push	r17
    d0f4:	cf 93       	push	r28
    d0f6:	df 93       	push	r29
    d0f8:	f8 2e       	mov	r15, r24
    d0fa:	fb 01       	movw	r30, r22
    d0fc:	da 01       	movw	r26, r20
    d0fe:	e9 01       	movw	r28, r18
	uint16_t meas;
	uint8_t  i;
	
	meas = sp[0];  // LSB
    d100:	80 81       	ld	r24, Z
    d102:	48 2f       	mov	r20, r24
    d104:	50 e0       	ldi	r21, 0x00	; 0
	meas |= ((uint16_t)sp[1])<<8; // MSB
    d106:	91 81       	ldd	r25, Z+1	; 0x01
    d108:	80 e0       	ldi	r24, 0x00	; 0
    d10a:	48 2b       	or	r20, r24
    d10c:	59 2b       	or	r21, r25
	//meas = 0xff5e; meas = 0xfe6f;
	
	//  only work on 12bit-base
	if( fc == DS18S20_ID ) { // 9 -> 12 bit if 18S20
    d10e:	80 e1       	ldi	r24, 0x10	; 16
    d110:	f8 16       	cp	r15, r24
    d112:	71 f4       	brne	.+28     	; 0xd130 <DS18X20_meas_to_cel+0x42>
		/* Extended measurements for DS18S20 contributed by Carsten Foss */
		meas &= (uint16_t) 0xfffe;	// Discard LSB , needed for later extended precicion calc
    d114:	ca 01       	movw	r24, r20
    d116:	8e 7f       	andi	r24, 0xFE	; 254
		meas <<= 3;					// Convert to 12-bit , now degrees are in 1/16 degrees units
    d118:	33 e0       	ldi	r19, 0x03	; 3
    d11a:	88 0f       	add	r24, r24
    d11c:	99 1f       	adc	r25, r25
    d11e:	3a 95       	dec	r19
    d120:	e1 f7       	brne	.-8      	; 0xd11a <DS18X20_meas_to_cel+0x2c>
		meas += (16 - sp[6]) - 4;	// Add the compensation , and remember to subtract 0.25 degree (4/16)
    d122:	26 81       	ldd	r18, Z+6	; 0x06
    d124:	4c e0       	ldi	r20, 0x0C	; 12
    d126:	50 e0       	ldi	r21, 0x00	; 0
    d128:	42 1b       	sub	r20, r18
    d12a:	51 09       	sbc	r21, r1
    d12c:	48 0f       	add	r20, r24
    d12e:	59 1f       	adc	r21, r25
	}
	
	// check for negative 
	if ( meas & 0x8000 )  {
    d130:	57 ff       	sbrs	r21, 7
    d132:	06 c0       	rjmp	.+12     	; 0xd140 <DS18X20_meas_to_cel+0x52>
		*subzero=1;      // mark negative
    d134:	81 e0       	ldi	r24, 0x01	; 1
    d136:	8c 93       	st	X, r24
		meas ^= 0xffff;  // convert to positive => (twos complement)++
		meas++;
    d138:	50 95       	com	r21
    d13a:	41 95       	neg	r20
    d13c:	5f 4f       	sbci	r21, 0xFF	; 255
    d13e:	01 c0       	rjmp	.+2      	; 0xd142 <DS18X20_meas_to_cel+0x54>
	}
	else *subzero=0;
    d140:	1c 92       	st	X, r1
	
	// clear undefined bits for B != 12bit
	if ( fc == DS18B20_ID ) { // check resolution 18B20
    d142:	88 e2       	ldi	r24, 0x28	; 40
    d144:	f8 16       	cp	r15, r24
    d146:	91 f4       	brne	.+36     	; 0xd16c <DS18X20_meas_to_cel+0x7e>
		i = sp[DS18B20_CONF_REG];
		if ( (i & DS18B20_12_BIT) == DS18B20_12_BIT ) ;
    d148:	84 81       	ldd	r24, Z+4	; 0x04
    d14a:	68 2f       	mov	r22, r24
    d14c:	70 e0       	ldi	r23, 0x00	; 0
    d14e:	cb 01       	movw	r24, r22
    d150:	80 76       	andi	r24, 0x60	; 96
    d152:	90 70       	andi	r25, 0x00	; 0
    d154:	80 36       	cpi	r24, 0x60	; 96
    d156:	91 05       	cpc	r25, r1
    d158:	49 f0       	breq	.+18     	; 0xd16c <DS18X20_meas_to_cel+0x7e>
		else if ( (i & DS18B20_11_BIT) == DS18B20_11_BIT ) 
    d15a:	66 ff       	sbrs	r22, 6
    d15c:	02 c0       	rjmp	.+4      	; 0xd162 <DS18X20_meas_to_cel+0x74>
			meas &= ~(DS18B20_11_BIT_UNDF);
    d15e:	4e 7f       	andi	r20, 0xFE	; 254
    d160:	05 c0       	rjmp	.+10     	; 0xd16c <DS18X20_meas_to_cel+0x7e>
		else if ( (i & DS18B20_10_BIT) == DS18B20_10_BIT ) 
    d162:	65 ff       	sbrs	r22, 5
    d164:	02 c0       	rjmp	.+4      	; 0xd16a <DS18X20_meas_to_cel+0x7c>
			meas &= ~(DS18B20_10_BIT_UNDF);
    d166:	4c 7f       	andi	r20, 0xFC	; 252
    d168:	01 c0       	rjmp	.+2      	; 0xd16c <DS18X20_meas_to_cel+0x7e>
		else { // if ( (i & DS18B20_9_BIT) == DS18B20_9_BIT ) { 
			meas &= ~(DS18B20_9_BIT_UNDF);
    d16a:	48 7f       	andi	r20, 0xF8	; 248
		}
	}			
	
	*cel  = (uint8_t)(meas >> 4); 
    d16c:	ca 01       	movw	r24, r20
    d16e:	24 e0       	ldi	r18, 0x04	; 4
    d170:	96 95       	lsr	r25
    d172:	87 95       	ror	r24
    d174:	2a 95       	dec	r18
    d176:	e1 f7       	brne	.-8      	; 0xd170 <DS18X20_meas_to_cel+0x82>
    d178:	88 83       	st	Y, r24
	*cel_frac_bits = (uint8_t)(meas & 0x000F);
    d17a:	84 2f       	mov	r24, r20
    d17c:	8f 70       	andi	r24, 0x0F	; 15
    d17e:	f8 01       	movw	r30, r16
    d180:	80 83       	st	Z, r24
	
	return DS18X20_OK;
}
    d182:	80 e0       	ldi	r24, 0x00	; 0
    d184:	df 91       	pop	r29
    d186:	cf 91       	pop	r28
    d188:	1f 91       	pop	r17
    d18a:	0f 91       	pop	r16
    d18c:	ff 90       	pop	r15
    d18e:	08 95       	ret

0000d190 <DS18X20_temp_to_decicel>:

	i.e.: sz=0, c=28, frac=15 returns 289 (=28.9C)
 */
uint16_t DS18X20_temp_to_decicel(uint8_t subzero, uint8_t cel, 
	uint8_t cel_frac_bits)
{
    d190:	f8 2f       	mov	r31, r24
    d192:	e6 2f       	mov	r30, r22
	uint16_t h;
	uint8_t  i;
	
	h = cel_frac_bits*DS18X20_FRACCONV/1000;
    d194:	24 2f       	mov	r18, r20
    d196:	30 e0       	ldi	r19, 0x00	; 0
    d198:	81 e7       	ldi	r24, 0x71	; 113
    d19a:	92 e0       	ldi	r25, 0x02	; 2
    d19c:	bc 01       	movw	r22, r24
    d19e:	26 9f       	mul	r18, r22
    d1a0:	c0 01       	movw	r24, r0
    d1a2:	27 9f       	mul	r18, r23
    d1a4:	90 0d       	add	r25, r0
    d1a6:	36 9f       	mul	r19, r22
    d1a8:	90 0d       	add	r25, r0
    d1aa:	11 24       	eor	r1, r1
    d1ac:	68 ee       	ldi	r22, 0xE8	; 232
    d1ae:	73 e0       	ldi	r23, 0x03	; 3
    d1b0:	0e 94 4f 6b 	call	0xd69e	; 0xd69e <__divmodhi4>
	h += cel*10;
    d1b4:	2a e0       	ldi	r18, 0x0A	; 10
    d1b6:	e2 9f       	mul	r30, r18
    d1b8:	90 01       	movw	r18, r0
    d1ba:	11 24       	eor	r1, r1
    d1bc:	26 0f       	add	r18, r22
    d1be:	37 1f       	adc	r19, r23
	if (!subzero) {
    d1c0:	ff 23       	and	r31, r31
    d1c2:	69 f4       	brne	.+26     	; 0xd1de <DS18X20_temp_to_decicel+0x4e>
    d1c4:	e2 e9       	ldi	r30, 0x92	; 146
    d1c6:	f3 e2       	ldi	r31, 0x23	; 35
		for (i=0; i<sizeof(need_rounding); i++) {
			if ( cel_frac_bits == pgm_read_byte(&need_rounding[i]) ) {
    d1c8:	84 91       	lpm	r24, Z+
    d1ca:	48 17       	cp	r20, r24
    d1cc:	19 f4       	brne	.+6      	; 0xd1d4 <DS18X20_temp_to_decicel+0x44>
				h++;
    d1ce:	2f 5f       	subi	r18, 0xFF	; 255
    d1d0:	3f 4f       	sbci	r19, 0xFF	; 255
    d1d2:	05 c0       	rjmp	.+10     	; 0xd1de <DS18X20_temp_to_decicel+0x4e>
				break;
    d1d4:	31 96       	adiw	r30, 0x01	; 1
	uint8_t  i;
	
	h = cel_frac_bits*DS18X20_FRACCONV/1000;
	h += cel*10;
	if (!subzero) {
		for (i=0; i<sizeof(need_rounding); i++) {
    d1d6:	73 e2       	ldi	r23, 0x23	; 35
    d1d8:	ea 39       	cpi	r30, 0x9A	; 154
    d1da:	f7 07       	cpc	r31, r23
    d1dc:	a9 f7       	brne	.-22     	; 0xd1c8 <DS18X20_temp_to_decicel+0x38>
				break;
			}
		}
	}
	return h;
}
    d1de:	c9 01       	movw	r24, r18
    d1e0:	08 95       	ret

0000d1e2 <DS18X20_temp_cmp>:
            0 if == <br>
			1 if >    */
int8_t DS18X20_temp_cmp(uint8_t subzero1, uint16_t cel1, 
	uint8_t subzero2, uint16_t cel2)
{
	int16_t t1 = (subzero1) ? (cel1*(-1)) : (cel1);
    d1e2:	88 23       	and	r24, r24
    d1e4:	19 f0       	breq	.+6      	; 0xd1ec <DS18X20_temp_cmp+0xa>
    d1e6:	70 95       	com	r23
    d1e8:	61 95       	neg	r22
    d1ea:	7f 4f       	sbci	r23, 0xFF	; 255
	int16_t t2 = (subzero2) ? (cel2*(-1)) : (cel2);
    d1ec:	44 23       	and	r20, r20
    d1ee:	19 f0       	breq	.+6      	; 0xd1f6 <DS18X20_temp_cmp+0x14>
    d1f0:	30 95       	com	r19
    d1f2:	21 95       	neg	r18
    d1f4:	3f 4f       	sbci	r19, 0xFF	; 255
	
	if (t1<t2) return -1;
    d1f6:	62 17       	cp	r22, r18
    d1f8:	73 07       	cpc	r23, r19
    d1fa:	14 f4       	brge	.+4      	; 0xd200 <DS18X20_temp_cmp+0x1e>
    d1fc:	8f ef       	ldi	r24, 0xFF	; 255
    d1fe:	08 95       	ret
    d200:	80 e0       	ldi	r24, 0x00	; 0
    d202:	26 17       	cp	r18, r22
    d204:	37 07       	cpc	r19, r23
    d206:	0c f4       	brge	.+2      	; 0xd20a <DS18X20_temp_cmp+0x28>
    d208:	81 e0       	ldi	r24, 0x01	; 1
	if (t1>t2) return 1;
	return 0;
}
    d20a:	08 95       	ret

0000d20c <DS18X20_recall_E2>:
		return DS18X20_START_FAIL;
	}
}

uint8_t DS18X20_recall_E2( uint8_t id[] )
{
    d20c:	cf 93       	push	r28
    d20e:	df 93       	push	r29
    d210:	ec 01       	movw	r28, r24
	ow_reset(); //**
    d212:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    d216:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <ow_input_pin_state>
    d21a:	88 23       	and	r24, r24
    d21c:	11 f4       	brne	.+4      	; 0xd222 <DS18X20_recall_E2+0x16>
    d21e:	81 e0       	ldi	r24, 0x01	; 1
    d220:	09 c0       	rjmp	.+18     	; 0xd234 <DS18X20_recall_E2+0x28>
		ow_command( DS18X20_RECALL_E2, id );
    d222:	88 eb       	ldi	r24, 0xB8	; 184
    d224:	be 01       	movw	r22, r28
    d226:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    d22a:	80 e0       	ldi	r24, 0x00	; 0
    d22c:	90 e9       	ldi	r25, 0x90	; 144
    d22e:	01 97       	sbiw	r24, 0x01	; 1
    d230:	f1 f7       	brne	.-4      	; 0xd22e <DS18X20_recall_E2+0x22>
    d232:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		uart_puts( "DS18X20_recall_E2: Short Circuit !\r" );
		#endif
		return DS18X20_ERROR;
	}
}
    d234:	df 91       	pop	r29
    d236:	cf 91       	pop	r28
    d238:	08 95       	ret

0000d23a <DS18X20_start_meas>:
 * \ingroup onewire

 start measurement (CONVERT_T) for all sensors if input id==NULL 
   or for single sensor. then id is the rom-code */
uint8_t DS18X20_start_meas( uint8_t with_power_extern, uint8_t id[])
{
    d23a:	1f 93       	push	r17
    d23c:	cf 93       	push	r28
    d23e:	df 93       	push	r29
    d240:	18 2f       	mov	r17, r24
    d242:	eb 01       	movw	r28, r22
	ow_reset(); //**
    d244:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    d248:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <ow_input_pin_state>
    d24c:	88 23       	and	r24, r24
    d24e:	11 f4       	brne	.+4      	; 0xd254 <DS18X20_start_meas+0x1a>
    d250:	82 e0       	ldi	r24, 0x02	; 2
    d252:	09 c0       	rjmp	.+18     	; 0xd266 <DS18X20_start_meas+0x2c>
		ow_command( DS18X20_CONVERT_T, id );
    d254:	84 e4       	ldi	r24, 0x44	; 68
    d256:	be 01       	movw	r22, r28
    d258:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
		if (with_power_extern != DS18X20_POWER_EXTERN)
    d25c:	11 30       	cpi	r17, 0x01	; 1
    d25e:	11 f0       	breq	.+4      	; 0xd264 <DS18X20_start_meas+0x2a>
			ow_parasite_enable();
    d260:	0e 94 be 67 	call	0xcf7c	; 0xcf7c <ow_parasite_enable>
    d264:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		uart_puts_P( "DS18X20_start_meas: Short Circuit !\r" );
		#endif
		return DS18X20_START_FAIL;
	}
}
    d266:	df 91       	pop	r29
    d268:	cf 91       	pop	r28
    d26a:	1f 91       	pop	r17
    d26c:	08 95       	ret

0000d26e <DS18X20_copy_scratchpad>:
	}
}

uint8_t DS18X20_copy_scratchpad( uint8_t with_power_extern, 
	uint8_t id[] )
{
    d26e:	1f 93       	push	r17
    d270:	cf 93       	push	r28
    d272:	df 93       	push	r29
    d274:	18 2f       	mov	r17, r24
    d276:	eb 01       	movw	r28, r22
	ow_reset(); //**
    d278:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    d27c:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <ow_input_pin_state>
    d280:	88 23       	and	r24, r24
    d282:	11 f4       	brne	.+4      	; 0xd288 <DS18X20_copy_scratchpad+0x1a>
    d284:	82 e0       	ldi	r24, 0x02	; 2
    d286:	11 c0       	rjmp	.+34     	; 0xd2aa <DS18X20_copy_scratchpad+0x3c>
		ow_command( DS18X20_COPY_SCRATCHPAD, id );
    d288:	88 e4       	ldi	r24, 0x48	; 72
    d28a:	be 01       	movw	r22, r28
    d28c:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
		if (with_power_extern != DS18X20_POWER_EXTERN)
    d290:	11 30       	cpi	r17, 0x01	; 1
    d292:	11 f0       	breq	.+4      	; 0xd298 <DS18X20_copy_scratchpad+0x2a>
			ow_parasite_enable();
    d294:	0e 94 be 67 	call	0xcf7c	; 0xcf7c <ow_parasite_enable>
    d298:	80 e0       	ldi	r24, 0x00	; 0
    d29a:	90 e9       	ldi	r25, 0x90	; 144
    d29c:	01 97       	sbiw	r24, 0x01	; 1
    d29e:	f1 f7       	brne	.-4      	; 0xd29c <DS18X20_copy_scratchpad+0x2e>
		_delay_ms(DS18X20_COPYSP_DELAY); // wait for 10 ms 
		if (with_power_extern != DS18X20_POWER_EXTERN)
    d2a0:	11 30       	cpi	r17, 0x01	; 1
    d2a2:	11 f0       	breq	.+4      	; 0xd2a8 <DS18X20_copy_scratchpad+0x3a>
			ow_parasite_disable();
    d2a4:	0e 94 c1 67 	call	0xcf82	; 0xcf82 <ow_parasite_disable>
    d2a8:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		uart_puts_P( "DS18X20_copy_scratchpad: Short Circuit !\r" );
		#endif
		return DS18X20_START_FAIL;
	}
}
    d2aa:	df 91       	pop	r29
    d2ac:	cf 91       	pop	r28
    d2ae:	1f 91       	pop	r17
    d2b0:	08 95       	ret

0000d2b2 <DS18X20_read_scratchpad>:
		return DS18X20_ERROR;
	}
}

uint8_t DS18X20_read_scratchpad( uint8_t id[], uint8_t sp[] )
{
    d2b2:	0f 93       	push	r16
    d2b4:	1f 93       	push	r17
    d2b6:	cf 93       	push	r28
    d2b8:	df 93       	push	r29
    d2ba:	ec 01       	movw	r28, r24
    d2bc:	8b 01       	movw	r16, r22
	uint8_t i;
	
	ow_reset(); //**
    d2be:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    d2c2:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <ow_input_pin_state>
    d2c6:	88 23       	and	r24, r24
    d2c8:	11 f4       	brne	.+4      	; 0xd2ce <DS18X20_read_scratchpad+0x1c>
    d2ca:	81 e0       	ldi	r24, 0x01	; 1
    d2cc:	11 c0       	rjmp	.+34     	; 0xd2f0 <DS18X20_read_scratchpad+0x3e>
		ow_command( DS18X20_READ, id );
    d2ce:	8e eb       	ldi	r24, 0xBE	; 190
    d2d0:	be 01       	movw	r22, r28
    d2d2:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
    d2d6:	c0 e0       	ldi	r28, 0x00	; 0
    d2d8:	d0 e0       	ldi	r29, 0x00	; 0
		for ( i=0 ; i< DS18X20_SP_SIZE; i++ )	sp[i]=ow_byte_rd();
    d2da:	0e 94 08 68 	call	0xd010	; 0xd010 <ow_byte_rd>
    d2de:	f8 01       	movw	r30, r16
    d2e0:	ec 0f       	add	r30, r28
    d2e2:	fd 1f       	adc	r31, r29
    d2e4:	80 83       	st	Z, r24
    d2e6:	21 96       	adiw	r28, 0x01	; 1
    d2e8:	c9 30       	cpi	r28, 0x09	; 9
    d2ea:	d1 05       	cpc	r29, r1
    d2ec:	b1 f7       	brne	.-20     	; 0xd2da <DS18X20_read_scratchpad+0x28>
    d2ee:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		uart_puts_P( "DS18X20_read_scratchpad: Short Circuit !\r" );
		#endif
		return DS18X20_ERROR;
	}
}
    d2f0:	df 91       	pop	r29
    d2f2:	cf 91       	pop	r28
    d2f4:	1f 91       	pop	r17
    d2f6:	0f 91       	pop	r16
    d2f8:	08 95       	ret

0000d2fa <DS18X20_write_scratchpad>:

#ifdef DS18X20_EEPROMSUPPORT

uint8_t DS18X20_write_scratchpad( uint8_t id[], 
	uint8_t th, uint8_t tl, uint8_t conf)
{
    d2fa:	ff 92       	push	r15
    d2fc:	0f 93       	push	r16
    d2fe:	1f 93       	push	r17
    d300:	cf 93       	push	r28
    d302:	df 93       	push	r29
    d304:	ec 01       	movw	r28, r24
    d306:	16 2f       	mov	r17, r22
    d308:	04 2f       	mov	r16, r20
    d30a:	f2 2e       	mov	r15, r18
	ow_reset(); //**
    d30c:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    d310:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <ow_input_pin_state>
    d314:	88 23       	and	r24, r24
    d316:	11 f4       	brne	.+4      	; 0xd31c <DS18X20_write_scratchpad+0x22>
    d318:	81 e0       	ldi	r24, 0x01	; 1
    d31a:	11 c0       	rjmp	.+34     	; 0xd33e <DS18X20_write_scratchpad+0x44>
		ow_command( DS18X20_WRITE_SCRATCHPAD, id );
    d31c:	8e e4       	ldi	r24, 0x4E	; 78
    d31e:	be 01       	movw	r22, r28
    d320:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
		ow_byte_wr(th);
    d324:	81 2f       	mov	r24, r17
    d326:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
		ow_byte_wr(tl);
    d32a:	80 2f       	mov	r24, r16
    d32c:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
		if (id[0] == DS18B20_ID) ow_byte_wr(conf); // config avail. on B20 only
    d330:	88 81       	ld	r24, Y
    d332:	88 32       	cpi	r24, 0x28	; 40
    d334:	19 f4       	brne	.+6      	; 0xd33c <DS18X20_write_scratchpad+0x42>
    d336:	8f 2d       	mov	r24, r15
    d338:	0e 94 f7 67 	call	0xcfee	; 0xcfee <ow_byte_wr>
    d33c:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		uart_puts_P( "DS18X20_write_scratchpad: Short Circuit !\r" );
		#endif
		return DS18X20_ERROR;
	}
}
    d33e:	df 91       	pop	r29
    d340:	cf 91       	pop	r28
    d342:	1f 91       	pop	r17
    d344:	0f 91       	pop	r16
    d346:	ff 90       	pop	r15
    d348:	08 95       	ret

0000d34a <DS18X20_read_meas_single>:

   i.e.:  subzero=1, cel=18, millicel=5000 =\> -18,5000C 
 */
uint8_t DS18X20_read_meas_single(uint8_t familycode, uint8_t *subzero, 
	uint8_t *cel, uint8_t *cel_frac_bits)
{
    d34a:	7f 92       	push	r7
    d34c:	8f 92       	push	r8
    d34e:	9f 92       	push	r9
    d350:	af 92       	push	r10
    d352:	bf 92       	push	r11
    d354:	cf 92       	push	r12
    d356:	df 92       	push	r13
    d358:	ef 92       	push	r14
    d35a:	ff 92       	push	r15
    d35c:	0f 93       	push	r16
    d35e:	1f 93       	push	r17
    d360:	df 93       	push	r29
    d362:	cf 93       	push	r28
    d364:	cd b7       	in	r28, 0x3d	; 61
    d366:	de b7       	in	r29, 0x3e	; 62
    d368:	29 97       	sbiw	r28, 0x09	; 9
    d36a:	0f b6       	in	r0, 0x3f	; 63
    d36c:	f8 94       	cli
    d36e:	de bf       	out	0x3e, r29	; 62
    d370:	0f be       	out	0x3f, r0	; 63
    d372:	cd bf       	out	0x3d, r28	; 61
    d374:	78 2e       	mov	r7, r24
    d376:	6b 01       	movw	r12, r22
    d378:	5a 01       	movw	r10, r20
    d37a:	49 01       	movw	r8, r18
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];
	
	ow_command(DS18X20_READ, NULL);
    d37c:	8e eb       	ldi	r24, 0xBE	; 190
    d37e:	60 e0       	ldi	r22, 0x00	; 0
    d380:	70 e0       	ldi	r23, 0x00	; 0
    d382:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
    d386:	8e 01       	movw	r16, r28
    d388:	0f 5f       	subi	r16, 0xFF	; 255
    d38a:	1f 4f       	sbci	r17, 0xFF	; 255
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
    d38c:	4a e0       	ldi	r20, 0x0A	; 10
    d38e:	e4 2e       	mov	r14, r20
    d390:	f1 2c       	mov	r15, r1
    d392:	ec 0e       	add	r14, r28
    d394:	fd 1e       	adc	r15, r29
    d396:	0e 94 08 68 	call	0xd010	; 0xd010 <ow_byte_rd>
    d39a:	f8 01       	movw	r30, r16
    d39c:	81 93       	st	Z+, r24
    d39e:	8f 01       	movw	r16, r30
    d3a0:	ee 15       	cp	r30, r14
    d3a2:	ff 05       	cpc	r31, r15
    d3a4:	c1 f7       	brne	.-16     	; 0xd396 <DS18X20_read_meas_single+0x4c>
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) 
    d3a6:	7e 01       	movw	r14, r28
    d3a8:	08 94       	sec
    d3aa:	e1 1c       	adc	r14, r1
    d3ac:	f1 1c       	adc	r15, r1
    d3ae:	c7 01       	movw	r24, r14
    d3b0:	69 e0       	ldi	r22, 0x09	; 9
    d3b2:	70 e0       	ldi	r23, 0x00	; 0
    d3b4:	0e 94 9b 67 	call	0xcf36	; 0xcf36 <crc8>
    d3b8:	88 23       	and	r24, r24
    d3ba:	11 f0       	breq	.+4      	; 0xd3c0 <DS18X20_read_meas_single+0x76>
    d3bc:	83 e0       	ldi	r24, 0x03	; 3
    d3be:	08 c0       	rjmp	.+16     	; 0xd3d0 <DS18X20_read_meas_single+0x86>
		return DS18X20_ERROR_CRC;
	DS18X20_meas_to_cel(familycode, sp, subzero, cel, cel_frac_bits);
    d3c0:	87 2d       	mov	r24, r7
    d3c2:	b7 01       	movw	r22, r14
    d3c4:	a6 01       	movw	r20, r12
    d3c6:	95 01       	movw	r18, r10
    d3c8:	84 01       	movw	r16, r8
    d3ca:	0e 94 77 68 	call	0xd0ee	; 0xd0ee <DS18X20_meas_to_cel>
    d3ce:	80 e0       	ldi	r24, 0x00	; 0
	return DS18X20_OK;
}
    d3d0:	29 96       	adiw	r28, 0x09	; 9
    d3d2:	0f b6       	in	r0, 0x3f	; 63
    d3d4:	f8 94       	cli
    d3d6:	de bf       	out	0x3e, r29	; 62
    d3d8:	0f be       	out	0x3f, r0	; 63
    d3da:	cd bf       	out	0x3d, r28	; 61
    d3dc:	cf 91       	pop	r28
    d3de:	df 91       	pop	r29
    d3e0:	1f 91       	pop	r17
    d3e2:	0f 91       	pop	r16
    d3e4:	ff 90       	pop	r15
    d3e6:	ef 90       	pop	r14
    d3e8:	df 90       	pop	r13
    d3ea:	cf 90       	pop	r12
    d3ec:	bf 90       	pop	r11
    d3ee:	af 90       	pop	r10
    d3f0:	9f 90       	pop	r9
    d3f2:	8f 90       	pop	r8
    d3f4:	7f 90       	pop	r7
    d3f6:	08 95       	ret

0000d3f8 <DS18X20_read_meas>:

   i.e.: subzero=1, cel=18, millicel=5000 =\> -18,5000C
 */
uint8_t DS18X20_read_meas(uint8_t id[], uint8_t *subzero, 
	uint8_t *cel, uint8_t *cel_frac_bits)
{
    d3f8:	6f 92       	push	r6
    d3fa:	7f 92       	push	r7
    d3fc:	8f 92       	push	r8
    d3fe:	9f 92       	push	r9
    d400:	af 92       	push	r10
    d402:	bf 92       	push	r11
    d404:	cf 92       	push	r12
    d406:	df 92       	push	r13
    d408:	ef 92       	push	r14
    d40a:	ff 92       	push	r15
    d40c:	0f 93       	push	r16
    d40e:	1f 93       	push	r17
    d410:	df 93       	push	r29
    d412:	cf 93       	push	r28
    d414:	cd b7       	in	r28, 0x3d	; 61
    d416:	de b7       	in	r29, 0x3e	; 62
    d418:	29 97       	sbiw	r28, 0x09	; 9
    d41a:	0f b6       	in	r0, 0x3f	; 63
    d41c:	f8 94       	cli
    d41e:	de bf       	out	0x3e, r29	; 62
    d420:	0f be       	out	0x3f, r0	; 63
    d422:	cd bf       	out	0x3d, r28	; 61
    d424:	6c 01       	movw	r12, r24
    d426:	5b 01       	movw	r10, r22
    d428:	4a 01       	movw	r8, r20
    d42a:	39 01       	movw	r6, r18
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];
	
	ow_reset(); //**
    d42c:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
	ow_command(DS18X20_READ, id);
    d430:	8e eb       	ldi	r24, 0xBE	; 190
    d432:	b6 01       	movw	r22, r12
    d434:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
    d438:	8e 01       	movw	r16, r28
    d43a:	0f 5f       	subi	r16, 0xFF	; 255
    d43c:	1f 4f       	sbci	r17, 0xFF	; 255
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
    d43e:	5a e0       	ldi	r21, 0x0A	; 10
    d440:	e5 2e       	mov	r14, r21
    d442:	f1 2c       	mov	r15, r1
    d444:	ec 0e       	add	r14, r28
    d446:	fd 1e       	adc	r15, r29
    d448:	0e 94 08 68 	call	0xd010	; 0xd010 <ow_byte_rd>
    d44c:	f8 01       	movw	r30, r16
    d44e:	81 93       	st	Z+, r24
    d450:	8f 01       	movw	r16, r30
    d452:	ee 15       	cp	r30, r14
    d454:	ff 05       	cpc	r31, r15
    d456:	c1 f7       	brne	.-16     	; 0xd448 <DS18X20_read_meas+0x50>
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) 
    d458:	7e 01       	movw	r14, r28
    d45a:	08 94       	sec
    d45c:	e1 1c       	adc	r14, r1
    d45e:	f1 1c       	adc	r15, r1
    d460:	c7 01       	movw	r24, r14
    d462:	69 e0       	ldi	r22, 0x09	; 9
    d464:	70 e0       	ldi	r23, 0x00	; 0
    d466:	0e 94 9b 67 	call	0xcf36	; 0xcf36 <crc8>
    d46a:	88 23       	and	r24, r24
    d46c:	11 f0       	breq	.+4      	; 0xd472 <DS18X20_read_meas+0x7a>
    d46e:	83 e0       	ldi	r24, 0x03	; 3
    d470:	09 c0       	rjmp	.+18     	; 0xd484 <DS18X20_read_meas+0x8c>
		return DS18X20_ERROR_CRC;
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits);
    d472:	f6 01       	movw	r30, r12
    d474:	80 81       	ld	r24, Z
    d476:	b7 01       	movw	r22, r14
    d478:	a5 01       	movw	r20, r10
    d47a:	94 01       	movw	r18, r8
    d47c:	83 01       	movw	r16, r6
    d47e:	0e 94 77 68 	call	0xd0ee	; 0xd0ee <DS18X20_meas_to_cel>
    d482:	80 e0       	ldi	r24, 0x00	; 0
	return DS18X20_OK;
}
    d484:	29 96       	adiw	r28, 0x09	; 9
    d486:	0f b6       	in	r0, 0x3f	; 63
    d488:	f8 94       	cli
    d48a:	de bf       	out	0x3e, r29	; 62
    d48c:	0f be       	out	0x3f, r0	; 63
    d48e:	cd bf       	out	0x3d, r28	; 61
    d490:	cf 91       	pop	r28
    d492:	df 91       	pop	r29
    d494:	1f 91       	pop	r17
    d496:	0f 91       	pop	r16
    d498:	ff 90       	pop	r15
    d49a:	ef 90       	pop	r14
    d49c:	df 90       	pop	r13
    d49e:	cf 90       	pop	r12
    d4a0:	bf 90       	pop	r11
    d4a2:	af 90       	pop	r10
    d4a4:	9f 90       	pop	r9
    d4a6:	8f 90       	pop	r8
    d4a8:	7f 90       	pop	r7
    d4aa:	6f 90       	pop	r6
    d4ac:	08 95       	ret

0000d4ae <DS18X20_get_power_status>:

 get power status of DS18x20 
   @param[in] id = rom_code 
   \return DS18X20_POWER_EXTERN or DS18X20_POWER_PARASITE */
uint8_t	DS18X20_get_power_status(uint8_t id[])
{
    d4ae:	0f 93       	push	r16
    d4b0:	1f 93       	push	r17
    d4b2:	8c 01       	movw	r16, r24
	uint8_t pstat;
    ow_reset();
    d4b4:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
    ow_command(DS18X20_READ_POWER_SUPPLY, id);
    d4b8:	84 eb       	ldi	r24, 0xB4	; 180
    d4ba:	b8 01       	movw	r22, r16
    d4bc:	0e 94 58 68 	call	0xd0b0	; 0xd0b0 <ow_command>
    pstat=ow_bit_io(1); // pstat 0=is parasite/ !=0 ext. powered
    d4c0:	81 e0       	ldi	r24, 0x01	; 1
    d4c2:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <ow_bit_io>
    d4c6:	18 2f       	mov	r17, r24
    ow_reset();
    d4c8:	0e 94 c4 67 	call	0xcf88	; 0xcf88 <ow_reset>
    d4cc:	11 11       	cpse	r17, r1
    d4ce:	11 e0       	ldi	r17, 0x01	; 1
	return (pstat) ? DS18X20_POWER_EXTERN:DS18X20_POWER_PARASITE;
}
    d4d0:	81 2f       	mov	r24, r17
    d4d2:	1f 91       	pop	r17
    d4d4:	0f 91       	pop	r16
    d4d6:	08 95       	ret

0000d4d8 <DS18X20_find_sensor>:

 find DS18X20 Sensors on 1-Wire-Bus
   @param[in,out] diff is the result of the last rom-search
   @param[out] id is the rom-code of the sensor found */
void DS18X20_find_sensor(uint8_t *diff, uint8_t id[])
{
    d4d8:	0f 93       	push	r16
    d4da:	1f 93       	push	r17
    d4dc:	cf 93       	push	r28
    d4de:	df 93       	push	r29
    d4e0:	8c 01       	movw	r16, r24
    d4e2:	eb 01       	movw	r28, r22
	for (;;) {
		*diff = ow_rom_search( *diff, &id[0] );
    d4e4:	f8 01       	movw	r30, r16
    d4e6:	80 81       	ld	r24, Z
    d4e8:	be 01       	movw	r22, r28
    d4ea:	0e 94 0c 68 	call	0xd018	; 0xd018 <ow_rom_search>
    d4ee:	f8 01       	movw	r30, r16
    d4f0:	80 83       	st	Z, r24
		if ( *diff==OW_PRESENCE_ERR || *diff==OW_DATA_ERR ||
    d4f2:	81 50       	subi	r24, 0x01	; 1
    d4f4:	8d 3f       	cpi	r24, 0xFD	; 253
    d4f6:	28 f4       	brcc	.+10     	; 0xd502 <DS18X20_find_sensor+0x2a>
		  *diff == OW_LAST_DEVICE ) return;
		if ( id[0] == DS18B20_ID || id[0] == DS18S20_ID ) return;
    d4f8:	88 81       	ld	r24, Y
    d4fa:	88 32       	cpi	r24, 0x28	; 40
    d4fc:	11 f0       	breq	.+4      	; 0xd502 <DS18X20_find_sensor+0x2a>
    d4fe:	80 31       	cpi	r24, 0x10	; 16
    d500:	89 f7       	brne	.-30     	; 0xd4e4 <DS18X20_find_sensor+0xc>
	}
}
    d502:	df 91       	pop	r29
    d504:	cf 91       	pop	r28
    d506:	1f 91       	pop	r17
    d508:	0f 91       	pop	r16
    d50a:	08 95       	ret

0000d50c <DS18X20_show_id_uart>:
	return DS18X20_OK;
}
#endif

void DS18X20_show_id_uart( uint8_t *id, size_t n )
{
    d50c:	6f 92       	push	r6
    d50e:	7f 92       	push	r7
    d510:	8f 92       	push	r8
    d512:	9f 92       	push	r9
    d514:	af 92       	push	r10
    d516:	bf 92       	push	r11
    d518:	cf 92       	push	r12
    d51a:	df 92       	push	r13
    d51c:	ef 92       	push	r14
    d51e:	ff 92       	push	r15
    d520:	0f 93       	push	r16
    d522:	1f 93       	push	r17
    d524:	cf 93       	push	r28
    d526:	df 93       	push	r29
    d528:	8c 01       	movw	r16, r24
    d52a:	7b 01       	movw	r14, r22
    d52c:	c0 e0       	ldi	r28, 0x00	; 0
    d52e:	d0 e0       	ldi	r29, 0x00	; 0
	size_t i;
	for( i = 0; i < n; i++ ) {
		usart_write("%x ",id[i]);
    d530:	f2 ec       	ldi	r31, 0xC2	; 194
    d532:	6f 2e       	mov	r6, r31
    d534:	f3 e2       	ldi	r31, 0x23	; 35
    d536:	7f 2e       	mov	r7, r31
		if ( i == 0 ) {
			if ( id[0] == DS18S20_ID ) usart_write ("(18S)");
			else if ( id[0] == DS18B20_ID ) usart_write ("(18B)");
			else usart_write ("( ? )");
    d538:	e0 eb       	ldi	r30, 0xB0	; 176
    d53a:	8e 2e       	mov	r8, r30
    d53c:	e3 e2       	ldi	r30, 0x23	; 35
    d53e:	9e 2e       	mov	r9, r30
	size_t i;
	for( i = 0; i < n; i++ ) {
		usart_write("%x ",id[i]);
		if ( i == 0 ) {
			if ( id[0] == DS18S20_ID ) usart_write ("(18S)");
			else if ( id[0] == DS18B20_ID ) usart_write ("(18B)");
    d540:	76 eb       	ldi	r23, 0xB6	; 182
    d542:	a7 2e       	mov	r10, r23
    d544:	73 e2       	ldi	r23, 0x23	; 35
    d546:	b7 2e       	mov	r11, r23
{
	size_t i;
	for( i = 0; i < n; i++ ) {
		usart_write("%x ",id[i]);
		if ( i == 0 ) {
			if ( id[0] == DS18S20_ID ) usart_write ("(18S)");
    d548:	6c eb       	ldi	r22, 0xBC	; 188
    d54a:	c6 2e       	mov	r12, r22
    d54c:	63 e2       	ldi	r22, 0x23	; 35
    d54e:	d6 2e       	mov	r13, r22
    d550:	39 c0       	rjmp	.+114    	; 0xd5c4 <DS18X20_show_id_uart+0xb8>

void DS18X20_show_id_uart( uint8_t *id, size_t n )
{
	size_t i;
	for( i = 0; i < n; i++ ) {
		usart_write("%x ",id[i]);
    d552:	00 d0       	rcall	.+0      	; 0xd554 <DS18X20_show_id_uart+0x48>
    d554:	00 d0       	rcall	.+0      	; 0xd556 <DS18X20_show_id_uart+0x4a>
    d556:	ed b7       	in	r30, 0x3d	; 61
    d558:	fe b7       	in	r31, 0x3e	; 62
    d55a:	31 96       	adiw	r30, 0x01	; 1
    d55c:	ad b7       	in	r26, 0x3d	; 61
    d55e:	be b7       	in	r27, 0x3e	; 62
    d560:	12 96       	adiw	r26, 0x02	; 2
    d562:	7c 92       	st	X, r7
    d564:	6e 92       	st	-X, r6
    d566:	11 97       	sbiw	r26, 0x01	; 1
    d568:	d8 01       	movw	r26, r16
    d56a:	ac 0f       	add	r26, r28
    d56c:	bd 1f       	adc	r27, r29
    d56e:	8c 91       	ld	r24, X
    d570:	82 83       	std	Z+2, r24	; 0x02
    d572:	13 82       	std	Z+3, r1	; 0x03
    d574:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
		if ( i == 0 ) {
    d578:	0f 90       	pop	r0
    d57a:	0f 90       	pop	r0
    d57c:	0f 90       	pop	r0
    d57e:	0f 90       	pop	r0
    d580:	20 97       	sbiw	r28, 0x00	; 0
    d582:	f9 f4       	brne	.+62     	; 0xd5c2 <DS18X20_show_id_uart+0xb6>
			if ( id[0] == DS18S20_ID ) usart_write ("(18S)");
    d584:	f8 01       	movw	r30, r16
    d586:	80 81       	ld	r24, Z
    d588:	80 31       	cpi	r24, 0x10	; 16
    d58a:	41 f4       	brne	.+16     	; 0xd59c <DS18X20_show_id_uart+0x90>
    d58c:	00 d0       	rcall	.+0      	; 0xd58e <DS18X20_show_id_uart+0x82>
    d58e:	ad b7       	in	r26, 0x3d	; 61
    d590:	be b7       	in	r27, 0x3e	; 62
    d592:	12 96       	adiw	r26, 0x02	; 2
    d594:	dc 92       	st	X, r13
    d596:	ce 92       	st	-X, r12
    d598:	11 97       	sbiw	r26, 0x01	; 1
    d59a:	0f c0       	rjmp	.+30     	; 0xd5ba <DS18X20_show_id_uart+0xae>
			else if ( id[0] == DS18B20_ID ) usart_write ("(18B)");
    d59c:	88 32       	cpi	r24, 0x28	; 40
    d59e:	31 f4       	brne	.+12     	; 0xd5ac <DS18X20_show_id_uart+0xa0>
    d5a0:	00 d0       	rcall	.+0      	; 0xd5a2 <DS18X20_show_id_uart+0x96>
    d5a2:	ed b7       	in	r30, 0x3d	; 61
    d5a4:	fe b7       	in	r31, 0x3e	; 62
    d5a6:	b2 82       	std	Z+2, r11	; 0x02
    d5a8:	a1 82       	std	Z+1, r10	; 0x01
    d5aa:	07 c0       	rjmp	.+14     	; 0xd5ba <DS18X20_show_id_uart+0xae>
			else usart_write ("( ? )");
    d5ac:	00 d0       	rcall	.+0      	; 0xd5ae <DS18X20_show_id_uart+0xa2>
    d5ae:	ad b7       	in	r26, 0x3d	; 61
    d5b0:	be b7       	in	r27, 0x3e	; 62
    d5b2:	12 96       	adiw	r26, 0x02	; 2
    d5b4:	9c 92       	st	X, r9
    d5b6:	8e 92       	st	-X, r8
    d5b8:	11 97       	sbiw	r26, 0x01	; 1
    d5ba:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    d5be:	0f 90       	pop	r0
    d5c0:	0f 90       	pop	r0
#endif

void DS18X20_show_id_uart( uint8_t *id, size_t n )
{
	size_t i;
	for( i = 0; i < n; i++ ) {
    d5c2:	21 96       	adiw	r28, 0x01	; 1
    d5c4:	ce 15       	cp	r28, r14
    d5c6:	df 05       	cpc	r29, r15
    d5c8:	20 f2       	brcs	.-120    	; 0xd552 <DS18X20_show_id_uart+0x46>
			if ( id[0] == DS18S20_ID ) usart_write ("(18S)");
			else if ( id[0] == DS18B20_ID ) usart_write ("(18B)");
			else usart_write ("( ? )");
		}
	}
	if ( crc8( id, OW_ROMCODE_SIZE) )
    d5ca:	c8 01       	movw	r24, r16
    d5cc:	68 e0       	ldi	r22, 0x08	; 8
    d5ce:	70 e0       	ldi	r23, 0x00	; 0
    d5d0:	0e 94 9b 67 	call	0xcf36	; 0xcf36 <crc8>
    d5d4:	88 23       	and	r24, r24
    d5d6:	41 f0       	breq	.+16     	; 0xd5e8 <DS18X20_show_id_uart+0xdc>
		usart_write( " CRC FAIL " );
    d5d8:	00 d0       	rcall	.+0      	; 0xd5da <DS18X20_show_id_uart+0xce>
    d5da:	85 ea       	ldi	r24, 0xA5	; 165
    d5dc:	93 e2       	ldi	r25, 0x23	; 35
    d5de:	ed b7       	in	r30, 0x3d	; 61
    d5e0:	fe b7       	in	r31, 0x3e	; 62
    d5e2:	92 83       	std	Z+2, r25	; 0x02
    d5e4:	81 83       	std	Z+1, r24	; 0x01
    d5e6:	09 c0       	rjmp	.+18     	; 0xd5fa <DS18X20_show_id_uart+0xee>
	else 
		usart_write( " CRC O.K. " );
    d5e8:	00 d0       	rcall	.+0      	; 0xd5ea <DS18X20_show_id_uart+0xde>
    d5ea:	8a e9       	ldi	r24, 0x9A	; 154
    d5ec:	93 e2       	ldi	r25, 0x23	; 35
    d5ee:	ad b7       	in	r26, 0x3d	; 61
    d5f0:	be b7       	in	r27, 0x3e	; 62
    d5f2:	12 96       	adiw	r26, 0x02	; 2
    d5f4:	9c 93       	st	X, r25
    d5f6:	8e 93       	st	-X, r24
    d5f8:	11 97       	sbiw	r26, 0x01	; 1
    d5fa:	0e 94 fc 6e 	call	0xddf8	; 0xddf8 <printf_P>
    d5fe:	0f 90       	pop	r0
    d600:	0f 90       	pop	r0
}
    d602:	df 91       	pop	r29
    d604:	cf 91       	pop	r28
    d606:	1f 91       	pop	r17
    d608:	0f 91       	pop	r16
    d60a:	ff 90       	pop	r15
    d60c:	ef 90       	pop	r14
    d60e:	df 90       	pop	r13
    d610:	cf 90       	pop	r12
    d612:	bf 90       	pop	r11
    d614:	af 90       	pop	r10
    d616:	9f 90       	pop	r9
    d618:	8f 90       	pop	r8
    d61a:	7f 90       	pop	r7
    d61c:	6f 90       	pop	r6
    d61e:	08 95       	ret

0000d620 <__mulsi3>:
    d620:	62 9f       	mul	r22, r18
    d622:	d0 01       	movw	r26, r0
    d624:	73 9f       	mul	r23, r19
    d626:	f0 01       	movw	r30, r0
    d628:	82 9f       	mul	r24, r18
    d62a:	e0 0d       	add	r30, r0
    d62c:	f1 1d       	adc	r31, r1
    d62e:	64 9f       	mul	r22, r20
    d630:	e0 0d       	add	r30, r0
    d632:	f1 1d       	adc	r31, r1
    d634:	92 9f       	mul	r25, r18
    d636:	f0 0d       	add	r31, r0
    d638:	83 9f       	mul	r24, r19
    d63a:	f0 0d       	add	r31, r0
    d63c:	74 9f       	mul	r23, r20
    d63e:	f0 0d       	add	r31, r0
    d640:	65 9f       	mul	r22, r21
    d642:	f0 0d       	add	r31, r0
    d644:	99 27       	eor	r25, r25
    d646:	72 9f       	mul	r23, r18
    d648:	b0 0d       	add	r27, r0
    d64a:	e1 1d       	adc	r30, r1
    d64c:	f9 1f       	adc	r31, r25
    d64e:	63 9f       	mul	r22, r19
    d650:	b0 0d       	add	r27, r0
    d652:	e1 1d       	adc	r30, r1
    d654:	f9 1f       	adc	r31, r25
    d656:	bd 01       	movw	r22, r26
    d658:	cf 01       	movw	r24, r30
    d65a:	11 24       	eor	r1, r1
    d65c:	08 95       	ret

0000d65e <__udivmodqi4>:
    d65e:	99 1b       	sub	r25, r25
    d660:	79 e0       	ldi	r23, 0x09	; 9
    d662:	04 c0       	rjmp	.+8      	; 0xd66c <__udivmodqi4_ep>

0000d664 <__udivmodqi4_loop>:
    d664:	99 1f       	adc	r25, r25
    d666:	96 17       	cp	r25, r22
    d668:	08 f0       	brcs	.+2      	; 0xd66c <__udivmodqi4_ep>
    d66a:	96 1b       	sub	r25, r22

0000d66c <__udivmodqi4_ep>:
    d66c:	88 1f       	adc	r24, r24
    d66e:	7a 95       	dec	r23
    d670:	c9 f7       	brne	.-14     	; 0xd664 <__udivmodqi4_loop>
    d672:	80 95       	com	r24
    d674:	08 95       	ret

0000d676 <__udivmodhi4>:
    d676:	aa 1b       	sub	r26, r26
    d678:	bb 1b       	sub	r27, r27
    d67a:	51 e1       	ldi	r21, 0x11	; 17
    d67c:	07 c0       	rjmp	.+14     	; 0xd68c <__udivmodhi4_ep>

0000d67e <__udivmodhi4_loop>:
    d67e:	aa 1f       	adc	r26, r26
    d680:	bb 1f       	adc	r27, r27
    d682:	a6 17       	cp	r26, r22
    d684:	b7 07       	cpc	r27, r23
    d686:	10 f0       	brcs	.+4      	; 0xd68c <__udivmodhi4_ep>
    d688:	a6 1b       	sub	r26, r22
    d68a:	b7 0b       	sbc	r27, r23

0000d68c <__udivmodhi4_ep>:
    d68c:	88 1f       	adc	r24, r24
    d68e:	99 1f       	adc	r25, r25
    d690:	5a 95       	dec	r21
    d692:	a9 f7       	brne	.-22     	; 0xd67e <__udivmodhi4_loop>
    d694:	80 95       	com	r24
    d696:	90 95       	com	r25
    d698:	bc 01       	movw	r22, r24
    d69a:	cd 01       	movw	r24, r26
    d69c:	08 95       	ret

0000d69e <__divmodhi4>:
    d69e:	97 fb       	bst	r25, 7
    d6a0:	09 2e       	mov	r0, r25
    d6a2:	07 26       	eor	r0, r23
    d6a4:	0a d0       	rcall	.+20     	; 0xd6ba <__divmodhi4_neg1>
    d6a6:	77 fd       	sbrc	r23, 7
    d6a8:	04 d0       	rcall	.+8      	; 0xd6b2 <__divmodhi4_neg2>
    d6aa:	e5 df       	rcall	.-54     	; 0xd676 <__udivmodhi4>
    d6ac:	06 d0       	rcall	.+12     	; 0xd6ba <__divmodhi4_neg1>
    d6ae:	00 20       	and	r0, r0
    d6b0:	1a f4       	brpl	.+6      	; 0xd6b8 <__divmodhi4_exit>

0000d6b2 <__divmodhi4_neg2>:
    d6b2:	70 95       	com	r23
    d6b4:	61 95       	neg	r22
    d6b6:	7f 4f       	sbci	r23, 0xFF	; 255

0000d6b8 <__divmodhi4_exit>:
    d6b8:	08 95       	ret

0000d6ba <__divmodhi4_neg1>:
    d6ba:	f6 f7       	brtc	.-4      	; 0xd6b8 <__divmodhi4_exit>
    d6bc:	90 95       	com	r25
    d6be:	81 95       	neg	r24
    d6c0:	9f 4f       	sbci	r25, 0xFF	; 255
    d6c2:	08 95       	ret

0000d6c4 <__udivmodsi4>:
    d6c4:	a1 e2       	ldi	r26, 0x21	; 33
    d6c6:	1a 2e       	mov	r1, r26
    d6c8:	aa 1b       	sub	r26, r26
    d6ca:	bb 1b       	sub	r27, r27
    d6cc:	fd 01       	movw	r30, r26
    d6ce:	0d c0       	rjmp	.+26     	; 0xd6ea <__udivmodsi4_ep>

0000d6d0 <__udivmodsi4_loop>:
    d6d0:	aa 1f       	adc	r26, r26
    d6d2:	bb 1f       	adc	r27, r27
    d6d4:	ee 1f       	adc	r30, r30
    d6d6:	ff 1f       	adc	r31, r31
    d6d8:	a2 17       	cp	r26, r18
    d6da:	b3 07       	cpc	r27, r19
    d6dc:	e4 07       	cpc	r30, r20
    d6de:	f5 07       	cpc	r31, r21
    d6e0:	20 f0       	brcs	.+8      	; 0xd6ea <__udivmodsi4_ep>
    d6e2:	a2 1b       	sub	r26, r18
    d6e4:	b3 0b       	sbc	r27, r19
    d6e6:	e4 0b       	sbc	r30, r20
    d6e8:	f5 0b       	sbc	r31, r21

0000d6ea <__udivmodsi4_ep>:
    d6ea:	66 1f       	adc	r22, r22
    d6ec:	77 1f       	adc	r23, r23
    d6ee:	88 1f       	adc	r24, r24
    d6f0:	99 1f       	adc	r25, r25
    d6f2:	1a 94       	dec	r1
    d6f4:	69 f7       	brne	.-38     	; 0xd6d0 <__udivmodsi4_loop>
    d6f6:	60 95       	com	r22
    d6f8:	70 95       	com	r23
    d6fa:	80 95       	com	r24
    d6fc:	90 95       	com	r25
    d6fe:	9b 01       	movw	r18, r22
    d700:	ac 01       	movw	r20, r24
    d702:	bd 01       	movw	r22, r26
    d704:	cf 01       	movw	r24, r30
    d706:	08 95       	ret

0000d708 <malloc>:
    d708:	cf 93       	push	r28
    d70a:	df 93       	push	r29
    d70c:	bc 01       	movw	r22, r24
    d70e:	82 30       	cpi	r24, 0x02	; 2
    d710:	91 05       	cpc	r25, r1
    d712:	10 f4       	brcc	.+4      	; 0xd718 <malloc+0x10>
    d714:	62 e0       	ldi	r22, 0x02	; 2
    d716:	70 e0       	ldi	r23, 0x00	; 0
    d718:	a0 91 cf 0d 	lds	r26, 0x0DCF
    d71c:	b0 91 d0 0d 	lds	r27, 0x0DD0
    d720:	ed 01       	movw	r28, r26
    d722:	e0 e0       	ldi	r30, 0x00	; 0
    d724:	f0 e0       	ldi	r31, 0x00	; 0
    d726:	40 e0       	ldi	r20, 0x00	; 0
    d728:	50 e0       	ldi	r21, 0x00	; 0
    d72a:	21 c0       	rjmp	.+66     	; 0xd76e <malloc+0x66>
    d72c:	88 81       	ld	r24, Y
    d72e:	99 81       	ldd	r25, Y+1	; 0x01
    d730:	86 17       	cp	r24, r22
    d732:	97 07       	cpc	r25, r23
    d734:	69 f4       	brne	.+26     	; 0xd750 <malloc+0x48>
    d736:	8a 81       	ldd	r24, Y+2	; 0x02
    d738:	9b 81       	ldd	r25, Y+3	; 0x03
    d73a:	30 97       	sbiw	r30, 0x00	; 0
    d73c:	19 f0       	breq	.+6      	; 0xd744 <malloc+0x3c>
    d73e:	93 83       	std	Z+3, r25	; 0x03
    d740:	82 83       	std	Z+2, r24	; 0x02
    d742:	04 c0       	rjmp	.+8      	; 0xd74c <malloc+0x44>
    d744:	90 93 d0 0d 	sts	0x0DD0, r25
    d748:	80 93 cf 0d 	sts	0x0DCF, r24
    d74c:	fe 01       	movw	r30, r28
    d74e:	34 c0       	rjmp	.+104    	; 0xd7b8 <malloc+0xb0>
    d750:	68 17       	cp	r22, r24
    d752:	79 07       	cpc	r23, r25
    d754:	38 f4       	brcc	.+14     	; 0xd764 <malloc+0x5c>
    d756:	41 15       	cp	r20, r1
    d758:	51 05       	cpc	r21, r1
    d75a:	19 f0       	breq	.+6      	; 0xd762 <malloc+0x5a>
    d75c:	84 17       	cp	r24, r20
    d75e:	95 07       	cpc	r25, r21
    d760:	08 f4       	brcc	.+2      	; 0xd764 <malloc+0x5c>
    d762:	ac 01       	movw	r20, r24
    d764:	fe 01       	movw	r30, r28
    d766:	8a 81       	ldd	r24, Y+2	; 0x02
    d768:	9b 81       	ldd	r25, Y+3	; 0x03
    d76a:	9c 01       	movw	r18, r24
    d76c:	e9 01       	movw	r28, r18
    d76e:	20 97       	sbiw	r28, 0x00	; 0
    d770:	e9 f6       	brne	.-70     	; 0xd72c <malloc+0x24>
    d772:	41 15       	cp	r20, r1
    d774:	51 05       	cpc	r21, r1
    d776:	a9 f1       	breq	.+106    	; 0xd7e2 <malloc+0xda>
    d778:	ca 01       	movw	r24, r20
    d77a:	86 1b       	sub	r24, r22
    d77c:	97 0b       	sbc	r25, r23
    d77e:	04 97       	sbiw	r24, 0x04	; 4
    d780:	08 f4       	brcc	.+2      	; 0xd784 <malloc+0x7c>
    d782:	ba 01       	movw	r22, r20
    d784:	e0 e0       	ldi	r30, 0x00	; 0
    d786:	f0 e0       	ldi	r31, 0x00	; 0
    d788:	2a c0       	rjmp	.+84     	; 0xd7de <malloc+0xd6>
    d78a:	8d 91       	ld	r24, X+
    d78c:	9c 91       	ld	r25, X
    d78e:	11 97       	sbiw	r26, 0x01	; 1
    d790:	84 17       	cp	r24, r20
    d792:	95 07       	cpc	r25, r21
    d794:	f9 f4       	brne	.+62     	; 0xd7d4 <malloc+0xcc>
    d796:	64 17       	cp	r22, r20
    d798:	75 07       	cpc	r23, r21
    d79a:	81 f4       	brne	.+32     	; 0xd7bc <malloc+0xb4>
    d79c:	12 96       	adiw	r26, 0x02	; 2
    d79e:	8d 91       	ld	r24, X+
    d7a0:	9c 91       	ld	r25, X
    d7a2:	13 97       	sbiw	r26, 0x03	; 3
    d7a4:	30 97       	sbiw	r30, 0x00	; 0
    d7a6:	19 f0       	breq	.+6      	; 0xd7ae <malloc+0xa6>
    d7a8:	93 83       	std	Z+3, r25	; 0x03
    d7aa:	82 83       	std	Z+2, r24	; 0x02
    d7ac:	04 c0       	rjmp	.+8      	; 0xd7b6 <malloc+0xae>
    d7ae:	90 93 d0 0d 	sts	0x0DD0, r25
    d7b2:	80 93 cf 0d 	sts	0x0DCF, r24
    d7b6:	fd 01       	movw	r30, r26
    d7b8:	32 96       	adiw	r30, 0x02	; 2
    d7ba:	4f c0       	rjmp	.+158    	; 0xd85a <malloc+0x152>
    d7bc:	ca 01       	movw	r24, r20
    d7be:	86 1b       	sub	r24, r22
    d7c0:	97 0b       	sbc	r25, r23
    d7c2:	fd 01       	movw	r30, r26
    d7c4:	e8 0f       	add	r30, r24
    d7c6:	f9 1f       	adc	r31, r25
    d7c8:	61 93       	st	Z+, r22
    d7ca:	71 93       	st	Z+, r23
    d7cc:	02 97       	sbiw	r24, 0x02	; 2
    d7ce:	8d 93       	st	X+, r24
    d7d0:	9c 93       	st	X, r25
    d7d2:	43 c0       	rjmp	.+134    	; 0xd85a <malloc+0x152>
    d7d4:	fd 01       	movw	r30, r26
    d7d6:	82 81       	ldd	r24, Z+2	; 0x02
    d7d8:	93 81       	ldd	r25, Z+3	; 0x03
    d7da:	9c 01       	movw	r18, r24
    d7dc:	d9 01       	movw	r26, r18
    d7de:	10 97       	sbiw	r26, 0x00	; 0
    d7e0:	a1 f6       	brne	.-88     	; 0xd78a <malloc+0x82>
    d7e2:	80 91 cd 0d 	lds	r24, 0x0DCD
    d7e6:	90 91 ce 0d 	lds	r25, 0x0DCE
    d7ea:	89 2b       	or	r24, r25
    d7ec:	41 f4       	brne	.+16     	; 0xd7fe <malloc+0xf6>
    d7ee:	80 91 d5 01 	lds	r24, 0x01D5
    d7f2:	90 91 d6 01 	lds	r25, 0x01D6
    d7f6:	90 93 ce 0d 	sts	0x0DCE, r25
    d7fa:	80 93 cd 0d 	sts	0x0DCD, r24
    d7fe:	40 91 d7 01 	lds	r20, 0x01D7
    d802:	50 91 d8 01 	lds	r21, 0x01D8
    d806:	41 15       	cp	r20, r1
    d808:	51 05       	cpc	r21, r1
    d80a:	41 f4       	brne	.+16     	; 0xd81c <malloc+0x114>
    d80c:	4d b7       	in	r20, 0x3d	; 61
    d80e:	5e b7       	in	r21, 0x3e	; 62
    d810:	80 91 d3 01 	lds	r24, 0x01D3
    d814:	90 91 d4 01 	lds	r25, 0x01D4
    d818:	48 1b       	sub	r20, r24
    d81a:	59 0b       	sbc	r21, r25
    d81c:	20 91 cd 0d 	lds	r18, 0x0DCD
    d820:	30 91 ce 0d 	lds	r19, 0x0DCE
    d824:	24 17       	cp	r18, r20
    d826:	35 07       	cpc	r19, r21
    d828:	b0 f4       	brcc	.+44     	; 0xd856 <malloc+0x14e>
    d82a:	ca 01       	movw	r24, r20
    d82c:	82 1b       	sub	r24, r18
    d82e:	93 0b       	sbc	r25, r19
    d830:	86 17       	cp	r24, r22
    d832:	97 07       	cpc	r25, r23
    d834:	80 f0       	brcs	.+32     	; 0xd856 <malloc+0x14e>
    d836:	ab 01       	movw	r20, r22
    d838:	4e 5f       	subi	r20, 0xFE	; 254
    d83a:	5f 4f       	sbci	r21, 0xFF	; 255
    d83c:	84 17       	cp	r24, r20
    d83e:	95 07       	cpc	r25, r21
    d840:	50 f0       	brcs	.+20     	; 0xd856 <malloc+0x14e>
    d842:	42 0f       	add	r20, r18
    d844:	53 1f       	adc	r21, r19
    d846:	50 93 ce 0d 	sts	0x0DCE, r21
    d84a:	40 93 cd 0d 	sts	0x0DCD, r20
    d84e:	f9 01       	movw	r30, r18
    d850:	61 93       	st	Z+, r22
    d852:	71 93       	st	Z+, r23
    d854:	02 c0       	rjmp	.+4      	; 0xd85a <malloc+0x152>
    d856:	e0 e0       	ldi	r30, 0x00	; 0
    d858:	f0 e0       	ldi	r31, 0x00	; 0
    d85a:	cf 01       	movw	r24, r30
    d85c:	df 91       	pop	r29
    d85e:	cf 91       	pop	r28
    d860:	08 95       	ret

0000d862 <free>:
    d862:	cf 93       	push	r28
    d864:	df 93       	push	r29
    d866:	00 97       	sbiw	r24, 0x00	; 0
    d868:	09 f4       	brne	.+2      	; 0xd86c <free+0xa>
    d86a:	50 c0       	rjmp	.+160    	; 0xd90c <free+0xaa>
    d86c:	ec 01       	movw	r28, r24
    d86e:	22 97       	sbiw	r28, 0x02	; 2
    d870:	1b 82       	std	Y+3, r1	; 0x03
    d872:	1a 82       	std	Y+2, r1	; 0x02
    d874:	a0 91 cf 0d 	lds	r26, 0x0DCF
    d878:	b0 91 d0 0d 	lds	r27, 0x0DD0
    d87c:	10 97       	sbiw	r26, 0x00	; 0
    d87e:	09 f1       	breq	.+66     	; 0xd8c2 <free+0x60>
    d880:	40 e0       	ldi	r20, 0x00	; 0
    d882:	50 e0       	ldi	r21, 0x00	; 0
    d884:	ac 17       	cp	r26, r28
    d886:	bd 07       	cpc	r27, r29
    d888:	08 f1       	brcs	.+66     	; 0xd8cc <free+0x6a>
    d88a:	bb 83       	std	Y+3, r27	; 0x03
    d88c:	aa 83       	std	Y+2, r26	; 0x02
    d88e:	fe 01       	movw	r30, r28
    d890:	21 91       	ld	r18, Z+
    d892:	31 91       	ld	r19, Z+
    d894:	e2 0f       	add	r30, r18
    d896:	f3 1f       	adc	r31, r19
    d898:	ae 17       	cp	r26, r30
    d89a:	bf 07       	cpc	r27, r31
    d89c:	79 f4       	brne	.+30     	; 0xd8bc <free+0x5a>
    d89e:	8d 91       	ld	r24, X+
    d8a0:	9c 91       	ld	r25, X
    d8a2:	11 97       	sbiw	r26, 0x01	; 1
    d8a4:	28 0f       	add	r18, r24
    d8a6:	39 1f       	adc	r19, r25
    d8a8:	2e 5f       	subi	r18, 0xFE	; 254
    d8aa:	3f 4f       	sbci	r19, 0xFF	; 255
    d8ac:	39 83       	std	Y+1, r19	; 0x01
    d8ae:	28 83       	st	Y, r18
    d8b0:	12 96       	adiw	r26, 0x02	; 2
    d8b2:	8d 91       	ld	r24, X+
    d8b4:	9c 91       	ld	r25, X
    d8b6:	13 97       	sbiw	r26, 0x03	; 3
    d8b8:	9b 83       	std	Y+3, r25	; 0x03
    d8ba:	8a 83       	std	Y+2, r24	; 0x02
    d8bc:	41 15       	cp	r20, r1
    d8be:	51 05       	cpc	r21, r1
    d8c0:	71 f4       	brne	.+28     	; 0xd8de <free+0x7c>
    d8c2:	d0 93 d0 0d 	sts	0x0DD0, r29
    d8c6:	c0 93 cf 0d 	sts	0x0DCF, r28
    d8ca:	20 c0       	rjmp	.+64     	; 0xd90c <free+0xaa>
    d8cc:	12 96       	adiw	r26, 0x02	; 2
    d8ce:	8d 91       	ld	r24, X+
    d8d0:	9c 91       	ld	r25, X
    d8d2:	13 97       	sbiw	r26, 0x03	; 3
    d8d4:	ad 01       	movw	r20, r26
    d8d6:	00 97       	sbiw	r24, 0x00	; 0
    d8d8:	11 f0       	breq	.+4      	; 0xd8de <free+0x7c>
    d8da:	dc 01       	movw	r26, r24
    d8dc:	d3 cf       	rjmp	.-90     	; 0xd884 <free+0x22>
    d8de:	fa 01       	movw	r30, r20
    d8e0:	d3 83       	std	Z+3, r29	; 0x03
    d8e2:	c2 83       	std	Z+2, r28	; 0x02
    d8e4:	21 91       	ld	r18, Z+
    d8e6:	31 91       	ld	r19, Z+
    d8e8:	e2 0f       	add	r30, r18
    d8ea:	f3 1f       	adc	r31, r19
    d8ec:	ce 17       	cp	r28, r30
    d8ee:	df 07       	cpc	r29, r31
    d8f0:	69 f4       	brne	.+26     	; 0xd90c <free+0xaa>
    d8f2:	88 81       	ld	r24, Y
    d8f4:	99 81       	ldd	r25, Y+1	; 0x01
    d8f6:	28 0f       	add	r18, r24
    d8f8:	39 1f       	adc	r19, r25
    d8fa:	2e 5f       	subi	r18, 0xFE	; 254
    d8fc:	3f 4f       	sbci	r19, 0xFF	; 255
    d8fe:	fa 01       	movw	r30, r20
    d900:	31 83       	std	Z+1, r19	; 0x01
    d902:	20 83       	st	Z, r18
    d904:	8a 81       	ldd	r24, Y+2	; 0x02
    d906:	9b 81       	ldd	r25, Y+3	; 0x03
    d908:	93 83       	std	Z+3, r25	; 0x03
    d90a:	82 83       	std	Z+2, r24	; 0x02
    d90c:	df 91       	pop	r29
    d90e:	cf 91       	pop	r28
    d910:	08 95       	ret

0000d912 <strtoul>:
    d912:	a0 e0       	ldi	r26, 0x00	; 0
    d914:	b0 e0       	ldi	r27, 0x00	; 0
    d916:	ef e8       	ldi	r30, 0x8F	; 143
    d918:	fc e6       	ldi	r31, 0x6C	; 108
    d91a:	0c 94 0a 72 	jmp	0xe414	; 0xe414 <__prologue_saves__+0x2>
    d91e:	ec 01       	movw	r28, r24
    d920:	2b 01       	movw	r4, r22
    d922:	6a 01       	movw	r12, r20
    d924:	61 15       	cp	r22, r1
    d926:	71 05       	cpc	r23, r1
    d928:	19 f0       	breq	.+6      	; 0xd930 <strtoul+0x1e>
    d92a:	fb 01       	movw	r30, r22
    d92c:	91 83       	std	Z+1, r25	; 0x01
    d92e:	80 83       	st	Z, r24
    d930:	c1 14       	cp	r12, r1
    d932:	d1 04       	cpc	r13, r1
    d934:	49 f0       	breq	.+18     	; 0xd948 <strtoul+0x36>
    d936:	c6 01       	movw	r24, r12
    d938:	02 97       	sbiw	r24, 0x02	; 2
    d93a:	83 97       	sbiw	r24, 0x23	; 35
    d93c:	28 f0       	brcs	.+10     	; 0xd948 <strtoul+0x36>
    d93e:	20 e0       	ldi	r18, 0x00	; 0
    d940:	30 e0       	ldi	r19, 0x00	; 0
    d942:	40 e0       	ldi	r20, 0x00	; 0
    d944:	50 e0       	ldi	r21, 0x00	; 0
    d946:	dc c0       	rjmp	.+440    	; 0xdb00 <strtoul+0x1ee>
    d948:	a9 90       	ld	r10, Y+
    d94a:	8a 2d       	mov	r24, r10
    d94c:	90 e0       	ldi	r25, 0x00	; 0
    d94e:	0e 94 a5 6d 	call	0xdb4a	; 0xdb4a <isspace>
    d952:	89 2b       	or	r24, r25
    d954:	c9 f7       	brne	.-14     	; 0xd948 <strtoul+0x36>
    d956:	fd e2       	ldi	r31, 0x2D	; 45
    d958:	af 16       	cp	r10, r31
    d95a:	21 f4       	brne	.+8      	; 0xd964 <strtoul+0x52>
    d95c:	a9 90       	ld	r10, Y+
    d95e:	33 24       	eor	r3, r3
    d960:	33 94       	inc	r3
    d962:	05 c0       	rjmp	.+10     	; 0xd96e <strtoul+0x5c>
    d964:	8b e2       	ldi	r24, 0x2B	; 43
    d966:	a8 16       	cp	r10, r24
    d968:	09 f4       	brne	.+2      	; 0xd96c <strtoul+0x5a>
    d96a:	a9 90       	ld	r10, Y+
    d96c:	33 24       	eor	r3, r3
    d96e:	c1 14       	cp	r12, r1
    d970:	d1 04       	cpc	r13, r1
    d972:	21 f0       	breq	.+8      	; 0xd97c <strtoul+0x6a>
    d974:	e0 e1       	ldi	r30, 0x10	; 16
    d976:	ce 16       	cp	r12, r30
    d978:	d1 04       	cpc	r13, r1
    d97a:	11 f5       	brne	.+68     	; 0xd9c0 <strtoul+0xae>
    d97c:	f0 e3       	ldi	r31, 0x30	; 48
    d97e:	af 16       	cp	r10, r31
    d980:	69 f4       	brne	.+26     	; 0xd99c <strtoul+0x8a>
    d982:	88 81       	ld	r24, Y
    d984:	88 37       	cpi	r24, 0x78	; 120
    d986:	11 f0       	breq	.+4      	; 0xd98c <strtoul+0x7a>
    d988:	88 35       	cpi	r24, 0x58	; 88
    d98a:	41 f4       	brne	.+16     	; 0xd99c <strtoul+0x8a>
    d98c:	a9 80       	ldd	r10, Y+1	; 0x01
    d98e:	22 96       	adiw	r28, 0x02	; 2
    d990:	82 e0       	ldi	r24, 0x02	; 2
    d992:	38 2a       	or	r3, r24
    d994:	20 e1       	ldi	r18, 0x10	; 16
    d996:	c2 2e       	mov	r12, r18
    d998:	d1 2c       	mov	r13, r1
    d99a:	12 c0       	rjmp	.+36     	; 0xd9c0 <strtoul+0xae>
    d99c:	c1 14       	cp	r12, r1
    d99e:	d1 04       	cpc	r13, r1
    d9a0:	79 f4       	brne	.+30     	; 0xd9c0 <strtoul+0xae>
    d9a2:	e0 e3       	ldi	r30, 0x30	; 48
    d9a4:	ae 16       	cp	r10, r30
    d9a6:	59 f1       	breq	.+86     	; 0xd9fe <strtoul+0xec>
    d9a8:	99 e9       	ldi	r25, 0x99	; 153
    d9aa:	e9 2e       	mov	r14, r25
    d9ac:	99 e9       	ldi	r25, 0x99	; 153
    d9ae:	f9 2e       	mov	r15, r25
    d9b0:	99 e9       	ldi	r25, 0x99	; 153
    d9b2:	09 2f       	mov	r16, r25
    d9b4:	99 e1       	ldi	r25, 0x19	; 25
    d9b6:	19 2f       	mov	r17, r25
    d9b8:	8a e0       	ldi	r24, 0x0A	; 10
    d9ba:	c8 2e       	mov	r12, r24
    d9bc:	d1 2c       	mov	r13, r1
    d9be:	3a c0       	rjmp	.+116    	; 0xda34 <strtoul+0x122>
    d9c0:	fa e0       	ldi	r31, 0x0A	; 10
    d9c2:	cf 16       	cp	r12, r31
    d9c4:	d1 04       	cpc	r13, r1
    d9c6:	91 f0       	breq	.+36     	; 0xd9ec <strtoul+0xda>
    d9c8:	80 e1       	ldi	r24, 0x10	; 16
    d9ca:	c8 16       	cp	r12, r24
    d9cc:	d1 04       	cpc	r13, r1
    d9ce:	29 f0       	breq	.+10     	; 0xd9da <strtoul+0xc8>
    d9d0:	e8 e0       	ldi	r30, 0x08	; 8
    d9d2:	ce 16       	cp	r12, r30
    d9d4:	d1 04       	cpc	r13, r1
    d9d6:	f9 f4       	brne	.+62     	; 0xda16 <strtoul+0x104>
    d9d8:	15 c0       	rjmp	.+42     	; 0xda04 <strtoul+0xf2>
    d9da:	bf ef       	ldi	r27, 0xFF	; 255
    d9dc:	eb 2e       	mov	r14, r27
    d9de:	bf ef       	ldi	r27, 0xFF	; 255
    d9e0:	fb 2e       	mov	r15, r27
    d9e2:	bf ef       	ldi	r27, 0xFF	; 255
    d9e4:	0b 2f       	mov	r16, r27
    d9e6:	bf e0       	ldi	r27, 0x0F	; 15
    d9e8:	1b 2f       	mov	r17, r27
    d9ea:	24 c0       	rjmp	.+72     	; 0xda34 <strtoul+0x122>
    d9ec:	a9 e9       	ldi	r26, 0x99	; 153
    d9ee:	ea 2e       	mov	r14, r26
    d9f0:	a9 e9       	ldi	r26, 0x99	; 153
    d9f2:	fa 2e       	mov	r15, r26
    d9f4:	a9 e9       	ldi	r26, 0x99	; 153
    d9f6:	0a 2f       	mov	r16, r26
    d9f8:	a9 e1       	ldi	r26, 0x19	; 25
    d9fa:	1a 2f       	mov	r17, r26
    d9fc:	1b c0       	rjmp	.+54     	; 0xda34 <strtoul+0x122>
    d9fe:	f8 e0       	ldi	r31, 0x08	; 8
    da00:	cf 2e       	mov	r12, r31
    da02:	d1 2c       	mov	r13, r1
    da04:	ef ef       	ldi	r30, 0xFF	; 255
    da06:	ee 2e       	mov	r14, r30
    da08:	ef ef       	ldi	r30, 0xFF	; 255
    da0a:	fe 2e       	mov	r15, r30
    da0c:	ef ef       	ldi	r30, 0xFF	; 255
    da0e:	0e 2f       	mov	r16, r30
    da10:	ef e1       	ldi	r30, 0x1F	; 31
    da12:	1e 2f       	mov	r17, r30
    da14:	0f c0       	rjmp	.+30     	; 0xda34 <strtoul+0x122>
    da16:	96 01       	movw	r18, r12
    da18:	44 27       	eor	r20, r20
    da1a:	37 fd       	sbrc	r19, 7
    da1c:	40 95       	com	r20
    da1e:	54 2f       	mov	r21, r20
    da20:	6f ef       	ldi	r22, 0xFF	; 255
    da22:	7f ef       	ldi	r23, 0xFF	; 255
    da24:	8f ef       	ldi	r24, 0xFF	; 255
    da26:	9f ef       	ldi	r25, 0xFF	; 255
    da28:	0e 94 62 6b 	call	0xd6c4	; 0xd6c4 <__udivmodsi4>
    da2c:	c9 01       	movw	r24, r18
    da2e:	da 01       	movw	r26, r20
    da30:	7c 01       	movw	r14, r24
    da32:	8d 01       	movw	r16, r26
    da34:	20 e0       	ldi	r18, 0x00	; 0
    da36:	30 e0       	ldi	r19, 0x00	; 0
    da38:	40 e0       	ldi	r20, 0x00	; 0
    da3a:	50 e0       	ldi	r21, 0x00	; 0
    da3c:	60 e0       	ldi	r22, 0x00	; 0
    da3e:	36 01       	movw	r6, r12
    da40:	88 24       	eor	r8, r8
    da42:	77 fc       	sbrc	r7, 7
    da44:	80 94       	com	r8
    da46:	98 2c       	mov	r9, r8
    da48:	70 ed       	ldi	r23, 0xD0	; 208
    da4a:	b7 2e       	mov	r11, r23
    da4c:	ba 0c       	add	r11, r10
    da4e:	f9 e0       	ldi	r31, 0x09	; 9
    da50:	fb 15       	cp	r31, r11
    da52:	70 f4       	brcc	.+28     	; 0xda70 <strtoul+0x15e>
    da54:	8a 2d       	mov	r24, r10
    da56:	81 54       	subi	r24, 0x41	; 65
    da58:	8a 31       	cpi	r24, 0x1A	; 26
    da5a:	18 f4       	brcc	.+6      	; 0xda62 <strtoul+0x150>
    da5c:	99 ec       	ldi	r25, 0xC9	; 201
    da5e:	b9 2e       	mov	r11, r25
    da60:	06 c0       	rjmp	.+12     	; 0xda6e <strtoul+0x15c>
    da62:	8a 2d       	mov	r24, r10
    da64:	81 56       	subi	r24, 0x61	; 97
    da66:	8a 31       	cpi	r24, 0x1A	; 26
    da68:	48 f5       	brcc	.+82     	; 0xdabc <strtoul+0x1aa>
    da6a:	89 ea       	ldi	r24, 0xA9	; 169
    da6c:	b8 2e       	mov	r11, r24
    da6e:	ba 0c       	add	r11, r10
    da70:	8b 2d       	mov	r24, r11
    da72:	90 e0       	ldi	r25, 0x00	; 0
    da74:	8c 15       	cp	r24, r12
    da76:	9d 05       	cpc	r25, r13
    da78:	0c f5       	brge	.+66     	; 0xdabc <strtoul+0x1aa>
    da7a:	6f 3f       	cpi	r22, 0xFF	; 255
    da7c:	e9 f0       	breq	.+58     	; 0xdab8 <strtoul+0x1a6>
    da7e:	e2 16       	cp	r14, r18
    da80:	f3 06       	cpc	r15, r19
    da82:	04 07       	cpc	r16, r20
    da84:	15 07       	cpc	r17, r21
    da86:	b8 f0       	brcs	.+46     	; 0xdab6 <strtoul+0x1a4>
    da88:	ca 01       	movw	r24, r20
    da8a:	b9 01       	movw	r22, r18
    da8c:	a4 01       	movw	r20, r8
    da8e:	93 01       	movw	r18, r6
    da90:	0e 94 10 6b 	call	0xd620	; 0xd620 <__mulsi3>
    da94:	9b 01       	movw	r18, r22
    da96:	ac 01       	movw	r20, r24
    da98:	8b 2d       	mov	r24, r11
    da9a:	90 e0       	ldi	r25, 0x00	; 0
    da9c:	a0 e0       	ldi	r26, 0x00	; 0
    da9e:	b0 e0       	ldi	r27, 0x00	; 0
    daa0:	28 0f       	add	r18, r24
    daa2:	39 1f       	adc	r19, r25
    daa4:	4a 1f       	adc	r20, r26
    daa6:	5b 1f       	adc	r21, r27
    daa8:	28 17       	cp	r18, r24
    daaa:	39 07       	cpc	r19, r25
    daac:	4a 07       	cpc	r20, r26
    daae:	5b 07       	cpc	r21, r27
    dab0:	10 f0       	brcs	.+4      	; 0xdab6 <strtoul+0x1a4>
    dab2:	61 e0       	ldi	r22, 0x01	; 1
    dab4:	01 c0       	rjmp	.+2      	; 0xdab8 <strtoul+0x1a6>
    dab6:	6f ef       	ldi	r22, 0xFF	; 255
    dab8:	a9 90       	ld	r10, Y+
    daba:	c6 cf       	rjmp	.-116    	; 0xda48 <strtoul+0x136>
    dabc:	41 14       	cp	r4, r1
    dabe:	51 04       	cpc	r5, r1
    dac0:	51 f0       	breq	.+20     	; 0xdad6 <strtoul+0x1c4>
    dac2:	66 23       	and	r22, r22
    dac4:	11 f0       	breq	.+4      	; 0xdaca <strtoul+0x1b8>
    dac6:	21 97       	sbiw	r28, 0x01	; 1
    dac8:	03 c0       	rjmp	.+6      	; 0xdad0 <strtoul+0x1be>
    daca:	31 fe       	sbrs	r3, 1
    dacc:	04 c0       	rjmp	.+8      	; 0xdad6 <strtoul+0x1c4>
    dace:	22 97       	sbiw	r28, 0x02	; 2
    dad0:	f2 01       	movw	r30, r4
    dad2:	d1 83       	std	Z+1, r29	; 0x01
    dad4:	c0 83       	st	Z, r28
    dad6:	30 fe       	sbrs	r3, 0
    dad8:	07 c0       	rjmp	.+14     	; 0xdae8 <strtoul+0x1d6>
    dada:	50 95       	com	r21
    dadc:	40 95       	com	r20
    dade:	30 95       	com	r19
    dae0:	21 95       	neg	r18
    dae2:	3f 4f       	sbci	r19, 0xFF	; 255
    dae4:	4f 4f       	sbci	r20, 0xFF	; 255
    dae6:	5f 4f       	sbci	r21, 0xFF	; 255
    dae8:	67 ff       	sbrs	r22, 7
    daea:	0a c0       	rjmp	.+20     	; 0xdb00 <strtoul+0x1ee>
    daec:	82 e2       	ldi	r24, 0x22	; 34
    daee:	90 e0       	ldi	r25, 0x00	; 0
    daf0:	90 93 d8 0d 	sts	0x0DD8, r25
    daf4:	80 93 d7 0d 	sts	0x0DD7, r24
    daf8:	2f ef       	ldi	r18, 0xFF	; 255
    dafa:	3f ef       	ldi	r19, 0xFF	; 255
    dafc:	4f ef       	ldi	r20, 0xFF	; 255
    dafe:	5f ef       	ldi	r21, 0xFF	; 255
    db00:	b9 01       	movw	r22, r18
    db02:	ca 01       	movw	r24, r20
    db04:	cd b7       	in	r28, 0x3d	; 61
    db06:	de b7       	in	r29, 0x3e	; 62
    db08:	e1 e1       	ldi	r30, 0x11	; 17
    db0a:	0c 94 26 72 	jmp	0xe44c	; 0xe44c <__epilogue_restores__+0x2>

0000db0e <atoi>:
    db0e:	fc 01       	movw	r30, r24
    db10:	88 27       	eor	r24, r24
    db12:	99 27       	eor	r25, r25
    db14:	e8 94       	clt
    db16:	21 91       	ld	r18, Z+
    db18:	20 32       	cpi	r18, 0x20	; 32
    db1a:	e9 f3       	breq	.-6      	; 0xdb16 <atoi+0x8>
    db1c:	29 30       	cpi	r18, 0x09	; 9
    db1e:	10 f0       	brcs	.+4      	; 0xdb24 <atoi+0x16>
    db20:	2e 30       	cpi	r18, 0x0E	; 14
    db22:	c8 f3       	brcs	.-14     	; 0xdb16 <atoi+0x8>
    db24:	2b 32       	cpi	r18, 0x2B	; 43
    db26:	41 f0       	breq	.+16     	; 0xdb38 <atoi+0x2a>
    db28:	2d 32       	cpi	r18, 0x2D	; 45
    db2a:	39 f4       	brne	.+14     	; 0xdb3a <atoi+0x2c>
    db2c:	68 94       	set
    db2e:	04 c0       	rjmp	.+8      	; 0xdb38 <atoi+0x2a>
    db30:	0e 94 f4 6e 	call	0xdde8	; 0xdde8 <__mulhi_const_10>
    db34:	82 0f       	add	r24, r18
    db36:	91 1d       	adc	r25, r1
    db38:	21 91       	ld	r18, Z+
    db3a:	20 53       	subi	r18, 0x30	; 48
    db3c:	2a 30       	cpi	r18, 0x0A	; 10
    db3e:	c0 f3       	brcs	.-16     	; 0xdb30 <atoi+0x22>
    db40:	1e f4       	brtc	.+6      	; 0xdb48 <atoi+0x3a>
    db42:	90 95       	com	r25
    db44:	81 95       	neg	r24
    db46:	9f 4f       	sbci	r25, 0xFF	; 255
    db48:	08 95       	ret

0000db4a <isspace>:
    db4a:	91 11       	cpse	r25, r1
    db4c:	b6 c3       	rjmp	.+1900   	; 0xe2ba <__ctype_isfalse>
    db4e:	80 32       	cpi	r24, 0x20	; 32
    db50:	19 f0       	breq	.+6      	; 0xdb58 <isspace+0xe>
    db52:	89 50       	subi	r24, 0x09	; 9
    db54:	85 50       	subi	r24, 0x05	; 5
    db56:	d0 f7       	brcc	.-12     	; 0xdb4c <isspace+0x2>
    db58:	08 95       	ret

0000db5a <ispunct>:
    db5a:	91 11       	cpse	r25, r1
    db5c:	ae c3       	rjmp	.+1884   	; 0xe2ba <__ctype_isfalse>
    db5e:	81 52       	subi	r24, 0x21	; 33
    db60:	8e 55       	subi	r24, 0x5E	; 94
    db62:	e0 f7       	brcc	.-8      	; 0xdb5c <ispunct+0x2>
    db64:	81 58       	subi	r24, 0x81	; 129
    db66:	a1 d3       	rcall	.+1858   	; 0xe2aa <isalnum>
    db68:	88 23       	and	r24, r24
    db6a:	c1 f7       	brne	.-16     	; 0xdb5c <ispunct+0x2>
    db6c:	81 e0       	ldi	r24, 0x01	; 1
    db6e:	08 95       	ret

0000db70 <memcpy_P>:
    db70:	fb 01       	movw	r30, r22
    db72:	dc 01       	movw	r26, r24
    db74:	02 c0       	rjmp	.+4      	; 0xdb7a <memcpy_P+0xa>
    db76:	05 90       	lpm	r0, Z+
    db78:	0d 92       	st	X+, r0
    db7a:	41 50       	subi	r20, 0x01	; 1
    db7c:	50 40       	sbci	r21, 0x00	; 0
    db7e:	d8 f7       	brcc	.-10     	; 0xdb76 <memcpy_P+0x6>
    db80:	08 95       	ret

0000db82 <strcasecmp_P>:
    db82:	fb 01       	movw	r30, r22
    db84:	dc 01       	movw	r26, r24
    db86:	8d 91       	ld	r24, X+
    db88:	81 34       	cpi	r24, 0x41	; 65
    db8a:	1c f0       	brlt	.+6      	; 0xdb92 <strcasecmp_P+0x10>
    db8c:	8b 35       	cpi	r24, 0x5B	; 91
    db8e:	0c f4       	brge	.+2      	; 0xdb92 <strcasecmp_P+0x10>
    db90:	80 5e       	subi	r24, 0xE0	; 224
    db92:	65 91       	lpm	r22, Z+
    db94:	61 34       	cpi	r22, 0x41	; 65
    db96:	1c f0       	brlt	.+6      	; 0xdb9e <strcasecmp_P+0x1c>
    db98:	6b 35       	cpi	r22, 0x5B	; 91
    db9a:	0c f4       	brge	.+2      	; 0xdb9e <strcasecmp_P+0x1c>
    db9c:	60 5e       	subi	r22, 0xE0	; 224
    db9e:	86 1b       	sub	r24, r22
    dba0:	61 11       	cpse	r22, r1
    dba2:	89 f3       	breq	.-30     	; 0xdb86 <strcasecmp_P+0x4>
    dba4:	99 0b       	sbc	r25, r25
    dba6:	08 95       	ret

0000dba8 <strcat_P>:
    dba8:	fb 01       	movw	r30, r22
    dbaa:	dc 01       	movw	r26, r24
    dbac:	0d 90       	ld	r0, X+
    dbae:	00 20       	and	r0, r0
    dbb0:	e9 f7       	brne	.-6      	; 0xdbac <strcat_P+0x4>
    dbb2:	11 97       	sbiw	r26, 0x01	; 1
    dbb4:	05 90       	lpm	r0, Z+
    dbb6:	0d 92       	st	X+, r0
    dbb8:	00 20       	and	r0, r0
    dbba:	e1 f7       	brne	.-8      	; 0xdbb4 <strcat_P+0xc>
    dbbc:	08 95       	ret

0000dbbe <strcpy_P>:
    dbbe:	fb 01       	movw	r30, r22
    dbc0:	dc 01       	movw	r26, r24
    dbc2:	05 90       	lpm	r0, Z+
    dbc4:	0d 92       	st	X+, r0
    dbc6:	00 20       	and	r0, r0
    dbc8:	e1 f7       	brne	.-8      	; 0xdbc2 <strcpy_P+0x4>
    dbca:	08 95       	ret

0000dbcc <strlen_P>:
    dbcc:	fc 01       	movw	r30, r24
    dbce:	05 90       	lpm	r0, Z+
    dbd0:	00 20       	and	r0, r0
    dbd2:	e9 f7       	brne	.-6      	; 0xdbce <strlen_P+0x2>
    dbd4:	80 95       	com	r24
    dbd6:	90 95       	com	r25
    dbd8:	8e 0f       	add	r24, r30
    dbda:	9f 1f       	adc	r25, r31
    dbdc:	08 95       	ret

0000dbde <strncasecmp_P>:
    dbde:	fb 01       	movw	r30, r22
    dbe0:	dc 01       	movw	r26, r24
    dbe2:	41 50       	subi	r20, 0x01	; 1
    dbe4:	50 40       	sbci	r21, 0x00	; 0
    dbe6:	88 f0       	brcs	.+34     	; 0xdc0a <strncasecmp_P+0x2c>
    dbe8:	8d 91       	ld	r24, X+
    dbea:	81 34       	cpi	r24, 0x41	; 65
    dbec:	1c f0       	brlt	.+6      	; 0xdbf4 <strncasecmp_P+0x16>
    dbee:	8b 35       	cpi	r24, 0x5B	; 91
    dbf0:	0c f4       	brge	.+2      	; 0xdbf4 <strncasecmp_P+0x16>
    dbf2:	80 5e       	subi	r24, 0xE0	; 224
    dbf4:	65 91       	lpm	r22, Z+
    dbf6:	61 34       	cpi	r22, 0x41	; 65
    dbf8:	1c f0       	brlt	.+6      	; 0xdc00 <strncasecmp_P+0x22>
    dbfa:	6b 35       	cpi	r22, 0x5B	; 91
    dbfc:	0c f4       	brge	.+2      	; 0xdc00 <strncasecmp_P+0x22>
    dbfe:	60 5e       	subi	r22, 0xE0	; 224
    dc00:	86 1b       	sub	r24, r22
    dc02:	61 11       	cpse	r22, r1
    dc04:	71 f3       	breq	.-36     	; 0xdbe2 <strncasecmp_P+0x4>
    dc06:	99 0b       	sbc	r25, r25
    dc08:	08 95       	ret
    dc0a:	88 1b       	sub	r24, r24
    dc0c:	fc cf       	rjmp	.-8      	; 0xdc06 <strncasecmp_P+0x28>

0000dc0e <strncmp_P>:
    dc0e:	fb 01       	movw	r30, r22
    dc10:	dc 01       	movw	r26, r24
    dc12:	41 50       	subi	r20, 0x01	; 1
    dc14:	50 40       	sbci	r21, 0x00	; 0
    dc16:	30 f0       	brcs	.+12     	; 0xdc24 <strncmp_P+0x16>
    dc18:	8d 91       	ld	r24, X+
    dc1a:	05 90       	lpm	r0, Z+
    dc1c:	80 19       	sub	r24, r0
    dc1e:	19 f4       	brne	.+6      	; 0xdc26 <strncmp_P+0x18>
    dc20:	00 20       	and	r0, r0
    dc22:	b9 f7       	brne	.-18     	; 0xdc12 <strncmp_P+0x4>
    dc24:	88 1b       	sub	r24, r24
    dc26:	99 0b       	sbc	r25, r25
    dc28:	08 95       	ret

0000dc2a <strncpy_P>:
    dc2a:	fb 01       	movw	r30, r22
    dc2c:	dc 01       	movw	r26, r24
    dc2e:	41 50       	subi	r20, 0x01	; 1
    dc30:	50 40       	sbci	r21, 0x00	; 0
    dc32:	48 f0       	brcs	.+18     	; 0xdc46 <strncpy_P+0x1c>
    dc34:	05 90       	lpm	r0, Z+
    dc36:	0d 92       	st	X+, r0
    dc38:	00 20       	and	r0, r0
    dc3a:	c9 f7       	brne	.-14     	; 0xdc2e <strncpy_P+0x4>
    dc3c:	01 c0       	rjmp	.+2      	; 0xdc40 <strncpy_P+0x16>
    dc3e:	1d 92       	st	X+, r1
    dc40:	41 50       	subi	r20, 0x01	; 1
    dc42:	50 40       	sbci	r21, 0x00	; 0
    dc44:	e0 f7       	brcc	.-8      	; 0xdc3e <strncpy_P+0x14>
    dc46:	08 95       	ret

0000dc48 <strstr_P>:
    dc48:	fb 01       	movw	r30, r22
    dc4a:	55 91       	lpm	r21, Z+
    dc4c:	55 23       	and	r21, r21
    dc4e:	a9 f0       	breq	.+42     	; 0xdc7a <strstr_P+0x32>
    dc50:	bf 01       	movw	r22, r30
    dc52:	dc 01       	movw	r26, r24
    dc54:	4d 91       	ld	r20, X+
    dc56:	45 17       	cp	r20, r21
    dc58:	41 11       	cpse	r20, r1
    dc5a:	e1 f7       	brne	.-8      	; 0xdc54 <strstr_P+0xc>
    dc5c:	59 f4       	brne	.+22     	; 0xdc74 <strstr_P+0x2c>
    dc5e:	cd 01       	movw	r24, r26
    dc60:	05 90       	lpm	r0, Z+
    dc62:	00 20       	and	r0, r0
    dc64:	49 f0       	breq	.+18     	; 0xdc78 <strstr_P+0x30>
    dc66:	4d 91       	ld	r20, X+
    dc68:	40 15       	cp	r20, r0
    dc6a:	41 11       	cpse	r20, r1
    dc6c:	c9 f3       	breq	.-14     	; 0xdc60 <strstr_P+0x18>
    dc6e:	fb 01       	movw	r30, r22
    dc70:	41 11       	cpse	r20, r1
    dc72:	ef cf       	rjmp	.-34     	; 0xdc52 <strstr_P+0xa>
    dc74:	81 e0       	ldi	r24, 0x01	; 1
    dc76:	90 e0       	ldi	r25, 0x00	; 0
    dc78:	01 97       	sbiw	r24, 0x01	; 1
    dc7a:	08 95       	ret

0000dc7c <memcpy>:
    dc7c:	fb 01       	movw	r30, r22
    dc7e:	dc 01       	movw	r26, r24
    dc80:	02 c0       	rjmp	.+4      	; 0xdc86 <memcpy+0xa>
    dc82:	01 90       	ld	r0, Z+
    dc84:	0d 92       	st	X+, r0
    dc86:	41 50       	subi	r20, 0x01	; 1
    dc88:	50 40       	sbci	r21, 0x00	; 0
    dc8a:	d8 f7       	brcc	.-10     	; 0xdc82 <memcpy+0x6>
    dc8c:	08 95       	ret

0000dc8e <memset>:
    dc8e:	dc 01       	movw	r26, r24
    dc90:	01 c0       	rjmp	.+2      	; 0xdc94 <memset+0x6>
    dc92:	6d 93       	st	X+, r22
    dc94:	41 50       	subi	r20, 0x01	; 1
    dc96:	50 40       	sbci	r21, 0x00	; 0
    dc98:	e0 f7       	brcc	.-8      	; 0xdc92 <memset+0x4>
    dc9a:	08 95       	ret

0000dc9c <strcasecmp>:
    dc9c:	fb 01       	movw	r30, r22
    dc9e:	dc 01       	movw	r26, r24
    dca0:	8d 91       	ld	r24, X+
    dca2:	81 34       	cpi	r24, 0x41	; 65
    dca4:	1c f0       	brlt	.+6      	; 0xdcac <strcasecmp+0x10>
    dca6:	8b 35       	cpi	r24, 0x5B	; 91
    dca8:	0c f4       	brge	.+2      	; 0xdcac <strcasecmp+0x10>
    dcaa:	80 5e       	subi	r24, 0xE0	; 224
    dcac:	61 91       	ld	r22, Z+
    dcae:	61 34       	cpi	r22, 0x41	; 65
    dcb0:	1c f0       	brlt	.+6      	; 0xdcb8 <strcasecmp+0x1c>
    dcb2:	6b 35       	cpi	r22, 0x5B	; 91
    dcb4:	0c f4       	brge	.+2      	; 0xdcb8 <strcasecmp+0x1c>
    dcb6:	60 5e       	subi	r22, 0xE0	; 224
    dcb8:	86 1b       	sub	r24, r22
    dcba:	61 11       	cpse	r22, r1
    dcbc:	89 f3       	breq	.-30     	; 0xdca0 <strcasecmp+0x4>
    dcbe:	99 0b       	sbc	r25, r25
    dcc0:	08 95       	ret

0000dcc2 <strcasestr_P>:
    dcc2:	fb 01       	movw	r30, r22
    dcc4:	55 91       	lpm	r21, Z+
    dcc6:	55 23       	and	r21, r21
    dcc8:	b1 f0       	breq	.+44     	; 0xdcf6 <strcasestr_P+0x34>
    dcca:	bf 01       	movw	r22, r30
    dccc:	dc 01       	movw	r26, r24
    dcce:	05 2e       	mov	r0, r21
    dcd0:	4d 91       	ld	r20, X+
    dcd2:	44 23       	and	r20, r20
    dcd4:	69 f0       	breq	.+26     	; 0xdcf0 <strcasestr_P+0x2e>
    dcd6:	10 d0       	rcall	.+32     	; 0xdcf8 <strcasestr_P+0x36>
    dcd8:	d9 f7       	brne	.-10     	; 0xdcd0 <strcasestr_P+0xe>
    dcda:	cd 01       	movw	r24, r26
    dcdc:	05 90       	lpm	r0, Z+
    dcde:	00 20       	and	r0, r0
    dce0:	49 f0       	breq	.+18     	; 0xdcf4 <strcasestr_P+0x32>
    dce2:	4d 91       	ld	r20, X+
    dce4:	41 11       	cpse	r20, r1
    dce6:	08 d0       	rcall	.+16     	; 0xdcf8 <strcasestr_P+0x36>
    dce8:	c9 f3       	breq	.-14     	; 0xdcdc <strcasestr_P+0x1a>
    dcea:	fb 01       	movw	r30, r22
    dcec:	41 11       	cpse	r20, r1
    dcee:	ee cf       	rjmp	.-36     	; 0xdccc <strcasestr_P+0xa>
    dcf0:	81 e0       	ldi	r24, 0x01	; 1
    dcf2:	90 e0       	ldi	r25, 0x00	; 0
    dcf4:	01 97       	sbiw	r24, 0x01	; 1
    dcf6:	08 95       	ret
    dcf8:	40 25       	eor	r20, r0
    dcfa:	39 f0       	breq	.+14     	; 0xdd0a <strcasestr_P+0x48>
    dcfc:	40 32       	cpi	r20, 0x20	; 32
    dcfe:	29 f4       	brne	.+10     	; 0xdd0a <strcasestr_P+0x48>
    dd00:	40 29       	or	r20, r0
    dd02:	4b 57       	subi	r20, 0x7B	; 123
    dd04:	46 5e       	subi	r20, 0xE6	; 230
    dd06:	08 f0       	brcs	.+2      	; 0xdd0a <strcasestr_P+0x48>
    dd08:	18 94       	sez
    dd0a:	08 95       	ret

0000dd0c <strcat>:
    dd0c:	fb 01       	movw	r30, r22
    dd0e:	dc 01       	movw	r26, r24
    dd10:	0d 90       	ld	r0, X+
    dd12:	00 20       	and	r0, r0
    dd14:	e9 f7       	brne	.-6      	; 0xdd10 <strcat+0x4>
    dd16:	11 97       	sbiw	r26, 0x01	; 1
    dd18:	01 90       	ld	r0, Z+
    dd1a:	0d 92       	st	X+, r0
    dd1c:	00 20       	and	r0, r0
    dd1e:	e1 f7       	brne	.-8      	; 0xdd18 <strcat+0xc>
    dd20:	08 95       	ret

0000dd22 <strchr>:
    dd22:	fc 01       	movw	r30, r24
    dd24:	81 91       	ld	r24, Z+
    dd26:	86 17       	cp	r24, r22
    dd28:	21 f0       	breq	.+8      	; 0xdd32 <strchr+0x10>
    dd2a:	88 23       	and	r24, r24
    dd2c:	d9 f7       	brne	.-10     	; 0xdd24 <strchr+0x2>
    dd2e:	99 27       	eor	r25, r25
    dd30:	08 95       	ret
    dd32:	31 97       	sbiw	r30, 0x01	; 1
    dd34:	cf 01       	movw	r24, r30
    dd36:	08 95       	ret

0000dd38 <strchrnul>:
    dd38:	fc 01       	movw	r30, r24
    dd3a:	01 90       	ld	r0, Z+
    dd3c:	06 16       	cp	r0, r22
    dd3e:	01 10       	cpse	r0, r1
    dd40:	e1 f7       	brne	.-8      	; 0xdd3a <strchrnul+0x2>
    dd42:	31 97       	sbiw	r30, 0x01	; 1
    dd44:	cf 01       	movw	r24, r30
    dd46:	08 95       	ret

0000dd48 <strcmp>:
    dd48:	fb 01       	movw	r30, r22
    dd4a:	dc 01       	movw	r26, r24
    dd4c:	8d 91       	ld	r24, X+
    dd4e:	01 90       	ld	r0, Z+
    dd50:	80 19       	sub	r24, r0
    dd52:	01 10       	cpse	r0, r1
    dd54:	d9 f3       	breq	.-10     	; 0xdd4c <strcmp+0x4>
    dd56:	99 0b       	sbc	r25, r25
    dd58:	08 95       	ret

0000dd5a <strcpy>:
    dd5a:	fb 01       	movw	r30, r22
    dd5c:	dc 01       	movw	r26, r24
    dd5e:	01 90       	ld	r0, Z+
    dd60:	0d 92       	st	X+, r0
    dd62:	00 20       	and	r0, r0
    dd64:	e1 f7       	brne	.-8      	; 0xdd5e <strcpy+0x4>
    dd66:	08 95       	ret

0000dd68 <strncmp>:
    dd68:	fb 01       	movw	r30, r22
    dd6a:	dc 01       	movw	r26, r24
    dd6c:	41 50       	subi	r20, 0x01	; 1
    dd6e:	50 40       	sbci	r21, 0x00	; 0
    dd70:	30 f0       	brcs	.+12     	; 0xdd7e <strncmp+0x16>
    dd72:	8d 91       	ld	r24, X+
    dd74:	01 90       	ld	r0, Z+
    dd76:	80 19       	sub	r24, r0
    dd78:	19 f4       	brne	.+6      	; 0xdd80 <strncmp+0x18>
    dd7a:	00 20       	and	r0, r0
    dd7c:	b9 f7       	brne	.-18     	; 0xdd6c <strncmp+0x4>
    dd7e:	88 1b       	sub	r24, r24
    dd80:	99 0b       	sbc	r25, r25
    dd82:	08 95       	ret

0000dd84 <strncpy>:
    dd84:	fb 01       	movw	r30, r22
    dd86:	dc 01       	movw	r26, r24
    dd88:	41 50       	subi	r20, 0x01	; 1
    dd8a:	50 40       	sbci	r21, 0x00	; 0
    dd8c:	48 f0       	brcs	.+18     	; 0xdda0 <strncpy+0x1c>
    dd8e:	01 90       	ld	r0, Z+
    dd90:	0d 92       	st	X+, r0
    dd92:	00 20       	and	r0, r0
    dd94:	c9 f7       	brne	.-14     	; 0xdd88 <strncpy+0x4>
    dd96:	01 c0       	rjmp	.+2      	; 0xdd9a <strncpy+0x16>
    dd98:	1d 92       	st	X+, r1
    dd9a:	41 50       	subi	r20, 0x01	; 1
    dd9c:	50 40       	sbci	r21, 0x00	; 0
    dd9e:	e0 f7       	brcc	.-8      	; 0xdd98 <strncpy+0x14>
    dda0:	08 95       	ret

0000dda2 <strrchr>:
    dda2:	fc 01       	movw	r30, r24
    dda4:	81 e0       	ldi	r24, 0x01	; 1
    dda6:	90 e0       	ldi	r25, 0x00	; 0
    dda8:	01 90       	ld	r0, Z+
    ddaa:	06 16       	cp	r0, r22
    ddac:	09 f4       	brne	.+2      	; 0xddb0 <strrchr+0xe>
    ddae:	cf 01       	movw	r24, r30
    ddb0:	00 20       	and	r0, r0
    ddb2:	d1 f7       	brne	.-12     	; 0xdda8 <strrchr+0x6>
    ddb4:	01 97       	sbiw	r24, 0x01	; 1
    ddb6:	08 95       	ret

0000ddb8 <strsep>:
    ddb8:	fc 01       	movw	r30, r24
    ddba:	a0 81       	ld	r26, Z
    ddbc:	b1 81       	ldd	r27, Z+1	; 0x01
    ddbe:	ad 01       	movw	r20, r26
    ddc0:	10 96       	adiw	r26, 0x00	; 0
    ddc2:	81 f0       	breq	.+32     	; 0xdde4 <strsep+0x2c>
    ddc4:	3d 91       	ld	r19, X+
    ddc6:	fb 01       	movw	r30, r22
    ddc8:	01 90       	ld	r0, Z+
    ddca:	03 16       	cp	r0, r19
    ddcc:	01 10       	cpse	r0, r1
    ddce:	e1 f7       	brne	.-8      	; 0xddc8 <strsep+0x10>
    ddd0:	c9 f7       	brne	.-14     	; 0xddc4 <strsep+0xc>
    ddd2:	00 20       	and	r0, r0
    ddd4:	11 f4       	brne	.+4      	; 0xddda <strsep+0x22>
    ddd6:	d0 01       	movw	r26, r0
    ddd8:	02 c0       	rjmp	.+4      	; 0xddde <strsep+0x26>
    ddda:	1e 92       	st	-X, r1
    dddc:	11 96       	adiw	r26, 0x01	; 1
    ddde:	fc 01       	movw	r30, r24
    dde0:	a0 83       	st	Z, r26
    dde2:	b1 83       	std	Z+1, r27	; 0x01
    dde4:	ca 01       	movw	r24, r20
    dde6:	08 95       	ret

0000dde8 <__mulhi_const_10>:
    dde8:	7a e0       	ldi	r23, 0x0A	; 10
    ddea:	97 9f       	mul	r25, r23
    ddec:	90 2d       	mov	r25, r0
    ddee:	87 9f       	mul	r24, r23
    ddf0:	80 2d       	mov	r24, r0
    ddf2:	91 0d       	add	r25, r1
    ddf4:	11 24       	eor	r1, r1
    ddf6:	08 95       	ret

0000ddf8 <printf_P>:
    ddf8:	a0 e0       	ldi	r26, 0x00	; 0
    ddfa:	b0 e0       	ldi	r27, 0x00	; 0
    ddfc:	e2 e0       	ldi	r30, 0x02	; 2
    ddfe:	ff e6       	ldi	r31, 0x6F	; 111
    de00:	0c 94 19 72 	jmp	0xe432	; 0xe432 <__prologue_saves__+0x20>
    de04:	fe 01       	movw	r30, r28
    de06:	35 96       	adiw	r30, 0x05	; 5
    de08:	61 91       	ld	r22, Z+
    de0a:	71 91       	ld	r23, Z+
    de0c:	a0 91 d3 0d 	lds	r26, 0x0DD3
    de10:	b0 91 d4 0d 	lds	r27, 0x0DD4
    de14:	13 96       	adiw	r26, 0x03	; 3
    de16:	8c 91       	ld	r24, X
    de18:	13 97       	sbiw	r26, 0x03	; 3
    de1a:	88 60       	ori	r24, 0x08	; 8
    de1c:	13 96       	adiw	r26, 0x03	; 3
    de1e:	8c 93       	st	X, r24
    de20:	80 91 d3 0d 	lds	r24, 0x0DD3
    de24:	90 91 d4 0d 	lds	r25, 0x0DD4
    de28:	af 01       	movw	r20, r30
    de2a:	0e 94 62 6f 	call	0xdec4	; 0xdec4 <vfprintf>
    de2e:	e0 91 d3 0d 	lds	r30, 0x0DD3
    de32:	f0 91 d4 0d 	lds	r31, 0x0DD4
    de36:	23 81       	ldd	r18, Z+3	; 0x03
    de38:	27 7f       	andi	r18, 0xF7	; 247
    de3a:	23 83       	std	Z+3, r18	; 0x03
    de3c:	20 96       	adiw	r28, 0x00	; 0
    de3e:	e2 e0       	ldi	r30, 0x02	; 2
    de40:	0c 94 35 72 	jmp	0xe46a	; 0xe46a <__epilogue_restores__+0x20>

0000de44 <sprintf_P>:
    de44:	ae e0       	ldi	r26, 0x0E	; 14
    de46:	b0 e0       	ldi	r27, 0x00	; 0
    de48:	e8 e2       	ldi	r30, 0x28	; 40
    de4a:	ff e6       	ldi	r31, 0x6F	; 111
    de4c:	0c 94 17 72 	jmp	0xe42e	; 0xe42e <__prologue_saves__+0x1c>
    de50:	0d 89       	ldd	r16, Y+21	; 0x15
    de52:	1e 89       	ldd	r17, Y+22	; 0x16
    de54:	8e e0       	ldi	r24, 0x0E	; 14
    de56:	8c 83       	std	Y+4, r24	; 0x04
    de58:	1a 83       	std	Y+2, r17	; 0x02
    de5a:	09 83       	std	Y+1, r16	; 0x01
    de5c:	8f ef       	ldi	r24, 0xFF	; 255
    de5e:	9f e7       	ldi	r25, 0x7F	; 127
    de60:	9e 83       	std	Y+6, r25	; 0x06
    de62:	8d 83       	std	Y+5, r24	; 0x05
    de64:	9e 01       	movw	r18, r28
    de66:	27 5e       	subi	r18, 0xE7	; 231
    de68:	3f 4f       	sbci	r19, 0xFF	; 255
    de6a:	ce 01       	movw	r24, r28
    de6c:	01 96       	adiw	r24, 0x01	; 1
    de6e:	6f 89       	ldd	r22, Y+23	; 0x17
    de70:	78 8d       	ldd	r23, Y+24	; 0x18
    de72:	a9 01       	movw	r20, r18
    de74:	0e 94 62 6f 	call	0xdec4	; 0xdec4 <vfprintf>
    de78:	2f 81       	ldd	r18, Y+7	; 0x07
    de7a:	38 85       	ldd	r19, Y+8	; 0x08
    de7c:	02 0f       	add	r16, r18
    de7e:	13 1f       	adc	r17, r19
    de80:	f8 01       	movw	r30, r16
    de82:	10 82       	st	Z, r1
    de84:	2e 96       	adiw	r28, 0x0e	; 14
    de86:	e4 e0       	ldi	r30, 0x04	; 4
    de88:	0c 94 33 72 	jmp	0xe466	; 0xe466 <__epilogue_restores__+0x1c>

0000de8c <vsprintf_P>:
    de8c:	ae e0       	ldi	r26, 0x0E	; 14
    de8e:	b0 e0       	ldi	r27, 0x00	; 0
    de90:	ec e4       	ldi	r30, 0x4C	; 76
    de92:	ff e6       	ldi	r31, 0x6F	; 111
    de94:	0c 94 17 72 	jmp	0xe42e	; 0xe42e <__prologue_saves__+0x1c>
    de98:	8c 01       	movw	r16, r24
    de9a:	8e e0       	ldi	r24, 0x0E	; 14
    de9c:	8c 83       	std	Y+4, r24	; 0x04
    de9e:	1a 83       	std	Y+2, r17	; 0x02
    dea0:	09 83       	std	Y+1, r16	; 0x01
    dea2:	8f ef       	ldi	r24, 0xFF	; 255
    dea4:	9f e7       	ldi	r25, 0x7F	; 127
    dea6:	9e 83       	std	Y+6, r25	; 0x06
    dea8:	8d 83       	std	Y+5, r24	; 0x05
    deaa:	ce 01       	movw	r24, r28
    deac:	01 96       	adiw	r24, 0x01	; 1
    deae:	0e 94 62 6f 	call	0xdec4	; 0xdec4 <vfprintf>
    deb2:	ef 81       	ldd	r30, Y+7	; 0x07
    deb4:	f8 85       	ldd	r31, Y+8	; 0x08
    deb6:	e0 0f       	add	r30, r16
    deb8:	f1 1f       	adc	r31, r17
    deba:	10 82       	st	Z, r1
    debc:	2e 96       	adiw	r28, 0x0e	; 14
    debe:	e4 e0       	ldi	r30, 0x04	; 4
    dec0:	0c 94 33 72 	jmp	0xe466	; 0xe466 <__epilogue_restores__+0x1c>

0000dec4 <vfprintf>:
    dec4:	ab e0       	ldi	r26, 0x0B	; 11
    dec6:	b0 e0       	ldi	r27, 0x00	; 0
    dec8:	e8 e6       	ldi	r30, 0x68	; 104
    deca:	ff e6       	ldi	r31, 0x6F	; 111
    decc:	0c 94 09 72 	jmp	0xe412	; 0xe412 <__prologue_saves__>
    ded0:	3c 01       	movw	r6, r24
    ded2:	2b 01       	movw	r4, r22
    ded4:	5a 01       	movw	r10, r20
    ded6:	fc 01       	movw	r30, r24
    ded8:	17 82       	std	Z+7, r1	; 0x07
    deda:	16 82       	std	Z+6, r1	; 0x06
    dedc:	83 81       	ldd	r24, Z+3	; 0x03
    dede:	81 fd       	sbrc	r24, 1
    dee0:	03 c0       	rjmp	.+6      	; 0xdee8 <vfprintf+0x24>
    dee2:	6f ef       	ldi	r22, 0xFF	; 255
    dee4:	7f ef       	ldi	r23, 0xFF	; 255
    dee6:	c6 c1       	rjmp	.+908    	; 0xe274 <vfprintf+0x3b0>
    dee8:	9a e0       	ldi	r25, 0x0A	; 10
    deea:	89 2e       	mov	r8, r25
    deec:	1e 01       	movw	r2, r28
    deee:	08 94       	sec
    def0:	21 1c       	adc	r2, r1
    def2:	31 1c       	adc	r3, r1
    def4:	f3 01       	movw	r30, r6
    def6:	23 81       	ldd	r18, Z+3	; 0x03
    def8:	f2 01       	movw	r30, r4
    defa:	23 fd       	sbrc	r18, 3
    defc:	85 91       	lpm	r24, Z+
    defe:	23 ff       	sbrs	r18, 3
    df00:	81 91       	ld	r24, Z+
    df02:	2f 01       	movw	r4, r30
    df04:	88 23       	and	r24, r24
    df06:	09 f4       	brne	.+2      	; 0xdf0a <vfprintf+0x46>
    df08:	b2 c1       	rjmp	.+868    	; 0xe26e <vfprintf+0x3aa>
    df0a:	85 32       	cpi	r24, 0x25	; 37
    df0c:	39 f4       	brne	.+14     	; 0xdf1c <vfprintf+0x58>
    df0e:	23 fd       	sbrc	r18, 3
    df10:	85 91       	lpm	r24, Z+
    df12:	23 ff       	sbrs	r18, 3
    df14:	81 91       	ld	r24, Z+
    df16:	2f 01       	movw	r4, r30
    df18:	85 32       	cpi	r24, 0x25	; 37
    df1a:	29 f4       	brne	.+10     	; 0xdf26 <vfprintf+0x62>
    df1c:	90 e0       	ldi	r25, 0x00	; 0
    df1e:	b3 01       	movw	r22, r6
    df20:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    df24:	e7 cf       	rjmp	.-50     	; 0xdef4 <vfprintf+0x30>
    df26:	98 2f       	mov	r25, r24
    df28:	ff 24       	eor	r15, r15
    df2a:	ee 24       	eor	r14, r14
    df2c:	99 24       	eor	r9, r9
    df2e:	ff e1       	ldi	r31, 0x1F	; 31
    df30:	ff 15       	cp	r31, r15
    df32:	d0 f0       	brcs	.+52     	; 0xdf68 <vfprintf+0xa4>
    df34:	9b 32       	cpi	r25, 0x2B	; 43
    df36:	69 f0       	breq	.+26     	; 0xdf52 <vfprintf+0x8e>
    df38:	9c 32       	cpi	r25, 0x2C	; 44
    df3a:	28 f4       	brcc	.+10     	; 0xdf46 <vfprintf+0x82>
    df3c:	90 32       	cpi	r25, 0x20	; 32
    df3e:	59 f0       	breq	.+22     	; 0xdf56 <vfprintf+0x92>
    df40:	93 32       	cpi	r25, 0x23	; 35
    df42:	91 f4       	brne	.+36     	; 0xdf68 <vfprintf+0xa4>
    df44:	0e c0       	rjmp	.+28     	; 0xdf62 <vfprintf+0x9e>
    df46:	9d 32       	cpi	r25, 0x2D	; 45
    df48:	49 f0       	breq	.+18     	; 0xdf5c <vfprintf+0x98>
    df4a:	90 33       	cpi	r25, 0x30	; 48
    df4c:	69 f4       	brne	.+26     	; 0xdf68 <vfprintf+0xa4>
    df4e:	41 e0       	ldi	r20, 0x01	; 1
    df50:	24 c0       	rjmp	.+72     	; 0xdf9a <vfprintf+0xd6>
    df52:	52 e0       	ldi	r21, 0x02	; 2
    df54:	f5 2a       	or	r15, r21
    df56:	84 e0       	ldi	r24, 0x04	; 4
    df58:	f8 2a       	or	r15, r24
    df5a:	28 c0       	rjmp	.+80     	; 0xdfac <vfprintf+0xe8>
    df5c:	98 e0       	ldi	r25, 0x08	; 8
    df5e:	f9 2a       	or	r15, r25
    df60:	25 c0       	rjmp	.+74     	; 0xdfac <vfprintf+0xe8>
    df62:	e0 e1       	ldi	r30, 0x10	; 16
    df64:	fe 2a       	or	r15, r30
    df66:	22 c0       	rjmp	.+68     	; 0xdfac <vfprintf+0xe8>
    df68:	f7 fc       	sbrc	r15, 7
    df6a:	29 c0       	rjmp	.+82     	; 0xdfbe <vfprintf+0xfa>
    df6c:	89 2f       	mov	r24, r25
    df6e:	80 53       	subi	r24, 0x30	; 48
    df70:	8a 30       	cpi	r24, 0x0A	; 10
    df72:	70 f4       	brcc	.+28     	; 0xdf90 <vfprintf+0xcc>
    df74:	f6 fe       	sbrs	r15, 6
    df76:	05 c0       	rjmp	.+10     	; 0xdf82 <vfprintf+0xbe>
    df78:	98 9c       	mul	r9, r8
    df7a:	90 2c       	mov	r9, r0
    df7c:	11 24       	eor	r1, r1
    df7e:	98 0e       	add	r9, r24
    df80:	15 c0       	rjmp	.+42     	; 0xdfac <vfprintf+0xe8>
    df82:	e8 9c       	mul	r14, r8
    df84:	e0 2c       	mov	r14, r0
    df86:	11 24       	eor	r1, r1
    df88:	e8 0e       	add	r14, r24
    df8a:	f0 e2       	ldi	r31, 0x20	; 32
    df8c:	ff 2a       	or	r15, r31
    df8e:	0e c0       	rjmp	.+28     	; 0xdfac <vfprintf+0xe8>
    df90:	9e 32       	cpi	r25, 0x2E	; 46
    df92:	29 f4       	brne	.+10     	; 0xdf9e <vfprintf+0xda>
    df94:	f6 fc       	sbrc	r15, 6
    df96:	6b c1       	rjmp	.+726    	; 0xe26e <vfprintf+0x3aa>
    df98:	40 e4       	ldi	r20, 0x40	; 64
    df9a:	f4 2a       	or	r15, r20
    df9c:	07 c0       	rjmp	.+14     	; 0xdfac <vfprintf+0xe8>
    df9e:	9c 36       	cpi	r25, 0x6C	; 108
    dfa0:	19 f4       	brne	.+6      	; 0xdfa8 <vfprintf+0xe4>
    dfa2:	50 e8       	ldi	r21, 0x80	; 128
    dfa4:	f5 2a       	or	r15, r21
    dfa6:	02 c0       	rjmp	.+4      	; 0xdfac <vfprintf+0xe8>
    dfa8:	98 36       	cpi	r25, 0x68	; 104
    dfaa:	49 f4       	brne	.+18     	; 0xdfbe <vfprintf+0xfa>
    dfac:	f2 01       	movw	r30, r4
    dfae:	23 fd       	sbrc	r18, 3
    dfb0:	95 91       	lpm	r25, Z+
    dfb2:	23 ff       	sbrs	r18, 3
    dfb4:	91 91       	ld	r25, Z+
    dfb6:	2f 01       	movw	r4, r30
    dfb8:	99 23       	and	r25, r25
    dfba:	09 f0       	breq	.+2      	; 0xdfbe <vfprintf+0xfa>
    dfbc:	b8 cf       	rjmp	.-144    	; 0xdf2e <vfprintf+0x6a>
    dfbe:	89 2f       	mov	r24, r25
    dfc0:	85 54       	subi	r24, 0x45	; 69
    dfc2:	83 30       	cpi	r24, 0x03	; 3
    dfc4:	18 f0       	brcs	.+6      	; 0xdfcc <vfprintf+0x108>
    dfc6:	80 52       	subi	r24, 0x20	; 32
    dfc8:	83 30       	cpi	r24, 0x03	; 3
    dfca:	38 f4       	brcc	.+14     	; 0xdfda <vfprintf+0x116>
    dfcc:	44 e0       	ldi	r20, 0x04	; 4
    dfce:	50 e0       	ldi	r21, 0x00	; 0
    dfd0:	a4 0e       	add	r10, r20
    dfd2:	b5 1e       	adc	r11, r21
    dfd4:	5f e3       	ldi	r21, 0x3F	; 63
    dfd6:	59 83       	std	Y+1, r21	; 0x01
    dfd8:	0f c0       	rjmp	.+30     	; 0xdff8 <vfprintf+0x134>
    dfda:	93 36       	cpi	r25, 0x63	; 99
    dfdc:	31 f0       	breq	.+12     	; 0xdfea <vfprintf+0x126>
    dfde:	93 37       	cpi	r25, 0x73	; 115
    dfe0:	79 f0       	breq	.+30     	; 0xe000 <vfprintf+0x13c>
    dfe2:	93 35       	cpi	r25, 0x53	; 83
    dfe4:	09 f0       	breq	.+2      	; 0xdfe8 <vfprintf+0x124>
    dfe6:	56 c0       	rjmp	.+172    	; 0xe094 <vfprintf+0x1d0>
    dfe8:	20 c0       	rjmp	.+64     	; 0xe02a <vfprintf+0x166>
    dfea:	f5 01       	movw	r30, r10
    dfec:	80 81       	ld	r24, Z
    dfee:	89 83       	std	Y+1, r24	; 0x01
    dff0:	42 e0       	ldi	r20, 0x02	; 2
    dff2:	50 e0       	ldi	r21, 0x00	; 0
    dff4:	a4 0e       	add	r10, r20
    dff6:	b5 1e       	adc	r11, r21
    dff8:	61 01       	movw	r12, r2
    dffa:	01 e0       	ldi	r16, 0x01	; 1
    dffc:	10 e0       	ldi	r17, 0x00	; 0
    dffe:	12 c0       	rjmp	.+36     	; 0xe024 <vfprintf+0x160>
    e000:	f5 01       	movw	r30, r10
    e002:	c0 80       	ld	r12, Z
    e004:	d1 80       	ldd	r13, Z+1	; 0x01
    e006:	f6 fc       	sbrc	r15, 6
    e008:	03 c0       	rjmp	.+6      	; 0xe010 <vfprintf+0x14c>
    e00a:	6f ef       	ldi	r22, 0xFF	; 255
    e00c:	7f ef       	ldi	r23, 0xFF	; 255
    e00e:	02 c0       	rjmp	.+4      	; 0xe014 <vfprintf+0x150>
    e010:	69 2d       	mov	r22, r9
    e012:	70 e0       	ldi	r23, 0x00	; 0
    e014:	42 e0       	ldi	r20, 0x02	; 2
    e016:	50 e0       	ldi	r21, 0x00	; 0
    e018:	a4 0e       	add	r10, r20
    e01a:	b5 1e       	adc	r11, r21
    e01c:	c6 01       	movw	r24, r12
    e01e:	0e 94 74 71 	call	0xe2e8	; 0xe2e8 <strnlen>
    e022:	8c 01       	movw	r16, r24
    e024:	5f e7       	ldi	r21, 0x7F	; 127
    e026:	f5 22       	and	r15, r21
    e028:	14 c0       	rjmp	.+40     	; 0xe052 <vfprintf+0x18e>
    e02a:	f5 01       	movw	r30, r10
    e02c:	c0 80       	ld	r12, Z
    e02e:	d1 80       	ldd	r13, Z+1	; 0x01
    e030:	f6 fc       	sbrc	r15, 6
    e032:	03 c0       	rjmp	.+6      	; 0xe03a <vfprintf+0x176>
    e034:	6f ef       	ldi	r22, 0xFF	; 255
    e036:	7f ef       	ldi	r23, 0xFF	; 255
    e038:	02 c0       	rjmp	.+4      	; 0xe03e <vfprintf+0x17a>
    e03a:	69 2d       	mov	r22, r9
    e03c:	70 e0       	ldi	r23, 0x00	; 0
    e03e:	42 e0       	ldi	r20, 0x02	; 2
    e040:	50 e0       	ldi	r21, 0x00	; 0
    e042:	a4 0e       	add	r10, r20
    e044:	b5 1e       	adc	r11, r21
    e046:	c6 01       	movw	r24, r12
    e048:	0e 94 69 71 	call	0xe2d2	; 0xe2d2 <strnlen_P>
    e04c:	8c 01       	movw	r16, r24
    e04e:	50 e8       	ldi	r21, 0x80	; 128
    e050:	f5 2a       	or	r15, r21
    e052:	f3 fe       	sbrs	r15, 3
    e054:	07 c0       	rjmp	.+14     	; 0xe064 <vfprintf+0x1a0>
    e056:	1a c0       	rjmp	.+52     	; 0xe08c <vfprintf+0x1c8>
    e058:	80 e2       	ldi	r24, 0x20	; 32
    e05a:	90 e0       	ldi	r25, 0x00	; 0
    e05c:	b3 01       	movw	r22, r6
    e05e:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e062:	ea 94       	dec	r14
    e064:	8e 2d       	mov	r24, r14
    e066:	90 e0       	ldi	r25, 0x00	; 0
    e068:	08 17       	cp	r16, r24
    e06a:	19 07       	cpc	r17, r25
    e06c:	a8 f3       	brcs	.-22     	; 0xe058 <vfprintf+0x194>
    e06e:	0e c0       	rjmp	.+28     	; 0xe08c <vfprintf+0x1c8>
    e070:	f6 01       	movw	r30, r12
    e072:	f7 fc       	sbrc	r15, 7
    e074:	85 91       	lpm	r24, Z+
    e076:	f7 fe       	sbrs	r15, 7
    e078:	81 91       	ld	r24, Z+
    e07a:	6f 01       	movw	r12, r30
    e07c:	90 e0       	ldi	r25, 0x00	; 0
    e07e:	b3 01       	movw	r22, r6
    e080:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e084:	e1 10       	cpse	r14, r1
    e086:	ea 94       	dec	r14
    e088:	01 50       	subi	r16, 0x01	; 1
    e08a:	10 40       	sbci	r17, 0x00	; 0
    e08c:	01 15       	cp	r16, r1
    e08e:	11 05       	cpc	r17, r1
    e090:	79 f7       	brne	.-34     	; 0xe070 <vfprintf+0x1ac>
    e092:	ea c0       	rjmp	.+468    	; 0xe268 <vfprintf+0x3a4>
    e094:	94 36       	cpi	r25, 0x64	; 100
    e096:	11 f0       	breq	.+4      	; 0xe09c <vfprintf+0x1d8>
    e098:	99 36       	cpi	r25, 0x69	; 105
    e09a:	69 f5       	brne	.+90     	; 0xe0f6 <vfprintf+0x232>
    e09c:	f7 fe       	sbrs	r15, 7
    e09e:	08 c0       	rjmp	.+16     	; 0xe0b0 <vfprintf+0x1ec>
    e0a0:	f5 01       	movw	r30, r10
    e0a2:	20 81       	ld	r18, Z
    e0a4:	31 81       	ldd	r19, Z+1	; 0x01
    e0a6:	42 81       	ldd	r20, Z+2	; 0x02
    e0a8:	53 81       	ldd	r21, Z+3	; 0x03
    e0aa:	84 e0       	ldi	r24, 0x04	; 4
    e0ac:	90 e0       	ldi	r25, 0x00	; 0
    e0ae:	0a c0       	rjmp	.+20     	; 0xe0c4 <vfprintf+0x200>
    e0b0:	f5 01       	movw	r30, r10
    e0b2:	80 81       	ld	r24, Z
    e0b4:	91 81       	ldd	r25, Z+1	; 0x01
    e0b6:	9c 01       	movw	r18, r24
    e0b8:	44 27       	eor	r20, r20
    e0ba:	37 fd       	sbrc	r19, 7
    e0bc:	40 95       	com	r20
    e0be:	54 2f       	mov	r21, r20
    e0c0:	82 e0       	ldi	r24, 0x02	; 2
    e0c2:	90 e0       	ldi	r25, 0x00	; 0
    e0c4:	a8 0e       	add	r10, r24
    e0c6:	b9 1e       	adc	r11, r25
    e0c8:	9f e6       	ldi	r25, 0x6F	; 111
    e0ca:	f9 22       	and	r15, r25
    e0cc:	57 ff       	sbrs	r21, 7
    e0ce:	09 c0       	rjmp	.+18     	; 0xe0e2 <vfprintf+0x21e>
    e0d0:	50 95       	com	r21
    e0d2:	40 95       	com	r20
    e0d4:	30 95       	com	r19
    e0d6:	21 95       	neg	r18
    e0d8:	3f 4f       	sbci	r19, 0xFF	; 255
    e0da:	4f 4f       	sbci	r20, 0xFF	; 255
    e0dc:	5f 4f       	sbci	r21, 0xFF	; 255
    e0de:	e0 e8       	ldi	r30, 0x80	; 128
    e0e0:	fe 2a       	or	r15, r30
    e0e2:	ca 01       	movw	r24, r20
    e0e4:	b9 01       	movw	r22, r18
    e0e6:	a1 01       	movw	r20, r2
    e0e8:	2a e0       	ldi	r18, 0x0A	; 10
    e0ea:	30 e0       	ldi	r19, 0x00	; 0
    e0ec:	0e 94 ab 71 	call	0xe356	; 0xe356 <__ultoa_invert>
    e0f0:	d8 2e       	mov	r13, r24
    e0f2:	d2 18       	sub	r13, r2
    e0f4:	40 c0       	rjmp	.+128    	; 0xe176 <vfprintf+0x2b2>
    e0f6:	95 37       	cpi	r25, 0x75	; 117
    e0f8:	29 f4       	brne	.+10     	; 0xe104 <vfprintf+0x240>
    e0fa:	1f 2d       	mov	r17, r15
    e0fc:	1f 7e       	andi	r17, 0xEF	; 239
    e0fe:	2a e0       	ldi	r18, 0x0A	; 10
    e100:	30 e0       	ldi	r19, 0x00	; 0
    e102:	1d c0       	rjmp	.+58     	; 0xe13e <vfprintf+0x27a>
    e104:	1f 2d       	mov	r17, r15
    e106:	19 7f       	andi	r17, 0xF9	; 249
    e108:	9f 36       	cpi	r25, 0x6F	; 111
    e10a:	61 f0       	breq	.+24     	; 0xe124 <vfprintf+0x260>
    e10c:	90 37       	cpi	r25, 0x70	; 112
    e10e:	20 f4       	brcc	.+8      	; 0xe118 <vfprintf+0x254>
    e110:	98 35       	cpi	r25, 0x58	; 88
    e112:	09 f0       	breq	.+2      	; 0xe116 <vfprintf+0x252>
    e114:	ac c0       	rjmp	.+344    	; 0xe26e <vfprintf+0x3aa>
    e116:	0f c0       	rjmp	.+30     	; 0xe136 <vfprintf+0x272>
    e118:	90 37       	cpi	r25, 0x70	; 112
    e11a:	39 f0       	breq	.+14     	; 0xe12a <vfprintf+0x266>
    e11c:	98 37       	cpi	r25, 0x78	; 120
    e11e:	09 f0       	breq	.+2      	; 0xe122 <vfprintf+0x25e>
    e120:	a6 c0       	rjmp	.+332    	; 0xe26e <vfprintf+0x3aa>
    e122:	04 c0       	rjmp	.+8      	; 0xe12c <vfprintf+0x268>
    e124:	28 e0       	ldi	r18, 0x08	; 8
    e126:	30 e0       	ldi	r19, 0x00	; 0
    e128:	0a c0       	rjmp	.+20     	; 0xe13e <vfprintf+0x27a>
    e12a:	10 61       	ori	r17, 0x10	; 16
    e12c:	14 fd       	sbrc	r17, 4
    e12e:	14 60       	ori	r17, 0x04	; 4
    e130:	20 e1       	ldi	r18, 0x10	; 16
    e132:	30 e0       	ldi	r19, 0x00	; 0
    e134:	04 c0       	rjmp	.+8      	; 0xe13e <vfprintf+0x27a>
    e136:	14 fd       	sbrc	r17, 4
    e138:	16 60       	ori	r17, 0x06	; 6
    e13a:	20 e1       	ldi	r18, 0x10	; 16
    e13c:	32 e0       	ldi	r19, 0x02	; 2
    e13e:	17 ff       	sbrs	r17, 7
    e140:	08 c0       	rjmp	.+16     	; 0xe152 <vfprintf+0x28e>
    e142:	f5 01       	movw	r30, r10
    e144:	60 81       	ld	r22, Z
    e146:	71 81       	ldd	r23, Z+1	; 0x01
    e148:	82 81       	ldd	r24, Z+2	; 0x02
    e14a:	93 81       	ldd	r25, Z+3	; 0x03
    e14c:	44 e0       	ldi	r20, 0x04	; 4
    e14e:	50 e0       	ldi	r21, 0x00	; 0
    e150:	08 c0       	rjmp	.+16     	; 0xe162 <vfprintf+0x29e>
    e152:	f5 01       	movw	r30, r10
    e154:	80 81       	ld	r24, Z
    e156:	91 81       	ldd	r25, Z+1	; 0x01
    e158:	bc 01       	movw	r22, r24
    e15a:	80 e0       	ldi	r24, 0x00	; 0
    e15c:	90 e0       	ldi	r25, 0x00	; 0
    e15e:	42 e0       	ldi	r20, 0x02	; 2
    e160:	50 e0       	ldi	r21, 0x00	; 0
    e162:	a4 0e       	add	r10, r20
    e164:	b5 1e       	adc	r11, r21
    e166:	a1 01       	movw	r20, r2
    e168:	0e 94 ab 71 	call	0xe356	; 0xe356 <__ultoa_invert>
    e16c:	d8 2e       	mov	r13, r24
    e16e:	d2 18       	sub	r13, r2
    e170:	8f e7       	ldi	r24, 0x7F	; 127
    e172:	f8 2e       	mov	r15, r24
    e174:	f1 22       	and	r15, r17
    e176:	f6 fe       	sbrs	r15, 6
    e178:	0b c0       	rjmp	.+22     	; 0xe190 <vfprintf+0x2cc>
    e17a:	5e ef       	ldi	r21, 0xFE	; 254
    e17c:	f5 22       	and	r15, r21
    e17e:	d9 14       	cp	r13, r9
    e180:	38 f4       	brcc	.+14     	; 0xe190 <vfprintf+0x2cc>
    e182:	f4 fe       	sbrs	r15, 4
    e184:	07 c0       	rjmp	.+14     	; 0xe194 <vfprintf+0x2d0>
    e186:	f2 fc       	sbrc	r15, 2
    e188:	05 c0       	rjmp	.+10     	; 0xe194 <vfprintf+0x2d0>
    e18a:	8f ee       	ldi	r24, 0xEF	; 239
    e18c:	f8 22       	and	r15, r24
    e18e:	02 c0       	rjmp	.+4      	; 0xe194 <vfprintf+0x2d0>
    e190:	1d 2d       	mov	r17, r13
    e192:	01 c0       	rjmp	.+2      	; 0xe196 <vfprintf+0x2d2>
    e194:	19 2d       	mov	r17, r9
    e196:	f4 fe       	sbrs	r15, 4
    e198:	0d c0       	rjmp	.+26     	; 0xe1b4 <vfprintf+0x2f0>
    e19a:	fe 01       	movw	r30, r28
    e19c:	ed 0d       	add	r30, r13
    e19e:	f1 1d       	adc	r31, r1
    e1a0:	80 81       	ld	r24, Z
    e1a2:	80 33       	cpi	r24, 0x30	; 48
    e1a4:	19 f4       	brne	.+6      	; 0xe1ac <vfprintf+0x2e8>
    e1a6:	99 ee       	ldi	r25, 0xE9	; 233
    e1a8:	f9 22       	and	r15, r25
    e1aa:	08 c0       	rjmp	.+16     	; 0xe1bc <vfprintf+0x2f8>
    e1ac:	1f 5f       	subi	r17, 0xFF	; 255
    e1ae:	f2 fe       	sbrs	r15, 2
    e1b0:	05 c0       	rjmp	.+10     	; 0xe1bc <vfprintf+0x2f8>
    e1b2:	03 c0       	rjmp	.+6      	; 0xe1ba <vfprintf+0x2f6>
    e1b4:	8f 2d       	mov	r24, r15
    e1b6:	86 78       	andi	r24, 0x86	; 134
    e1b8:	09 f0       	breq	.+2      	; 0xe1bc <vfprintf+0x2f8>
    e1ba:	1f 5f       	subi	r17, 0xFF	; 255
    e1bc:	0f 2d       	mov	r16, r15
    e1be:	f3 fc       	sbrc	r15, 3
    e1c0:	14 c0       	rjmp	.+40     	; 0xe1ea <vfprintf+0x326>
    e1c2:	f0 fe       	sbrs	r15, 0
    e1c4:	0f c0       	rjmp	.+30     	; 0xe1e4 <vfprintf+0x320>
    e1c6:	1e 15       	cp	r17, r14
    e1c8:	10 f0       	brcs	.+4      	; 0xe1ce <vfprintf+0x30a>
    e1ca:	9d 2c       	mov	r9, r13
    e1cc:	0b c0       	rjmp	.+22     	; 0xe1e4 <vfprintf+0x320>
    e1ce:	9d 2c       	mov	r9, r13
    e1d0:	9e 0c       	add	r9, r14
    e1d2:	91 1a       	sub	r9, r17
    e1d4:	1e 2d       	mov	r17, r14
    e1d6:	06 c0       	rjmp	.+12     	; 0xe1e4 <vfprintf+0x320>
    e1d8:	80 e2       	ldi	r24, 0x20	; 32
    e1da:	90 e0       	ldi	r25, 0x00	; 0
    e1dc:	b3 01       	movw	r22, r6
    e1de:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e1e2:	1f 5f       	subi	r17, 0xFF	; 255
    e1e4:	1e 15       	cp	r17, r14
    e1e6:	c0 f3       	brcs	.-16     	; 0xe1d8 <vfprintf+0x314>
    e1e8:	04 c0       	rjmp	.+8      	; 0xe1f2 <vfprintf+0x32e>
    e1ea:	1e 15       	cp	r17, r14
    e1ec:	10 f4       	brcc	.+4      	; 0xe1f2 <vfprintf+0x32e>
    e1ee:	e1 1a       	sub	r14, r17
    e1f0:	01 c0       	rjmp	.+2      	; 0xe1f4 <vfprintf+0x330>
    e1f2:	ee 24       	eor	r14, r14
    e1f4:	04 ff       	sbrs	r16, 4
    e1f6:	0f c0       	rjmp	.+30     	; 0xe216 <vfprintf+0x352>
    e1f8:	80 e3       	ldi	r24, 0x30	; 48
    e1fa:	90 e0       	ldi	r25, 0x00	; 0
    e1fc:	b3 01       	movw	r22, r6
    e1fe:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e202:	02 ff       	sbrs	r16, 2
    e204:	1d c0       	rjmp	.+58     	; 0xe240 <vfprintf+0x37c>
    e206:	01 fd       	sbrc	r16, 1
    e208:	03 c0       	rjmp	.+6      	; 0xe210 <vfprintf+0x34c>
    e20a:	88 e7       	ldi	r24, 0x78	; 120
    e20c:	90 e0       	ldi	r25, 0x00	; 0
    e20e:	0e c0       	rjmp	.+28     	; 0xe22c <vfprintf+0x368>
    e210:	88 e5       	ldi	r24, 0x58	; 88
    e212:	90 e0       	ldi	r25, 0x00	; 0
    e214:	0b c0       	rjmp	.+22     	; 0xe22c <vfprintf+0x368>
    e216:	80 2f       	mov	r24, r16
    e218:	86 78       	andi	r24, 0x86	; 134
    e21a:	91 f0       	breq	.+36     	; 0xe240 <vfprintf+0x37c>
    e21c:	01 ff       	sbrs	r16, 1
    e21e:	02 c0       	rjmp	.+4      	; 0xe224 <vfprintf+0x360>
    e220:	8b e2       	ldi	r24, 0x2B	; 43
    e222:	01 c0       	rjmp	.+2      	; 0xe226 <vfprintf+0x362>
    e224:	80 e2       	ldi	r24, 0x20	; 32
    e226:	f7 fc       	sbrc	r15, 7
    e228:	8d e2       	ldi	r24, 0x2D	; 45
    e22a:	90 e0       	ldi	r25, 0x00	; 0
    e22c:	b3 01       	movw	r22, r6
    e22e:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e232:	06 c0       	rjmp	.+12     	; 0xe240 <vfprintf+0x37c>
    e234:	80 e3       	ldi	r24, 0x30	; 48
    e236:	90 e0       	ldi	r25, 0x00	; 0
    e238:	b3 01       	movw	r22, r6
    e23a:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e23e:	9a 94       	dec	r9
    e240:	d9 14       	cp	r13, r9
    e242:	c0 f3       	brcs	.-16     	; 0xe234 <vfprintf+0x370>
    e244:	da 94       	dec	r13
    e246:	f1 01       	movw	r30, r2
    e248:	ed 0d       	add	r30, r13
    e24a:	f1 1d       	adc	r31, r1
    e24c:	80 81       	ld	r24, Z
    e24e:	90 e0       	ldi	r25, 0x00	; 0
    e250:	b3 01       	movw	r22, r6
    e252:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e256:	dd 20       	and	r13, r13
    e258:	a9 f7       	brne	.-22     	; 0xe244 <vfprintf+0x380>
    e25a:	06 c0       	rjmp	.+12     	; 0xe268 <vfprintf+0x3a4>
    e25c:	80 e2       	ldi	r24, 0x20	; 32
    e25e:	90 e0       	ldi	r25, 0x00	; 0
    e260:	b3 01       	movw	r22, r6
    e262:	0e 94 7f 71 	call	0xe2fe	; 0xe2fe <fputc>
    e266:	ea 94       	dec	r14
    e268:	ee 20       	and	r14, r14
    e26a:	c1 f7       	brne	.-16     	; 0xe25c <vfprintf+0x398>
    e26c:	43 ce       	rjmp	.-890    	; 0xdef4 <vfprintf+0x30>
    e26e:	f3 01       	movw	r30, r6
    e270:	66 81       	ldd	r22, Z+6	; 0x06
    e272:	77 81       	ldd	r23, Z+7	; 0x07
    e274:	cb 01       	movw	r24, r22
    e276:	2b 96       	adiw	r28, 0x0b	; 11
    e278:	e2 e1       	ldi	r30, 0x12	; 18
    e27a:	0c 94 25 72 	jmp	0xe44a	; 0xe44a <__epilogue_restores__>

0000e27e <__eerd_byte_m644p>:
    e27e:	f9 99       	sbic	0x1f, 1	; 31
    e280:	fe cf       	rjmp	.-4      	; 0xe27e <__eerd_byte_m644p>
    e282:	92 bd       	out	0x22, r25	; 34
    e284:	81 bd       	out	0x21, r24	; 33
    e286:	f8 9a       	sbi	0x1f, 0	; 31
    e288:	99 27       	eor	r25, r25
    e28a:	80 b5       	in	r24, 0x20	; 32
    e28c:	08 95       	ret

0000e28e <__eewr_byte_m644p>:
    e28e:	26 2f       	mov	r18, r22

0000e290 <__eewr_r18_m644p>:
    e290:	f9 99       	sbic	0x1f, 1	; 31
    e292:	fe cf       	rjmp	.-4      	; 0xe290 <__eewr_r18_m644p>
    e294:	1f ba       	out	0x1f, r1	; 31
    e296:	92 bd       	out	0x22, r25	; 34
    e298:	81 bd       	out	0x21, r24	; 33
    e29a:	20 bd       	out	0x20, r18	; 32
    e29c:	0f b6       	in	r0, 0x3f	; 63
    e29e:	f8 94       	cli
    e2a0:	fa 9a       	sbi	0x1f, 2	; 31
    e2a2:	f9 9a       	sbi	0x1f, 1	; 31
    e2a4:	0f be       	out	0x3f, r0	; 63
    e2a6:	01 96       	adiw	r24, 0x01	; 1
    e2a8:	08 95       	ret

0000e2aa <isalnum>:
    e2aa:	91 11       	cpse	r25, r1
    e2ac:	06 c0       	rjmp	.+12     	; 0xe2ba <__ctype_isfalse>
    e2ae:	80 53       	subi	r24, 0x30	; 48
    e2b0:	8a 50       	subi	r24, 0x0A	; 10
    e2b2:	10 f0       	brcs	.+4      	; 0xe2b8 <isalnum+0xe>
    e2b4:	86 5c       	subi	r24, 0xC6	; 198
    e2b6:	06 c0       	rjmp	.+12     	; 0xe2c4 <isalpha>
    e2b8:	08 95       	ret

0000e2ba <__ctype_isfalse>:
    e2ba:	99 27       	eor	r25, r25
    e2bc:	88 27       	eor	r24, r24

0000e2be <__ctype_istrue>:
    e2be:	08 95       	ret

0000e2c0 <isupper>:
    e2c0:	85 fd       	sbrc	r24, 5
    e2c2:	fb cf       	rjmp	.-10     	; 0xe2ba <__ctype_isfalse>

0000e2c4 <isalpha>:
    e2c4:	80 62       	ori	r24, 0x20	; 32

0000e2c6 <islower>:
    e2c6:	91 11       	cpse	r25, r1
    e2c8:	f8 cf       	rjmp	.-16     	; 0xe2ba <__ctype_isfalse>
    e2ca:	81 56       	subi	r24, 0x61	; 97
    e2cc:	8a 51       	subi	r24, 0x1A	; 26
    e2ce:	e0 f7       	brcc	.-8      	; 0xe2c8 <islower+0x2>
    e2d0:	08 95       	ret

0000e2d2 <strnlen_P>:
    e2d2:	fc 01       	movw	r30, r24
    e2d4:	05 90       	lpm	r0, Z+
    e2d6:	61 50       	subi	r22, 0x01	; 1
    e2d8:	70 40       	sbci	r23, 0x00	; 0
    e2da:	01 10       	cpse	r0, r1
    e2dc:	d8 f7       	brcc	.-10     	; 0xe2d4 <strnlen_P+0x2>
    e2de:	80 95       	com	r24
    e2e0:	90 95       	com	r25
    e2e2:	8e 0f       	add	r24, r30
    e2e4:	9f 1f       	adc	r25, r31
    e2e6:	08 95       	ret

0000e2e8 <strnlen>:
    e2e8:	fc 01       	movw	r30, r24
    e2ea:	61 50       	subi	r22, 0x01	; 1
    e2ec:	70 40       	sbci	r23, 0x00	; 0
    e2ee:	01 90       	ld	r0, Z+
    e2f0:	01 10       	cpse	r0, r1
    e2f2:	d8 f7       	brcc	.-10     	; 0xe2ea <strnlen+0x2>
    e2f4:	80 95       	com	r24
    e2f6:	90 95       	com	r25
    e2f8:	8e 0f       	add	r24, r30
    e2fa:	9f 1f       	adc	r25, r31
    e2fc:	08 95       	ret

0000e2fe <fputc>:
    e2fe:	0f 93       	push	r16
    e300:	1f 93       	push	r17
    e302:	cf 93       	push	r28
    e304:	df 93       	push	r29
    e306:	8c 01       	movw	r16, r24
    e308:	eb 01       	movw	r28, r22
    e30a:	8b 81       	ldd	r24, Y+3	; 0x03
    e30c:	81 ff       	sbrs	r24, 1
    e30e:	1b c0       	rjmp	.+54     	; 0xe346 <fputc+0x48>
    e310:	82 ff       	sbrs	r24, 2
    e312:	0d c0       	rjmp	.+26     	; 0xe32e <fputc+0x30>
    e314:	2e 81       	ldd	r18, Y+6	; 0x06
    e316:	3f 81       	ldd	r19, Y+7	; 0x07
    e318:	8c 81       	ldd	r24, Y+4	; 0x04
    e31a:	9d 81       	ldd	r25, Y+5	; 0x05
    e31c:	28 17       	cp	r18, r24
    e31e:	39 07       	cpc	r19, r25
    e320:	64 f4       	brge	.+24     	; 0xe33a <fputc+0x3c>
    e322:	e8 81       	ld	r30, Y
    e324:	f9 81       	ldd	r31, Y+1	; 0x01
    e326:	01 93       	st	Z+, r16
    e328:	f9 83       	std	Y+1, r31	; 0x01
    e32a:	e8 83       	st	Y, r30
    e32c:	06 c0       	rjmp	.+12     	; 0xe33a <fputc+0x3c>
    e32e:	e8 85       	ldd	r30, Y+8	; 0x08
    e330:	f9 85       	ldd	r31, Y+9	; 0x09
    e332:	80 2f       	mov	r24, r16
    e334:	09 95       	icall
    e336:	89 2b       	or	r24, r25
    e338:	31 f4       	brne	.+12     	; 0xe346 <fputc+0x48>
    e33a:	8e 81       	ldd	r24, Y+6	; 0x06
    e33c:	9f 81       	ldd	r25, Y+7	; 0x07
    e33e:	01 96       	adiw	r24, 0x01	; 1
    e340:	9f 83       	std	Y+7, r25	; 0x07
    e342:	8e 83       	std	Y+6, r24	; 0x06
    e344:	02 c0       	rjmp	.+4      	; 0xe34a <fputc+0x4c>
    e346:	0f ef       	ldi	r16, 0xFF	; 255
    e348:	1f ef       	ldi	r17, 0xFF	; 255
    e34a:	c8 01       	movw	r24, r16
    e34c:	df 91       	pop	r29
    e34e:	cf 91       	pop	r28
    e350:	1f 91       	pop	r17
    e352:	0f 91       	pop	r16
    e354:	08 95       	ret

0000e356 <__ultoa_invert>:
    e356:	fa 01       	movw	r30, r20
    e358:	aa 27       	eor	r26, r26
    e35a:	28 30       	cpi	r18, 0x08	; 8
    e35c:	51 f1       	breq	.+84     	; 0xe3b2 <__ultoa_invert+0x5c>
    e35e:	20 31       	cpi	r18, 0x10	; 16
    e360:	81 f1       	breq	.+96     	; 0xe3c2 <__ultoa_invert+0x6c>
    e362:	e8 94       	clt
    e364:	6f 93       	push	r22
    e366:	6e 7f       	andi	r22, 0xFE	; 254
    e368:	6e 5f       	subi	r22, 0xFE	; 254
    e36a:	7f 4f       	sbci	r23, 0xFF	; 255
    e36c:	8f 4f       	sbci	r24, 0xFF	; 255
    e36e:	9f 4f       	sbci	r25, 0xFF	; 255
    e370:	af 4f       	sbci	r26, 0xFF	; 255
    e372:	b1 e0       	ldi	r27, 0x01	; 1
    e374:	3e d0       	rcall	.+124    	; 0xe3f2 <__ultoa_invert+0x9c>
    e376:	b4 e0       	ldi	r27, 0x04	; 4
    e378:	3c d0       	rcall	.+120    	; 0xe3f2 <__ultoa_invert+0x9c>
    e37a:	67 0f       	add	r22, r23
    e37c:	78 1f       	adc	r23, r24
    e37e:	89 1f       	adc	r24, r25
    e380:	9a 1f       	adc	r25, r26
    e382:	a1 1d       	adc	r26, r1
    e384:	68 0f       	add	r22, r24
    e386:	79 1f       	adc	r23, r25
    e388:	8a 1f       	adc	r24, r26
    e38a:	91 1d       	adc	r25, r1
    e38c:	a1 1d       	adc	r26, r1
    e38e:	6a 0f       	add	r22, r26
    e390:	71 1d       	adc	r23, r1
    e392:	81 1d       	adc	r24, r1
    e394:	91 1d       	adc	r25, r1
    e396:	a1 1d       	adc	r26, r1
    e398:	20 d0       	rcall	.+64     	; 0xe3da <__ultoa_invert+0x84>
    e39a:	09 f4       	brne	.+2      	; 0xe39e <__ultoa_invert+0x48>
    e39c:	68 94       	set
    e39e:	3f 91       	pop	r19
    e3a0:	2a e0       	ldi	r18, 0x0A	; 10
    e3a2:	26 9f       	mul	r18, r22
    e3a4:	11 24       	eor	r1, r1
    e3a6:	30 19       	sub	r19, r0
    e3a8:	30 5d       	subi	r19, 0xD0	; 208
    e3aa:	31 93       	st	Z+, r19
    e3ac:	de f6       	brtc	.-74     	; 0xe364 <__ultoa_invert+0xe>
    e3ae:	cf 01       	movw	r24, r30
    e3b0:	08 95       	ret
    e3b2:	46 2f       	mov	r20, r22
    e3b4:	47 70       	andi	r20, 0x07	; 7
    e3b6:	40 5d       	subi	r20, 0xD0	; 208
    e3b8:	41 93       	st	Z+, r20
    e3ba:	b3 e0       	ldi	r27, 0x03	; 3
    e3bc:	0f d0       	rcall	.+30     	; 0xe3dc <__ultoa_invert+0x86>
    e3be:	c9 f7       	brne	.-14     	; 0xe3b2 <__ultoa_invert+0x5c>
    e3c0:	f6 cf       	rjmp	.-20     	; 0xe3ae <__ultoa_invert+0x58>
    e3c2:	46 2f       	mov	r20, r22
    e3c4:	4f 70       	andi	r20, 0x0F	; 15
    e3c6:	40 5d       	subi	r20, 0xD0	; 208
    e3c8:	4a 33       	cpi	r20, 0x3A	; 58
    e3ca:	18 f0       	brcs	.+6      	; 0xe3d2 <__ultoa_invert+0x7c>
    e3cc:	49 5d       	subi	r20, 0xD9	; 217
    e3ce:	31 fd       	sbrc	r19, 1
    e3d0:	40 52       	subi	r20, 0x20	; 32
    e3d2:	41 93       	st	Z+, r20
    e3d4:	02 d0       	rcall	.+4      	; 0xe3da <__ultoa_invert+0x84>
    e3d6:	a9 f7       	brne	.-22     	; 0xe3c2 <__ultoa_invert+0x6c>
    e3d8:	ea cf       	rjmp	.-44     	; 0xe3ae <__ultoa_invert+0x58>
    e3da:	b4 e0       	ldi	r27, 0x04	; 4
    e3dc:	a6 95       	lsr	r26
    e3de:	97 95       	ror	r25
    e3e0:	87 95       	ror	r24
    e3e2:	77 95       	ror	r23
    e3e4:	67 95       	ror	r22
    e3e6:	ba 95       	dec	r27
    e3e8:	c9 f7       	brne	.-14     	; 0xe3dc <__ultoa_invert+0x86>
    e3ea:	00 97       	sbiw	r24, 0x00	; 0
    e3ec:	61 05       	cpc	r22, r1
    e3ee:	71 05       	cpc	r23, r1
    e3f0:	08 95       	ret
    e3f2:	9b 01       	movw	r18, r22
    e3f4:	ac 01       	movw	r20, r24
    e3f6:	0a 2e       	mov	r0, r26
    e3f8:	06 94       	lsr	r0
    e3fa:	57 95       	ror	r21
    e3fc:	47 95       	ror	r20
    e3fe:	37 95       	ror	r19
    e400:	27 95       	ror	r18
    e402:	ba 95       	dec	r27
    e404:	c9 f7       	brne	.-14     	; 0xe3f8 <__ultoa_invert+0xa2>
    e406:	62 0f       	add	r22, r18
    e408:	73 1f       	adc	r23, r19
    e40a:	84 1f       	adc	r24, r20
    e40c:	95 1f       	adc	r25, r21
    e40e:	a0 1d       	adc	r26, r0
    e410:	08 95       	ret

0000e412 <__prologue_saves__>:
    e412:	2f 92       	push	r2
    e414:	3f 92       	push	r3
    e416:	4f 92       	push	r4
    e418:	5f 92       	push	r5
    e41a:	6f 92       	push	r6
    e41c:	7f 92       	push	r7
    e41e:	8f 92       	push	r8
    e420:	9f 92       	push	r9
    e422:	af 92       	push	r10
    e424:	bf 92       	push	r11
    e426:	cf 92       	push	r12
    e428:	df 92       	push	r13
    e42a:	ef 92       	push	r14
    e42c:	ff 92       	push	r15
    e42e:	0f 93       	push	r16
    e430:	1f 93       	push	r17
    e432:	cf 93       	push	r28
    e434:	df 93       	push	r29
    e436:	cd b7       	in	r28, 0x3d	; 61
    e438:	de b7       	in	r29, 0x3e	; 62
    e43a:	ca 1b       	sub	r28, r26
    e43c:	db 0b       	sbc	r29, r27
    e43e:	0f b6       	in	r0, 0x3f	; 63
    e440:	f8 94       	cli
    e442:	de bf       	out	0x3e, r29	; 62
    e444:	0f be       	out	0x3f, r0	; 63
    e446:	cd bf       	out	0x3d, r28	; 61
    e448:	09 94       	ijmp

0000e44a <__epilogue_restores__>:
    e44a:	2a 88       	ldd	r2, Y+18	; 0x12
    e44c:	39 88       	ldd	r3, Y+17	; 0x11
    e44e:	48 88       	ldd	r4, Y+16	; 0x10
    e450:	5f 84       	ldd	r5, Y+15	; 0x0f
    e452:	6e 84       	ldd	r6, Y+14	; 0x0e
    e454:	7d 84       	ldd	r7, Y+13	; 0x0d
    e456:	8c 84       	ldd	r8, Y+12	; 0x0c
    e458:	9b 84       	ldd	r9, Y+11	; 0x0b
    e45a:	aa 84       	ldd	r10, Y+10	; 0x0a
    e45c:	b9 84       	ldd	r11, Y+9	; 0x09
    e45e:	c8 84       	ldd	r12, Y+8	; 0x08
    e460:	df 80       	ldd	r13, Y+7	; 0x07
    e462:	ee 80       	ldd	r14, Y+6	; 0x06
    e464:	fd 80       	ldd	r15, Y+5	; 0x05
    e466:	0c 81       	ldd	r16, Y+4	; 0x04
    e468:	1b 81       	ldd	r17, Y+3	; 0x03
    e46a:	aa 81       	ldd	r26, Y+2	; 0x02
    e46c:	b9 81       	ldd	r27, Y+1	; 0x01
    e46e:	ce 0f       	add	r28, r30
    e470:	d1 1d       	adc	r29, r1
    e472:	0f b6       	in	r0, 0x3f	; 63
    e474:	f8 94       	cli
    e476:	de bf       	out	0x3e, r29	; 62
    e478:	0f be       	out	0x3f, r0	; 63
    e47a:	cd bf       	out	0x3d, r28	; 61
    e47c:	ed 01       	movw	r28, r26
    e47e:	08 95       	ret

0000e480 <_exit>:
    e480:	f8 94       	cli

0000e482 <__stop_program>:
    e482:	ff cf       	rjmp	.-2      	; 0xe482 <__stop_program>
